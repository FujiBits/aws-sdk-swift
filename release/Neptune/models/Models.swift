// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AddRoleToDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddRoleToDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddRoleToDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddRoleToDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddRoleToDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddRoleToDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddRoleToDBClusterOutputError>
}

extension AddRoleToDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddRoleToDBClusterInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), featureName: \(Swift.String(describing: featureName)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension AddRoleToDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: ClientRuntime.Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        try container.encode("AddRoleToDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AddRoleToDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddRoleToDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddRoleToDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddRoleToDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddRoleToDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddRoleToDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddRoleToDBClusterOutputError>
}

public struct AddRoleToDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddRoleToDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddRoleToDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddRoleToDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddRoleToDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddRoleToDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddRoleToDBClusterOutputError>
}

public struct AddRoleToDBClusterInput: Swift.Equatable {
    /// <p>The name of the DB cluster to associate the IAM role with.</p>
    public let dBClusterIdentifier: Swift.String?
    /// <p>The name of the feature for the Neptune DB cluster that the IAM role is to be associated with.
    ///       For the list of supported feature names, see <a>DBEngineVersion</a>.</p>
    public let featureName: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role to associate with the Neptune DB cluster,
    ///       for example <code>arn:aws:iam::123456789012:role/NeptuneAccessRole</code>.</p>
    public let roleArn: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        featureName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

extension AddRoleToDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddRoleToDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterRoleAlreadyExistsFault" : self = .dBClusterRoleAlreadyExistsFault(try DBClusterRoleAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterRoleQuotaExceededFault" : self = .dBClusterRoleQuotaExceededFault(try DBClusterRoleQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddRoleToDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterRoleAlreadyExistsFault(DBClusterRoleAlreadyExistsFault)
    case dBClusterRoleQuotaExceededFault(DBClusterRoleQuotaExceededFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddRoleToDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddRoleToDBClusterOutputResponse()"}
}

extension AddRoleToDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddRoleToDBClusterOutputResponse: Swift.Equatable {

    public init() {}
}

struct AddRoleToDBClusterOutputResponseBody: Swift.Equatable {
}

extension AddRoleToDBClusterOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AddSourceIdentifierToSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddSourceIdentifierToSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddSourceIdentifierToSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddSourceIdentifierToSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddSourceIdentifierToSubscriptionOutputError>
}

extension AddSourceIdentifierToSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddSourceIdentifierToSubscriptionInput(sourceIdentifier: \(Swift.String(describing: sourceIdentifier)), subscriptionName: \(Swift.String(describing: subscriptionName)))"}
}

extension AddSourceIdentifierToSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: ClientRuntime.Key("SourceIdentifier"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("AddSourceIdentifierToSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AddSourceIdentifierToSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddSourceIdentifierToSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddSourceIdentifierToSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddSourceIdentifierToSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddSourceIdentifierToSubscriptionOutputError>
}

public struct AddSourceIdentifierToSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddSourceIdentifierToSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddSourceIdentifierToSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddSourceIdentifierToSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddSourceIdentifierToSubscriptionOutputError>
}

public struct AddSourceIdentifierToSubscriptionInput: Swift.Equatable {
    /// <p>The identifier of the event source to be added.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the source type is a DB instance, then a <code>DBInstanceIdentifier</code> must be
    ///           supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB security group, a <code>DBSecurityGroupName</code> must be
    ///           supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB parameter group, a <code>DBParameterGroupName</code> must
    ///           be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB snapshot, a <code>DBSnapshotIdentifier</code> must be
    ///           supplied.</p>
    ///             </li>
    ///          </ul>
    public let sourceIdentifier: Swift.String?
    /// <p>The name of the event notification subscription you want to add a source identifier
    ///       to.</p>
    public let subscriptionName: Swift.String?

    public init (
        sourceIdentifier: Swift.String? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.sourceIdentifier = sourceIdentifier
        self.subscriptionName = subscriptionName
    }
}

extension AddSourceIdentifierToSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddSourceIdentifierToSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "SourceNotFoundFault" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddSourceIdentifierToSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddSourceIdentifierToSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddSourceIdentifierToSubscriptionOutputResponse(eventSubscription: \(Swift.String(describing: eventSubscription)))"}
}

extension AddSourceIdentifierToSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddSourceIdentifierToSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct AddSourceIdentifierToSubscriptionOutputResponse: Swift.Equatable {
    /// <p>Contains the results of a successful invocation of the <a>DescribeEventSubscriptions</a> action.</p>
    public let eventSubscription: NeptuneClientTypes.EventSubscription?

    public init (
        eventSubscription: NeptuneClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct AddSourceIdentifierToSubscriptionOutputResponseBody: Swift.Equatable {
    public let eventSubscription: NeptuneClientTypes.EventSubscription?
}

extension AddSourceIdentifierToSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AddSourceIdentifierToSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct AddTagsToResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

extension AddTagsToResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToResourceInput(resourceName: \(Swift.String(describing: resourceName)), tags: \(Swift.String(describing: tags)))"}
}

extension AddTagsToResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: ClientRuntime.Key("ResourceName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("AddTagsToResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AddTagsToResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInput: Swift.Equatable {
    /// <p>The Amazon Neptune resource that the tags are added to. This value is an Amazon Resource
    ///       Name (ARN). For information about creating an ARN, see <a href="https://docs.aws.amazon.com/neptune/latest/UserGuide/tagging.ARN.html#tagging.ARN.Constructing"> Constructing an
    ///       Amazon Resource Name (ARN)</a>.</p>
    public let resourceName: Swift.String?
    /// <p>The tags to be assigned to the Amazon Neptune resource.</p>
    public let tags: [NeptuneClientTypes.Tag]?

    public init (
        resourceName: Swift.String? = nil,
        tags: [NeptuneClientTypes.Tag]? = nil
    )
    {
        self.resourceName = resourceName
        self.tags = tags
    }
}

extension AddTagsToResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToResourceOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToResourceOutputResponse()"}
}

extension AddTagsToResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsToResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct AddTagsToResourceOutputResponseBody: Swift.Equatable {
}

extension AddTagsToResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension NeptuneClientTypes {
    public enum ApplyMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case immediate
        case pendingReboot
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplyMethod] {
            return [
                .immediate,
                .pendingReboot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .immediate: return "immediate"
            case .pendingReboot: return "pending-reboot"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplyMethod(rawValue: rawValue) ?? ApplyMethod.sdkUnknown(rawValue)
        }
    }
}

public struct ApplyPendingMaintenanceActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplyPendingMaintenanceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplyPendingMaintenanceActionOutputError>
}

extension ApplyPendingMaintenanceActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplyPendingMaintenanceActionInput(applyAction: \(Swift.String(describing: applyAction)), optInType: \(Swift.String(describing: optInType)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)))"}
}

extension ApplyPendingMaintenanceActionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let applyAction = applyAction {
            try container.encode(applyAction, forKey: ClientRuntime.Key("ApplyAction"))
        }
        if let optInType = optInType {
            try container.encode(optInType, forKey: ClientRuntime.Key("OptInType"))
        }
        if let resourceIdentifier = resourceIdentifier {
            try container.encode(resourceIdentifier, forKey: ClientRuntime.Key("ResourceIdentifier"))
        }
        try container.encode("ApplyPendingMaintenanceAction", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ApplyPendingMaintenanceActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplyPendingMaintenanceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplyPendingMaintenanceActionOutputError>
}

public struct ApplyPendingMaintenanceActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplyPendingMaintenanceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplyPendingMaintenanceActionOutputError>
}

public struct ApplyPendingMaintenanceActionInput: Swift.Equatable {
    /// <p>The pending maintenance action to apply to this resource.</p>
    ///          <p>Valid values: <code>system-update</code>, <code>db-upgrade</code>
    ///          </p>
    public let applyAction: Swift.String?
    /// <p>A value that specifies the type of opt-in request, or undoes an opt-in request. An opt-in
    ///       request of type <code>immediate</code> can't be undone.</p>
    ///          <p>Valid values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>immediate</code> - Apply the maintenance action immediately.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>next-maintenance</code> - Apply the maintenance action during the next
    ///           maintenance window for the resource.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>undo-opt-in</code> - Cancel any existing <code>next-maintenance</code> opt-in
    ///           requests.</p>
    ///             </li>
    ///          </ul>
    public let optInType: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the resource that the pending maintenance action applies
    ///       to. For information about creating an ARN, see <a href="https://docs.aws.amazon.com/neptune/latest/UserGuide/tagging.ARN.html#tagging.ARN.Constructing"> Constructing an
    ///       Amazon Resource Name (ARN)</a>.</p>
    public let resourceIdentifier: Swift.String?

    public init (
        applyAction: Swift.String? = nil,
        optInType: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.applyAction = applyAction
        self.optInType = optInType
        self.resourceIdentifier = resourceIdentifier
    }
}

extension ApplyPendingMaintenanceActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ApplyPendingMaintenanceActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApplyPendingMaintenanceActionOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplyPendingMaintenanceActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplyPendingMaintenanceActionOutputResponse(resourcePendingMaintenanceActions: \(Swift.String(describing: resourcePendingMaintenanceActions)))"}
}

extension ApplyPendingMaintenanceActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ApplyPendingMaintenanceActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourcePendingMaintenanceActions = output.resourcePendingMaintenanceActions
        } else {
            self.resourcePendingMaintenanceActions = nil
        }
    }
}

public struct ApplyPendingMaintenanceActionOutputResponse: Swift.Equatable {
    /// <p>Describes the pending maintenance actions for a resource.</p>
    public let resourcePendingMaintenanceActions: NeptuneClientTypes.ResourcePendingMaintenanceActions?

    public init (
        resourcePendingMaintenanceActions: NeptuneClientTypes.ResourcePendingMaintenanceActions? = nil
    )
    {
        self.resourcePendingMaintenanceActions = resourcePendingMaintenanceActions
    }
}

struct ApplyPendingMaintenanceActionOutputResponseBody: Swift.Equatable {
    public let resourcePendingMaintenanceActions: NeptuneClientTypes.ResourcePendingMaintenanceActions?
}

extension ApplyPendingMaintenanceActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePendingMaintenanceActions = "ResourcePendingMaintenanceActions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ApplyPendingMaintenanceActionResult"))
        let resourcePendingMaintenanceActionsDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.ResourcePendingMaintenanceActions.self, forKey: .resourcePendingMaintenanceActions)
        resourcePendingMaintenanceActions = resourcePendingMaintenanceActionsDecoded
    }
}

extension AuthorizationNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizationNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension AuthorizationNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<AuthorizationNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Specified CIDRIP or EC2 security group is not authorized for the specified DB security group.</p>
///          <p>Neptune may not also be authorized via IAM to perform necessary actions on your behalf.</p>
public struct AuthorizationNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AuthorizationNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.AvailabilityZone: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension NeptuneClientTypes.AvailabilityZone: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AvailabilityZone(name: \(Swift.String(describing: name)))"}
}

extension NeptuneClientTypes {
    /// <p>Specifies an Availability Zone.</p>
    public struct AvailabilityZone: Swift.Equatable {
        /// <p>The name of the availability zone.</p>
        public let name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension CertificateNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CertificateNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension CertificateNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<CertificateNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>CertificateIdentifier</i> does not refer to an existing certificate.</p>
public struct CertificateNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CertificateNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CertificateNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.CharacterSet: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case characterSetDescription = "CharacterSetDescription"
        case characterSetName = "CharacterSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let characterSetDescription = characterSetDescription {
            try container.encode(characterSetDescription, forKey: ClientRuntime.Key("CharacterSetDescription"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let characterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let characterSetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetDescription)
        characterSetDescription = characterSetDescriptionDecoded
    }
}

extension NeptuneClientTypes.CharacterSet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CharacterSet(characterSetDescription: \(Swift.String(describing: characterSetDescription)), characterSetName: \(Swift.String(describing: characterSetName)))"}
}

extension NeptuneClientTypes {
    /// <p>Specifies a character set.</p>
    public struct CharacterSet: Swift.Equatable {
        /// <p>The description of the character set.</p>
        public let characterSetDescription: Swift.String?
        /// <p>The name of the character set.</p>
        public let characterSetName: Swift.String?

        public init (
            characterSetDescription: Swift.String? = nil,
            characterSetName: Swift.String? = nil
        )
        {
            self.characterSetDescription = characterSetDescription
            self.characterSetName = characterSetName
        }
    }

}

extension NeptuneClientTypes.CloudwatchLogsExportConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableLogTypes = "DisableLogTypes"
        case enableLogTypes = "EnableLogTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let disableLogTypes = disableLogTypes {
            var disableLogTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DisableLogTypes"))
            for (index0, string0) in disableLogTypes.enumerated() {
                try disableLogTypesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableLogTypes = enableLogTypes {
            var enableLogTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableLogTypes"))
            for (index0, string0) in enableLogTypes.enumerated() {
                try enableLogTypesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.enableLogTypes) {
            struct KeyVal0{struct member{}}
            let enableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableLogTypes)
            if let enableLogTypesWrappedContainer = enableLogTypesWrappedContainer {
                let enableLogTypesContainer = try enableLogTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enableLogTypesBuffer:[Swift.String]? = nil
                if let enableLogTypesContainer = enableLogTypesContainer {
                    enableLogTypesBuffer = [Swift.String]()
                    for stringContainer0 in enableLogTypesContainer {
                        enableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                enableLogTypes = enableLogTypesBuffer
            } else {
                enableLogTypes = []
            }
        } else {
            enableLogTypes = nil
        }
        if containerValues.contains(.disableLogTypes) {
            struct KeyVal0{struct member{}}
            let disableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .disableLogTypes)
            if let disableLogTypesWrappedContainer = disableLogTypesWrappedContainer {
                let disableLogTypesContainer = try disableLogTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var disableLogTypesBuffer:[Swift.String]? = nil
                if let disableLogTypesContainer = disableLogTypesContainer {
                    disableLogTypesBuffer = [Swift.String]()
                    for stringContainer0 in disableLogTypesContainer {
                        disableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                disableLogTypes = disableLogTypesBuffer
            } else {
                disableLogTypes = []
            }
        } else {
            disableLogTypes = nil
        }
    }
}

extension NeptuneClientTypes.CloudwatchLogsExportConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudwatchLogsExportConfiguration(disableLogTypes: \(Swift.String(describing: disableLogTypes)), enableLogTypes: \(Swift.String(describing: enableLogTypes)))"}
}

extension NeptuneClientTypes {
    /// <p>The configuration setting for the log types to be enabled for export
    ///       to CloudWatch Logs for a specific DB instance or DB cluster.</p>
    ///
    ///          <p>The <code>EnableLogTypes</code> and <code>DisableLogTypes</code> arrays
    ///       determine which logs will be exported (or not exported) to CloudWatch Logs.</p>
    public struct CloudwatchLogsExportConfiguration: Swift.Equatable {
        /// <p>The list of log types to disable.</p>
        public let disableLogTypes: [Swift.String]?
        /// <p>The list of log types to enable.</p>
        public let enableLogTypes: [Swift.String]?

        public init (
            disableLogTypes: [Swift.String]? = nil,
            enableLogTypes: [Swift.String]? = nil
        )
        {
            self.disableLogTypes = disableLogTypes
            self.enableLogTypes = enableLogTypes
        }
    }

}

public struct CopyDBClusterParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBClusterParameterGroupOutputError>
}

extension CopyDBClusterParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyDBClusterParameterGroupInput(sourceDBClusterParameterGroupIdentifier: \(Swift.String(describing: sourceDBClusterParameterGroupIdentifier)), tags: \(Swift.String(describing: tags)), targetDBClusterParameterGroupDescription: \(Swift.String(describing: targetDBClusterParameterGroupDescription)), targetDBClusterParameterGroupIdentifier: \(Swift.String(describing: targetDBClusterParameterGroupIdentifier)))"}
}

extension CopyDBClusterParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceDBClusterParameterGroupIdentifier = sourceDBClusterParameterGroupIdentifier {
            try container.encode(sourceDBClusterParameterGroupIdentifier, forKey: ClientRuntime.Key("SourceDBClusterParameterGroupIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBClusterParameterGroupDescription = targetDBClusterParameterGroupDescription {
            try container.encode(targetDBClusterParameterGroupDescription, forKey: ClientRuntime.Key("TargetDBClusterParameterGroupDescription"))
        }
        if let targetDBClusterParameterGroupIdentifier = targetDBClusterParameterGroupIdentifier {
            try container.encode(targetDBClusterParameterGroupIdentifier, forKey: ClientRuntime.Key("TargetDBClusterParameterGroupIdentifier"))
        }
        try container.encode("CopyDBClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CopyDBClusterParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBClusterParameterGroupOutputError>
}

public struct CopyDBClusterParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBClusterParameterGroupOutputError>
}

public struct CopyDBClusterParameterGroupInput: Swift.Equatable {
    /// <p>The identifier or Amazon Resource Name (ARN) for the source DB cluster parameter group.
    ///       For information about creating an ARN, see <a href="https://docs.aws.amazon.com/neptune/latest/UserGuide/tagging.ARN.html#tagging.ARN.Constructing"> Constructing an
    ///       Amazon Resource Name (ARN)</a>.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must specify a valid DB cluster parameter group.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source DB cluster parameter group is in the same Amazon Region as the copy,
    ///           specify a valid DB parameter group identifier, for example
    ///           <code>my-db-cluster-param-group</code>, or a valid ARN.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source DB parameter group is in a different Amazon Region than the copy, specify a
    ///           valid DB cluster parameter group ARN, for example
    ///           <code>arn:aws:rds:us-east-1:123456789012:cluster-pg:custom-cluster-group1</code>.</p>
    ///             </li>
    ///          </ul>
    public let sourceDBClusterParameterGroupIdentifier: Swift.String?
    /// <p>The tags to be assigned to the copied DB cluster parameter group.</p>
    public let tags: [NeptuneClientTypes.Tag]?
    /// <p>A description for the copied DB cluster parameter group.</p>
    public let targetDBClusterParameterGroupDescription: Swift.String?
    /// <p>The identifier for the copied DB cluster parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Cannot be null, empty, or blank</p>
    ///             </li>
    ///             <li>
    ///                <p>Must contain from 1 to 255 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster-param-group1</code>
    ///          </p>
    public let targetDBClusterParameterGroupIdentifier: Swift.String?

    public init (
        sourceDBClusterParameterGroupIdentifier: Swift.String? = nil,
        tags: [NeptuneClientTypes.Tag]? = nil,
        targetDBClusterParameterGroupDescription: Swift.String? = nil,
        targetDBClusterParameterGroupIdentifier: Swift.String? = nil
    )
    {
        self.sourceDBClusterParameterGroupIdentifier = sourceDBClusterParameterGroupIdentifier
        self.tags = tags
        self.targetDBClusterParameterGroupDescription = targetDBClusterParameterGroupDescription
        self.targetDBClusterParameterGroupIdentifier = targetDBClusterParameterGroupIdentifier
    }
}

extension CopyDBClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExistsFault" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceededFault" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBClusterParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyDBClusterParameterGroupOutputResponse(dBClusterParameterGroup: \(Swift.String(describing: dBClusterParameterGroup)))"}
}

extension CopyDBClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterParameterGroup = output.dBClusterParameterGroup
        } else {
            self.dBClusterParameterGroup = nil
        }
    }
}

public struct CopyDBClusterParameterGroupOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster parameter group.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusterParameterGroups</a> action.</p>
    public let dBClusterParameterGroup: NeptuneClientTypes.DBClusterParameterGroup?

    public init (
        dBClusterParameterGroup: NeptuneClientTypes.DBClusterParameterGroup? = nil
    )
    {
        self.dBClusterParameterGroup = dBClusterParameterGroup
    }
}

struct CopyDBClusterParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBClusterParameterGroup: NeptuneClientTypes.DBClusterParameterGroup?
}

extension CopyDBClusterParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroup = "DBClusterParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CopyDBClusterParameterGroupResult"))
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBClusterParameterGroup.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
    }
}

public struct CopyDBClusterSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBClusterSnapshotOutputError>
}

extension CopyDBClusterSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyDBClusterSnapshotInput(copyTags: \(Swift.String(describing: copyTags)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), preSignedUrl: \(Swift.String(describing: preSignedUrl)), sourceDBClusterSnapshotIdentifier: \(Swift.String(describing: sourceDBClusterSnapshotIdentifier)), tags: \(Swift.String(describing: tags)), targetDBClusterSnapshotIdentifier: \(Swift.String(describing: targetDBClusterSnapshotIdentifier)))"}
}

extension CopyDBClusterSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let copyTags = copyTags {
            try container.encode(copyTags, forKey: ClientRuntime.Key("CopyTags"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: ClientRuntime.Key("PreSignedUrl"))
        }
        if let sourceDBClusterSnapshotIdentifier = sourceDBClusterSnapshotIdentifier {
            try container.encode(sourceDBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("SourceDBClusterSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBClusterSnapshotIdentifier = targetDBClusterSnapshotIdentifier {
            try container.encode(targetDBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("TargetDBClusterSnapshotIdentifier"))
        }
        try container.encode("CopyDBClusterSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CopyDBClusterSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBClusterSnapshotOutputError>
}

public struct CopyDBClusterSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBClusterSnapshotOutputError>
}

public struct CopyDBClusterSnapshotInput: Swift.Equatable {
    /// <p>True to copy all tags from the source DB cluster snapshot to the target DB cluster
    ///       snapshot, and otherwise false. The default is false.</p>
    public let copyTags: Swift.Bool?
    /// <p>The Amazon Amazon KMS key ID for an encrypted DB cluster snapshot. The KMS key ID is the Amazon
    ///       Resource Name (ARN), KMS key identifier, or the KMS key alias for the KMS encryption key.</p>
    ///
    ///          <p>If you copy an encrypted DB cluster snapshot from your Amazon account, you can specify a
    ///       value for <code>KmsKeyId</code> to encrypt the copy with a new KMS encryption key. If you
    ///       don't specify a value for <code>KmsKeyId</code>, then the copy of the DB cluster snapshot is
    ///       encrypted with the same KMS key as the source DB cluster snapshot.</p>
    ///
    ///          <p>If you copy an encrypted DB cluster snapshot that is shared from another Amazon account, then
    ///       you must specify a value for <code>KmsKeyId</code>.</p>
    ///          <p> KMS encryption keys are specific to the Amazon Region that they are created in, and you
    ///       can't use encryption keys from one Amazon Region in another Amazon Region.</p>
    ///
    ///          <p>You cannot encrypt an unencrypted DB cluster snapshot when you copy it. If you try to
    ///       copy an unencrypted DB cluster snapshot and specify a value for the KmsKeyId parameter, an
    ///       error is returned.</p>
    public let kmsKeyId: Swift.String?
    /// <p>Not currently supported.</p>
    public let preSignedUrl: Swift.String?
    /// <p>The identifier of the DB cluster snapshot to copy. This parameter is not
    ///       case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must specify a valid system snapshot in the "available" state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Specify a valid DB snapshot identifier.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster-snapshot1</code>
    ///          </p>
    public let sourceDBClusterSnapshotIdentifier: Swift.String?
    /// <p>The tags to assign to the new DB cluster snapshot copy.</p>
    public let tags: [NeptuneClientTypes.Tag]?
    /// <p>The identifier of the new DB cluster snapshot to create from the source DB cluster
    ///       snapshot. This parameter is not case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster-snapshot2</code>
    ///          </p>
    public let targetDBClusterSnapshotIdentifier: Swift.String?

    public init (
        copyTags: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        preSignedUrl: Swift.String? = nil,
        sourceDBClusterSnapshotIdentifier: Swift.String? = nil,
        tags: [NeptuneClientTypes.Tag]? = nil,
        targetDBClusterSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.copyTags = copyTags
        self.kmsKeyId = kmsKeyId
        self.preSignedUrl = preSignedUrl
        self.sourceDBClusterSnapshotIdentifier = sourceDBClusterSnapshotIdentifier
        self.tags = tags
        self.targetDBClusterSnapshotIdentifier = targetDBClusterSnapshotIdentifier
    }
}

extension CopyDBClusterSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBClusterSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotAlreadyExistsFault" : self = .dBClusterSnapshotAlreadyExistsFault(try DBClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceededFault" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBClusterSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotAlreadyExistsFault(DBClusterSnapshotAlreadyExistsFault)
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBClusterSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyDBClusterSnapshotOutputResponse(dBClusterSnapshot: \(Swift.String(describing: dBClusterSnapshot)))"}
}

extension CopyDBClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyDBClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshot = output.dBClusterSnapshot
        } else {
            self.dBClusterSnapshot = nil
        }
    }
}

public struct CopyDBClusterSnapshotOutputResponse: Swift.Equatable {
    /// <p>Contains the details for an Amazon Neptune DB cluster snapshot</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusterSnapshots</a> action.</p>
    public let dBClusterSnapshot: NeptuneClientTypes.DBClusterSnapshot?

    public init (
        dBClusterSnapshot: NeptuneClientTypes.DBClusterSnapshot? = nil
    )
    {
        self.dBClusterSnapshot = dBClusterSnapshot
    }
}

struct CopyDBClusterSnapshotOutputResponseBody: Swift.Equatable {
    public let dBClusterSnapshot: NeptuneClientTypes.DBClusterSnapshot?
}

extension CopyDBClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshot = "DBClusterSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CopyDBClusterSnapshotResult"))
        let dBClusterSnapshotDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBClusterSnapshot.self, forKey: .dBClusterSnapshot)
        dBClusterSnapshot = dBClusterSnapshotDecoded
    }
}

public struct CopyDBParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBParameterGroupOutputError>
}

extension CopyDBParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyDBParameterGroupInput(sourceDBParameterGroupIdentifier: \(Swift.String(describing: sourceDBParameterGroupIdentifier)), tags: \(Swift.String(describing: tags)), targetDBParameterGroupDescription: \(Swift.String(describing: targetDBParameterGroupDescription)), targetDBParameterGroupIdentifier: \(Swift.String(describing: targetDBParameterGroupIdentifier)))"}
}

extension CopyDBParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceDBParameterGroupIdentifier = sourceDBParameterGroupIdentifier {
            try container.encode(sourceDBParameterGroupIdentifier, forKey: ClientRuntime.Key("SourceDBParameterGroupIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBParameterGroupDescription = targetDBParameterGroupDescription {
            try container.encode(targetDBParameterGroupDescription, forKey: ClientRuntime.Key("TargetDBParameterGroupDescription"))
        }
        if let targetDBParameterGroupIdentifier = targetDBParameterGroupIdentifier {
            try container.encode(targetDBParameterGroupIdentifier, forKey: ClientRuntime.Key("TargetDBParameterGroupIdentifier"))
        }
        try container.encode("CopyDBParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CopyDBParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBParameterGroupOutputError>
}

public struct CopyDBParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBParameterGroupOutputError>
}

public struct CopyDBParameterGroupInput: Swift.Equatable {
    /// <p>The identifier or ARN for the source DB parameter group. For information about creating
    ///       an ARN, see <a href="https://docs.aws.amazon.com/neptune/latest/UserGuide/tagging.ARN.html#tagging.ARN.Constructing"> Constructing an
    ///       Amazon Resource Name (ARN)</a>.</p>
    ///
    ///          <p>Constraints:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>Must specify a valid DB parameter group.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must specify a valid DB parameter group identifier, for example
    ///         <code>my-db-param-group</code>, or a valid ARN.</p>
    ///             </li>
    ///          </ul>
    public let sourceDBParameterGroupIdentifier: Swift.String?
    /// <p>The tags to be assigned to the copied DB parameter group.</p>
    public let tags: [NeptuneClientTypes.Tag]?
    /// <p>A description for the copied DB parameter group.</p>
    public let targetDBParameterGroupDescription: Swift.String?
    /// <p>The identifier for the copied DB parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Cannot be null, empty, or blank.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must contain from 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>Example: <code>my-db-parameter-group</code>
    ///          </p>
    public let targetDBParameterGroupIdentifier: Swift.String?

    public init (
        sourceDBParameterGroupIdentifier: Swift.String? = nil,
        tags: [NeptuneClientTypes.Tag]? = nil,
        targetDBParameterGroupDescription: Swift.String? = nil,
        targetDBParameterGroupIdentifier: Swift.String? = nil
    )
    {
        self.sourceDBParameterGroupIdentifier = sourceDBParameterGroupIdentifier
        self.tags = tags
        self.targetDBParameterGroupDescription = targetDBParameterGroupDescription
        self.targetDBParameterGroupIdentifier = targetDBParameterGroupIdentifier
    }
}

extension CopyDBParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExistsFault" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceededFault" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyDBParameterGroupOutputResponse(dBParameterGroup: \(Swift.String(describing: dBParameterGroup)))"}
}

extension CopyDBParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBParameterGroup = output.dBParameterGroup
        } else {
            self.dBParameterGroup = nil
        }
    }
}

public struct CopyDBParameterGroupOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB parameter group.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBParameterGroups</a> action.</p>
    public let dBParameterGroup: NeptuneClientTypes.DBParameterGroup?

    public init (
        dBParameterGroup: NeptuneClientTypes.DBParameterGroup? = nil
    )
    {
        self.dBParameterGroup = dBParameterGroup
    }
}

struct CopyDBParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBParameterGroup: NeptuneClientTypes.DBParameterGroup?
}

extension CopyDBParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroup = "DBParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CopyDBParameterGroupResult"))
        let dBParameterGroupDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBParameterGroup.self, forKey: .dBParameterGroup)
        dBParameterGroup = dBParameterGroupDecoded
    }
}

public struct CreateDBClusterEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterEndpointOutputError>
}

extension CreateDBClusterEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterEndpointInput(dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), endpointType: \(Swift.String(describing: endpointType)), excludedMembers: \(Swift.String(describing: excludedMembers)), staticMembers: \(Swift.String(describing: staticMembers)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDBClusterEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let endpointType = endpointType {
            try container.encode(endpointType, forKey: ClientRuntime.Key("EndpointType"))
        }
        if let excludedMembers = excludedMembers {
            var excludedMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExcludedMembers"))
            for (index0, string0) in excludedMembers.enumerated() {
                try excludedMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let staticMembers = staticMembers {
            var staticMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("StaticMembers"))
            for (index0, string0) in staticMembers.enumerated() {
                try staticMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBClusterEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBClusterEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterEndpointOutputError>
}

public struct CreateDBClusterEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterEndpointOutputError>
}

public struct CreateDBClusterEndpointInput: Swift.Equatable {
    /// <p>The identifier to use for the new endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: Swift.String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///       stored as a lowercase string.</p>
    public let dBClusterIdentifier: Swift.String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>ANY</code>.</p>
    public let endpointType: Swift.String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///       All other eligible instances are reachable through the custom endpoint.
    ///       Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [Swift.String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [Swift.String]?
    /// <p>The tags to be assigned to the Amazon Neptune resource.</p>
    public let tags: [NeptuneClientTypes.Tag]?

    public init (
        dBClusterEndpointIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        excludedMembers: [Swift.String]? = nil,
        staticMembers: [Swift.String]? = nil,
        tags: [NeptuneClientTypes.Tag]? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.tags = tags
    }
}

extension CreateDBClusterEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterEndpointAlreadyExistsFault" : self = .dBClusterEndpointAlreadyExistsFault(try DBClusterEndpointAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterEndpointQuotaExceededFault" : self = .dBClusterEndpointQuotaExceededFault(try DBClusterEndpointQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterEndpointOutputError: Swift.Error, Swift.Equatable {
    case dBClusterEndpointAlreadyExistsFault(DBClusterEndpointAlreadyExistsFault)
    case dBClusterEndpointQuotaExceededFault(DBClusterEndpointQuotaExceededFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterEndpointOutputResponse(customEndpointType: \(Swift.String(describing: customEndpointType)), dBClusterEndpointArn: \(Swift.String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(Swift.String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), endpoint: \(Swift.String(describing: endpoint)), endpointType: \(Swift.String(describing: endpointType)), excludedMembers: \(Swift.String(describing: excludedMembers)), staticMembers: \(Swift.String(describing: staticMembers)), status: \(Swift.String(describing: status)))"}
}

extension CreateDBClusterEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBClusterEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customEndpointType = output.customEndpointType
            self.dBClusterEndpointArn = output.dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = output.dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = output.dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.endpoint = output.endpoint
            self.endpointType = output.endpointType
            self.excludedMembers = output.excludedMembers
            self.staticMembers = output.staticMembers
            self.status = output.status
        } else {
            self.customEndpointType = nil
            self.dBClusterEndpointArn = nil
            self.dBClusterEndpointIdentifier = nil
            self.dBClusterEndpointResourceIdentifier = nil
            self.dBClusterIdentifier = nil
            self.endpoint = nil
            self.endpointType = nil
            self.excludedMembers = nil
            self.staticMembers = nil
            self.status = nil
        }
    }
}

/// <p>This data type represents the information you need to connect to an Amazon Neptune DB cluster.
///       This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>CreateDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBClusterEndpoints</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>ModifyDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DeleteDBClusterEndpoint</code>
///                </p>
///             </li>
///          </ul>
///          <p>For the data structure that represents Amazon Neptune DB instance endpoints,
///       see <code>Endpoint</code>.</p>
public struct CreateDBClusterEndpointOutputResponse: Swift.Equatable {
    /// <p>The type associated with a custom endpoint. One of: <code>READER</code>,
    ///       <code>WRITER</code>, <code>ANY</code>.</p>
    public let customEndpointType: Swift.String?
    /// <p>The Amazon Resource Name (ARN) for the endpoint.</p>
    public let dBClusterEndpointArn: Swift.String?
    /// <p>The identifier associated with the endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: Swift.String?
    /// <p>A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.</p>
    public let dBClusterEndpointResourceIdentifier: Swift.String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///       stored as a lowercase string.</p>
    public let dBClusterIdentifier: Swift.String?
    /// <p>The DNS address of the endpoint.</p>
    public let endpoint: Swift.String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>CUSTOM</code>.</p>
    public let endpointType: Swift.String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///       All other eligible instances are reachable through the custom endpoint.
    ///       Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [Swift.String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [Swift.String]?
    /// <p>The current status of the endpoint. One of: <code>creating</code>, <code>available</code>, <code>deleting</code>, <code>inactive</code>, <code>modifying</code>. The <code>inactive</code> state applies to an endpoint that cannot be used for a certain kind of cluster,
    ///       such as a <code>writer</code> endpoint for a read-only secondary cluster in a global database.</p>
    public let status: Swift.String?

    public init (
        customEndpointType: Swift.String? = nil,
        dBClusterEndpointArn: Swift.String? = nil,
        dBClusterEndpointIdentifier: Swift.String? = nil,
        dBClusterEndpointResourceIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        endpoint: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        excludedMembers: [Swift.String]? = nil,
        staticMembers: [Swift.String]? = nil,
        status: Swift.String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

struct CreateDBClusterEndpointOutputResponseBody: Swift.Equatable {
    public let dBClusterEndpointIdentifier: Swift.String?
    public let dBClusterIdentifier: Swift.String?
    public let dBClusterEndpointResourceIdentifier: Swift.String?
    public let endpoint: Swift.String?
    public let status: Swift.String?
    public let endpointType: Swift.String?
    public let customEndpointType: Swift.String?
    public let staticMembers: [Swift.String]?
    public let excludedMembers: [Swift.String]?
    public let dBClusterEndpointArn: Swift.String?
}

extension CreateDBClusterEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBClusterEndpointResult"))
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var staticMembersBuffer:[Swift.String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [Swift.String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedMembersBuffer:[Swift.String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [Swift.String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

public struct CreateDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterOutputError>
}

extension CreateDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterInput(availabilityZones: \(Swift.String(describing: availabilityZones)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), characterSetName: \(Swift.String(describing: characterSetName)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), databaseName: \(Swift.String(describing: databaseName)), deletionProtection: \(Swift.String(describing: deletionProtection)), enableCloudwatchLogsExports: \(Swift.String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), masterUsername: \(Swift.String(describing: masterUsername)), optionGroupName: \(Swift.String(describing: optionGroupName)), port: \(Swift.String(describing: port)), preSignedUrl: \(Swift.String(describing: preSignedUrl)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), replicationSourceIdentifier: \(Swift.String(describing: replicationSourceIdentifier)), storageEncrypted: \(Swift.String(describing: storageEncrypted)), tags: \(Swift.String(describing: tags)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension CreateDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: ClientRuntime.Key("PreSignedUrl"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let replicationSourceIdentifier = replicationSourceIdentifier {
            try container.encode(replicationSourceIdentifier, forKey: ClientRuntime.Key("ReplicationSourceIdentifier"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterOutputError>
}

public struct CreateDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterOutputError>
}

public struct CreateDBClusterInput: Swift.Equatable {
    /// <p>A list of EC2 Availability Zones that instances in the DB cluster can be created
    ///       in.</p>
    public let availabilityZones: [Swift.String]?
    /// <p>The number of days for which automated backups are retained. You must specify a minimum
    ///       value of 1.</p>
    ///          <p>Default: 1</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be a value from 1 to 35</p>
    ///             </li>
    ///          </ul>
    public let backupRetentionPeriod: Swift.Int?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let characterSetName: Swift.String?
    /// <p>
    ///             <i>If set to <code>true</code>, tags are copied to any snapshot of
    ///       the DB cluster that is created.</i>
    ///          </p>
    public let copyTagsToSnapshot: Swift.Bool?
    /// <p>The DB cluster identifier. This parameter is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster1</code>
    ///          </p>
    public let dBClusterIdentifier: Swift.String?
    /// <p> The name of the DB cluster parameter group to associate with this DB cluster. If this
    ///       argument is omitted, the default is used.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: Swift.String?
    /// <p>A DB subnet group to associate with this DB cluster.</p>
    ///          <p>Constraints: Must match the name of an existing DBSubnetGroup. Must not be default.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: Swift.String?
    /// <p>The name for your database of up to 64 alpha-numeric characters. If you do not provide a
    ///       name, Amazon Neptune will not create a database in the DB cluster you are creating.</p>
    public let databaseName: Swift.String?
    /// <p>A value that indicates whether the DB cluster has deletion protection enabled.
    ///       The database can't be deleted when deletion protection is enabled. By default,
    ///       deletion protection is enabled.</p>
    public let deletionProtection: Swift.Bool?
    /// <p>The list of log types that need to be enabled for exporting to CloudWatch Logs.</p>
    public let enableCloudwatchLogsExports: [Swift.String]?
    /// <p>If set to <code>true</code>, enables Amazon Identity and Access Management
    ///       (IAM) authentication for the entire DB cluster (this cannot be set at an
    ///       instance level).</p>
    ///          <p>Default: <code>false</code>.</p>
    public let enableIAMDatabaseAuthentication: Swift.Bool?
    /// <p>The name of the database engine to be used for this DB cluster.</p>
    ///          <p>Valid Values: <code>neptune</code>
    ///          </p>
    public let engine: Swift.String?
    /// <p>The version number of the database engine to use for the new DB cluster.</p>
    ///          <p>Example: <code>1.0.2.1</code>
    ///          </p>
    public let engineVersion: Swift.String?
    /// <p>The Amazon KMS key identifier for an encrypted DB cluster.</p>
    ///          <p>The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If
    ///       you are creating a DB cluster with the same Amazon account that owns the KMS encryption key used
    ///       to encrypt the new DB cluster, then you can use the KMS key alias instead of the ARN for the
    ///       KMS encryption key.</p>
    ///          <p>If an encryption key is not specified in <code>KmsKeyId</code>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If <code>ReplicationSourceIdentifier</code> identifies an encrypted source, then
    ///           Amazon Neptune will use the encryption key used to encrypt the source. Otherwise, Amazon
    ///           Neptune will use your default encryption key.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the <code>StorageEncrypted</code> parameter is true and
    ///           <code>ReplicationSourceIdentifier</code> is not specified, then Amazon Neptune will use
    ///           your default encryption key.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Amazon KMS creates the default encryption key for your Amazon account. Your Amazon account has a
    ///       different default encryption key for each Amazon Region.</p>
    ///          <p>If you create a Read Replica of an encrypted DB cluster in another Amazon Region, you must
    ///       set <code>KmsKeyId</code> to a KMS key ID that is valid in the destination Amazon Region. This
    ///       key is used to encrypt the Read Replica in that Amazon Region.</p>
    public let kmsKeyId: Swift.String?
    /// <p>Not supported by Neptune.</p>
    public let masterUserPassword: Swift.String?
    /// <p>Not supported by Neptune.</p>
    public let masterUsername: Swift.String?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let optionGroupName: Swift.String?
    /// <p>The port number on which the instances in the DB cluster accept connections.</p>
    ///          <p> Default: <code>8182</code>
    ///          </p>
    public let port: Swift.Int?
    /// <p>This parameter is not currently supported.</p>
    public let preSignedUrl: Swift.String?
    /// <p>The daily time range during which automated backups are created if automated backups are
    ///       enabled using the <code>BackupRetentionPeriod</code> parameter.</p>
    ///          <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    ///       Amazon Region. To see the time blocks available, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/AdjustingTheMaintenanceWindow.html"> Adjusting the Preferred
    ///       Maintenance Window</a> in the <i>Amazon Neptune User Guide.</i>
    ///          </p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be in the format <code>hh24:mi-hh24:mi</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be in Universal Coordinated Time (UTC).</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not conflict with the preferred maintenance window.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be at least 30 minutes.</p>
    ///             </li>
    ///          </ul>
    public let preferredBackupWindow: Swift.String?
    /// <p>The weekly time range during which system maintenance can occur, in Universal Coordinated
    ///       Time (UTC).</p>
    ///          <p>Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///          </p>
    ///          <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    ///       Amazon Region, occurring on a random day of the week. To see the time blocks available, see
    ///       <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/AdjustingTheMaintenanceWindow.html"> Adjusting the Preferred
    ///       Maintenance Window</a> in the <i>Amazon Neptune User Guide.</i>
    ///          </p>
    ///          <p>Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
    ///          <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster
    ///       is created as a Read Replica.</p>
    public let replicationSourceIdentifier: Swift.String?
    /// <p>Specifies whether the DB cluster is encrypted.</p>
    public let storageEncrypted: Swift.Bool?
    /// <p>The tags to assign to the new DB cluster.</p>
    public let tags: [NeptuneClientTypes.Tag]?
    /// <p>A list of EC2 VPC security groups to associate with this DB cluster.</p>
    public let vpcSecurityGroupIds: [Swift.String]?

    public init (
        availabilityZones: [Swift.String]? = nil,
        backupRetentionPeriod: Swift.Int? = nil,
        characterSetName: Swift.String? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterParameterGroupName: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        masterUserPassword: Swift.String? = nil,
        masterUsername: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        preSignedUrl: Swift.String? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        replicationSourceIdentifier: Swift.String? = nil,
        storageEncrypted: Swift.Bool? = nil,
        tags: [NeptuneClientTypes.Tag]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.backupRetentionPeriod = backupRetentionPeriod
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.optionGroupName = optionGroupName
        self.port = port
        self.preSignedUrl = preSignedUrl
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.replicationSourceIdentifier = replicationSourceIdentifier
        self.storageEncrypted = storageEncrypted
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension CreateDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFoundFault" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacityFault" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension CreateDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct CreateDBClusterOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: NeptuneClientTypes.DBCluster?

    public init (
        dBCluster: NeptuneClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct CreateDBClusterOutputResponseBody: Swift.Equatable {
    public let dBCluster: NeptuneClientTypes.DBCluster?
}

extension CreateDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct CreateDBClusterParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterParameterGroupOutputError>
}

extension CreateDBClusterParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterParameterGroupInput(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), description: \(Swift.String(describing: description)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDBClusterParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBClusterParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterParameterGroupOutputError>
}

public struct CreateDBClusterParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterParameterGroupOutputError>
}

public struct CreateDBClusterParameterGroupInput: Swift.Equatable {
    /// <p>The name of the DB cluster parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>This value is stored as a lowercase string.</p>
    ///          </note>
    public let dBClusterParameterGroupName: Swift.String?
    /// <p>The DB cluster parameter group family name. A DB cluster parameter group can be associated
    ///       with one and only one DB cluster parameter group family, and can be applied only to a DB
    ///       cluster running a database engine and engine version compatible with that DB cluster parameter
    ///       group family.</p>
    public let dBParameterGroupFamily: Swift.String?
    /// <p>The description for the DB cluster parameter group.</p>
    public let description: Swift.String?
    /// <p>The tags to be assigned to the new DB cluster parameter group.</p>
    public let tags: [NeptuneClientTypes.Tag]?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil,
        dBParameterGroupFamily: Swift.String? = nil,
        description: Swift.String? = nil,
        tags: [NeptuneClientTypes.Tag]? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.description = description
        self.tags = tags
    }
}

extension CreateDBClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExistsFault" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceededFault" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterParameterGroupOutputResponse(dBClusterParameterGroup: \(Swift.String(describing: dBClusterParameterGroup)))"}
}

extension CreateDBClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterParameterGroup = output.dBClusterParameterGroup
        } else {
            self.dBClusterParameterGroup = nil
        }
    }
}

public struct CreateDBClusterParameterGroupOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster parameter group.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusterParameterGroups</a> action.</p>
    public let dBClusterParameterGroup: NeptuneClientTypes.DBClusterParameterGroup?

    public init (
        dBClusterParameterGroup: NeptuneClientTypes.DBClusterParameterGroup? = nil
    )
    {
        self.dBClusterParameterGroup = dBClusterParameterGroup
    }
}

struct CreateDBClusterParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBClusterParameterGroup: NeptuneClientTypes.DBClusterParameterGroup?
}

extension CreateDBClusterParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroup = "DBClusterParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBClusterParameterGroupResult"))
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBClusterParameterGroup.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
    }
}

public struct CreateDBClusterSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterSnapshotOutputError>
}

extension CreateDBClusterSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterSnapshotInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterSnapshotIdentifier: \(Swift.String(describing: dBClusterSnapshotIdentifier)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDBClusterSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBClusterSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBClusterSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterSnapshotOutputError>
}

public struct CreateDBClusterSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterSnapshotOutputError>
}

public struct CreateDBClusterSnapshotInput: Swift.Equatable {
    /// <p>The identifier of the DB cluster to create a snapshot for. This parameter is not
    ///       case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBCluster.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster1</code>
    ///          </p>
    public let dBClusterIdentifier: Swift.String?
    /// <p>The identifier of the DB cluster snapshot. This parameter is stored as a lowercase
    ///       string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster1-snapshot1</code>
    ///          </p>
    public let dBClusterSnapshotIdentifier: Swift.String?
    /// <p>The tags to be assigned to the DB cluster snapshot.</p>
    public let tags: [NeptuneClientTypes.Tag]?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterSnapshotIdentifier: Swift.String? = nil,
        tags: [NeptuneClientTypes.Tag]? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.tags = tags
    }
}

extension CreateDBClusterSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotAlreadyExistsFault" : self = .dBClusterSnapshotAlreadyExistsFault(try DBClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceededFault" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterSnapshotAlreadyExistsFault(DBClusterSnapshotAlreadyExistsFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterSnapshotOutputResponse(dBClusterSnapshot: \(Swift.String(describing: dBClusterSnapshot)))"}
}

extension CreateDBClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshot = output.dBClusterSnapshot
        } else {
            self.dBClusterSnapshot = nil
        }
    }
}

public struct CreateDBClusterSnapshotOutputResponse: Swift.Equatable {
    /// <p>Contains the details for an Amazon Neptune DB cluster snapshot</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusterSnapshots</a> action.</p>
    public let dBClusterSnapshot: NeptuneClientTypes.DBClusterSnapshot?

    public init (
        dBClusterSnapshot: NeptuneClientTypes.DBClusterSnapshot? = nil
    )
    {
        self.dBClusterSnapshot = dBClusterSnapshot
    }
}

struct CreateDBClusterSnapshotOutputResponseBody: Swift.Equatable {
    public let dBClusterSnapshot: NeptuneClientTypes.DBClusterSnapshot?
}

extension CreateDBClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshot = "DBClusterSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBClusterSnapshotResult"))
        let dBClusterSnapshotDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBClusterSnapshot.self, forKey: .dBClusterSnapshot)
        dBClusterSnapshot = dBClusterSnapshotDecoded
    }
}

public struct CreateDBInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBInstanceOutputError>
}

extension CreateDBInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBInstanceInput(allocatedStorage: \(Swift.String(describing: allocatedStorage)), autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), availabilityZone: \(Swift.String(describing: availabilityZone)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), characterSetName: \(Swift.String(describing: characterSetName)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dBName: \(Swift.String(describing: dBName)), dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), dBSecurityGroups: \(Swift.String(describing: dBSecurityGroups)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), deletionProtection: \(Swift.String(describing: deletionProtection)), domain: \(Swift.String(describing: domain)), domainIAMRoleName: \(Swift.String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(Swift.String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), enablePerformanceInsights: \(Swift.String(describing: enablePerformanceInsights)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), iops: \(Swift.String(describing: iops)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), licenseModel: \(Swift.String(describing: licenseModel)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), masterUsername: \(Swift.String(describing: masterUsername)), monitoringInterval: \(Swift.String(describing: monitoringInterval)), monitoringRoleArn: \(Swift.String(describing: monitoringRoleArn)), multiAZ: \(Swift.String(describing: multiAZ)), optionGroupName: \(Swift.String(describing: optionGroupName)), performanceInsightsKMSKeyId: \(Swift.String(describing: performanceInsightsKMSKeyId)), port: \(Swift.String(describing: port)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), promotionTier: \(Swift.String(describing: promotionTier)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), storageEncrypted: \(Swift.String(describing: storageEncrypted)), storageType: \(Swift.String(describing: storageType)), tags: \(Swift.String(describing: tags)), tdeCredentialArn: \(Swift.String(describing: tdeCredentialArn)), tdeCredentialPassword: \(Swift.String(describing: tdeCredentialPassword)), timezone: \(Swift.String(describing: timezone)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension CreateDBInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSecurityGroups"))
            for (index0, string0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(string0, forKey: ClientRuntime.Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: ClientRuntime.Key("EnablePerformanceInsights"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: ClientRuntime.Key("PromotionTier"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: ClientRuntime.Key("TdeCredentialPassword"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: ClientRuntime.Key("Timezone"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBInstanceOutputError>
}

public struct CreateDBInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBInstanceOutputError>
}

public struct CreateDBInstanceInput: Swift.Equatable {
    /// <p>Not supported by Neptune.</p>
    public let allocatedStorage: Swift.Int?
    /// <p>Indicates that minor engine upgrades are applied automatically to the DB instance during
    ///       the maintenance window.</p>
    ///          <p>Default: <code>true</code>
    ///          </p>
    public let autoMinorVersionUpgrade: Swift.Bool?
    /// <p> The EC2 Availability Zone that the DB instance is created in</p>
    ///          <p>Default: A random, system-chosen Availability Zone in the endpoint's Amazon Region.</p>
    ///          <p> Example: <code>us-east-1d</code>
    ///          </p>
    ///          <p> Constraint: The AvailabilityZone parameter can't be specified if the MultiAZ parameter is
    ///       set to <code>true</code>. The specified Availability Zone must be in the same Amazon Region as
    ///       the current endpoint.</p>
    public let availabilityZone: Swift.String?
    /// <p>The number of days for which automated backups are
    ///       retained.</p>
    ///          <p>Not applicable. The retention period for automated backups is managed by the DB cluster.
    ///       For more information, see <a>CreateDBCluster</a>.</p>
    ///          <p>Default: 1</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be a value from 0 to 35</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot be set to 0 if the DB instance is a source to Read Replicas</p>
    ///             </li>
    ///          </ul>
    public let backupRetentionPeriod: Swift.Int?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let characterSetName: Swift.String?
    /// <p>True to copy all tags from the DB instance to snapshots of the DB instance, and otherwise
    ///       false. The default is false.</p>
    public let copyTagsToSnapshot: Swift.Bool?
    /// <p>The identifier of the DB cluster that the instance will belong to.</p>
    ///          <p>For information on creating a DB cluster, see <a>CreateDBCluster</a>.</p>
    ///          <p>Type: String</p>
    public let dBClusterIdentifier: Swift.String?
    /// <p>The compute and memory capacity of the DB instance, for example, <code>db.m4.large</code>.
    ///       Not all DB instance classes are available in all Amazon Regions.</p>
    public let dBInstanceClass: Swift.String?
    /// <p>The DB instance identifier. This parameter is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>mydbinstance</code>
    ///          </p>
    public let dBInstanceIdentifier: Swift.String?
    /// <p>Not supported.</p>
    public let dBName: Swift.String?
    /// <p>The name of the DB parameter group to associate with this DB instance. If this argument is
    ///       omitted, the default DBParameterGroup for the specified engine is used.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: Swift.String?
    /// <p>A list of DB security groups to associate with this DB instance.</p>
    ///          <p>Default: The default DB security group for the database engine.</p>
    public let dBSecurityGroups: [Swift.String]?
    /// <p>A DB subnet group to associate with this DB instance.</p>
    ///          <p>If there is no DB subnet group, then it is a non-VPC DB instance.</p>
    public let dBSubnetGroupName: Swift.String?
    /// <p>A value that indicates whether the DB instance has deletion protection enabled.
    ///       The database can't be deleted when deletion protection is enabled. By default,
    ///       deletion protection is disabled. See <a href="https://docs.aws.amazon.com/neptune/latest/userguide/manage-console-instances-delete.html">Deleting
    ///       a DB Instance</a>.</p>
    ///
    ///          <p>DB instances in a DB cluster can be deleted even when deletion
    ///       protection is enabled in their parent DB cluster.</p>
    public let deletionProtection: Swift.Bool?
    /// <p>Specify the Active Directory Domain to create the instance in.</p>
    public let domain: Swift.String?
    /// <p>Specify the name of the IAM role to be used when making API calls to the Directory
    ///       Service.</p>
    public let domainIAMRoleName: Swift.String?
    /// <p>The list of log types that need to be enabled for exporting to CloudWatch Logs.</p>
    public let enableCloudwatchLogsExports: [Swift.String]?
    /// <p>Not supported by Neptune (ignored).</p>
    public let enableIAMDatabaseAuthentication: Swift.Bool?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let enablePerformanceInsights: Swift.Bool?
    /// <p>The name of the database engine to be used for this instance.</p>
    ///          <p>Valid Values: <code>neptune</code>
    ///          </p>
    public let engine: Swift.String?
    /// <p>The version number of the database engine to use. Currently, setting this
    ///       parameter has no effect.</p>
    public let engineVersion: Swift.String?
    /// <p>The amount of Provisioned IOPS (input/output operations per second) to be initially
    ///       allocated for the DB instance.</p>
    public let iops: Swift.Int?
    /// <p>The Amazon KMS key identifier for an encrypted DB instance.</p>
    ///          <p>The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If
    ///       you are creating a DB instance with the same Amazon account that owns the KMS encryption key used
    ///       to encrypt the new DB instance, then you can use the KMS key alias instead of the ARN for the
    ///       KM encryption key.</p>
    ///          <p>Not applicable. The KMS key identifier is managed by the DB cluster. For more information,
    ///       see <a>CreateDBCluster</a>.</p>
    ///          <p>If the <code>StorageEncrypted</code> parameter is true, and you do not specify a value for
    ///       the <code>KmsKeyId</code> parameter, then Amazon Neptune will use your default encryption key.
    ///       Amazon KMS creates the default encryption key for your Amazon account. Your Amazon account has a
    ///       different default encryption key for each Amazon Region.</p>
    public let kmsKeyId: Swift.String?
    /// <p>License model information for this DB instance.</p>
    ///          <p> Valid values: <code>license-included</code> | <code>bring-your-own-license</code> |
    ///       <code>general-public-license</code>
    ///          </p>
    public let licenseModel: Swift.String?
    /// <p>Not supported by Neptune.</p>
    public let masterUserPassword: Swift.String?
    /// <p>Not supported by Neptune.</p>
    public let masterUsername: Swift.String?
    /// <p>The interval, in seconds, between points when Enhanced Monitoring metrics are collected
    ///       for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default
    ///       is 0.</p>
    ///          <p>If <code>MonitoringRoleArn</code> is specified, then you must also set
    ///       <code>MonitoringInterval</code> to a value other than 0.</p>
    ///          <p>Valid Values: <code>0, 1, 5, 10, 15, 30, 60</code>
    ///          </p>
    public let monitoringInterval: Swift.Int?
    /// <p>The ARN for the IAM role that permits Neptune to send enhanced monitoring metrics to
    ///       Amazon CloudWatch Logs. For example,
    ///       <code>arn:aws:iam:123456789012:role/emaccess</code>.</p>
    ///          <p>If <code>MonitoringInterval</code> is set to a value other than 0, then you must supply a
    ///       <code>MonitoringRoleArn</code> value.</p>
    public let monitoringRoleArn: Swift.String?
    /// <p>Specifies if the DB instance is a Multi-AZ deployment. You can't set the AvailabilityZone
    ///       parameter if the MultiAZ parameter is set to true.</p>
    public let multiAZ: Swift.Bool?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let optionGroupName: Swift.String?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let performanceInsightsKMSKeyId: Swift.String?
    /// <p>The port number on which the database accepts connections.</p>
    ///          <p>Not applicable. The port is managed by the DB cluster. For more information, see <a>CreateDBCluster</a>.</p>
    ///          <p> Default: <code>8182</code>
    ///          </p>
    ///          <p>Type: Integer</p>
    public let port: Swift.Int?
    /// <p> The daily time range during which automated backups are created.</p>
    ///          <p>Not applicable. The daily time range for creating automated backups is managed by the DB
    ///       cluster. For more information, see <a>CreateDBCluster</a>.</p>
    public let preferredBackupWindow: Swift.String?
    /// <p>The time range each week during which system maintenance can occur, in Universal
    ///       Coordinated Time (UTC).</p>
    ///          <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///          </p>
    ///          <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    ///       Amazon Region, occurring on a random day of the week.</p>
    ///          <p>Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
    ///          <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: Swift.String?
    /// <p>A value that specifies the order in which an Read Replica is promoted to the primary
    ///       instance after a failure of the existing primary instance.
    ///       </p>
    ///          <p>Default: 1</p>
    ///          <p>Valid Values: 0 - 15</p>
    public let promotionTier: Swift.Int?
    /// <p>This flag should no longer be used.</p>
    @available(*, deprecated)
    public let publiclyAccessible: Swift.Bool?
    /// <p>Specifies whether the DB instance is encrypted.</p>
    ///          <p>Not applicable. The encryption for DB instances is managed by the DB cluster. For more
    ///       information, see <a>CreateDBCluster</a>.</p>
    ///          <p>Default: false</p>
    public let storageEncrypted: Swift.Bool?
    /// <p>Specifies the storage type to be associated with the DB instance.</p>
    ///          <p>Not applicable. Storage is managed by the DB Cluster.</p>
    public let storageType: Swift.String?
    /// <p>The tags to assign to the new instance.</p>
    public let tags: [NeptuneClientTypes.Tag]?
    /// <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
    public let tdeCredentialArn: Swift.String?
    /// <p>The password for the given ARN from the key store in order to access the device.</p>
    public let tdeCredentialPassword: Swift.String?
    /// <p>The time zone of the DB instance.</p>
    public let timezone: Swift.String?
    /// <p>A list of EC2 VPC security groups to associate with this DB instance.</p>
    ///          <p>Not applicable. The associated list of EC2 VPC security groups is managed by the DB
    ///       cluster. For more information, see <a>CreateDBCluster</a>.</p>
    ///          <p>Default: The default EC2 VPC security group for the DB subnet group's VPC.</p>
    public let vpcSecurityGroupIds: [Swift.String]?

    public init (
        allocatedStorage: Swift.Int? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZone: Swift.String? = nil,
        backupRetentionPeriod: Swift.Int? = nil,
        characterSetName: Swift.String? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBInstanceClass: Swift.String? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        dBName: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        dBSecurityGroups: [Swift.String]? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        enablePerformanceInsights: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        iops: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        licenseModel: Swift.String? = nil,
        masterUserPassword: Swift.String? = nil,
        masterUsername: Swift.String? = nil,
        monitoringInterval: Swift.Int? = nil,
        monitoringRoleArn: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        optionGroupName: Swift.String? = nil,
        performanceInsightsKMSKeyId: Swift.String? = nil,
        port: Swift.Int? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        promotionTier: Swift.Int? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        storageEncrypted: Swift.Bool? = nil,
        storageType: Swift.String? = nil,
        tags: [NeptuneClientTypes.Tag]? = nil,
        tdeCredentialArn: Swift.String? = nil,
        tdeCredentialPassword: Swift.String? = nil,
        timezone: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.backupRetentionPeriod = backupRetentionPeriod
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBName = dBName
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSecurityGroups = dBSecurityGroups
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.engine = engine
        self.engineVersion = engineVersion
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.promotionTier = promotionTier
        self.publiclyAccessible = publiclyAccessible
        self.storageEncrypted = storageEncrypted
        self.storageType = storageType
        self.tags = tags
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.timezone = timezone
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension CreateDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFoundFault" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExistsFault" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFoundFault" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceededFault" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacityFault" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupportedFault" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBInstanceOutputResponse(dBInstance: \(Swift.String(describing: dBInstance)))"}
}

extension CreateDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct CreateDBInstanceOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB instance.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBInstances</a> action.</p>
    public let dBInstance: NeptuneClientTypes.DBInstance?

    public init (
        dBInstance: NeptuneClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct CreateDBInstanceOutputResponseBody: Swift.Equatable {
    public let dBInstance: NeptuneClientTypes.DBInstance?
}

extension CreateDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct CreateDBParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBParameterGroupOutputError>
}

extension CreateDBParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBParameterGroupInput(dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), description: \(Swift.String(describing: description)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDBParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBParameterGroupOutputError>
}

public struct CreateDBParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBParameterGroupOutputError>
}

public struct CreateDBParameterGroupInput: Swift.Equatable {
    /// <p>The DB parameter group family name. A DB parameter group can be associated with one and
    ///       only one DB parameter group family, and can be applied only to a DB instance running a
    ///       database engine and engine version compatible with that DB parameter group family.</p>
    public let dBParameterGroupFamily: Swift.String?
    /// <p>The name of the DB parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>This value is stored as a lowercase string.</p>
    ///          </note>
    public let dBParameterGroupName: Swift.String?
    /// <p>The description for the DB parameter group.</p>
    public let description: Swift.String?
    /// <p>The tags to be assigned to the new DB parameter group.</p>
    public let tags: [NeptuneClientTypes.Tag]?

    public init (
        dBParameterGroupFamily: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        description: Swift.String? = nil,
        tags: [NeptuneClientTypes.Tag]? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.dBParameterGroupName = dBParameterGroupName
        self.description = description
        self.tags = tags
    }
}

extension CreateDBParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExistsFault" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceededFault" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBParameterGroupOutputResponse(dBParameterGroup: \(Swift.String(describing: dBParameterGroup)))"}
}

extension CreateDBParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBParameterGroup = output.dBParameterGroup
        } else {
            self.dBParameterGroup = nil
        }
    }
}

public struct CreateDBParameterGroupOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB parameter group.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBParameterGroups</a> action.</p>
    public let dBParameterGroup: NeptuneClientTypes.DBParameterGroup?

    public init (
        dBParameterGroup: NeptuneClientTypes.DBParameterGroup? = nil
    )
    {
        self.dBParameterGroup = dBParameterGroup
    }
}

struct CreateDBParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBParameterGroup: NeptuneClientTypes.DBParameterGroup?
}

extension CreateDBParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroup = "DBParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBParameterGroupResult"))
        let dBParameterGroupDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBParameterGroup.self, forKey: .dBParameterGroup)
        dBParameterGroup = dBParameterGroupDecoded
    }
}

public struct CreateDBSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBSubnetGroupOutputError>
}

extension CreateDBSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBSubnetGroupInput(dBSubnetGroupDescription: \(Swift.String(describing: dBSubnetGroupDescription)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), subnetIds: \(Swift.String(describing: subnetIds)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDBSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSubnetGroupDescription = dBSubnetGroupDescription {
            try container.encode(dBSubnetGroupDescription, forKey: ClientRuntime.Key("DBSubnetGroupDescription"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SubnetIds"))
            for (index0, string0) in subnetIds.enumerated() {
                try subnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("SubnetIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBSubnetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBSubnetGroupOutputError>
}

public struct CreateDBSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBSubnetGroupOutputError>
}

public struct CreateDBSubnetGroupInput: Swift.Equatable {
    /// <p>The description for the DB subnet group.</p>
    public let dBSubnetGroupDescription: Swift.String?
    /// <p>The name for the DB subnet group. This value is stored as a lowercase string.</p>
    ///          <p>Constraints: Must contain no more than 255 letters, numbers, periods, underscores, spaces,
    ///       or hyphens. Must not be default.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: Swift.String?
    /// <p>The EC2 Subnet IDs for the DB subnet group.</p>
    public let subnetIds: [Swift.String]?
    /// <p>The tags to be assigned to the new DB subnet group.</p>
    public let tags: [NeptuneClientTypes.Tag]?

    public init (
        dBSubnetGroupDescription: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [NeptuneClientTypes.Tag]? = nil
    )
    {
        self.dBSubnetGroupDescription = dBSubnetGroupDescription
        self.dBSubnetGroupName = dBSubnetGroupName
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

extension CreateDBSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupAlreadyExistsFault" : self = .dBSubnetGroupAlreadyExistsFault(try DBSubnetGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupQuotaExceededFault" : self = .dBSubnetGroupQuotaExceededFault(try DBSubnetGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetQuotaExceededFault" : self = .dBSubnetQuotaExceededFault(try DBSubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case dBSubnetGroupAlreadyExistsFault(DBSubnetGroupAlreadyExistsFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupQuotaExceededFault(DBSubnetGroupQuotaExceededFault)
    case dBSubnetQuotaExceededFault(DBSubnetQuotaExceededFault)
    case invalidSubnet(InvalidSubnet)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBSubnetGroupOutputResponse(dBSubnetGroup: \(Swift.String(describing: dBSubnetGroup)))"}
}

extension CreateDBSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSubnetGroup = output.dBSubnetGroup
        } else {
            self.dBSubnetGroup = nil
        }
    }
}

public struct CreateDBSubnetGroupOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB subnet group.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBSubnetGroups</a> action.</p>
    public let dBSubnetGroup: NeptuneClientTypes.DBSubnetGroup?

    public init (
        dBSubnetGroup: NeptuneClientTypes.DBSubnetGroup? = nil
    )
    {
        self.dBSubnetGroup = dBSubnetGroup
    }
}

struct CreateDBSubnetGroupOutputResponseBody: Swift.Equatable {
    public let dBSubnetGroup: NeptuneClientTypes.DBSubnetGroup?
}

extension CreateDBSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroup = "DBSubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBSubnetGroupResult"))
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBSubnetGroup.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
    }
}

public struct CreateEventSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSubscriptionOutputError>
}

extension CreateEventSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventSubscriptionInput(enabled: \(Swift.String(describing: enabled)), eventCategories: \(Swift.String(describing: eventCategories)), snsTopicArn: \(Swift.String(describing: snsTopicArn)), sourceIds: \(Swift.String(describing: sourceIds)), sourceType: \(Swift.String(describing: sourceType)), subscriptionName: \(Swift.String(describing: subscriptionName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateEventSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: ClientRuntime.Key("SnsTopicArn"))
        }
        if let sourceIds = sourceIds {
            var sourceIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SourceIds"))
            for (index0, string0) in sourceIds.enumerated() {
                try sourceIdsContainer.encode(string0, forKey: ClientRuntime.Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateEventSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateEventSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSubscriptionOutputError>
}

public struct CreateEventSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSubscriptionOutputError>
}

public struct CreateEventSubscriptionInput: Swift.Equatable {
    /// <p> A Boolean value; set to <b>true</b> to activate the
    ///       subscription, set to <b>false</b> to create the subscription but not
    ///       active it.</p>
    public let enabled: Swift.Bool?
    /// <p> A list of event categories for a SourceType that you want to subscribe to. You can see a
    ///       list of the categories for a given SourceType by using the
    ///       <b>DescribeEventCategories</b> action.</p>
    public let eventCategories: [Swift.String]?
    /// <p>The Amazon Resource Name (ARN) of the SNS topic created for event notification. The ARN is
    ///       created by Amazon SNS when you create a topic and subscribe to it.</p>
    public let snsTopicArn: Swift.String?
    /// <p>The list of identifiers of the event sources for which events are returned. If not
    ///       specified, then all sources are included in the response. An identifier must begin with a
    ///       letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or
    ///       contain two consecutive hyphens.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If SourceIds are supplied, SourceType must also be provided.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB instance, then a <code>DBInstanceIdentifier</code> must be
    ///           supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB security group, a <code>DBSecurityGroupName</code> must be
    ///           supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB parameter group, a <code>DBParameterGroupName</code> must
    ///           be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is a DB snapshot, a <code>DBSnapshotIdentifier</code> must be
    ///           supplied.</p>
    ///             </li>
    ///          </ul>
    public let sourceIds: [Swift.String]?
    /// <p>The type of source that is generating the events. For example, if you want to be notified
    ///       of events generated by a DB instance, you would set this parameter to db-instance. if this
    ///       value is not specified, all events are returned.</p>
    ///          <p>Valid values: <code>db-instance</code> | <code>db-cluster</code> |
    ///       <code>db-parameter-group</code> | <code>db-security-group</code> | <code>db-snapshot</code> |
    ///       <code>db-cluster-snapshot</code>
    ///          </p>
    public let sourceType: Swift.String?
    /// <p>The name of the subscription.</p>
    ///          <p>Constraints: The name must be less than 255 characters.</p>
    public let subscriptionName: Swift.String?
    /// <p>The tags to be applied to the new event subscription.</p>
    public let tags: [NeptuneClientTypes.Tag]?

    public init (
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceIds: [Swift.String]? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil,
        tags: [NeptuneClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceIds = sourceIds
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
        self.tags = tags
    }
}

extension CreateEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EventSubscriptionQuotaExceededFault" : self = .eventSubscriptionQuotaExceededFault(try EventSubscriptionQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSTopicArnNotFoundFault" : self = .sNSTopicArnNotFoundFault(try SNSTopicArnNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceNotFoundFault" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionAlreadyExistFault" : self = .subscriptionAlreadyExistFault(try SubscriptionAlreadyExistFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionCategoryNotFoundFault" : self = .subscriptionCategoryNotFoundFault(try SubscriptionCategoryNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case eventSubscriptionQuotaExceededFault(EventSubscriptionQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case sNSTopicArnNotFoundFault(SNSTopicArnNotFoundFault)
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionAlreadyExistFault(SubscriptionAlreadyExistFault)
    case subscriptionCategoryNotFoundFault(SubscriptionCategoryNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventSubscriptionOutputResponse(eventSubscription: \(Swift.String(describing: eventSubscription)))"}
}

extension CreateEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct CreateEventSubscriptionOutputResponse: Swift.Equatable {
    /// <p>Contains the results of a successful invocation of the <a>DescribeEventSubscriptions</a> action.</p>
    public let eventSubscription: NeptuneClientTypes.EventSubscription?

    public init (
        eventSubscription: NeptuneClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct CreateEventSubscriptionOutputResponseBody: Swift.Equatable {
    public let eventSubscription: NeptuneClientTypes.EventSubscription?
}

extension CreateEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

extension NeptuneClientTypes.DBCluster: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case associatedRoles = "AssociatedRoles"
        case automaticRestartTime = "AutomaticRestartTime"
        case availabilityZones = "AvailabilityZones"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case characterSetName = "CharacterSetName"
        case cloneGroupId = "CloneGroupId"
        case clusterCreateTime = "ClusterCreateTime"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case crossAccountClone = "CrossAccountClone"
        case dBClusterArn = "DBClusterArn"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterMembers = "DBClusterMembers"
        case dBClusterOptionGroupMemberships = "DBClusterOptionGroupMemberships"
        case dBClusterParameterGroup = "DBClusterParameterGroup"
        case dBSubnetGroup = "DBSubnetGroup"
        case databaseName = "DatabaseName"
        case dbClusterResourceId = "DbClusterResourceId"
        case deletionProtection = "DeletionProtection"
        case earliestRestorableTime = "EarliestRestorableTime"
        case enabledCloudwatchLogsExports = "EnabledCloudwatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case hostedZoneId = "HostedZoneId"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case kmsKeyId = "KmsKeyId"
        case latestRestorableTime = "LatestRestorableTime"
        case masterUsername = "MasterUsername"
        case multiAZ = "MultiAZ"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case readReplicaIdentifiers = "ReadReplicaIdentifiers"
        case readerEndpoint = "ReaderEndpoint"
        case replicationSourceIdentifier = "ReplicationSourceIdentifier"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let associatedRoles = associatedRoles {
            var associatedRolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AssociatedRoles"))
            for (index0, dbclusterrole0) in associatedRoles.enumerated() {
                try associatedRolesContainer.encode(dbclusterrole0, forKey: ClientRuntime.Key("DBClusterRole.\(index0.advanced(by: 1))"))
            }
        }
        if let automaticRestartTime = automaticRestartTime {
            try container.encode(ClientRuntime.TimestampWrapper(automaticRestartTime, format: .dateTime), forKey: ClientRuntime.Key("automaticRestartTime"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
        if let cloneGroupId = cloneGroupId {
            try container.encode(cloneGroupId, forKey: ClientRuntime.Key("CloneGroupId"))
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: ClientRuntime.Key("clusterCreateTime"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let crossAccountClone = crossAccountClone {
            try container.encode(crossAccountClone, forKey: ClientRuntime.Key("CrossAccountClone"))
        }
        if let dBClusterArn = dBClusterArn {
            try container.encode(dBClusterArn, forKey: ClientRuntime.Key("DBClusterArn"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterMembers = dBClusterMembers {
            var dBClusterMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBClusterMembers"))
            for (index0, dbclustermember0) in dBClusterMembers.enumerated() {
                try dBClusterMembersContainer.encode(dbclustermember0, forKey: ClientRuntime.Key("DBClusterMember.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterOptionGroupMemberships = dBClusterOptionGroupMemberships {
            var dBClusterOptionGroupMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBClusterOptionGroupMemberships"))
            for (index0, dbclusteroptiongroupstatus0) in dBClusterOptionGroupMemberships.enumerated() {
                try dBClusterOptionGroupMembershipsContainer.encode(dbclusteroptiongroupstatus0, forKey: ClientRuntime.Key("DBClusterOptionGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterParameterGroup = dBClusterParameterGroup {
            try container.encode(dBClusterParameterGroup, forKey: ClientRuntime.Key("DBClusterParameterGroup"))
        }
        if let dBSubnetGroup = dBSubnetGroup {
            try container.encode(dBSubnetGroup, forKey: ClientRuntime.Key("DBSubnetGroup"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let dbClusterResourceId = dbClusterResourceId {
            try container.encode(dbClusterResourceId, forKey: ClientRuntime.Key("DbClusterResourceId"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let earliestRestorableTime = earliestRestorableTime {
            try container.encode(ClientRuntime.TimestampWrapper(earliestRestorableTime, format: .dateTime), forKey: ClientRuntime.Key("earliestRestorableTime"))
        }
        if let enabledCloudwatchLogsExports = enabledCloudwatchLogsExports {
            var enabledCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnabledCloudwatchLogsExports"))
            for (index0, string0) in enabledCloudwatchLogsExports.enumerated() {
                try enabledCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let hostedZoneId = hostedZoneId {
            try container.encode(hostedZoneId, forKey: ClientRuntime.Key("HostedZoneId"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let latestRestorableTime = latestRestorableTime {
            try container.encode(ClientRuntime.TimestampWrapper(latestRestorableTime, format: .dateTime), forKey: ClientRuntime.Key("latestRestorableTime"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if multiAZ != false {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let percentProgress = percentProgress {
            try container.encode(percentProgress, forKey: ClientRuntime.Key("PercentProgress"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let readReplicaIdentifiers = readReplicaIdentifiers {
            var readReplicaIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ReadReplicaIdentifiers"))
            for (index0, string0) in readReplicaIdentifiers.enumerated() {
                try readReplicaIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("ReadReplicaIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readerEndpoint = readerEndpoint {
            try container.encode(readerEndpoint, forKey: ClientRuntime.Key("ReaderEndpoint"))
        }
        if let replicationSourceIdentifier = replicationSourceIdentifier {
            try container.encode(replicationSourceIdentifier, forKey: ClientRuntime.Key("ReplicationSourceIdentifier"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: ClientRuntime.Key("VpcSecurityGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let characterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let percentProgressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let earliestRestorableTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .earliestRestorableTime)
        var earliestRestorableTimeBuffer:ClientRuntime.Date? = nil
        if let earliestRestorableTimeDecoded = earliestRestorableTimeDecoded {
            earliestRestorableTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(earliestRestorableTimeDecoded, format: .dateTime)
        }
        earliestRestorableTime = earliestRestorableTimeBuffer
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let readerEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readerEndpoint)
        readerEndpoint = readerEndpointDecoded
        let multiAZDecoded = try containerValues.decode(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let latestRestorableTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestRestorableTime)
        var latestRestorableTimeBuffer:ClientRuntime.Date? = nil
        if let latestRestorableTimeDecoded = latestRestorableTimeDecoded {
            latestRestorableTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(latestRestorableTimeDecoded, format: .dateTime)
        }
        latestRestorableTime = latestRestorableTimeBuffer
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        if containerValues.contains(.dBClusterOptionGroupMemberships) {
            struct KeyVal0{struct DBClusterOptionGroup{}}
            let dBClusterOptionGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterOptionGroup>.CodingKeys.self, forKey: .dBClusterOptionGroupMemberships)
            if let dBClusterOptionGroupMembershipsWrappedContainer = dBClusterOptionGroupMembershipsWrappedContainer {
                let dBClusterOptionGroupMembershipsContainer = try dBClusterOptionGroupMembershipsWrappedContainer.decodeIfPresent([NeptuneClientTypes.DBClusterOptionGroupStatus].self, forKey: .member)
                var dBClusterOptionGroupMembershipsBuffer:[NeptuneClientTypes.DBClusterOptionGroupStatus]? = nil
                if let dBClusterOptionGroupMembershipsContainer = dBClusterOptionGroupMembershipsContainer {
                    dBClusterOptionGroupMembershipsBuffer = [NeptuneClientTypes.DBClusterOptionGroupStatus]()
                    for structureContainer0 in dBClusterOptionGroupMembershipsContainer {
                        dBClusterOptionGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterOptionGroupMemberships = dBClusterOptionGroupMembershipsBuffer
            } else {
                dBClusterOptionGroupMemberships = []
            }
        } else {
            dBClusterOptionGroupMemberships = nil
        }
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let replicationSourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSourceIdentifier)
        replicationSourceIdentifier = replicationSourceIdentifierDecoded
        if containerValues.contains(.readReplicaIdentifiers) {
            struct KeyVal0{struct ReadReplicaIdentifier{}}
            let readReplicaIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaIdentifier>.CodingKeys.self, forKey: .readReplicaIdentifiers)
            if let readReplicaIdentifiersWrappedContainer = readReplicaIdentifiersWrappedContainer {
                let readReplicaIdentifiersContainer = try readReplicaIdentifiersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var readReplicaIdentifiersBuffer:[Swift.String]? = nil
                if let readReplicaIdentifiersContainer = readReplicaIdentifiersContainer {
                    readReplicaIdentifiersBuffer = [Swift.String]()
                    for stringContainer0 in readReplicaIdentifiersContainer {
                        readReplicaIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaIdentifiers = readReplicaIdentifiersBuffer
            } else {
                readReplicaIdentifiers = []
            }
        } else {
            readReplicaIdentifiers = nil
        }
        if containerValues.contains(.dBClusterMembers) {
            struct KeyVal0{struct DBClusterMember{}}
            let dBClusterMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterMember>.CodingKeys.self, forKey: .dBClusterMembers)
            if let dBClusterMembersWrappedContainer = dBClusterMembersWrappedContainer {
                let dBClusterMembersContainer = try dBClusterMembersWrappedContainer.decodeIfPresent([NeptuneClientTypes.DBClusterMember].self, forKey: .member)
                var dBClusterMembersBuffer:[NeptuneClientTypes.DBClusterMember]? = nil
                if let dBClusterMembersContainer = dBClusterMembersContainer {
                    dBClusterMembersBuffer = [NeptuneClientTypes.DBClusterMember]()
                    for structureContainer0 in dBClusterMembersContainer {
                        dBClusterMembersBuffer?.append(structureContainer0)
                    }
                }
                dBClusterMembers = dBClusterMembersBuffer
            } else {
                dBClusterMembers = []
            }
        } else {
            dBClusterMembers = nil
        }
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroupMembership{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupMembership>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([NeptuneClientTypes.VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[NeptuneClientTypes.VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [NeptuneClientTypes.VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
        let storageEncryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbClusterResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterResourceId)
        dbClusterResourceId = dbClusterResourceIdDecoded
        let dBClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterArn)
        dBClusterArn = dBClusterArnDecoded
        if containerValues.contains(.associatedRoles) {
            struct KeyVal0{struct DBClusterRole{}}
            let associatedRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterRole>.CodingKeys.self, forKey: .associatedRoles)
            if let associatedRolesWrappedContainer = associatedRolesWrappedContainer {
                let associatedRolesContainer = try associatedRolesWrappedContainer.decodeIfPresent([NeptuneClientTypes.DBClusterRole].self, forKey: .member)
                var associatedRolesBuffer:[NeptuneClientTypes.DBClusterRole]? = nil
                if let associatedRolesContainer = associatedRolesContainer {
                    associatedRolesBuffer = [NeptuneClientTypes.DBClusterRole]()
                    for structureContainer0 in associatedRolesContainer {
                        associatedRolesBuffer?.append(structureContainer0)
                    }
                }
                associatedRoles = associatedRolesBuffer
            } else {
                associatedRoles = []
            }
        } else {
            associatedRoles = nil
        }
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let cloneGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloneGroupId)
        cloneGroupId = cloneGroupIdDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:ClientRuntime.Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        if containerValues.contains(.enabledCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enabledCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enabledCloudwatchLogsExports)
            if let enabledCloudwatchLogsExportsWrappedContainer = enabledCloudwatchLogsExportsWrappedContainer {
                let enabledCloudwatchLogsExportsContainer = try enabledCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enabledCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enabledCloudwatchLogsExportsContainer = enabledCloudwatchLogsExportsContainer {
                    enabledCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enabledCloudwatchLogsExportsContainer {
                        enabledCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enabledCloudwatchLogsExports = enabledCloudwatchLogsExportsBuffer
            } else {
                enabledCloudwatchLogsExports = []
            }
        } else {
            enabledCloudwatchLogsExports = nil
        }
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let crossAccountCloneDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccountClone)
        crossAccountClone = crossAccountCloneDecoded
        let automaticRestartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automaticRestartTime)
        var automaticRestartTimeBuffer:ClientRuntime.Date? = nil
        if let automaticRestartTimeDecoded = automaticRestartTimeDecoded {
            automaticRestartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(automaticRestartTimeDecoded, format: .dateTime)
        }
        automaticRestartTime = automaticRestartTimeBuffer
    }
}

extension NeptuneClientTypes.DBCluster: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBCluster(allocatedStorage: \(Swift.String(describing: allocatedStorage)), associatedRoles: \(Swift.String(describing: associatedRoles)), automaticRestartTime: \(Swift.String(describing: automaticRestartTime)), availabilityZones: \(Swift.String(describing: availabilityZones)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), characterSetName: \(Swift.String(describing: characterSetName)), cloneGroupId: \(Swift.String(describing: cloneGroupId)), clusterCreateTime: \(Swift.String(describing: clusterCreateTime)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), crossAccountClone: \(Swift.String(describing: crossAccountClone)), dBClusterArn: \(Swift.String(describing: dBClusterArn)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterMembers: \(Swift.String(describing: dBClusterMembers)), dBClusterOptionGroupMemberships: \(Swift.String(describing: dBClusterOptionGroupMemberships)), dBClusterParameterGroup: \(Swift.String(describing: dBClusterParameterGroup)), dBSubnetGroup: \(Swift.String(describing: dBSubnetGroup)), databaseName: \(Swift.String(describing: databaseName)), dbClusterResourceId: \(Swift.String(describing: dbClusterResourceId)), deletionProtection: \(Swift.String(describing: deletionProtection)), earliestRestorableTime: \(Swift.String(describing: earliestRestorableTime)), enabledCloudwatchLogsExports: \(Swift.String(describing: enabledCloudwatchLogsExports)), endpoint: \(Swift.String(describing: endpoint)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), hostedZoneId: \(Swift.String(describing: hostedZoneId)), iAMDatabaseAuthenticationEnabled: \(Swift.String(describing: iAMDatabaseAuthenticationEnabled)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), latestRestorableTime: \(Swift.String(describing: latestRestorableTime)), masterUsername: \(Swift.String(describing: masterUsername)), multiAZ: \(Swift.String(describing: multiAZ)), percentProgress: \(Swift.String(describing: percentProgress)), port: \(Swift.String(describing: port)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), readReplicaIdentifiers: \(Swift.String(describing: readReplicaIdentifiers)), readerEndpoint: \(Swift.String(describing: readerEndpoint)), replicationSourceIdentifier: \(Swift.String(describing: replicationSourceIdentifier)), status: \(Swift.String(describing: status)), storageEncrypted: \(Swift.String(describing: storageEncrypted)), vpcSecurityGroups: \(Swift.String(describing: vpcSecurityGroups)))"}
}

extension NeptuneClientTypes {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public struct DBCluster: Swift.Equatable {
        /// <p>
        ///             <code>AllocatedStorage</code> always returns 1, because Neptune DB cluster storage size is
        ///       not fixed, but instead automatically adjusts as needed.</p>
        public let allocatedStorage: Swift.Int?
        /// <p>Provides a list of the Amazon Identity and Access Management (IAM) roles that are associated
        ///       with the DB cluster. IAM roles that are associated with a DB cluster grant permission for the
        ///       DB cluster to access other Amazon services on your behalf.</p>
        public let associatedRoles: [NeptuneClientTypes.DBClusterRole]?
        /// <p>Time at which the DB cluster will be automatically restarted.</p>
        public let automaticRestartTime: ClientRuntime.Date?
        /// <p>Provides the list of EC2 Availability Zones that instances in the DB cluster can be
        ///       created in.</p>
        public let availabilityZones: [Swift.String]?
        /// <p>Specifies the number of days for which automatic DB snapshots are retained.</p>
        public let backupRetentionPeriod: Swift.Int?
        /// <p>Not supported by Neptune.</p>
        public let characterSetName: Swift.String?
        /// <p>Identifies the clone group to which the DB cluster is associated.</p>
        public let cloneGroupId: Swift.String?
        /// <p>Specifies the time when the DB cluster was created, in Universal Coordinated Time
        ///       (UTC).</p>
        public let clusterCreateTime: ClientRuntime.Date?
        /// <p>
        ///             <i>If set to <code>true</code>, tags are copied to any snapshot of
        ///       the DB cluster that is created.</i>
        ///          </p>
        public let copyTagsToSnapshot: Swift.Bool?
        /// <p>If set to <code>true</code>, the DB cluster can be cloned across accounts.</p>
        public let crossAccountClone: Swift.Bool?
        /// <p>The Amazon Resource Name (ARN) for the DB cluster.</p>
        public let dBClusterArn: Swift.String?
        /// <p>Contains a user-supplied DB cluster identifier. This identifier is the unique key that
        ///       identifies a DB cluster.</p>
        public let dBClusterIdentifier: Swift.String?
        /// <p>Provides the list of instances that make up the DB cluster.</p>
        public let dBClusterMembers: [NeptuneClientTypes.DBClusterMember]?
        /// <p>Not supported by Neptune.</p>
        public let dBClusterOptionGroupMemberships: [NeptuneClientTypes.DBClusterOptionGroupStatus]?
        /// <p>Specifies the name of the DB cluster parameter group for the DB cluster.</p>
        public let dBClusterParameterGroup: Swift.String?
        /// <p>Specifies information on the subnet group associated with the DB cluster, including the
        ///       name, description, and subnets in the subnet group.</p>
        public let dBSubnetGroup: Swift.String?
        /// <p>Contains the name of the initial database of this DB cluster that was provided at create
        ///       time, if one was specified when the DB cluster was created. This same name is returned for the
        ///       life of the DB cluster.</p>
        public let databaseName: Swift.String?
        /// <p>The Amazon Region-unique, immutable identifier for the DB cluster. This identifier is found
        ///       in Amazon CloudTrail log entries whenever the Amazon KMS key for the DB cluster is accessed.</p>
        public let dbClusterResourceId: Swift.String?
        /// <p>Indicates whether or not the DB cluster has deletion protection enabled.
        ///       The database can't be deleted when deletion protection is enabled.</p>
        public let deletionProtection: Swift.Bool?
        /// <p>Specifies the earliest time to which a database can be restored with point-in-time
        ///       restore.</p>
        public let earliestRestorableTime: ClientRuntime.Date?
        /// <p>A list of log types that this DB cluster is configured to export to CloudWatch Logs.</p>
        public let enabledCloudwatchLogsExports: [Swift.String]?
        /// <p>Specifies the connection endpoint for the primary instance of the DB cluster.</p>
        public let endpoint: Swift.String?
        /// <p>Provides the name of the database engine to be used for this DB cluster.</p>
        public let engine: Swift.String?
        /// <p>Indicates the database engine version.</p>
        public let engineVersion: Swift.String?
        /// <p>Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.</p>
        public let hostedZoneId: Swift.String?
        /// <p>True if mapping of Amazon Identity and Access Management (IAM) accounts to database accounts
        ///       is enabled, and otherwise false.</p>
        public let iAMDatabaseAuthenticationEnabled: Swift.Bool
        /// <p>If <code>StorageEncrypted</code> is true, the Amazon KMS key identifier for the
        ///       encrypted DB cluster.</p>
        public let kmsKeyId: Swift.String?
        /// <p>Specifies the latest time to which a database can be restored with point-in-time
        ///       restore.</p>
        public let latestRestorableTime: ClientRuntime.Date?
        /// <p>Not supported by Neptune.</p>
        public let masterUsername: Swift.String?
        /// <p>Specifies whether the DB cluster has instances in multiple Availability Zones.</p>
        public let multiAZ: Swift.Bool
        /// <p>Specifies the progress of the operation as a percentage.</p>
        public let percentProgress: Swift.String?
        /// <p>Specifies the port that the database engine is listening on.</p>
        public let port: Swift.Int?
        /// <p>Specifies the daily time range during which automated backups are created if automated
        ///       backups are enabled, as determined by the <code>BackupRetentionPeriod</code>.</p>
        public let preferredBackupWindow: Swift.String?
        /// <p>Specifies the weekly time range during which system maintenance can occur, in Universal
        ///       Coordinated Time (UTC).</p>
        public let preferredMaintenanceWindow: Swift.String?
        /// <p>Contains one or more identifiers of the Read Replicas associated with this DB
        ///       cluster.</p>
        public let readReplicaIdentifiers: [Swift.String]?
        /// <p>The reader endpoint for the DB cluster. The reader endpoint for a DB cluster load-balances
        ///       connections across the Read Replicas that are available in a DB cluster. As clients request
        ///       new connections to the reader endpoint, Neptune distributes the connection requests among the
        ///       Read Replicas in the DB cluster. This functionality can help balance your read workload across
        ///       multiple Read Replicas in your DB cluster.</p>
        ///          <p>If a failover occurs, and the Read Replica that you are connected to is promoted to be the
        ///       primary instance, your connection is dropped. To continue sending your read workload to other
        ///       Read Replicas in the cluster, you can then reconnect to the reader endpoint.</p>
        public let readerEndpoint: Swift.String?
        /// <p>Not supported by Neptune.</p>
        public let replicationSourceIdentifier: Swift.String?
        /// <p>Specifies the current state of this DB cluster.</p>
        public let status: Swift.String?
        /// <p>Specifies whether the DB cluster is encrypted.</p>
        public let storageEncrypted: Swift.Bool
        /// <p>Provides a list of VPC security groups that the DB cluster belongs to.</p>
        public let vpcSecurityGroups: [NeptuneClientTypes.VpcSecurityGroupMembership]?

        public init (
            allocatedStorage: Swift.Int? = nil,
            associatedRoles: [NeptuneClientTypes.DBClusterRole]? = nil,
            automaticRestartTime: ClientRuntime.Date? = nil,
            availabilityZones: [Swift.String]? = nil,
            backupRetentionPeriod: Swift.Int? = nil,
            characterSetName: Swift.String? = nil,
            cloneGroupId: Swift.String? = nil,
            clusterCreateTime: ClientRuntime.Date? = nil,
            copyTagsToSnapshot: Swift.Bool? = nil,
            crossAccountClone: Swift.Bool? = nil,
            dBClusterArn: Swift.String? = nil,
            dBClusterIdentifier: Swift.String? = nil,
            dBClusterMembers: [NeptuneClientTypes.DBClusterMember]? = nil,
            dBClusterOptionGroupMemberships: [NeptuneClientTypes.DBClusterOptionGroupStatus]? = nil,
            dBClusterParameterGroup: Swift.String? = nil,
            dBSubnetGroup: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            dbClusterResourceId: Swift.String? = nil,
            deletionProtection: Swift.Bool? = nil,
            earliestRestorableTime: ClientRuntime.Date? = nil,
            enabledCloudwatchLogsExports: [Swift.String]? = nil,
            endpoint: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool = false,
            kmsKeyId: Swift.String? = nil,
            latestRestorableTime: ClientRuntime.Date? = nil,
            masterUsername: Swift.String? = nil,
            multiAZ: Swift.Bool = false,
            percentProgress: Swift.String? = nil,
            port: Swift.Int? = nil,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            readReplicaIdentifiers: [Swift.String]? = nil,
            readerEndpoint: Swift.String? = nil,
            replicationSourceIdentifier: Swift.String? = nil,
            status: Swift.String? = nil,
            storageEncrypted: Swift.Bool = false,
            vpcSecurityGroups: [NeptuneClientTypes.VpcSecurityGroupMembership]? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.associatedRoles = associatedRoles
            self.automaticRestartTime = automaticRestartTime
            self.availabilityZones = availabilityZones
            self.backupRetentionPeriod = backupRetentionPeriod
            self.characterSetName = characterSetName
            self.cloneGroupId = cloneGroupId
            self.clusterCreateTime = clusterCreateTime
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.crossAccountClone = crossAccountClone
            self.dBClusterArn = dBClusterArn
            self.dBClusterIdentifier = dBClusterIdentifier
            self.dBClusterMembers = dBClusterMembers
            self.dBClusterOptionGroupMemberships = dBClusterOptionGroupMemberships
            self.dBClusterParameterGroup = dBClusterParameterGroup
            self.dBSubnetGroup = dBSubnetGroup
            self.databaseName = databaseName
            self.dbClusterResourceId = dbClusterResourceId
            self.deletionProtection = deletionProtection
            self.earliestRestorableTime = earliestRestorableTime
            self.enabledCloudwatchLogsExports = enabledCloudwatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineVersion = engineVersion
            self.hostedZoneId = hostedZoneId
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.kmsKeyId = kmsKeyId
            self.latestRestorableTime = latestRestorableTime
            self.masterUsername = masterUsername
            self.multiAZ = multiAZ
            self.percentProgress = percentProgress
            self.port = port
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.readReplicaIdentifiers = readReplicaIdentifiers
            self.readerEndpoint = readerEndpoint
            self.replicationSourceIdentifier = replicationSourceIdentifier
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension DBClusterAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBClusterAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>User already has a DB cluster with the given identifier.</p>
public struct DBClusterAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.DBClusterEndpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customEndpointType = customEndpointType {
            try container.encode(customEndpointType, forKey: ClientRuntime.Key("CustomEndpointType"))
        }
        if let dBClusterEndpointArn = dBClusterEndpointArn {
            try container.encode(dBClusterEndpointArn, forKey: ClientRuntime.Key("DBClusterEndpointArn"))
        }
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointIdentifier"))
        }
        if let dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier {
            try container.encode(dBClusterEndpointResourceIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointResourceIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let endpointType = endpointType {
            try container.encode(endpointType, forKey: ClientRuntime.Key("EndpointType"))
        }
        if let excludedMembers = excludedMembers {
            var excludedMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExcludedMembers"))
            for (index0, string0) in excludedMembers.enumerated() {
                try excludedMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let staticMembers = staticMembers {
            var staticMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("StaticMembers"))
            for (index0, string0) in staticMembers.enumerated() {
                try staticMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var staticMembersBuffer:[Swift.String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [Swift.String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedMembersBuffer:[Swift.String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [Swift.String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

extension NeptuneClientTypes.DBClusterEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterEndpoint(customEndpointType: \(Swift.String(describing: customEndpointType)), dBClusterEndpointArn: \(Swift.String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(Swift.String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), endpoint: \(Swift.String(describing: endpoint)), endpointType: \(Swift.String(describing: endpointType)), excludedMembers: \(Swift.String(describing: excludedMembers)), staticMembers: \(Swift.String(describing: staticMembers)), status: \(Swift.String(describing: status)))"}
}

extension NeptuneClientTypes {
    /// <p>This data type represents the information you need to connect to an Amazon Neptune DB cluster.
    ///       This data type is used as a response element in the following actions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CreateDBClusterEndpoint</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DescribeDBClusterEndpoints</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ModifyDBClusterEndpoint</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DeleteDBClusterEndpoint</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>For the data structure that represents Amazon Neptune DB instance endpoints,
    ///       see <code>Endpoint</code>.</p>
    public struct DBClusterEndpoint: Swift.Equatable {
        /// <p>The type associated with a custom endpoint. One of: <code>READER</code>,
        ///       <code>WRITER</code>, <code>ANY</code>.</p>
        public let customEndpointType: Swift.String?
        /// <p>The Amazon Resource Name (ARN) for the endpoint.</p>
        public let dBClusterEndpointArn: Swift.String?
        /// <p>The identifier associated with the endpoint. This parameter is stored as a lowercase string.</p>
        public let dBClusterEndpointIdentifier: Swift.String?
        /// <p>A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.</p>
        public let dBClusterEndpointResourceIdentifier: Swift.String?
        /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
        ///       stored as a lowercase string.</p>
        public let dBClusterIdentifier: Swift.String?
        /// <p>The DNS address of the endpoint.</p>
        public let endpoint: Swift.String?
        /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>CUSTOM</code>.</p>
        public let endpointType: Swift.String?
        /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
        ///       All other eligible instances are reachable through the custom endpoint.
        ///       Only relevant if the list of static members is empty.</p>
        public let excludedMembers: [Swift.String]?
        /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
        public let staticMembers: [Swift.String]?
        /// <p>The current status of the endpoint. One of: <code>creating</code>, <code>available</code>, <code>deleting</code>, <code>inactive</code>, <code>modifying</code>. The <code>inactive</code> state applies to an endpoint that cannot be used for a certain kind of cluster,
        ///       such as a <code>writer</code> endpoint for a read-only secondary cluster in a global database.</p>
        public let status: Swift.String?

        public init (
            customEndpointType: Swift.String? = nil,
            dBClusterEndpointArn: Swift.String? = nil,
            dBClusterEndpointIdentifier: Swift.String? = nil,
            dBClusterEndpointResourceIdentifier: Swift.String? = nil,
            dBClusterIdentifier: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            endpointType: Swift.String? = nil,
            excludedMembers: [Swift.String]? = nil,
            staticMembers: [Swift.String]? = nil,
            status: Swift.String? = nil
        )
        {
            self.customEndpointType = customEndpointType
            self.dBClusterEndpointArn = dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = dBClusterIdentifier
            self.endpoint = endpoint
            self.endpointType = endpointType
            self.excludedMembers = excludedMembers
            self.staticMembers = staticMembers
            self.status = status
        }
    }

}

extension DBClusterEndpointAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterEndpointAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterEndpointAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBClusterEndpointAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified custom endpoint cannot be created because it already exists.</p>
public struct DBClusterEndpointAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterEndpointAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterEndpointAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterEndpointNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterEndpointNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterEndpointNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBClusterEndpointNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified custom endpoint doesn't exist.</p>
public struct DBClusterEndpointNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterEndpointNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterEndpointNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterEndpointQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterEndpointQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterEndpointQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBClusterEndpointQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cluster already has the maximum number of custom endpoints.</p>
public struct DBClusterEndpointQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterEndpointQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterEndpointQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.DBClusterMember: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupStatus = "DBClusterParameterGroupStatus"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case isClusterWriter = "IsClusterWriter"
        case promotionTier = "PromotionTier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupStatus = dBClusterParameterGroupStatus {
            try container.encode(dBClusterParameterGroupStatus, forKey: ClientRuntime.Key("DBClusterParameterGroupStatus"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if isClusterWriter != false {
            try container.encode(isClusterWriter, forKey: ClientRuntime.Key("IsClusterWriter"))
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: ClientRuntime.Key("PromotionTier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let isClusterWriterDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isClusterWriter)
        isClusterWriter = isClusterWriterDecoded
        let dBClusterParameterGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupStatus)
        dBClusterParameterGroupStatus = dBClusterParameterGroupStatusDecoded
        let promotionTierDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .promotionTier)
        promotionTier = promotionTierDecoded
    }
}

extension NeptuneClientTypes.DBClusterMember: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterMember(dBClusterParameterGroupStatus: \(Swift.String(describing: dBClusterParameterGroupStatus)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), isClusterWriter: \(Swift.String(describing: isClusterWriter)), promotionTier: \(Swift.String(describing: promotionTier)))"}
}

extension NeptuneClientTypes {
    /// <p>Contains information about an instance that is part of a DB cluster.</p>
    public struct DBClusterMember: Swift.Equatable {
        /// <p>Specifies the status of the DB cluster parameter group for this member of the DB
        ///       cluster.</p>
        public let dBClusterParameterGroupStatus: Swift.String?
        /// <p>Specifies the instance identifier for this member of the DB cluster.</p>
        public let dBInstanceIdentifier: Swift.String?
        /// <p>Value that is <code>true</code> if the cluster member is the primary instance for the DB
        ///       cluster and <code>false</code> otherwise.</p>
        public let isClusterWriter: Swift.Bool
        /// <p>A value that specifies the order in which a Read Replica is promoted to the primary
        ///       instance after a failure of the existing primary instance.</p>
        public let promotionTier: Swift.Int?

        public init (
            dBClusterParameterGroupStatus: Swift.String? = nil,
            dBInstanceIdentifier: Swift.String? = nil,
            isClusterWriter: Swift.Bool = false,
            promotionTier: Swift.Int? = nil
        )
        {
            self.dBClusterParameterGroupStatus = dBClusterParameterGroupStatus
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.isClusterWriter = isClusterWriter
            self.promotionTier = promotionTier
        }
    }

}

extension DBClusterNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBClusterNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
public struct DBClusterNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.DBClusterOptionGroupStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterOptionGroupName = "DBClusterOptionGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterOptionGroupName = dBClusterOptionGroupName {
            try container.encode(dBClusterOptionGroupName, forKey: ClientRuntime.Key("DBClusterOptionGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterOptionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterOptionGroupName)
        dBClusterOptionGroupName = dBClusterOptionGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension NeptuneClientTypes.DBClusterOptionGroupStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterOptionGroupStatus(dBClusterOptionGroupName: \(Swift.String(describing: dBClusterOptionGroupName)), status: \(Swift.String(describing: status)))"}
}

extension NeptuneClientTypes {
    /// <p>Not supported by Neptune.</p>
    public struct DBClusterOptionGroupStatus: Swift.Equatable {
        /// <p>Not supported by Neptune.</p>
        public let dBClusterOptionGroupName: Swift.String?
        /// <p>Not supported by Neptune.</p>
        public let status: Swift.String?

        public init (
            dBClusterOptionGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.dBClusterOptionGroupName = dBClusterOptionGroupName
            self.status = status
        }
    }

}

extension NeptuneClientTypes.DBClusterParameterGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupArn = "DBClusterParameterGroupArn"
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupArn = dBClusterParameterGroupArn {
            try container.encode(dBClusterParameterGroupArn, forKey: ClientRuntime.Key("DBClusterParameterGroupArn"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dBClusterParameterGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupArn)
        dBClusterParameterGroupArn = dBClusterParameterGroupArnDecoded
    }
}

extension NeptuneClientTypes.DBClusterParameterGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterParameterGroup(dBClusterParameterGroupArn: \(Swift.String(describing: dBClusterParameterGroupArn)), dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), description: \(Swift.String(describing: description)))"}
}

extension NeptuneClientTypes {
    /// <p>Contains the details of an Amazon Neptune DB cluster parameter group.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusterParameterGroups</a> action.</p>
    public struct DBClusterParameterGroup: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) for the DB cluster parameter group.</p>
        public let dBClusterParameterGroupArn: Swift.String?
        /// <p>Provides the name of the DB cluster parameter group.</p>
        public let dBClusterParameterGroupName: Swift.String?
        /// <p>Provides the name of the DB parameter group family that this DB cluster parameter group is
        ///       compatible with.</p>
        public let dBParameterGroupFamily: Swift.String?
        /// <p>Provides the customer-specified description for this DB cluster parameter group.</p>
        public let description: Swift.String?

        public init (
            dBClusterParameterGroupArn: Swift.String? = nil,
            dBClusterParameterGroupName: Swift.String? = nil,
            dBParameterGroupFamily: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.dBClusterParameterGroupArn = dBClusterParameterGroupArn
            self.dBClusterParameterGroupName = dBClusterParameterGroupName
            self.dBParameterGroupFamily = dBParameterGroupFamily
            self.description = description
        }
    }

}

extension DBClusterParameterGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterParameterGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterParameterGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBClusterParameterGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBClusterParameterGroupName</i> does not refer to an
///       existing DB Cluster parameter group.</p>
public struct DBClusterParameterGroupNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterParameterGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterParameterGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBClusterQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>User attempted to create a new DB cluster and the user has already reached the maximum allowed DB cluster quota.</p>
public struct DBClusterQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.DBClusterRole: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureName = "FeatureName"
        case roleArn = "RoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let featureName = featureName {
            try container.encode(featureName, forKey: ClientRuntime.Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
    }
}

extension NeptuneClientTypes.DBClusterRole: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterRole(featureName: \(Swift.String(describing: featureName)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)))"}
}

extension NeptuneClientTypes {
    /// <p>Describes an Amazon Identity and Access Management (IAM) role that is associated with a DB
    ///       cluster.</p>
    public struct DBClusterRole: Swift.Equatable {
        /// <p>The name of the feature associated with the Amazon Identity and Access Management (IAM) role.
        ///       For the list of supported feature names, see <a>DBEngineVersion</a>.
        ///     </p>
        public let featureName: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the IAM role that is associated with the DB
        ///       cluster.</p>
        public let roleArn: Swift.String?
        /// <p>Describes the state of association between the IAM role and the DB cluster. The Status
        ///       property returns one of the following values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>ACTIVE</code> - the IAM role ARN is associated with the DB cluster and can be
        ///           used to access other Amazon services on your behalf.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>PENDING</code> - the IAM role ARN is being associated with the DB
        ///           cluster.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>INVALID</code> - the IAM role ARN is associated with the DB cluster, but the DB
        ///           cluster is unable to assume the IAM role in order to access other Amazon services on your
        ///           behalf.</p>
        ///             </li>
        ///          </ul>
        public let status: Swift.String?

        public init (
            featureName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.featureName = featureName
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension DBClusterRoleAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterRoleAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterRoleAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBClusterRoleAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified IAM role Amazon Resource Name (ARN) is already associated with the specified DB cluster.</p>
public struct DBClusterRoleAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterRoleAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterRoleAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterRoleNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterRoleNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterRoleNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBClusterRoleNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified IAM role Amazon Resource Name (ARN) is not associated with the specified DB cluster.</p>
public struct DBClusterRoleNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterRoleNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterRoleNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterRoleQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterRoleQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterRoleQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBClusterRoleQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the maximum number of IAM roles that can be associated with the specified DB cluster.</p>
public struct DBClusterRoleQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterRoleQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterRoleQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.DBClusterSnapshot: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case availabilityZones = "AvailabilityZones"
        case clusterCreateTime = "ClusterCreateTime"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterSnapshotArn = "DBClusterSnapshotArn"
        case dBClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotType = "SnapshotType"
        case sourceDBClusterSnapshotArn = "SourceDBClusterSnapshotArn"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: ClientRuntime.Key("clusterCreateTime"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterSnapshotArn = dBClusterSnapshotArn {
            try container.encode(dBClusterSnapshotArn, forKey: ClientRuntime.Key("DBClusterSnapshotArn"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if percentProgress != 0 {
            try container.encode(percentProgress, forKey: ClientRuntime.Key("PercentProgress"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let snapshotCreateTime = snapshotCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(snapshotCreateTime, format: .dateTime), forKey: ClientRuntime.Key("snapshotCreateTime"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: ClientRuntime.Key("SnapshotType"))
        }
        if let sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArn {
            try container.encode(sourceDBClusterSnapshotArn, forKey: ClientRuntime.Key("SourceDBClusterSnapshotArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let dBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterSnapshotIdentifier)
        dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCreateTime)
        var snapshotCreateTimeBuffer:ClientRuntime.Date? = nil
        if let snapshotCreateTimeDecoded = snapshotCreateTimeDecoded {
            snapshotCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(snapshotCreateTimeDecoded, format: .dateTime)
        }
        snapshotCreateTime = snapshotCreateTimeBuffer
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let allocatedStorageDecoded = try containerValues.decode(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:ClientRuntime.Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let percentProgressDecoded = try containerValues.decode(Swift.Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let storageEncryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dBClusterSnapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterSnapshotArn)
        dBClusterSnapshotArn = dBClusterSnapshotArnDecoded
        let sourceDBClusterSnapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBClusterSnapshotArn)
        sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArnDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
    }
}

extension NeptuneClientTypes.DBClusterSnapshot: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterSnapshot(allocatedStorage: \(Swift.String(describing: allocatedStorage)), availabilityZones: \(Swift.String(describing: availabilityZones)), clusterCreateTime: \(Swift.String(describing: clusterCreateTime)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterSnapshotArn: \(Swift.String(describing: dBClusterSnapshotArn)), dBClusterSnapshotIdentifier: \(Swift.String(describing: dBClusterSnapshotIdentifier)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), iAMDatabaseAuthenticationEnabled: \(Swift.String(describing: iAMDatabaseAuthenticationEnabled)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), licenseModel: \(Swift.String(describing: licenseModel)), masterUsername: \(Swift.String(describing: masterUsername)), percentProgress: \(Swift.String(describing: percentProgress)), port: \(Swift.String(describing: port)), snapshotCreateTime: \(Swift.String(describing: snapshotCreateTime)), snapshotType: \(Swift.String(describing: snapshotType)), sourceDBClusterSnapshotArn: \(Swift.String(describing: sourceDBClusterSnapshotArn)), status: \(Swift.String(describing: status)), storageEncrypted: \(Swift.String(describing: storageEncrypted)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension NeptuneClientTypes {
    /// <p>Contains the details for an Amazon Neptune DB cluster snapshot</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusterSnapshots</a> action.</p>
    public struct DBClusterSnapshot: Swift.Equatable {
        /// <p>Specifies the allocated storage size in gibibytes (GiB).</p>
        public let allocatedStorage: Swift.Int
        /// <p>Provides the list of EC2 Availability Zones that instances in the DB cluster snapshot can
        ///       be restored in.</p>
        public let availabilityZones: [Swift.String]?
        /// <p>Specifies the time when the DB cluster was created, in Universal Coordinated Time
        ///       (UTC).</p>
        public let clusterCreateTime: ClientRuntime.Date?
        /// <p>Specifies the DB cluster identifier of the DB cluster that this DB cluster snapshot was
        ///       created from.</p>
        public let dBClusterIdentifier: Swift.String?
        /// <p>The Amazon Resource Name (ARN) for the DB cluster snapshot.</p>
        public let dBClusterSnapshotArn: Swift.String?
        /// <p>Specifies the identifier for a DB cluster snapshot. Must match the identifier
        ///       of an existing snapshot.</p>
        ///
        ///          <p>After you restore a DB cluster using a <code>DBClusterSnapshotIdentifier</code>,
        ///       you must specify the same <code>DBClusterSnapshotIdentifier</code> for any future
        ///       updates to the DB cluster. When you specify this property for an update, the DB
        ///       cluster is not restored from the snapshot again, and the data in the database is not
        ///       changed.</p>
        ///
        ///          <p>However, if you don't specify the <code>DBClusterSnapshotIdentifier</code>, an empty
        ///       DB cluster is created, and the original DB cluster is deleted. If you specify a
        ///       property that is different from the previous snapshot restore property, the DB
        ///       cluster is restored from the snapshot specified by the <code>DBClusterSnapshotIdentifier</code>,
        ///       and the original DB cluster is deleted.</p>
        public let dBClusterSnapshotIdentifier: Swift.String?
        /// <p>Specifies the name of the database engine.</p>
        public let engine: Swift.String?
        /// <p>Provides the version of the database engine for this DB cluster snapshot.</p>
        public let engineVersion: Swift.String?
        /// <p>True if mapping of Amazon Identity and Access Management (IAM) accounts to database accounts
        ///       is enabled, and otherwise false.</p>
        public let iAMDatabaseAuthenticationEnabled: Swift.Bool
        /// <p>If <code>StorageEncrypted</code> is true, the Amazon KMS key identifier for the encrypted DB
        ///       cluster snapshot.</p>
        public let kmsKeyId: Swift.String?
        /// <p>Provides the license model information for this DB cluster snapshot.</p>
        public let licenseModel: Swift.String?
        /// <p>Not supported by Neptune.</p>
        public let masterUsername: Swift.String?
        /// <p>Specifies the percentage of the estimated data that has been transferred.</p>
        public let percentProgress: Swift.Int
        /// <p>Specifies the port that the DB cluster was listening on at the time of the
        ///       snapshot.</p>
        public let port: Swift.Int
        /// <p>Provides the time when the snapshot was taken, in Universal Coordinated Time (UTC).</p>
        public let snapshotCreateTime: ClientRuntime.Date?
        /// <p>Provides the type of the DB cluster snapshot.</p>
        public let snapshotType: Swift.String?
        /// <p>If the DB cluster snapshot was copied from a source DB cluster snapshot, the Amazon
        ///       Resource Name (ARN) for the source DB cluster snapshot, otherwise, a null value.</p>
        public let sourceDBClusterSnapshotArn: Swift.String?
        /// <p>Specifies the status of this DB cluster snapshot.</p>
        public let status: Swift.String?
        /// <p>Specifies whether the DB cluster snapshot is encrypted.</p>
        public let storageEncrypted: Swift.Bool
        /// <p>Provides the VPC ID associated with the DB cluster snapshot.</p>
        public let vpcId: Swift.String?

        public init (
            allocatedStorage: Swift.Int = 0,
            availabilityZones: [Swift.String]? = nil,
            clusterCreateTime: ClientRuntime.Date? = nil,
            dBClusterIdentifier: Swift.String? = nil,
            dBClusterSnapshotArn: Swift.String? = nil,
            dBClusterSnapshotIdentifier: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool = false,
            kmsKeyId: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            masterUsername: Swift.String? = nil,
            percentProgress: Swift.Int = 0,
            port: Swift.Int = 0,
            snapshotCreateTime: ClientRuntime.Date? = nil,
            snapshotType: Swift.String? = nil,
            sourceDBClusterSnapshotArn: Swift.String? = nil,
            status: Swift.String? = nil,
            storageEncrypted: Swift.Bool = false,
            vpcId: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.availabilityZones = availabilityZones
            self.clusterCreateTime = clusterCreateTime
            self.dBClusterIdentifier = dBClusterIdentifier
            self.dBClusterSnapshotArn = dBClusterSnapshotArn
            self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
            self.engine = engine
            self.engineVersion = engineVersion
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.percentProgress = percentProgress
            self.port = port
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotType = snapshotType
            self.sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArn
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.vpcId = vpcId
        }
    }

}

extension DBClusterSnapshotAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterSnapshotAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterSnapshotAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBClusterSnapshotAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>User already has a DB cluster snapshot with the given identifier.</p>
public struct DBClusterSnapshotAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterSnapshotAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterSnapshotAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.DBClusterSnapshotAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValues = "AttributeValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValues = attributeValues {
            var attributeValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttributeValues"))
            for (index0, string0) in attributeValues.enumerated() {
                try attributeValuesContainer.encode(string0, forKey: ClientRuntime.Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        if containerValues.contains(.attributeValues) {
            struct KeyVal0{struct AttributeValue{}}
            let attributeValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AttributeValue>.CodingKeys.self, forKey: .attributeValues)
            if let attributeValuesWrappedContainer = attributeValuesWrappedContainer {
                let attributeValuesContainer = try attributeValuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var attributeValuesBuffer:[Swift.String]? = nil
                if let attributeValuesContainer = attributeValuesContainer {
                    attributeValuesBuffer = [Swift.String]()
                    for stringContainer0 in attributeValuesContainer {
                        attributeValuesBuffer?.append(stringContainer0)
                    }
                }
                attributeValues = attributeValuesBuffer
            } else {
                attributeValues = []
            }
        } else {
            attributeValues = nil
        }
    }
}

extension NeptuneClientTypes.DBClusterSnapshotAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterSnapshotAttribute(attributeName: \(Swift.String(describing: attributeName)), attributeValues: \(Swift.String(describing: attributeValues)))"}
}

extension NeptuneClientTypes {
    /// <p>Contains the name and values of a manual DB cluster snapshot attribute.</p>
    ///          <p>Manual DB cluster snapshot attributes are used to authorize other Amazon accounts to restore
    ///       a manual DB cluster snapshot. For more information, see the <a>ModifyDBClusterSnapshotAttribute</a> API action.</p>
    public struct DBClusterSnapshotAttribute: Swift.Equatable {
        /// <p>The name of the manual DB cluster snapshot attribute.</p>
        ///          <p>The attribute named <code>restore</code> refers to the list of Amazon accounts that have
        ///       permission to copy or restore the manual DB cluster snapshot. For more information, see the
        ///       <a>ModifyDBClusterSnapshotAttribute</a> API action.</p>
        public let attributeName: Swift.String?
        /// <p>The value(s) for the manual DB cluster snapshot attribute.</p>
        ///          <p>If the <code>AttributeName</code> field is set to <code>restore</code>, then this element
        ///       returns a list of IDs of the Amazon accounts that are authorized to copy or restore the manual DB
        ///       cluster snapshot. If a value of <code>all</code> is in the list, then the manual DB cluster
        ///       snapshot is public and available for any Amazon account to copy or restore.</p>
        public let attributeValues: [Swift.String]?

        public init (
            attributeName: Swift.String? = nil,
            attributeValues: [Swift.String]? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValues = attributeValues
        }
    }

}

extension NeptuneClientTypes.DBClusterSnapshotAttributesResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshotAttributes = "DBClusterSnapshotAttributes"
        case dBClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterSnapshotAttributes = dBClusterSnapshotAttributes {
            var dBClusterSnapshotAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBClusterSnapshotAttributes"))
            for (index0, dbclustersnapshotattribute0) in dBClusterSnapshotAttributes.enumerated() {
                try dBClusterSnapshotAttributesContainer.encode(dbclustersnapshotattribute0, forKey: ClientRuntime.Key("DBClusterSnapshotAttribute.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterSnapshotIdentifier)
        dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifierDecoded
        if containerValues.contains(.dBClusterSnapshotAttributes) {
            struct KeyVal0{struct DBClusterSnapshotAttribute{}}
            let dBClusterSnapshotAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterSnapshotAttribute>.CodingKeys.self, forKey: .dBClusterSnapshotAttributes)
            if let dBClusterSnapshotAttributesWrappedContainer = dBClusterSnapshotAttributesWrappedContainer {
                let dBClusterSnapshotAttributesContainer = try dBClusterSnapshotAttributesWrappedContainer.decodeIfPresent([NeptuneClientTypes.DBClusterSnapshotAttribute].self, forKey: .member)
                var dBClusterSnapshotAttributesBuffer:[NeptuneClientTypes.DBClusterSnapshotAttribute]? = nil
                if let dBClusterSnapshotAttributesContainer = dBClusterSnapshotAttributesContainer {
                    dBClusterSnapshotAttributesBuffer = [NeptuneClientTypes.DBClusterSnapshotAttribute]()
                    for structureContainer0 in dBClusterSnapshotAttributesContainer {
                        dBClusterSnapshotAttributesBuffer?.append(structureContainer0)
                    }
                }
                dBClusterSnapshotAttributes = dBClusterSnapshotAttributesBuffer
            } else {
                dBClusterSnapshotAttributes = []
            }
        } else {
            dBClusterSnapshotAttributes = nil
        }
    }
}

extension NeptuneClientTypes.DBClusterSnapshotAttributesResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterSnapshotAttributesResult(dBClusterSnapshotAttributes: \(Swift.String(describing: dBClusterSnapshotAttributes)), dBClusterSnapshotIdentifier: \(Swift.String(describing: dBClusterSnapshotIdentifier)))"}
}

extension NeptuneClientTypes {
    /// <p>Contains the results of a successful call to the <a>DescribeDBClusterSnapshotAttributes</a> API action.</p>
    ///          <p>Manual DB cluster snapshot attributes are used to authorize other Amazon accounts to copy or
    ///       restore a manual DB cluster snapshot. For more information, see the <a>ModifyDBClusterSnapshotAttribute</a> API action.</p>
    public struct DBClusterSnapshotAttributesResult: Swift.Equatable {
        /// <p>The list of attributes and values for the manual DB cluster snapshot.</p>
        public let dBClusterSnapshotAttributes: [NeptuneClientTypes.DBClusterSnapshotAttribute]?
        /// <p>The identifier of the manual DB cluster snapshot that the attributes apply to.</p>
        public let dBClusterSnapshotIdentifier: Swift.String?

        public init (
            dBClusterSnapshotAttributes: [NeptuneClientTypes.DBClusterSnapshotAttribute]? = nil,
            dBClusterSnapshotIdentifier: Swift.String? = nil
        )
        {
            self.dBClusterSnapshotAttributes = dBClusterSnapshotAttributes
            self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        }
    }

}

extension DBClusterSnapshotNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterSnapshotNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterSnapshotNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBClusterSnapshotNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBClusterSnapshotIdentifier</i> does not refer to an existing
///       DB cluster snapshot.</p>
public struct DBClusterSnapshotNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterSnapshotNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterSnapshotNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.DBEngineVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBEngineDescription = "DBEngineDescription"
        case dBEngineVersionDescription = "DBEngineVersionDescription"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case defaultCharacterSet = "DefaultCharacterSet"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case exportableLogTypes = "ExportableLogTypes"
        case supportedCharacterSets = "SupportedCharacterSets"
        case supportedTimezones = "SupportedTimezones"
        case supportsLogExportsToCloudwatchLogs = "SupportsLogExportsToCloudwatchLogs"
        case supportsReadReplica = "SupportsReadReplica"
        case validUpgradeTarget = "ValidUpgradeTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBEngineDescription = dBEngineDescription {
            try container.encode(dBEngineDescription, forKey: ClientRuntime.Key("DBEngineDescription"))
        }
        if let dBEngineVersionDescription = dBEngineVersionDescription {
            try container.encode(dBEngineVersionDescription, forKey: ClientRuntime.Key("DBEngineVersionDescription"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let defaultCharacterSet = defaultCharacterSet {
            try container.encode(defaultCharacterSet, forKey: ClientRuntime.Key("DefaultCharacterSet"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let exportableLogTypes = exportableLogTypes {
            var exportableLogTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExportableLogTypes"))
            for (index0, string0) in exportableLogTypes.enumerated() {
                try exportableLogTypesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedCharacterSets = supportedCharacterSets {
            var supportedCharacterSetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedCharacterSets"))
            for (index0, characterset0) in supportedCharacterSets.enumerated() {
                try supportedCharacterSetsContainer.encode(characterset0, forKey: ClientRuntime.Key("CharacterSet.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedTimezones = supportedTimezones {
            var supportedTimezonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedTimezones"))
            for (index0, timezone0) in supportedTimezones.enumerated() {
                try supportedTimezonesContainer.encode(timezone0, forKey: ClientRuntime.Key("Timezone.\(index0.advanced(by: 1))"))
            }
        }
        if supportsLogExportsToCloudwatchLogs != false {
            try container.encode(supportsLogExportsToCloudwatchLogs, forKey: ClientRuntime.Key("SupportsLogExportsToCloudwatchLogs"))
        }
        if supportsReadReplica != false {
            try container.encode(supportsReadReplica, forKey: ClientRuntime.Key("SupportsReadReplica"))
        }
        if let validUpgradeTarget = validUpgradeTarget {
            var validUpgradeTargetContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValidUpgradeTarget"))
            for (index0, upgradetarget0) in validUpgradeTarget.enumerated() {
                try validUpgradeTargetContainer.encode(upgradetarget0, forKey: ClientRuntime.Key("UpgradeTarget.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let dBEngineDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineDescription)
        dBEngineDescription = dBEngineDescriptionDecoded
        let dBEngineVersionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineVersionDescription)
        dBEngineVersionDescription = dBEngineVersionDescriptionDecoded
        let defaultCharacterSetDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.CharacterSet.self, forKey: .defaultCharacterSet)
        defaultCharacterSet = defaultCharacterSetDecoded
        if containerValues.contains(.supportedCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedCharacterSets)
            if let supportedCharacterSetsWrappedContainer = supportedCharacterSetsWrappedContainer {
                let supportedCharacterSetsContainer = try supportedCharacterSetsWrappedContainer.decodeIfPresent([NeptuneClientTypes.CharacterSet].self, forKey: .member)
                var supportedCharacterSetsBuffer:[NeptuneClientTypes.CharacterSet]? = nil
                if let supportedCharacterSetsContainer = supportedCharacterSetsContainer {
                    supportedCharacterSetsBuffer = [NeptuneClientTypes.CharacterSet]()
                    for structureContainer0 in supportedCharacterSetsContainer {
                        supportedCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedCharacterSets = supportedCharacterSetsBuffer
            } else {
                supportedCharacterSets = []
            }
        } else {
            supportedCharacterSets = nil
        }
        if containerValues.contains(.validUpgradeTarget) {
            struct KeyVal0{struct UpgradeTarget{}}
            let validUpgradeTargetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UpgradeTarget>.CodingKeys.self, forKey: .validUpgradeTarget)
            if let validUpgradeTargetWrappedContainer = validUpgradeTargetWrappedContainer {
                let validUpgradeTargetContainer = try validUpgradeTargetWrappedContainer.decodeIfPresent([NeptuneClientTypes.UpgradeTarget].self, forKey: .member)
                var validUpgradeTargetBuffer:[NeptuneClientTypes.UpgradeTarget]? = nil
                if let validUpgradeTargetContainer = validUpgradeTargetContainer {
                    validUpgradeTargetBuffer = [NeptuneClientTypes.UpgradeTarget]()
                    for structureContainer0 in validUpgradeTargetContainer {
                        validUpgradeTargetBuffer?.append(structureContainer0)
                    }
                }
                validUpgradeTarget = validUpgradeTargetBuffer
            } else {
                validUpgradeTarget = []
            }
        } else {
            validUpgradeTarget = nil
        }
        if containerValues.contains(.supportedTimezones) {
            struct KeyVal0{struct Timezone{}}
            let supportedTimezonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Timezone>.CodingKeys.self, forKey: .supportedTimezones)
            if let supportedTimezonesWrappedContainer = supportedTimezonesWrappedContainer {
                let supportedTimezonesContainer = try supportedTimezonesWrappedContainer.decodeIfPresent([NeptuneClientTypes.Timezone].self, forKey: .member)
                var supportedTimezonesBuffer:[NeptuneClientTypes.Timezone]? = nil
                if let supportedTimezonesContainer = supportedTimezonesContainer {
                    supportedTimezonesBuffer = [NeptuneClientTypes.Timezone]()
                    for structureContainer0 in supportedTimezonesContainer {
                        supportedTimezonesBuffer?.append(structureContainer0)
                    }
                }
                supportedTimezones = supportedTimezonesBuffer
            } else {
                supportedTimezones = []
            }
        } else {
            supportedTimezones = nil
        }
        if containerValues.contains(.exportableLogTypes) {
            struct KeyVal0{struct member{}}
            let exportableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportableLogTypes)
            if let exportableLogTypesWrappedContainer = exportableLogTypesWrappedContainer {
                let exportableLogTypesContainer = try exportableLogTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var exportableLogTypesBuffer:[Swift.String]? = nil
                if let exportableLogTypesContainer = exportableLogTypesContainer {
                    exportableLogTypesBuffer = [Swift.String]()
                    for stringContainer0 in exportableLogTypesContainer {
                        exportableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                exportableLogTypes = exportableLogTypesBuffer
            } else {
                exportableLogTypes = []
            }
        } else {
            exportableLogTypes = nil
        }
        let supportsLogExportsToCloudwatchLogsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsLogExportsToCloudwatchLogs)
        supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogsDecoded
        let supportsReadReplicaDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsReadReplica)
        supportsReadReplica = supportsReadReplicaDecoded
    }
}

extension NeptuneClientTypes.DBEngineVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBEngineVersion(dBEngineDescription: \(Swift.String(describing: dBEngineDescription)), dBEngineVersionDescription: \(Swift.String(describing: dBEngineVersionDescription)), dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), defaultCharacterSet: \(Swift.String(describing: defaultCharacterSet)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), exportableLogTypes: \(Swift.String(describing: exportableLogTypes)), supportedCharacterSets: \(Swift.String(describing: supportedCharacterSets)), supportedTimezones: \(Swift.String(describing: supportedTimezones)), supportsLogExportsToCloudwatchLogs: \(Swift.String(describing: supportsLogExportsToCloudwatchLogs)), supportsReadReplica: \(Swift.String(describing: supportsReadReplica)), validUpgradeTarget: \(Swift.String(describing: validUpgradeTarget)))"}
}

extension NeptuneClientTypes {
    /// <p> This data type is used as a response element in the action <a>DescribeDBEngineVersions</a>.</p>
    public struct DBEngineVersion: Swift.Equatable {
        /// <p>The description of the database engine.</p>
        public let dBEngineDescription: Swift.String?
        /// <p>The description of the database engine version.</p>
        public let dBEngineVersionDescription: Swift.String?
        /// <p>The name of the DB parameter group family for the database engine.</p>
        public let dBParameterGroupFamily: Swift.String?
        /// <p>
        ///             <i>(Not supported by Neptune)</i>
        ///          </p>
        public let defaultCharacterSet: NeptuneClientTypes.CharacterSet?
        /// <p>The name of the database engine.</p>
        public let engine: Swift.String?
        /// <p>The version number of the database engine.</p>
        public let engineVersion: Swift.String?
        /// <p>The types of logs that the database engine has available for export to CloudWatch
        ///       Logs.</p>
        public let exportableLogTypes: [Swift.String]?
        /// <p>
        ///             <i>(Not supported by Neptune)</i>
        ///          </p>
        public let supportedCharacterSets: [NeptuneClientTypes.CharacterSet]?
        /// <p>A list of the time zones supported by this engine for the <code>Timezone</code> parameter
        ///       of the <code>CreateDBInstance</code> action.</p>
        public let supportedTimezones: [NeptuneClientTypes.Timezone]?
        /// <p>A value that indicates whether the engine version supports exporting the log types
        ///       specified by ExportableLogTypes to CloudWatch Logs.</p>
        public let supportsLogExportsToCloudwatchLogs: Swift.Bool
        /// <p>Indicates whether the database engine version supports read replicas.</p>
        public let supportsReadReplica: Swift.Bool
        /// <p>A list of engine versions that this database engine version can be upgraded to.</p>
        public let validUpgradeTarget: [NeptuneClientTypes.UpgradeTarget]?

        public init (
            dBEngineDescription: Swift.String? = nil,
            dBEngineVersionDescription: Swift.String? = nil,
            dBParameterGroupFamily: Swift.String? = nil,
            defaultCharacterSet: NeptuneClientTypes.CharacterSet? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            exportableLogTypes: [Swift.String]? = nil,
            supportedCharacterSets: [NeptuneClientTypes.CharacterSet]? = nil,
            supportedTimezones: [NeptuneClientTypes.Timezone]? = nil,
            supportsLogExportsToCloudwatchLogs: Swift.Bool = false,
            supportsReadReplica: Swift.Bool = false,
            validUpgradeTarget: [NeptuneClientTypes.UpgradeTarget]? = nil
        )
        {
            self.dBEngineDescription = dBEngineDescription
            self.dBEngineVersionDescription = dBEngineVersionDescription
            self.dBParameterGroupFamily = dBParameterGroupFamily
            self.defaultCharacterSet = defaultCharacterSet
            self.engine = engine
            self.engineVersion = engineVersion
            self.exportableLogTypes = exportableLogTypes
            self.supportedCharacterSets = supportedCharacterSets
            self.supportedTimezones = supportedTimezones
            self.supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogs
            self.supportsReadReplica = supportsReadReplica
            self.validUpgradeTarget = validUpgradeTarget
        }
    }

}

extension NeptuneClientTypes.DBInstance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case cACertificateIdentifier = "CACertificateIdentifier"
        case characterSetName = "CharacterSetName"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBInstanceArn = "DBInstanceArn"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBInstanceStatus = "DBInstanceStatus"
        case dBName = "DBName"
        case dBParameterGroups = "DBParameterGroups"
        case dBSecurityGroups = "DBSecurityGroups"
        case dBSubnetGroup = "DBSubnetGroup"
        case dbInstancePort = "DbInstancePort"
        case dbiResourceId = "DbiResourceId"
        case deletionProtection = "DeletionProtection"
        case domainMemberships = "DomainMemberships"
        case enabledCloudwatchLogsExports = "EnabledCloudwatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case enhancedMonitoringResourceArn = "EnhancedMonitoringResourceArn"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case instanceCreateTime = "InstanceCreateTime"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case latestRestorableTime = "LatestRestorableTime"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case monitoringInterval = "MonitoringInterval"
        case monitoringRoleArn = "MonitoringRoleArn"
        case multiAZ = "MultiAZ"
        case optionGroupMemberships = "OptionGroupMemberships"
        case pendingModifiedValues = "PendingModifiedValues"
        case performanceInsightsEnabled = "PerformanceInsightsEnabled"
        case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case promotionTier = "PromotionTier"
        case publiclyAccessible = "PubliclyAccessible"
        case readReplicaDBClusterIdentifiers = "ReadReplicaDBClusterIdentifiers"
        case readReplicaDBInstanceIdentifiers = "ReadReplicaDBInstanceIdentifiers"
        case readReplicaSourceDBInstanceIdentifier = "ReadReplicaSourceDBInstanceIdentifier"
        case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
        case statusInfos = "StatusInfos"
        case storageEncrypted = "StorageEncrypted"
        case storageType = "StorageType"
        case tdeCredentialArn = "TdeCredentialArn"
        case timezone = "Timezone"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if autoMinorVersionUpgrade != false {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if backupRetentionPeriod != 0 {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try container.encode(cACertificateIdentifier, forKey: ClientRuntime.Key("CACertificateIdentifier"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
        if copyTagsToSnapshot != false {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBInstanceArn = dBInstanceArn {
            try container.encode(dBInstanceArn, forKey: ClientRuntime.Key("DBInstanceArn"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBInstanceStatus = dBInstanceStatus {
            try container.encode(dBInstanceStatus, forKey: ClientRuntime.Key("DBInstanceStatus"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if let dBParameterGroups = dBParameterGroups {
            var dBParameterGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBParameterGroups"))
            for (index0, dbparametergroupstatus0) in dBParameterGroups.enumerated() {
                try dBParameterGroupsContainer.encode(dbparametergroupstatus0, forKey: ClientRuntime.Key("DBParameterGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSecurityGroups"))
            for (index0, dbsecuritygroupmembership0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(dbsecuritygroupmembership0, forKey: ClientRuntime.Key("DBSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroup = dBSubnetGroup {
            try container.encode(dBSubnetGroup, forKey: ClientRuntime.Key("DBSubnetGroup"))
        }
        if dbInstancePort != 0 {
            try container.encode(dbInstancePort, forKey: ClientRuntime.Key("DbInstancePort"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: ClientRuntime.Key("DbiResourceId"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domainMemberships = domainMemberships {
            var domainMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DomainMemberships"))
            for (index0, domainmembership0) in domainMemberships.enumerated() {
                try domainMembershipsContainer.encode(domainmembership0, forKey: ClientRuntime.Key("DomainMembership.\(index0.advanced(by: 1))"))
            }
        }
        if let enabledCloudwatchLogsExports = enabledCloudwatchLogsExports {
            var enabledCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnabledCloudwatchLogsExports"))
            for (index0, string0) in enabledCloudwatchLogsExports.enumerated() {
                try enabledCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let enhancedMonitoringResourceArn = enhancedMonitoringResourceArn {
            try container.encode(enhancedMonitoringResourceArn, forKey: ClientRuntime.Key("EnhancedMonitoringResourceArn"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let instanceCreateTime = instanceCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(instanceCreateTime, format: .dateTime), forKey: ClientRuntime.Key("instanceCreateTime"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let latestRestorableTime = latestRestorableTime {
            try container.encode(ClientRuntime.TimestampWrapper(latestRestorableTime, format: .dateTime), forKey: ClientRuntime.Key("latestRestorableTime"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if multiAZ != false {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let optionGroupMemberships = optionGroupMemberships {
            var optionGroupMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionGroupMemberships"))
            for (index0, optiongroupmembership0) in optionGroupMemberships.enumerated() {
                try optionGroupMembershipsContainer.encode(optiongroupmembership0, forKey: ClientRuntime.Key("OptionGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try container.encode(pendingModifiedValues, forKey: ClientRuntime.Key("PendingModifiedValues"))
        }
        if let performanceInsightsEnabled = performanceInsightsEnabled {
            try container.encode(performanceInsightsEnabled, forKey: ClientRuntime.Key("PerformanceInsightsEnabled"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: ClientRuntime.Key("PromotionTier"))
        }
        if publiclyAccessible != false {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers {
            var readReplicaDBClusterIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ReadReplicaDBClusterIdentifiers"))
            for (index0, string0) in readReplicaDBClusterIdentifiers.enumerated() {
                try readReplicaDBClusterIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("ReadReplicaDBClusterIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers {
            var readReplicaDBInstanceIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ReadReplicaDBInstanceIdentifiers"))
            for (index0, string0) in readReplicaDBInstanceIdentifiers.enumerated() {
                try readReplicaDBInstanceIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("ReadReplicaDBInstanceIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier {
            try container.encode(readReplicaSourceDBInstanceIdentifier, forKey: ClientRuntime.Key("ReadReplicaSourceDBInstanceIdentifier"))
        }
        if let secondaryAvailabilityZone = secondaryAvailabilityZone {
            try container.encode(secondaryAvailabilityZone, forKey: ClientRuntime.Key("SecondaryAvailabilityZone"))
        }
        if let statusInfos = statusInfos {
            var statusInfosContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("StatusInfos"))
            for (index0, dbinstancestatusinfo0) in statusInfos.enumerated() {
                try statusInfosContainer.encode(dbinstancestatusinfo0, forKey: ClientRuntime.Key("DBInstanceStatusInfo.\(index0.advanced(by: 1))"))
            }
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: ClientRuntime.Key("Timezone"))
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: ClientRuntime.Key("VpcSecurityGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let dBInstanceStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceStatus)
        dBInstanceStatus = dBInstanceStatusDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let allocatedStorageDecoded = try containerValues.decode(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceCreateTime)
        var instanceCreateTimeBuffer:ClientRuntime.Date? = nil
        if let instanceCreateTimeDecoded = instanceCreateTimeDecoded {
            instanceCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(instanceCreateTimeDecoded, format: .dateTime)
        }
        instanceCreateTime = instanceCreateTimeBuffer
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let backupRetentionPeriodDecoded = try containerValues.decode(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        if containerValues.contains(.dBSecurityGroups) {
            struct KeyVal0{struct DBSecurityGroup{}}
            let dBSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroup>.CodingKeys.self, forKey: .dBSecurityGroups)
            if let dBSecurityGroupsWrappedContainer = dBSecurityGroupsWrappedContainer {
                let dBSecurityGroupsContainer = try dBSecurityGroupsWrappedContainer.decodeIfPresent([NeptuneClientTypes.DBSecurityGroupMembership].self, forKey: .member)
                var dBSecurityGroupsBuffer:[NeptuneClientTypes.DBSecurityGroupMembership]? = nil
                if let dBSecurityGroupsContainer = dBSecurityGroupsContainer {
                    dBSecurityGroupsBuffer = [NeptuneClientTypes.DBSecurityGroupMembership]()
                    for structureContainer0 in dBSecurityGroupsContainer {
                        dBSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBSecurityGroups = dBSecurityGroupsBuffer
            } else {
                dBSecurityGroups = []
            }
        } else {
            dBSecurityGroups = nil
        }
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroupMembership{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupMembership>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([NeptuneClientTypes.VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[NeptuneClientTypes.VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [NeptuneClientTypes.VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        if containerValues.contains(.dBParameterGroups) {
            struct KeyVal0{struct DBParameterGroup{}}
            let dBParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBParameterGroup>.CodingKeys.self, forKey: .dBParameterGroups)
            if let dBParameterGroupsWrappedContainer = dBParameterGroupsWrappedContainer {
                let dBParameterGroupsContainer = try dBParameterGroupsWrappedContainer.decodeIfPresent([NeptuneClientTypes.DBParameterGroupStatus].self, forKey: .member)
                var dBParameterGroupsBuffer:[NeptuneClientTypes.DBParameterGroupStatus]? = nil
                if let dBParameterGroupsContainer = dBParameterGroupsContainer {
                    dBParameterGroupsBuffer = [NeptuneClientTypes.DBParameterGroupStatus]()
                    for structureContainer0 in dBParameterGroupsContainer {
                        dBParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBParameterGroups = dBParameterGroupsBuffer
            } else {
                dBParameterGroups = []
            }
        } else {
            dBParameterGroups = nil
        }
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBSubnetGroup.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.PendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let latestRestorableTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestRestorableTime)
        var latestRestorableTimeBuffer:ClientRuntime.Date? = nil
        if let latestRestorableTimeDecoded = latestRestorableTimeDecoded {
            latestRestorableTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(latestRestorableTimeDecoded, format: .dateTime)
        }
        latestRestorableTime = latestRestorableTimeBuffer
        let multiAZDecoded = try containerValues.decode(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let readReplicaSourceDBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readReplicaSourceDBInstanceIdentifier)
        readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifierDecoded
        if containerValues.contains(.readReplicaDBInstanceIdentifiers) {
            struct KeyVal0{struct ReadReplicaDBInstanceIdentifier{}}
            let readReplicaDBInstanceIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaDBInstanceIdentifier>.CodingKeys.self, forKey: .readReplicaDBInstanceIdentifiers)
            if let readReplicaDBInstanceIdentifiersWrappedContainer = readReplicaDBInstanceIdentifiersWrappedContainer {
                let readReplicaDBInstanceIdentifiersContainer = try readReplicaDBInstanceIdentifiersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var readReplicaDBInstanceIdentifiersBuffer:[Swift.String]? = nil
                if let readReplicaDBInstanceIdentifiersContainer = readReplicaDBInstanceIdentifiersContainer {
                    readReplicaDBInstanceIdentifiersBuffer = [Swift.String]()
                    for stringContainer0 in readReplicaDBInstanceIdentifiersContainer {
                        readReplicaDBInstanceIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiersBuffer
            } else {
                readReplicaDBInstanceIdentifiers = []
            }
        } else {
            readReplicaDBInstanceIdentifiers = nil
        }
        if containerValues.contains(.readReplicaDBClusterIdentifiers) {
            struct KeyVal0{struct ReadReplicaDBClusterIdentifier{}}
            let readReplicaDBClusterIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaDBClusterIdentifier>.CodingKeys.self, forKey: .readReplicaDBClusterIdentifiers)
            if let readReplicaDBClusterIdentifiersWrappedContainer = readReplicaDBClusterIdentifiersWrappedContainer {
                let readReplicaDBClusterIdentifiersContainer = try readReplicaDBClusterIdentifiersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var readReplicaDBClusterIdentifiersBuffer:[Swift.String]? = nil
                if let readReplicaDBClusterIdentifiersContainer = readReplicaDBClusterIdentifiersContainer {
                    readReplicaDBClusterIdentifiersBuffer = [Swift.String]()
                    for stringContainer0 in readReplicaDBClusterIdentifiersContainer {
                        readReplicaDBClusterIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiersBuffer
            } else {
                readReplicaDBClusterIdentifiers = []
            }
        } else {
            readReplicaDBClusterIdentifiers = nil
        }
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        if containerValues.contains(.optionGroupMemberships) {
            struct KeyVal0{struct OptionGroupMembership{}}
            let optionGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionGroupMembership>.CodingKeys.self, forKey: .optionGroupMemberships)
            if let optionGroupMembershipsWrappedContainer = optionGroupMembershipsWrappedContainer {
                let optionGroupMembershipsContainer = try optionGroupMembershipsWrappedContainer.decodeIfPresent([NeptuneClientTypes.OptionGroupMembership].self, forKey: .member)
                var optionGroupMembershipsBuffer:[NeptuneClientTypes.OptionGroupMembership]? = nil
                if let optionGroupMembershipsContainer = optionGroupMembershipsContainer {
                    optionGroupMembershipsBuffer = [NeptuneClientTypes.OptionGroupMembership]()
                    for structureContainer0 in optionGroupMembershipsContainer {
                        optionGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupMemberships = optionGroupMembershipsBuffer
            } else {
                optionGroupMemberships = []
            }
        } else {
            optionGroupMemberships = nil
        }
        let characterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let secondaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryAvailabilityZone)
        secondaryAvailabilityZone = secondaryAvailabilityZoneDecoded
        let publiclyAccessibleDecoded = try containerValues.decode(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        if containerValues.contains(.statusInfos) {
            struct KeyVal0{struct DBInstanceStatusInfo{}}
            let statusInfosWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceStatusInfo>.CodingKeys.self, forKey: .statusInfos)
            if let statusInfosWrappedContainer = statusInfosWrappedContainer {
                let statusInfosContainer = try statusInfosWrappedContainer.decodeIfPresent([NeptuneClientTypes.DBInstanceStatusInfo].self, forKey: .member)
                var statusInfosBuffer:[NeptuneClientTypes.DBInstanceStatusInfo]? = nil
                if let statusInfosContainer = statusInfosContainer {
                    statusInfosBuffer = [NeptuneClientTypes.DBInstanceStatusInfo]()
                    for structureContainer0 in statusInfosContainer {
                        statusInfosBuffer?.append(structureContainer0)
                    }
                }
                statusInfos = statusInfosBuffer
            } else {
                statusInfos = []
            }
        } else {
            statusInfos = nil
        }
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let dbInstancePortDecoded = try containerValues.decode(Swift.Int.self, forKey: .dbInstancePort)
        dbInstancePort = dbInstancePortDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let storageEncryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
        let cACertificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cACertificateIdentifier)
        cACertificateIdentifier = cACertificateIdentifierDecoded
        if containerValues.contains(.domainMemberships) {
            struct KeyVal0{struct DomainMembership{}}
            let domainMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DomainMembership>.CodingKeys.self, forKey: .domainMemberships)
            if let domainMembershipsWrappedContainer = domainMembershipsWrappedContainer {
                let domainMembershipsContainer = try domainMembershipsWrappedContainer.decodeIfPresent([NeptuneClientTypes.DomainMembership].self, forKey: .member)
                var domainMembershipsBuffer:[NeptuneClientTypes.DomainMembership]? = nil
                if let domainMembershipsContainer = domainMembershipsContainer {
                    domainMembershipsBuffer = [NeptuneClientTypes.DomainMembership]()
                    for structureContainer0 in domainMembershipsContainer {
                        domainMembershipsBuffer?.append(structureContainer0)
                    }
                }
                domainMemberships = domainMembershipsBuffer
            } else {
                domainMemberships = []
            }
        } else {
            domainMemberships = nil
        }
        let copyTagsToSnapshotDecoded = try containerValues.decode(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let monitoringIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monitoringInterval)
        monitoringInterval = monitoringIntervalDecoded
        let enhancedMonitoringResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enhancedMonitoringResourceArn)
        enhancedMonitoringResourceArn = enhancedMonitoringResourceArnDecoded
        let monitoringRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitoringRoleArn)
        monitoringRoleArn = monitoringRoleArnDecoded
        let promotionTierDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .promotionTier)
        promotionTier = promotionTierDecoded
        let dBInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceArn)
        dBInstanceArn = dBInstanceArnDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let performanceInsightsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performanceInsightsEnabled)
        performanceInsightsEnabled = performanceInsightsEnabledDecoded
        let performanceInsightsKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .performanceInsightsKMSKeyId)
        performanceInsightsKMSKeyId = performanceInsightsKMSKeyIdDecoded
        if containerValues.contains(.enabledCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enabledCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enabledCloudwatchLogsExports)
            if let enabledCloudwatchLogsExportsWrappedContainer = enabledCloudwatchLogsExportsWrappedContainer {
                let enabledCloudwatchLogsExportsContainer = try enabledCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enabledCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enabledCloudwatchLogsExportsContainer = enabledCloudwatchLogsExportsContainer {
                    enabledCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enabledCloudwatchLogsExportsContainer {
                        enabledCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enabledCloudwatchLogsExports = enabledCloudwatchLogsExportsBuffer
            } else {
                enabledCloudwatchLogsExports = []
            }
        } else {
            enabledCloudwatchLogsExports = nil
        }
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
    }
}

extension NeptuneClientTypes.DBInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstance(allocatedStorage: \(Swift.String(describing: allocatedStorage)), autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), availabilityZone: \(Swift.String(describing: availabilityZone)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), cACertificateIdentifier: \(Swift.String(describing: cACertificateIdentifier)), characterSetName: \(Swift.String(describing: characterSetName)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBInstanceArn: \(Swift.String(describing: dBInstanceArn)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dBInstanceStatus: \(Swift.String(describing: dBInstanceStatus)), dBName: \(Swift.String(describing: dBName)), dBParameterGroups: \(Swift.String(describing: dBParameterGroups)), dBSecurityGroups: \(Swift.String(describing: dBSecurityGroups)), dBSubnetGroup: \(Swift.String(describing: dBSubnetGroup)), dbInstancePort: \(Swift.String(describing: dbInstancePort)), dbiResourceId: \(Swift.String(describing: dbiResourceId)), deletionProtection: \(Swift.String(describing: deletionProtection)), domainMemberships: \(Swift.String(describing: domainMemberships)), enabledCloudwatchLogsExports: \(Swift.String(describing: enabledCloudwatchLogsExports)), endpoint: \(Swift.String(describing: endpoint)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), enhancedMonitoringResourceArn: \(Swift.String(describing: enhancedMonitoringResourceArn)), iAMDatabaseAuthenticationEnabled: \(Swift.String(describing: iAMDatabaseAuthenticationEnabled)), instanceCreateTime: \(Swift.String(describing: instanceCreateTime)), iops: \(Swift.String(describing: iops)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), latestRestorableTime: \(Swift.String(describing: latestRestorableTime)), licenseModel: \(Swift.String(describing: licenseModel)), masterUsername: \(Swift.String(describing: masterUsername)), monitoringInterval: \(Swift.String(describing: monitoringInterval)), monitoringRoleArn: \(Swift.String(describing: monitoringRoleArn)), multiAZ: \(Swift.String(describing: multiAZ)), optionGroupMemberships: \(Swift.String(describing: optionGroupMemberships)), pendingModifiedValues: \(Swift.String(describing: pendingModifiedValues)), performanceInsightsEnabled: \(Swift.String(describing: performanceInsightsEnabled)), performanceInsightsKMSKeyId: \(Swift.String(describing: performanceInsightsKMSKeyId)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), promotionTier: \(Swift.String(describing: promotionTier)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), readReplicaDBClusterIdentifiers: \(Swift.String(describing: readReplicaDBClusterIdentifiers)), readReplicaDBInstanceIdentifiers: \(Swift.String(describing: readReplicaDBInstanceIdentifiers)), readReplicaSourceDBInstanceIdentifier: \(Swift.String(describing: readReplicaSourceDBInstanceIdentifier)), secondaryAvailabilityZone: \(Swift.String(describing: secondaryAvailabilityZone)), statusInfos: \(Swift.String(describing: statusInfos)), storageEncrypted: \(Swift.String(describing: storageEncrypted)), storageType: \(Swift.String(describing: storageType)), tdeCredentialArn: \(Swift.String(describing: tdeCredentialArn)), timezone: \(Swift.String(describing: timezone)), vpcSecurityGroups: \(Swift.String(describing: vpcSecurityGroups)))"}
}

extension NeptuneClientTypes {
    /// <p>Contains the details of an Amazon Neptune DB instance.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBInstances</a> action.</p>
    public struct DBInstance: Swift.Equatable {
        /// <p>Not supported by Neptune.</p>
        public let allocatedStorage: Swift.Int
        /// <p>Indicates that minor version patches are applied automatically.</p>
        public let autoMinorVersionUpgrade: Swift.Bool
        /// <p>Specifies the name of the Availability Zone the DB instance is located in.</p>
        public let availabilityZone: Swift.String?
        /// <p>Specifies the number of days for which automatic DB snapshots are retained.</p>
        public let backupRetentionPeriod: Swift.Int
        /// <p>The identifier of the CA certificate for this DB instance.</p>
        public let cACertificateIdentifier: Swift.String?
        /// <p>
        ///             <i>(Not supported by Neptune)</i>
        ///          </p>
        public let characterSetName: Swift.String?
        /// <p>Specifies whether tags are copied from the DB instance to snapshots of the DB
        ///       instance.</p>
        public let copyTagsToSnapshot: Swift.Bool
        /// <p>If the DB instance is a member of a DB cluster, contains the name of the DB cluster that
        ///       the DB instance is a member of.</p>
        public let dBClusterIdentifier: Swift.String?
        /// <p>The Amazon Resource Name (ARN) for the DB instance.</p>
        public let dBInstanceArn: Swift.String?
        /// <p>Contains the name of the compute and memory capacity class of the DB instance.</p>
        public let dBInstanceClass: Swift.String?
        /// <p>Contains a user-supplied database identifier. This identifier is the unique key that
        ///       identifies a DB instance.</p>
        public let dBInstanceIdentifier: Swift.String?
        /// <p>Specifies the current state of this database.</p>
        public let dBInstanceStatus: Swift.String?
        /// <p>The database name.</p>
        public let dBName: Swift.String?
        /// <p>Provides the list of DB parameter groups applied to this DB instance.</p>
        public let dBParameterGroups: [NeptuneClientTypes.DBParameterGroupStatus]?
        /// <p> Provides List of DB security group elements containing only
        ///       <code>DBSecurityGroup.Name</code> and <code>DBSecurityGroup.Status</code> subelements.</p>
        public let dBSecurityGroups: [NeptuneClientTypes.DBSecurityGroupMembership]?
        /// <p>Specifies information on the subnet group associated with the DB instance, including the
        ///       name, description, and subnets in the subnet group.</p>
        public let dBSubnetGroup: NeptuneClientTypes.DBSubnetGroup?
        /// <p>Specifies the port that the DB instance listens on. If the DB instance is part of a DB
        ///       cluster, this can be a different port than the DB cluster port.</p>
        public let dbInstancePort: Swift.Int
        /// <p>The Amazon Region-unique, immutable identifier for the DB instance. This identifier is found
        ///       in Amazon CloudTrail log entries whenever the Amazon KMS key for the DB instance is accessed.</p>
        public let dbiResourceId: Swift.String?
        /// <p>Indicates whether or not the DB instance has deletion protection enabled.
        ///       The instance can't be deleted when deletion protection is enabled. See <a href="https://docs.aws.amazon.com/neptune/latest/userguide/manage-console-instances-delete.html">Deleting
        ///       a DB Instance</a>.</p>
        public let deletionProtection: Swift.Bool?
        /// <p>Not supported</p>
        public let domainMemberships: [NeptuneClientTypes.DomainMembership]?
        /// <p>A list of log types that this DB instance is configured to export to CloudWatch
        ///       Logs.</p>
        public let enabledCloudwatchLogsExports: [Swift.String]?
        /// <p>Specifies the connection endpoint.</p>
        public let endpoint: NeptuneClientTypes.Endpoint?
        /// <p>Provides the name of the database engine to be used for this DB instance.</p>
        public let engine: Swift.String?
        /// <p>Indicates the database engine version.</p>
        public let engineVersion: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log stream that receives the
        ///       Enhanced Monitoring metrics data for the DB instance.</p>
        public let enhancedMonitoringResourceArn: Swift.String?
        /// <p>True if Amazon Identity and Access Management (IAM) authentication is enabled, and otherwise
        ///       false.</p>
        public let iAMDatabaseAuthenticationEnabled: Swift.Bool
        /// <p>Provides the date and time the DB instance was created.</p>
        public let instanceCreateTime: ClientRuntime.Date?
        /// <p>Specifies the Provisioned IOPS (I/O operations per second) value.</p>
        public let iops: Swift.Int?
        /// <p> Not supported: The encryption for DB instances is managed by the DB cluster.</p>
        public let kmsKeyId: Swift.String?
        /// <p>Specifies the latest time to which a database can be restored with point-in-time
        ///       restore.</p>
        public let latestRestorableTime: ClientRuntime.Date?
        /// <p>License model information for this DB instance.</p>
        public let licenseModel: Swift.String?
        /// <p>Not supported by Neptune.</p>
        public let masterUsername: Swift.String?
        /// <p>The interval, in seconds, between points when Enhanced Monitoring metrics are collected
        ///       for the DB instance.</p>
        public let monitoringInterval: Swift.Int?
        /// <p>The ARN for the IAM role that permits Neptune to send Enhanced Monitoring metrics to
        ///       Amazon CloudWatch Logs.</p>
        public let monitoringRoleArn: Swift.String?
        /// <p>Specifies if the DB instance is a Multi-AZ deployment.</p>
        public let multiAZ: Swift.Bool
        /// <p>
        ///             <i>(Not supported by Neptune)</i>
        ///          </p>
        public let optionGroupMemberships: [NeptuneClientTypes.OptionGroupMembership]?
        /// <p>Specifies that changes to the DB instance are pending. This element is only included when
        ///       changes are pending. Specific changes are identified by subelements.</p>
        public let pendingModifiedValues: NeptuneClientTypes.PendingModifiedValues?
        /// <p>
        ///             <i>(Not supported by Neptune)</i>
        ///          </p>
        public let performanceInsightsEnabled: Swift.Bool?
        /// <p>
        ///             <i>(Not supported by Neptune)</i>
        ///          </p>
        public let performanceInsightsKMSKeyId: Swift.String?
        /// <p> Specifies the daily time range during which automated backups are created if automated
        ///       backups are enabled, as determined by the <code>BackupRetentionPeriod</code>.</p>
        public let preferredBackupWindow: Swift.String?
        /// <p>Specifies the weekly time range during which system maintenance can occur, in Universal
        ///       Coordinated Time (UTC).</p>
        public let preferredMaintenanceWindow: Swift.String?
        /// <p>A value that specifies the order in which a Read Replica is promoted to the primary
        ///       instance after a failure of the existing primary instance.
        ///    </p>
        public let promotionTier: Swift.Int?
        /// <p>This flag should no longer be used.</p>
        @available(*, deprecated)
        public let publiclyAccessible: Swift.Bool
        /// <p>Contains one or more identifiers of DB clusters that are Read Replicas of this DB
        ///       instance.</p>
        public let readReplicaDBClusterIdentifiers: [Swift.String]?
        /// <p>Contains one or more identifiers of the Read Replicas associated with this DB
        ///       instance.</p>
        public let readReplicaDBInstanceIdentifiers: [Swift.String]?
        /// <p>Contains the identifier of the source DB instance if this DB instance is a Read
        ///       Replica.</p>
        public let readReplicaSourceDBInstanceIdentifier: Swift.String?
        /// <p>If present, specifies the name of the secondary Availability Zone for a DB instance with
        ///       multi-AZ support.</p>
        public let secondaryAvailabilityZone: Swift.String?
        /// <p>The status of a Read Replica. If the instance is not a Read Replica, this is blank.</p>
        public let statusInfos: [NeptuneClientTypes.DBInstanceStatusInfo]?
        /// <p>Not supported: The encryption for DB instances is managed by the DB cluster.</p>
        public let storageEncrypted: Swift.Bool
        /// <p>Specifies the storage type associated with DB instance.</p>
        public let storageType: Swift.String?
        /// <p>The ARN from the key store with which the instance is associated for TDE
        ///       encryption.</p>
        public let tdeCredentialArn: Swift.String?
        /// <p>Not supported.</p>
        public let timezone: Swift.String?
        /// <p>Provides a list of VPC security group elements that the DB instance belongs to.</p>
        public let vpcSecurityGroups: [NeptuneClientTypes.VpcSecurityGroupMembership]?

        public init (
            allocatedStorage: Swift.Int = 0,
            autoMinorVersionUpgrade: Swift.Bool = false,
            availabilityZone: Swift.String? = nil,
            backupRetentionPeriod: Swift.Int = 0,
            cACertificateIdentifier: Swift.String? = nil,
            characterSetName: Swift.String? = nil,
            copyTagsToSnapshot: Swift.Bool = false,
            dBClusterIdentifier: Swift.String? = nil,
            dBInstanceArn: Swift.String? = nil,
            dBInstanceClass: Swift.String? = nil,
            dBInstanceIdentifier: Swift.String? = nil,
            dBInstanceStatus: Swift.String? = nil,
            dBName: Swift.String? = nil,
            dBParameterGroups: [NeptuneClientTypes.DBParameterGroupStatus]? = nil,
            dBSecurityGroups: [NeptuneClientTypes.DBSecurityGroupMembership]? = nil,
            dBSubnetGroup: NeptuneClientTypes.DBSubnetGroup? = nil,
            dbInstancePort: Swift.Int = 0,
            dbiResourceId: Swift.String? = nil,
            deletionProtection: Swift.Bool? = nil,
            domainMemberships: [NeptuneClientTypes.DomainMembership]? = nil,
            enabledCloudwatchLogsExports: [Swift.String]? = nil,
            endpoint: NeptuneClientTypes.Endpoint? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            enhancedMonitoringResourceArn: Swift.String? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool = false,
            instanceCreateTime: ClientRuntime.Date? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            latestRestorableTime: ClientRuntime.Date? = nil,
            licenseModel: Swift.String? = nil,
            masterUsername: Swift.String? = nil,
            monitoringInterval: Swift.Int? = nil,
            monitoringRoleArn: Swift.String? = nil,
            multiAZ: Swift.Bool = false,
            optionGroupMemberships: [NeptuneClientTypes.OptionGroupMembership]? = nil,
            pendingModifiedValues: NeptuneClientTypes.PendingModifiedValues? = nil,
            performanceInsightsEnabled: Swift.Bool? = nil,
            performanceInsightsKMSKeyId: Swift.String? = nil,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            promotionTier: Swift.Int? = nil,
            publiclyAccessible: Swift.Bool = false,
            readReplicaDBClusterIdentifiers: [Swift.String]? = nil,
            readReplicaDBInstanceIdentifiers: [Swift.String]? = nil,
            readReplicaSourceDBInstanceIdentifier: Swift.String? = nil,
            secondaryAvailabilityZone: Swift.String? = nil,
            statusInfos: [NeptuneClientTypes.DBInstanceStatusInfo]? = nil,
            storageEncrypted: Swift.Bool = false,
            storageType: Swift.String? = nil,
            tdeCredentialArn: Swift.String? = nil,
            timezone: Swift.String? = nil,
            vpcSecurityGroups: [NeptuneClientTypes.VpcSecurityGroupMembership]? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.backupRetentionPeriod = backupRetentionPeriod
            self.cACertificateIdentifier = cACertificateIdentifier
            self.characterSetName = characterSetName
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.dBClusterIdentifier = dBClusterIdentifier
            self.dBInstanceArn = dBInstanceArn
            self.dBInstanceClass = dBInstanceClass
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.dBInstanceStatus = dBInstanceStatus
            self.dBName = dBName
            self.dBParameterGroups = dBParameterGroups
            self.dBSecurityGroups = dBSecurityGroups
            self.dBSubnetGroup = dBSubnetGroup
            self.dbInstancePort = dbInstancePort
            self.dbiResourceId = dbiResourceId
            self.deletionProtection = deletionProtection
            self.domainMemberships = domainMemberships
            self.enabledCloudwatchLogsExports = enabledCloudwatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineVersion = engineVersion
            self.enhancedMonitoringResourceArn = enhancedMonitoringResourceArn
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.latestRestorableTime = latestRestorableTime
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.multiAZ = multiAZ
            self.optionGroupMemberships = optionGroupMemberships
            self.pendingModifiedValues = pendingModifiedValues
            self.performanceInsightsEnabled = performanceInsightsEnabled
            self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.promotionTier = promotionTier
            self.publiclyAccessible = publiclyAccessible
            self.readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers
            self.readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers
            self.readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.statusInfos = statusInfos
            self.storageEncrypted = storageEncrypted
            self.storageType = storageType
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension DBInstanceAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstanceAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBInstanceAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBInstanceAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>User already has a DB instance with the given identifier.</p>
public struct DBInstanceAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBInstanceAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstanceNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBInstanceNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBInstanceNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBInstanceIdentifier</i> does not refer to an existing DB instance.</p>
public struct DBInstanceNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBInstanceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.DBInstanceStatusInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case normal = "Normal"
        case status = "Status"
        case statusType = "StatusType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if normal != false {
            try container.encode(normal, forKey: ClientRuntime.Key("Normal"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let statusType = statusType {
            try container.encode(statusType, forKey: ClientRuntime.Key("StatusType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusType)
        statusType = statusTypeDecoded
        let normalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .normal)
        normal = normalDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.DBInstanceStatusInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstanceStatusInfo(message: \(Swift.String(describing: message)), normal: \(Swift.String(describing: normal)), status: \(Swift.String(describing: status)), statusType: \(Swift.String(describing: statusType)))"}
}

extension NeptuneClientTypes {
    /// <p>Provides a list of status information for a DB instance.</p>
    public struct DBInstanceStatusInfo: Swift.Equatable {
        /// <p>Details of the error if there is an error for the instance. If the instance is not in an
        ///       error state, this value is blank.</p>
        public let message: Swift.String?
        /// <p>Boolean value that is true if the instance is operating normally, or false if the instance
        ///       is in an error state.</p>
        public let normal: Swift.Bool
        /// <p>Status of the DB instance. For a StatusType of read replica, the values can be
        ///       replicating, error, stopped, or terminated.</p>
        public let status: Swift.String?
        /// <p>This value is currently "read replication."</p>
        public let statusType: Swift.String?

        public init (
            message: Swift.String? = nil,
            normal: Swift.Bool = false,
            status: Swift.String? = nil,
            statusType: Swift.String? = nil
        )
        {
            self.message = message
            self.normal = normal
            self.status = status
            self.statusType = statusType
        }
    }

}

extension NeptuneClientTypes.DBParameterGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupArn = "DBParameterGroupArn"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case dBParameterGroupName = "DBParameterGroupName"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupArn = dBParameterGroupArn {
            try container.encode(dBParameterGroupArn, forKey: ClientRuntime.Key("DBParameterGroupArn"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dBParameterGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupArn)
        dBParameterGroupArn = dBParameterGroupArnDecoded
    }
}

extension NeptuneClientTypes.DBParameterGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBParameterGroup(dBParameterGroupArn: \(Swift.String(describing: dBParameterGroupArn)), dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), description: \(Swift.String(describing: description)))"}
}

extension NeptuneClientTypes {
    /// <p>Contains the details of an Amazon Neptune DB parameter group.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBParameterGroups</a> action.</p>
    public struct DBParameterGroup: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) for the DB parameter group.</p>
        public let dBParameterGroupArn: Swift.String?
        /// <p>Provides the name of the DB parameter group family that this DB parameter group is
        ///       compatible with.</p>
        public let dBParameterGroupFamily: Swift.String?
        /// <p>Provides the name of the DB parameter group.</p>
        public let dBParameterGroupName: Swift.String?
        /// <p>Provides the customer-specified description for this DB parameter group.</p>
        public let description: Swift.String?

        public init (
            dBParameterGroupArn: Swift.String? = nil,
            dBParameterGroupFamily: Swift.String? = nil,
            dBParameterGroupName: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.dBParameterGroupArn = dBParameterGroupArn
            self.dBParameterGroupFamily = dBParameterGroupFamily
            self.dBParameterGroupName = dBParameterGroupName
            self.description = description
        }
    }

}

extension DBParameterGroupAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBParameterGroupAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBParameterGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBParameterGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A DB parameter group with the same name exists.</p>
public struct DBParameterGroupAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBParameterGroupAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBParameterGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBParameterGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBParameterGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBParameterGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBParameterGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBParameterGroupName</i> does not refer to an
///       existing DB parameter group.</p>
public struct DBParameterGroupNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBParameterGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBParameterGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBParameterGroupQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBParameterGroupQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBParameterGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBParameterGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would result in user exceeding the allowed number of DB parameter groups.</p>
public struct DBParameterGroupQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBParameterGroupQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBParameterGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.DBParameterGroupStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
        case parameterApplyStatus = "ParameterApplyStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let parameterApplyStatus = parameterApplyStatus {
            try container.encode(parameterApplyStatus, forKey: ClientRuntime.Key("ParameterApplyStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
    }
}

extension NeptuneClientTypes.DBParameterGroupStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBParameterGroupStatus(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), parameterApplyStatus: \(Swift.String(describing: parameterApplyStatus)))"}
}

extension NeptuneClientTypes {
    /// <p>The status of the DB parameter group.</p>
    ///          <p>This data type is used as a response element in the following actions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a>CreateDBInstance</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DeleteDBInstance</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>ModifyDBInstance</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>RebootDBInstance</a>
    ///                </p>
    ///             </li>
    ///          </ul>
    public struct DBParameterGroupStatus: Swift.Equatable {
        /// <p>The name of the DP parameter group.</p>
        public let dBParameterGroupName: Swift.String?
        /// <p>The status of parameter updates.</p>
        public let parameterApplyStatus: Swift.String?

        public init (
            dBParameterGroupName: Swift.String? = nil,
            parameterApplyStatus: Swift.String? = nil
        )
        {
            self.dBParameterGroupName = dBParameterGroupName
            self.parameterApplyStatus = parameterApplyStatus
        }
    }

}

extension NeptuneClientTypes.DBSecurityGroupMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroupName = "DBSecurityGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: ClientRuntime.Key("DBSecurityGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSecurityGroupName)
        dBSecurityGroupName = dBSecurityGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension NeptuneClientTypes.DBSecurityGroupMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSecurityGroupMembership(dBSecurityGroupName: \(Swift.String(describing: dBSecurityGroupName)), status: \(Swift.String(describing: status)))"}
}

extension NeptuneClientTypes {
    /// <p>Specifies membership in a designated DB security group.</p>
    public struct DBSecurityGroupMembership: Swift.Equatable {
        /// <p>The name of the DB security group.</p>
        public let dBSecurityGroupName: Swift.String?
        /// <p>The status of the DB security group.</p>
        public let status: Swift.String?

        public init (
            dBSecurityGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.dBSecurityGroupName = dBSecurityGroupName
            self.status = status
        }
    }

}

extension DBSecurityGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSecurityGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBSecurityGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBSecurityGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBSecurityGroupName</i> does not refer
///       to an existing DB security group.</p>
public struct DBSecurityGroupNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSecurityGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSecurityGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSnapshotAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSnapshotAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBSnapshotAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBSnapshotAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBSnapshotIdentifier</i> is already used by an existing snapshot.</p>
public struct DBSnapshotAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSnapshotAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSnapshotAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSnapshotNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSnapshotNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBSnapshotNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBSnapshotNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBSnapshotIdentifier</i> does not refer to an existing DB snapshot.</p>
public struct DBSnapshotNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSnapshotNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSnapshotNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.DBSubnetGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroupArn = "DBSubnetGroupArn"
        case dBSubnetGroupDescription = "DBSubnetGroupDescription"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case subnetGroupStatus = "SubnetGroupStatus"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSubnetGroupArn = dBSubnetGroupArn {
            try container.encode(dBSubnetGroupArn, forKey: ClientRuntime.Key("DBSubnetGroupArn"))
        }
        if let dBSubnetGroupDescription = dBSubnetGroupDescription {
            try container.encode(dBSubnetGroupDescription, forKey: ClientRuntime.Key("DBSubnetGroupDescription"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let subnetGroupStatus = subnetGroupStatus {
            try container.encode(subnetGroupStatus, forKey: ClientRuntime.Key("SubnetGroupStatus"))
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
            for (index0, subnet0) in subnets.enumerated() {
                try subnetsContainer.encode(subnet0, forKey: ClientRuntime.Key("Subnet.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let dBSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupDescription)
        dBSubnetGroupDescription = dBSubnetGroupDescriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupStatus)
        subnetGroupStatus = subnetGroupStatusDecoded
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct Subnet{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Subnet>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([NeptuneClientTypes.Subnet].self, forKey: .member)
                var subnetsBuffer:[NeptuneClientTypes.Subnet]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [NeptuneClientTypes.Subnet]()
                    for structureContainer0 in subnetsContainer {
                        subnetsBuffer?.append(structureContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
        let dBSubnetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupArn)
        dBSubnetGroupArn = dBSubnetGroupArnDecoded
    }
}

extension NeptuneClientTypes.DBSubnetGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSubnetGroup(dBSubnetGroupArn: \(Swift.String(describing: dBSubnetGroupArn)), dBSubnetGroupDescription: \(Swift.String(describing: dBSubnetGroupDescription)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), subnetGroupStatus: \(Swift.String(describing: subnetGroupStatus)), subnets: \(Swift.String(describing: subnets)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension NeptuneClientTypes {
    /// <p>Contains the details of an Amazon Neptune DB subnet group.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBSubnetGroups</a> action.</p>
    public struct DBSubnetGroup: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) for the DB subnet group.</p>
        public let dBSubnetGroupArn: Swift.String?
        /// <p>Provides the description of the DB subnet group.</p>
        public let dBSubnetGroupDescription: Swift.String?
        /// <p>The name of the DB subnet group.</p>
        public let dBSubnetGroupName: Swift.String?
        /// <p>Provides the status of the DB subnet group.</p>
        public let subnetGroupStatus: Swift.String?
        /// <p> Contains a list of <a>Subnet</a> elements.</p>
        public let subnets: [NeptuneClientTypes.Subnet]?
        /// <p>Provides the VpcId of the DB subnet group.</p>
        public let vpcId: Swift.String?

        public init (
            dBSubnetGroupArn: Swift.String? = nil,
            dBSubnetGroupDescription: Swift.String? = nil,
            dBSubnetGroupName: Swift.String? = nil,
            subnetGroupStatus: Swift.String? = nil,
            subnets: [NeptuneClientTypes.Subnet]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.dBSubnetGroupArn = dBSubnetGroupArn
            self.dBSubnetGroupDescription = dBSubnetGroupDescription
            self.dBSubnetGroupName = dBSubnetGroupName
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension DBSubnetGroupAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSubnetGroupAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBSubnetGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBSubnetGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBSubnetGroupName</i> is already used by an existing DB subnet group.</p>
public struct DBSubnetGroupAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSubnetGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupDoesNotCoverEnoughAZs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSubnetGroupDoesNotCoverEnoughAZs(message: \(Swift.String(describing: message)))"}
}

extension DBSubnetGroupDoesNotCoverEnoughAZs: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBSubnetGroupDoesNotCoverEnoughAZsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Subnets in the DB subnet group should cover at least two Availability
///       Zones unless there is only one Availability Zone.</p>
public struct DBSubnetGroupDoesNotCoverEnoughAZs: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupDoesNotCoverEnoughAZsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSubnetGroupDoesNotCoverEnoughAZsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSubnetGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBSubnetGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBSubnetGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>DBSubnetGroupName</i> does not refer to an
///       existing DB subnet group.</p>
public struct DBSubnetGroupNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSubnetGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSubnetGroupQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBSubnetGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBSubnetGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would result in user exceeding the allowed number of DB subnet groups.</p>
public struct DBSubnetGroupQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSubnetGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSubnetQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBSubnetQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBSubnetQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would result in user exceeding the allowed number of subnets in a DB subnet groups.</p>
public struct DBSubnetQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSubnetQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBUpgradeDependencyFailureFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBUpgradeDependencyFailureFault(message: \(Swift.String(describing: message)))"}
}

extension DBUpgradeDependencyFailureFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DBUpgradeDependencyFailureFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB upgrade failed because a resource the DB depends on could not be modified.</p>
public struct DBUpgradeDependencyFailureFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBUpgradeDependencyFailureFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBUpgradeDependencyFailureFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteDBClusterEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterEndpointOutputError>
}

extension DeleteDBClusterEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterEndpointInput(dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)))"}
}

extension DeleteDBClusterEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointIdentifier"))
        }
        try container.encode("DeleteDBClusterEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBClusterEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterEndpointOutputError>
}

public struct DeleteDBClusterEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterEndpointOutputError>
}

public struct DeleteDBClusterEndpointInput: Swift.Equatable {
    /// <p>The identifier associated with the custom endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: Swift.String?

    public init (
        dBClusterEndpointIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
    }
}

extension DeleteDBClusterEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterEndpointNotFoundFault" : self = .dBClusterEndpointNotFoundFault(try DBClusterEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterEndpointStateFault" : self = .invalidDBClusterEndpointStateFault(try InvalidDBClusterEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterEndpointOutputError: Swift.Error, Swift.Equatable {
    case dBClusterEndpointNotFoundFault(DBClusterEndpointNotFoundFault)
    case invalidDBClusterEndpointStateFault(InvalidDBClusterEndpointStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterEndpointOutputResponse(customEndpointType: \(Swift.String(describing: customEndpointType)), dBClusterEndpointArn: \(Swift.String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(Swift.String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), endpoint: \(Swift.String(describing: endpoint)), endpointType: \(Swift.String(describing: endpointType)), excludedMembers: \(Swift.String(describing: excludedMembers)), staticMembers: \(Swift.String(describing: staticMembers)), status: \(Swift.String(describing: status)))"}
}

extension DeleteDBClusterEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBClusterEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customEndpointType = output.customEndpointType
            self.dBClusterEndpointArn = output.dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = output.dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = output.dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.endpoint = output.endpoint
            self.endpointType = output.endpointType
            self.excludedMembers = output.excludedMembers
            self.staticMembers = output.staticMembers
            self.status = output.status
        } else {
            self.customEndpointType = nil
            self.dBClusterEndpointArn = nil
            self.dBClusterEndpointIdentifier = nil
            self.dBClusterEndpointResourceIdentifier = nil
            self.dBClusterIdentifier = nil
            self.endpoint = nil
            self.endpointType = nil
            self.excludedMembers = nil
            self.staticMembers = nil
            self.status = nil
        }
    }
}

/// <p>This data type represents the information you need to connect to an Amazon Neptune DB cluster.
///       This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>CreateDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBClusterEndpoints</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>ModifyDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DeleteDBClusterEndpoint</code>
///                </p>
///             </li>
///          </ul>
///          <p>For the data structure that represents Amazon RDS DB instance endpoints,
///       see <code>Endpoint</code>.</p>
public struct DeleteDBClusterEndpointOutputResponse: Swift.Equatable {
    /// <p>The type associated with a custom endpoint. One of: <code>READER</code>,
    ///       <code>WRITER</code>, <code>ANY</code>.</p>
    public let customEndpointType: Swift.String?
    /// <p>The Amazon Resource Name (ARN) for the endpoint.</p>
    public let dBClusterEndpointArn: Swift.String?
    /// <p>The identifier associated with the endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: Swift.String?
    /// <p>A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.</p>
    public let dBClusterEndpointResourceIdentifier: Swift.String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///       stored as a lowercase string.</p>
    public let dBClusterIdentifier: Swift.String?
    /// <p>The DNS address of the endpoint.</p>
    public let endpoint: Swift.String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>CUSTOM</code>.</p>
    public let endpointType: Swift.String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///       All other eligible instances are reachable through the custom endpoint.
    ///       Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [Swift.String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [Swift.String]?
    /// <p>The current status of the endpoint. One of: <code>creating</code>, <code>available</code>, <code>deleting</code>, <code>inactive</code>, <code>modifying</code>. The <code>inactive</code> state applies to an endpoint that cannot be used for a certain kind of cluster,
    ///       such as a <code>writer</code> endpoint for a read-only secondary cluster in a global database.</p>
    public let status: Swift.String?

    public init (
        customEndpointType: Swift.String? = nil,
        dBClusterEndpointArn: Swift.String? = nil,
        dBClusterEndpointIdentifier: Swift.String? = nil,
        dBClusterEndpointResourceIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        endpoint: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        excludedMembers: [Swift.String]? = nil,
        staticMembers: [Swift.String]? = nil,
        status: Swift.String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

struct DeleteDBClusterEndpointOutputResponseBody: Swift.Equatable {
    public let dBClusterEndpointIdentifier: Swift.String?
    public let dBClusterIdentifier: Swift.String?
    public let dBClusterEndpointResourceIdentifier: Swift.String?
    public let endpoint: Swift.String?
    public let status: Swift.String?
    public let endpointType: Swift.String?
    public let customEndpointType: Swift.String?
    public let staticMembers: [Swift.String]?
    public let excludedMembers: [Swift.String]?
    public let dBClusterEndpointArn: Swift.String?
}

extension DeleteDBClusterEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBClusterEndpointResult"))
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var staticMembersBuffer:[Swift.String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [Swift.String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedMembersBuffer:[Swift.String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [Swift.String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

public struct DeleteDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterOutputError>
}

extension DeleteDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), finalDBSnapshotIdentifier: \(Swift.String(describing: finalDBSnapshotIdentifier)), skipFinalSnapshot: \(Swift.String(describing: skipFinalSnapshot)))"}
}

extension DeleteDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let finalDBSnapshotIdentifier = finalDBSnapshotIdentifier {
            try container.encode(finalDBSnapshotIdentifier, forKey: ClientRuntime.Key("FinalDBSnapshotIdentifier"))
        }
        if skipFinalSnapshot != false {
            try container.encode(skipFinalSnapshot, forKey: ClientRuntime.Key("SkipFinalSnapshot"))
        }
        try container.encode("DeleteDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterOutputError>
}

public struct DeleteDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterOutputError>
}

public struct DeleteDBClusterInput: Swift.Equatable {
    /// <p>The DB cluster identifier for the DB cluster to be deleted. This parameter isn't
    ///       case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match an existing DBClusterIdentifier.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: Swift.String?
    /// <p> The DB cluster snapshot identifier of the new DB cluster snapshot created when
    ///       <code>SkipFinalSnapshot</code> is set to <code>false</code>.</p>
    ///          <note>
    ///             <p> Specifying this parameter and also setting the <code>SkipFinalShapshot</code> parameter
    ///         to true results in an error.</p>
    ///          </note>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    public let finalDBSnapshotIdentifier: Swift.String?
    /// <p> Determines whether a final DB cluster snapshot is created before the DB cluster is
    ///       deleted. If <code>true</code> is specified, no DB cluster snapshot is created. If
    ///       <code>false</code> is specified, a DB cluster snapshot is created before the DB cluster is
    ///       deleted.</p>
    ///          <note>
    ///             <p>You must specify a <code>FinalDBSnapshotIdentifier</code> parameter if
    ///         <code>SkipFinalSnapshot</code> is <code>false</code>.</p>
    ///          </note>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let skipFinalSnapshot: Swift.Bool

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        finalDBSnapshotIdentifier: Swift.String? = nil,
        skipFinalSnapshot: Swift.Bool = false
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.finalDBSnapshotIdentifier = finalDBSnapshotIdentifier
        self.skipFinalSnapshot = skipFinalSnapshot
    }
}

extension DeleteDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotAlreadyExistsFault" : self = .dBClusterSnapshotAlreadyExistsFault(try DBClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceededFault" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterSnapshotAlreadyExistsFault(DBClusterSnapshotAlreadyExistsFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension DeleteDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct DeleteDBClusterOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: NeptuneClientTypes.DBCluster?

    public init (
        dBCluster: NeptuneClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct DeleteDBClusterOutputResponseBody: Swift.Equatable {
    public let dBCluster: NeptuneClientTypes.DBCluster?
}

extension DeleteDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct DeleteDBClusterParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterParameterGroupOutputError>
}

extension DeleteDBClusterParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterParameterGroupInput(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)))"}
}

extension DeleteDBClusterParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        try container.encode("DeleteDBClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBClusterParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterParameterGroupOutputError>
}

public struct DeleteDBClusterParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterParameterGroupOutputError>
}

public struct DeleteDBClusterParameterGroupInput: Swift.Equatable {
    /// <p>The name of the DB cluster parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be the name of an existing DB cluster parameter group.</p>
    ///             </li>
    ///             <li>
    ///                <p>You can't delete a default DB cluster parameter group.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot be associated with any DB clusters.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: Swift.String?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
    }
}

extension DeleteDBClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterParameterGroupOutputResponse()"}
}

extension DeleteDBClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBClusterParameterGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDBClusterParameterGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteDBClusterParameterGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteDBClusterSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterSnapshotOutputError>
}

extension DeleteDBClusterSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterSnapshotInput(dBClusterSnapshotIdentifier: \(Swift.String(describing: dBClusterSnapshotIdentifier)))"}
}

extension DeleteDBClusterSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        try container.encode("DeleteDBClusterSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBClusterSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterSnapshotOutputError>
}

public struct DeleteDBClusterSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterSnapshotOutputError>
}

public struct DeleteDBClusterSnapshotInput: Swift.Equatable {
    /// <p>The identifier of the DB cluster snapshot to delete.</p>
    ///          <p>Constraints: Must be the name of an existing DB cluster snapshot in the
    ///       <code>available</code> state.</p>
    public let dBClusterSnapshotIdentifier: Swift.String?

    public init (
        dBClusterSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
    }
}

extension DeleteDBClusterSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterSnapshotOutputResponse(dBClusterSnapshot: \(Swift.String(describing: dBClusterSnapshot)))"}
}

extension DeleteDBClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshot = output.dBClusterSnapshot
        } else {
            self.dBClusterSnapshot = nil
        }
    }
}

public struct DeleteDBClusterSnapshotOutputResponse: Swift.Equatable {
    /// <p>Contains the details for an Amazon Neptune DB cluster snapshot</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusterSnapshots</a> action.</p>
    public let dBClusterSnapshot: NeptuneClientTypes.DBClusterSnapshot?

    public init (
        dBClusterSnapshot: NeptuneClientTypes.DBClusterSnapshot? = nil
    )
    {
        self.dBClusterSnapshot = dBClusterSnapshot
    }
}

struct DeleteDBClusterSnapshotOutputResponseBody: Swift.Equatable {
    public let dBClusterSnapshot: NeptuneClientTypes.DBClusterSnapshot?
}

extension DeleteDBClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshot = "DBClusterSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBClusterSnapshotResult"))
        let dBClusterSnapshotDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBClusterSnapshot.self, forKey: .dBClusterSnapshot)
        dBClusterSnapshot = dBClusterSnapshotDecoded
    }
}

public struct DeleteDBInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBInstanceOutputError>
}

extension DeleteDBInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBInstanceInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), finalDBSnapshotIdentifier: \(Swift.String(describing: finalDBSnapshotIdentifier)), skipFinalSnapshot: \(Swift.String(describing: skipFinalSnapshot)))"}
}

extension DeleteDBInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let finalDBSnapshotIdentifier = finalDBSnapshotIdentifier {
            try container.encode(finalDBSnapshotIdentifier, forKey: ClientRuntime.Key("FinalDBSnapshotIdentifier"))
        }
        if skipFinalSnapshot != false {
            try container.encode(skipFinalSnapshot, forKey: ClientRuntime.Key("SkipFinalSnapshot"))
        }
        try container.encode("DeleteDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBInstanceOutputError>
}

public struct DeleteDBInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBInstanceOutputError>
}

public struct DeleteDBInstanceInput: Swift.Equatable {
    /// <p>The DB instance identifier for the DB instance to be deleted. This parameter isn't
    ///       case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the name of an existing DB instance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: Swift.String?
    /// <p> The DBSnapshotIdentifier of the new DBSnapshot created when SkipFinalSnapshot is set to
    ///       <code>false</code>.</p>
    ///          <note>
    ///             <p>Specifying this parameter and also setting the SkipFinalShapshot parameter to true
    ///         results in an error.</p>
    ///          </note>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot be specified when deleting a Read Replica.</p>
    ///             </li>
    ///          </ul>
    public let finalDBSnapshotIdentifier: Swift.String?
    /// <p> Determines whether a final DB snapshot is created before the DB instance is deleted. If
    ///       <code>true</code> is specified, no DBSnapshot is created. If <code>false</code> is specified,
    ///       a DB snapshot is created before the DB instance is deleted.</p>
    ///          <p>Note that when a DB instance is in a failure state and has a status of 'failed',
    ///       'incompatible-restore', or 'incompatible-network', it can only be deleted when the
    ///       SkipFinalSnapshot parameter is set to "true".</p>
    ///          <p>Specify <code>true</code> when deleting a Read Replica.</p>
    ///          <note>
    ///             <p>The FinalDBSnapshotIdentifier parameter must be specified if SkipFinalSnapshot is
    ///         <code>false</code>.</p>
    ///          </note>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let skipFinalSnapshot: Swift.Bool

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        finalDBSnapshotIdentifier: Swift.String? = nil,
        skipFinalSnapshot: Swift.Bool = false
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.finalDBSnapshotIdentifier = finalDBSnapshotIdentifier
        self.skipFinalSnapshot = skipFinalSnapshot
    }
}

extension DeleteDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotAlreadyExistsFault" : self = .dBSnapshotAlreadyExistsFault(try DBSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceededFault" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotAlreadyExistsFault(DBSnapshotAlreadyExistsFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBInstanceOutputResponse(dBInstance: \(Swift.String(describing: dBInstance)))"}
}

extension DeleteDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct DeleteDBInstanceOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB instance.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBInstances</a> action.</p>
    public let dBInstance: NeptuneClientTypes.DBInstance?

    public init (
        dBInstance: NeptuneClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct DeleteDBInstanceOutputResponseBody: Swift.Equatable {
    public let dBInstance: NeptuneClientTypes.DBInstance?
}

extension DeleteDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct DeleteDBParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBParameterGroupOutputError>
}

extension DeleteDBParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBParameterGroupInput(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)))"}
}

extension DeleteDBParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        try container.encode("DeleteDBParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBParameterGroupOutputError>
}

public struct DeleteDBParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBParameterGroupOutputError>
}

public struct DeleteDBParameterGroupInput: Swift.Equatable {
    /// <p>The name of the DB parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be the name of an existing DB parameter group</p>
    ///             </li>
    ///             <li>
    ///                <p>You can't delete a default DB parameter group</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot be associated with any DB instances</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: Swift.String?

    public init (
        dBParameterGroupName: Swift.String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
    }
}

extension DeleteDBParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBParameterGroupOutputResponse()"}
}

extension DeleteDBParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBParameterGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDBParameterGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteDBParameterGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteDBSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBSubnetGroupOutputError>
}

extension DeleteDBSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBSubnetGroupInput(dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)))"}
}

extension DeleteDBSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        try container.encode("DeleteDBSubnetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBSubnetGroupOutputError>
}

public struct DeleteDBSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBSubnetGroupOutputError>
}

public struct DeleteDBSubnetGroupInput: Swift.Equatable {
    /// <p>The name of the database subnet group to delete.</p>
    ///          <note>
    ///             <p>You can't delete the default subnet group.</p>
    ///          </note>
    ///          <p>Constraints:</p>
    ///          <p>Constraints: Must match the name of an existing DBSubnetGroup. Must not be default.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: Swift.String?

    public init (
        dBSubnetGroupName: Swift.String? = nil
    )
    {
        self.dBSubnetGroupName = dBSubnetGroupName
    }
}

extension DeleteDBSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetStateFault" : self = .invalidDBSubnetStateFault(try InvalidDBSubnetStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidDBSubnetStateFault(InvalidDBSubnetStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBSubnetGroupOutputResponse()"}
}

extension DeleteDBSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBSubnetGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDBSubnetGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteDBSubnetGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteEventSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSubscriptionOutputError>
}

extension DeleteEventSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventSubscriptionInput(subscriptionName: \(Swift.String(describing: subscriptionName)))"}
}

extension DeleteEventSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("DeleteEventSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteEventSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSubscriptionOutputError>
}

public struct DeleteEventSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSubscriptionOutputError>
}

public struct DeleteEventSubscriptionInput: Swift.Equatable {
    /// <p>The name of the event notification subscription you want to delete.</p>
    public let subscriptionName: Swift.String?

    public init (
        subscriptionName: Swift.String? = nil
    )
    {
        self.subscriptionName = subscriptionName
    }
}

extension DeleteEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidEventSubscriptionStateFault" : self = .invalidEventSubscriptionStateFault(try InvalidEventSubscriptionStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case invalidEventSubscriptionStateFault(InvalidEventSubscriptionStateFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventSubscriptionOutputResponse(eventSubscription: \(Swift.String(describing: eventSubscription)))"}
}

extension DeleteEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct DeleteEventSubscriptionOutputResponse: Swift.Equatable {
    /// <p>Contains the results of a successful invocation of the <a>DescribeEventSubscriptions</a> action.</p>
    public let eventSubscription: NeptuneClientTypes.EventSubscription?

    public init (
        eventSubscription: NeptuneClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct DeleteEventSubscriptionOutputResponseBody: Swift.Equatable {
    public let eventSubscription: NeptuneClientTypes.EventSubscription?
}

extension DeleteEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct DescribeDBClusterEndpointsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterEndpointsOutputError>
}

extension DescribeDBClusterEndpointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterEndpointsInput(dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBClusterEndpointsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusterEndpoints", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBClusterEndpointsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterEndpointsOutputError>
}

public struct DescribeDBClusterEndpointsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterEndpointsOutputError>
}

public struct DescribeDBClusterEndpointsInput: Swift.Equatable {
    /// <p>The identifier of the endpoint to describe. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: Swift.String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///       stored as a lowercase string.</p>
    public let dBClusterIdentifier: Swift.String?
    /// <p>A set of name-value pairs that define which endpoints to include in the output.
    ///       The filters are specified as name-value pairs, in the format
    ///       <code>Name=<i>endpoint_type</i>,Values=<i>endpoint_type1</i>,<i>endpoint_type2</i>,...</code>.
    ///       <code>Name</code> can be one of: <code>db-cluster-endpoint-type</code>, <code>db-cluster-endpoint-custom-type</code>, <code>db-cluster-endpoint-id</code>, <code>db-cluster-endpoint-status</code>.
    ///       <code>Values</code> for the <code> db-cluster-endpoint-type</code> filter can be one or more of: <code>reader</code>, <code>writer</code>, <code>custom</code>.
    ///       <code>Values</code> for the <code>db-cluster-endpoint-custom-type</code> filter can be one or more of: <code>reader</code>, <code>any</code>.
    ///       <code>Values</code> for the <code>db-cluster-endpoint-status</code> filter can be one or more of: <code>available</code>, <code>creating</code>, <code>deleting</code>, <code>inactive</code>, <code>modifying</code>.
    ///     </p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribeDBClusterEndpoints</code> request.
    ///       If this parameter is specified, the response includes
    ///       only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code>.
    ///     </p>
    public let marker: Swift.String?
    /// <p>The maximum number of records to include in the response.
    ///       If more records exist than the specified <code>MaxRecords</code> value,
    ///       a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///     </p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        dBClusterEndpointIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        filters: [NeptuneClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBClusterEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterEndpointsOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterEndpointsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterEndpointsOutputResponse(dBClusterEndpoints: \(Swift.String(describing: dBClusterEndpoints)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBClusterEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterEndpoints = output.dBClusterEndpoints
            self.marker = output.marker
        } else {
            self.dBClusterEndpoints = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBClusterEndpointsOutputResponse: Swift.Equatable {
    /// <p>Contains the details of the endpoints associated with the cluster
    ///       and matching any filter conditions.</p>
    public let dBClusterEndpoints: [NeptuneClientTypes.DBClusterEndpoint]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribeDBClusterEndpoints</code> request.
    ///       If this parameter is specified, the response includes
    ///       only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code>.
    ///     </p>
    public let marker: Swift.String?

    public init (
        dBClusterEndpoints: [NeptuneClientTypes.DBClusterEndpoint]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBClusterEndpoints = dBClusterEndpoints
        self.marker = marker
    }
}

struct DescribeDBClusterEndpointsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBClusterEndpoints: [NeptuneClientTypes.DBClusterEndpoint]?
}

extension DescribeDBClusterEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterEndpoints = "DBClusterEndpoints"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterEndpointsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterEndpoints) {
            struct KeyVal0{struct DBClusterEndpointList{}}
            let dBClusterEndpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterEndpointList>.CodingKeys.self, forKey: .dBClusterEndpoints)
            if let dBClusterEndpointsWrappedContainer = dBClusterEndpointsWrappedContainer {
                let dBClusterEndpointsContainer = try dBClusterEndpointsWrappedContainer.decodeIfPresent([NeptuneClientTypes.DBClusterEndpoint].self, forKey: .member)
                var dBClusterEndpointsBuffer:[NeptuneClientTypes.DBClusterEndpoint]? = nil
                if let dBClusterEndpointsContainer = dBClusterEndpointsContainer {
                    dBClusterEndpointsBuffer = [NeptuneClientTypes.DBClusterEndpoint]()
                    for structureContainer0 in dBClusterEndpointsContainer {
                        dBClusterEndpointsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterEndpoints = dBClusterEndpointsBuffer
            } else {
                dBClusterEndpoints = []
            }
        } else {
            dBClusterEndpoints = nil
        }
    }
}

public struct DescribeDBClusterParameterGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterParameterGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterParameterGroupsOutputError>
}

extension DescribeDBClusterParameterGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterParameterGroupsInput(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBClusterParameterGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusterParameterGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBClusterParameterGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterParameterGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterParameterGroupsOutputError>
}

public struct DescribeDBClusterParameterGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterParameterGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterParameterGroupsOutputError>
}

public struct DescribeDBClusterParameterGroupsInput: Swift.Equatable {
    /// <p>The name of a specific DB cluster parameter group to return details for.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: Swift.String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribeDBClusterParameterGroups</code> request. If this parameter is specified, the
    ///       response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil,
        filters: [NeptuneClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBClusterParameterGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterParameterGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterParameterGroupsOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterParameterGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterParameterGroupsOutputResponse(dBClusterParameterGroups: \(Swift.String(describing: dBClusterParameterGroups)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBClusterParameterGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterParameterGroups = output.dBClusterParameterGroups
            self.marker = output.marker
        } else {
            self.dBClusterParameterGroups = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBClusterParameterGroupsOutputResponse: Swift.Equatable {
    /// <p>A list of DB cluster parameter groups.</p>
    public let dBClusterParameterGroups: [NeptuneClientTypes.DBClusterParameterGroup]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribeDBClusterParameterGroups</code> request. If this parameter is specified, the
    ///       response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: Swift.String?

    public init (
        dBClusterParameterGroups: [NeptuneClientTypes.DBClusterParameterGroup]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBClusterParameterGroups = dBClusterParameterGroups
        self.marker = marker
    }
}

struct DescribeDBClusterParameterGroupsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBClusterParameterGroups: [NeptuneClientTypes.DBClusterParameterGroup]?
}

extension DescribeDBClusterParameterGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroups = "DBClusterParameterGroups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterParameterGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterParameterGroups) {
            struct KeyVal0{struct DBClusterParameterGroup{}}
            let dBClusterParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterParameterGroup>.CodingKeys.self, forKey: .dBClusterParameterGroups)
            if let dBClusterParameterGroupsWrappedContainer = dBClusterParameterGroupsWrappedContainer {
                let dBClusterParameterGroupsContainer = try dBClusterParameterGroupsWrappedContainer.decodeIfPresent([NeptuneClientTypes.DBClusterParameterGroup].self, forKey: .member)
                var dBClusterParameterGroupsBuffer:[NeptuneClientTypes.DBClusterParameterGroup]? = nil
                if let dBClusterParameterGroupsContainer = dBClusterParameterGroupsContainer {
                    dBClusterParameterGroupsBuffer = [NeptuneClientTypes.DBClusterParameterGroup]()
                    for structureContainer0 in dBClusterParameterGroupsContainer {
                        dBClusterParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterParameterGroups = dBClusterParameterGroupsBuffer
            } else {
                dBClusterParameterGroups = []
            }
        } else {
            dBClusterParameterGroups = nil
        }
    }
}

public struct DescribeDBClusterParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterParametersOutputError>
}

extension DescribeDBClusterParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterParametersInput(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), source: \(Swift.String(describing: source)))"}
}

extension DescribeDBClusterParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let source = source {
            try container.encode(source, forKey: ClientRuntime.Key("Source"))
        }
        try container.encode("DescribeDBClusterParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBClusterParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterParametersOutputError>
}

public struct DescribeDBClusterParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterParametersOutputError>
}

public struct DescribeDBClusterParametersInput: Swift.Equatable {
    /// <p>The name of a specific DB cluster parameter group to return parameter details for.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: Swift.String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribeDBClusterParameters</code> request. If this parameter is specified, the response
    ///       includes only records beyond the marker, up to the value specified by <code>MaxRecords</code>.
    ///    </p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p> A value that indicates to return only parameters for a specific source. Parameter sources
    ///       can be <code>engine</code>, <code>service</code>, or <code>customer</code>.</p>
    public let source: Swift.String?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil,
        filters: [NeptuneClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        source: Swift.String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.source = source
    }
}

extension DescribeDBClusterParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterParametersOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterParametersOutputResponse(marker: \(Swift.String(describing: marker)), parameters: \(Swift.String(describing: parameters)))"}
}

extension DescribeDBClusterParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.parameters = output.parameters
        } else {
            self.marker = nil
            self.parameters = nil
        }
    }
}

public struct DescribeDBClusterParametersOutputResponse: Swift.Equatable {
    /// <p> An optional pagination token provided by a previous DescribeDBClusterParameters request.
    ///       If this parameter is specified, the response includes only records beyond the marker, up to
    ///       the value specified by <code>MaxRecords</code> .</p>
    public let marker: Swift.String?
    /// <p>Provides a list of parameters for the DB cluster parameter group.</p>
    public let parameters: [NeptuneClientTypes.Parameter]?

    public init (
        marker: Swift.String? = nil,
        parameters: [NeptuneClientTypes.Parameter]? = nil
    )
    {
        self.marker = marker
        self.parameters = parameters
    }
}

struct DescribeDBClusterParametersOutputResponseBody: Swift.Equatable {
    public let parameters: [NeptuneClientTypes.Parameter]?
    public let marker: Swift.String?
}

extension DescribeDBClusterParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterParametersResult"))
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([NeptuneClientTypes.Parameter].self, forKey: .member)
                var parametersBuffer:[NeptuneClientTypes.Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [NeptuneClientTypes.Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBClusterSnapshotAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterSnapshotAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterSnapshotAttributesOutputError>
}

extension DescribeDBClusterSnapshotAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterSnapshotAttributesInput(dBClusterSnapshotIdentifier: \(Swift.String(describing: dBClusterSnapshotIdentifier)))"}
}

extension DescribeDBClusterSnapshotAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        try container.encode("DescribeDBClusterSnapshotAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBClusterSnapshotAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterSnapshotAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterSnapshotAttributesOutputError>
}

public struct DescribeDBClusterSnapshotAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterSnapshotAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterSnapshotAttributesOutputError>
}

public struct DescribeDBClusterSnapshotAttributesInput: Swift.Equatable {
    /// <p>The identifier for the DB cluster snapshot to describe the attributes for.</p>
    public let dBClusterSnapshotIdentifier: Swift.String?

    public init (
        dBClusterSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
    }
}

extension DescribeDBClusterSnapshotAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterSnapshotAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterSnapshotAttributesOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterSnapshotAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterSnapshotAttributesOutputResponse(dBClusterSnapshotAttributesResult: \(Swift.String(describing: dBClusterSnapshotAttributesResult)))"}
}

extension DescribeDBClusterSnapshotAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterSnapshotAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshotAttributesResult = output.dBClusterSnapshotAttributesResult
        } else {
            self.dBClusterSnapshotAttributesResult = nil
        }
    }
}

public struct DescribeDBClusterSnapshotAttributesOutputResponse: Swift.Equatable {
    /// <p>Contains the results of a successful call to the <a>DescribeDBClusterSnapshotAttributes</a> API action.</p>
    ///          <p>Manual DB cluster snapshot attributes are used to authorize other Amazon accounts to copy or
    ///       restore a manual DB cluster snapshot. For more information, see the <a>ModifyDBClusterSnapshotAttribute</a> API action.</p>
    public let dBClusterSnapshotAttributesResult: NeptuneClientTypes.DBClusterSnapshotAttributesResult?

    public init (
        dBClusterSnapshotAttributesResult: NeptuneClientTypes.DBClusterSnapshotAttributesResult? = nil
    )
    {
        self.dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResult
    }
}

struct DescribeDBClusterSnapshotAttributesOutputResponseBody: Swift.Equatable {
    public let dBClusterSnapshotAttributesResult: NeptuneClientTypes.DBClusterSnapshotAttributesResult?
}

extension DescribeDBClusterSnapshotAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshotAttributesResult = "DBClusterSnapshotAttributesResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterSnapshotAttributesResult"))
        let dBClusterSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBClusterSnapshotAttributesResult.self, forKey: .dBClusterSnapshotAttributesResult)
        dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResultDecoded
    }
}

public struct DescribeDBClusterSnapshotsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterSnapshotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterSnapshotsOutputError>
}

extension DescribeDBClusterSnapshotsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterSnapshotsInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterSnapshotIdentifier: \(Swift.String(describing: dBClusterSnapshotIdentifier)), filters: \(Swift.String(describing: filters)), includePublic: \(Swift.String(describing: includePublic)), includeShared: \(Swift.String(describing: includeShared)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), snapshotType: \(Swift.String(describing: snapshotType)))"}
}

extension DescribeDBClusterSnapshotsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if includePublic != false {
            try container.encode(includePublic, forKey: ClientRuntime.Key("IncludePublic"))
        }
        if includeShared != false {
            try container.encode(includeShared, forKey: ClientRuntime.Key("IncludeShared"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: ClientRuntime.Key("SnapshotType"))
        }
        try container.encode("DescribeDBClusterSnapshots", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBClusterSnapshotsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterSnapshotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterSnapshotsOutputError>
}

public struct DescribeDBClusterSnapshotsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterSnapshotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterSnapshotsOutputError>
}

public struct DescribeDBClusterSnapshotsInput: Swift.Equatable {
    /// <p>The ID of the DB cluster to retrieve the list of DB cluster snapshots for. This parameter
    ///       can't be used in conjunction with the <code>DBClusterSnapshotIdentifier</code> parameter. This
    ///       parameter is not case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the identifier of an existing DBCluster.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: Swift.String?
    /// <p>A specific DB cluster snapshot identifier to describe. This parameter can't be used in
    ///       conjunction with the <code>DBClusterIdentifier</code> parameter. This value is stored as a
    ///       lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the identifier of an existing DBClusterSnapshot.</p>
    ///             </li>
    ///             <li>
    ///                <p>If this identifier is for an automated snapshot, the <code>SnapshotType</code>
    ///           parameter must also be specified.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterSnapshotIdentifier: Swift.String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p>True to include manual DB cluster snapshots that are public and can be copied or restored
    ///       by any Amazon account, and otherwise false. The default is <code>false</code>. The default is
    ///       false.</p>
    ///          <p>You can share a manual DB cluster snapshot as public by using the <a>ModifyDBClusterSnapshotAttribute</a> API action.</p>
    public let includePublic: Swift.Bool
    /// <p>True to include shared manual DB cluster snapshots from other Amazon accounts that this AWS
    ///       account has been given permission to copy or restore, and otherwise false. The default is
    ///       <code>false</code>.</p>
    ///          <p>You can give an Amazon account permission to restore a manual DB cluster snapshot from
    ///       another Amazon account by the <a>ModifyDBClusterSnapshotAttribute</a> API
    ///       action.</p>
    public let includeShared: Swift.Bool
    /// <p>An optional pagination token provided by a previous
    ///       <code>DescribeDBClusterSnapshots</code> request. If this parameter is specified, the response
    ///       includes only records beyond the marker, up to the value specified by <code>MaxRecords</code>.
    ///    </p>
    public let marker: Swift.String?
    /// <p>The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The type of DB cluster snapshots to be returned. You can specify one of the following
    ///       values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>automated</code> - Return all DB cluster snapshots that have been automatically
    ///           taken by Amazon Neptune for my Amazon account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>manual</code> - Return all DB cluster snapshots that have been taken by my AWS
    ///           account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>shared</code> - Return all manual DB cluster snapshots that have been shared to
    ///           my Amazon account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>public</code> - Return all DB cluster snapshots that have been marked as
    ///           public.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you don't specify a <code>SnapshotType</code> value, then both automated and manual DB
    ///       cluster snapshots are returned. You can include shared DB cluster snapshots with these results
    ///       by setting the <code>IncludeShared</code> parameter to <code>true</code>. You can include
    ///       public DB cluster snapshots with these results by setting the <code>IncludePublic</code>
    ///       parameter to <code>true</code>.</p>
    ///          <p>The <code>IncludeShared</code> and <code>IncludePublic</code> parameters don't apply for
    ///       <code>SnapshotType</code> values of <code>manual</code> or <code>automated</code>. The
    ///       <code>IncludePublic</code> parameter doesn't apply when <code>SnapshotType</code> is set to
    ///       <code>shared</code>. The <code>IncludeShared</code> parameter doesn't apply when
    ///       <code>SnapshotType</code> is set to <code>public</code>.</p>
    public let snapshotType: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterSnapshotIdentifier: Swift.String? = nil,
        filters: [NeptuneClientTypes.Filter]? = nil,
        includePublic: Swift.Bool = false,
        includeShared: Swift.Bool = false,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        snapshotType: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.filters = filters
        self.includePublic = includePublic
        self.includeShared = includeShared
        self.marker = marker
        self.maxRecords = maxRecords
        self.snapshotType = snapshotType
    }
}

extension DescribeDBClusterSnapshotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterSnapshotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterSnapshotsOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterSnapshotsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterSnapshotsOutputResponse(dBClusterSnapshots: \(Swift.String(describing: dBClusterSnapshots)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBClusterSnapshotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshots = output.dBClusterSnapshots
            self.marker = output.marker
        } else {
            self.dBClusterSnapshots = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBClusterSnapshotsOutputResponse: Swift.Equatable {
    /// <p>Provides a list of DB cluster snapshots for the user.</p>
    public let dBClusterSnapshots: [NeptuneClientTypes.DBClusterSnapshot]?
    /// <p> An optional pagination token provided by a previous <a>DescribeDBClusterSnapshots</a> request. If this parameter is specified, the response
    ///       includes only records beyond the marker, up to the value specified by <code>MaxRecords</code>.
    ///    </p>
    public let marker: Swift.String?

    public init (
        dBClusterSnapshots: [NeptuneClientTypes.DBClusterSnapshot]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBClusterSnapshots = dBClusterSnapshots
        self.marker = marker
    }
}

struct DescribeDBClusterSnapshotsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBClusterSnapshots: [NeptuneClientTypes.DBClusterSnapshot]?
}

extension DescribeDBClusterSnapshotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshots = "DBClusterSnapshots"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterSnapshotsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterSnapshots) {
            struct KeyVal0{struct DBClusterSnapshot{}}
            let dBClusterSnapshotsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterSnapshot>.CodingKeys.self, forKey: .dBClusterSnapshots)
            if let dBClusterSnapshotsWrappedContainer = dBClusterSnapshotsWrappedContainer {
                let dBClusterSnapshotsContainer = try dBClusterSnapshotsWrappedContainer.decodeIfPresent([NeptuneClientTypes.DBClusterSnapshot].self, forKey: .member)
                var dBClusterSnapshotsBuffer:[NeptuneClientTypes.DBClusterSnapshot]? = nil
                if let dBClusterSnapshotsContainer = dBClusterSnapshotsContainer {
                    dBClusterSnapshotsBuffer = [NeptuneClientTypes.DBClusterSnapshot]()
                    for structureContainer0 in dBClusterSnapshotsContainer {
                        dBClusterSnapshotsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterSnapshots = dBClusterSnapshotsBuffer
            } else {
                dBClusterSnapshots = []
            }
        } else {
            dBClusterSnapshots = nil
        }
    }
}

public struct DescribeDBClustersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClustersOutputError>
}

extension DescribeDBClustersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClustersInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBClustersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBClustersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClustersOutputError>
}

public struct DescribeDBClustersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClustersOutputError>
}

public struct DescribeDBClustersInput: Swift.Equatable {
    /// <p>The user-supplied DB cluster identifier. If this parameter is specified, information from
    ///       only the specific DB cluster is returned. This parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match an existing DBClusterIdentifier.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: Swift.String?
    /// <p>A filter that specifies one or more DB clusters to describe.</p>
    ///          <p>Supported filters:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db-cluster-id</code> - Accepts DB cluster identifiers and DB cluster Amazon
    ///         Resource Names (ARNs). The results list will only include information about the DB
    ///         clusters identified by these ARNs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>engine</code> - Accepts an engine name (such as <code>neptune</code>),
    ///         and restricts the results list to DB clusters created by that engine.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>For example, to invoke this API from the Amazon CLI and filter so that only
    ///       Neptune DB clusters are returned, you could use the following command:</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p>An optional pagination token provided by a previous <a>DescribeDBClusters</a>
    ///       request. If this parameter is specified, the response includes only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        filters: [NeptuneClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBClustersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClustersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClustersOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClustersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClustersOutputResponse(dBClusters: \(Swift.String(describing: dBClusters)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusters = output.dBClusters
            self.marker = output.marker
        } else {
            self.dBClusters = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBClustersOutputResponse: Swift.Equatable {
    /// <p>Contains a list of DB clusters for the user.</p>
    public let dBClusters: [NeptuneClientTypes.DBCluster]?
    /// <p>A pagination token that can be used in a subsequent DescribeDBClusters request.</p>
    public let marker: Swift.String?

    public init (
        dBClusters: [NeptuneClientTypes.DBCluster]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBClusters = dBClusters
        self.marker = marker
    }
}

struct DescribeDBClustersOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBClusters: [NeptuneClientTypes.DBCluster]?
}

extension DescribeDBClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusters = "DBClusters"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClustersResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusters) {
            struct KeyVal0{struct DBCluster{}}
            let dBClustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBCluster>.CodingKeys.self, forKey: .dBClusters)
            if let dBClustersWrappedContainer = dBClustersWrappedContainer {
                let dBClustersContainer = try dBClustersWrappedContainer.decodeIfPresent([NeptuneClientTypes.DBCluster].self, forKey: .member)
                var dBClustersBuffer:[NeptuneClientTypes.DBCluster]? = nil
                if let dBClustersContainer = dBClustersContainer {
                    dBClustersBuffer = [NeptuneClientTypes.DBCluster]()
                    for structureContainer0 in dBClustersContainer {
                        dBClustersBuffer?.append(structureContainer0)
                    }
                }
                dBClusters = dBClustersBuffer
            } else {
                dBClusters = []
            }
        } else {
            dBClusters = nil
        }
    }
}

public struct DescribeDBEngineVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBEngineVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBEngineVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBEngineVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBEngineVersionsOutputError>
}

extension DescribeDBEngineVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBEngineVersionsInput(dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), defaultOnly: \(Swift.String(describing: defaultOnly)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), filters: \(Swift.String(describing: filters)), listSupportedCharacterSets: \(Swift.String(describing: listSupportedCharacterSets)), listSupportedTimezones: \(Swift.String(describing: listSupportedTimezones)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBEngineVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if defaultOnly != false {
            try container.encode(defaultOnly, forKey: ClientRuntime.Key("DefaultOnly"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let listSupportedCharacterSets = listSupportedCharacterSets {
            try container.encode(listSupportedCharacterSets, forKey: ClientRuntime.Key("ListSupportedCharacterSets"))
        }
        if let listSupportedTimezones = listSupportedTimezones {
            try container.encode(listSupportedTimezones, forKey: ClientRuntime.Key("ListSupportedTimezones"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBEngineVersions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBEngineVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBEngineVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBEngineVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBEngineVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBEngineVersionsOutputError>
}

public struct DescribeDBEngineVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBEngineVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBEngineVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBEngineVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBEngineVersionsOutputError>
}

public struct DescribeDBEngineVersionsInput: Swift.Equatable {
    /// <p>The name of a specific DB parameter group family to return details for.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match an existing DBParameterGroupFamily.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupFamily: Swift.String?
    /// <p>Indicates that only the default version of the specified engine or engine and major
    ///       version combination is returned.</p>
    public let defaultOnly: Swift.Bool
    /// <p>The database engine to return.</p>
    public let engine: Swift.String?
    /// <p>The database engine version to return.</p>
    ///          <p>Example: <code>5.1.49</code>
    ///          </p>
    public let engineVersion: Swift.String?
    /// <p>Not currently supported.</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p>If this parameter is specified and the requested engine supports the
    ///       <code>CharacterSetName</code> parameter for <code>CreateDBInstance</code>, the response
    ///       includes a list of supported character sets for each engine version.</p>
    public let listSupportedCharacterSets: Swift.Bool?
    /// <p>If this parameter is specified and the requested engine supports the <code>TimeZone</code>
    ///       parameter for <code>CreateDBInstance</code>, the response includes a list of supported time
    ///       zones for each engine version.</p>
    public let listSupportedTimezones: Swift.Bool?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///       specified, the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more than the
    ///       <code>MaxRecords</code> value is available, a pagination token called a marker is included in
    ///       the response so that the following results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        dBParameterGroupFamily: Swift.String? = nil,
        defaultOnly: Swift.Bool = false,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        filters: [NeptuneClientTypes.Filter]? = nil,
        listSupportedCharacterSets: Swift.Bool? = nil,
        listSupportedTimezones: Swift.Bool? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.defaultOnly = defaultOnly
        self.engine = engine
        self.engineVersion = engineVersion
        self.filters = filters
        self.listSupportedCharacterSets = listSupportedCharacterSets
        self.listSupportedTimezones = listSupportedTimezones
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBEngineVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBEngineVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBEngineVersionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBEngineVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBEngineVersionsOutputResponse(dBEngineVersions: \(Swift.String(describing: dBEngineVersions)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBEngineVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBEngineVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBEngineVersions = output.dBEngineVersions
            self.marker = output.marker
        } else {
            self.dBEngineVersions = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBEngineVersionsOutputResponse: Swift.Equatable {
    /// <p> A list of <code>DBEngineVersion</code> elements.</p>
    public let dBEngineVersions: [NeptuneClientTypes.DBEngineVersion]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///       specified, the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: Swift.String?

    public init (
        dBEngineVersions: [NeptuneClientTypes.DBEngineVersion]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBEngineVersions = dBEngineVersions
        self.marker = marker
    }
}

struct DescribeDBEngineVersionsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBEngineVersions: [NeptuneClientTypes.DBEngineVersion]?
}

extension DescribeDBEngineVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBEngineVersions = "DBEngineVersions"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBEngineVersionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBEngineVersions) {
            struct KeyVal0{struct DBEngineVersion{}}
            let dBEngineVersionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBEngineVersion>.CodingKeys.self, forKey: .dBEngineVersions)
            if let dBEngineVersionsWrappedContainer = dBEngineVersionsWrappedContainer {
                let dBEngineVersionsContainer = try dBEngineVersionsWrappedContainer.decodeIfPresent([NeptuneClientTypes.DBEngineVersion].self, forKey: .member)
                var dBEngineVersionsBuffer:[NeptuneClientTypes.DBEngineVersion]? = nil
                if let dBEngineVersionsContainer = dBEngineVersionsContainer {
                    dBEngineVersionsBuffer = [NeptuneClientTypes.DBEngineVersion]()
                    for structureContainer0 in dBEngineVersionsContainer {
                        dBEngineVersionsBuffer?.append(structureContainer0)
                    }
                }
                dBEngineVersions = dBEngineVersionsBuffer
            } else {
                dBEngineVersions = []
            }
        } else {
            dBEngineVersions = nil
        }
    }
}

public struct DescribeDBInstancesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBInstancesOutputError>
}

extension DescribeDBInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBInstancesInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBInstancesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBInstances", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBInstancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBInstancesOutputError>
}

public struct DescribeDBInstancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBInstancesOutputError>
}

public struct DescribeDBInstancesInput: Swift.Equatable {
    /// <p>The user-supplied instance identifier. If this parameter is specified, information from
    ///       only the specific DB instance is returned. This parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the identifier of an existing DBInstance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: Swift.String?
    /// <p>A filter that specifies one or more DB instances to describe.</p>
    ///          <p>Supported filters:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db-cluster-id</code> - Accepts DB cluster identifiers and DB cluster Amazon
    ///         Resource Names (ARNs). The results list will only include information about the DB
    ///         instances associated with the DB clusters identified by these ARNs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>engine</code> - Accepts an engine name (such as <code>neptune</code>),
    ///         and restricts the results list to DB instances created by that engine.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>For example, to invoke this API from the Amazon CLI and filter so that only
    ///       Neptune DB instances are returned, you could use the following command:</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous <code>DescribeDBInstances</code>
    ///       request. If this parameter is specified, the response includes only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        filters: [NeptuneClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBInstancesOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBInstancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBInstancesOutputResponse(dBInstances: \(Swift.String(describing: dBInstances)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstances = output.dBInstances
            self.marker = output.marker
        } else {
            self.dBInstances = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBInstancesOutputResponse: Swift.Equatable {
    /// <p> A list of <a>DBInstance</a> instances.</p>
    public let dBInstances: [NeptuneClientTypes.DBInstance]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///       specified, the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code> .</p>
    public let marker: Swift.String?

    public init (
        dBInstances: [NeptuneClientTypes.DBInstance]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBInstances = dBInstances
        self.marker = marker
    }
}

struct DescribeDBInstancesOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBInstances: [NeptuneClientTypes.DBInstance]?
}

extension DescribeDBInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstances = "DBInstances"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBInstancesResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBInstances) {
            struct KeyVal0{struct DBInstance{}}
            let dBInstancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstance>.CodingKeys.self, forKey: .dBInstances)
            if let dBInstancesWrappedContainer = dBInstancesWrappedContainer {
                let dBInstancesContainer = try dBInstancesWrappedContainer.decodeIfPresent([NeptuneClientTypes.DBInstance].self, forKey: .member)
                var dBInstancesBuffer:[NeptuneClientTypes.DBInstance]? = nil
                if let dBInstancesContainer = dBInstancesContainer {
                    dBInstancesBuffer = [NeptuneClientTypes.DBInstance]()
                    for structureContainer0 in dBInstancesContainer {
                        dBInstancesBuffer?.append(structureContainer0)
                    }
                }
                dBInstances = dBInstancesBuffer
            } else {
                dBInstances = []
            }
        } else {
            dBInstances = nil
        }
    }
}

public struct DescribeDBParameterGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBParameterGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBParameterGroupsOutputError>
}

extension DescribeDBParameterGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBParameterGroupsInput(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBParameterGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBParameterGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBParameterGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBParameterGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBParameterGroupsOutputError>
}

public struct DescribeDBParameterGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBParameterGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBParameterGroupsOutputError>
}

public struct DescribeDBParameterGroupsInput: Swift.Equatable {
    /// <p>The name of a specific DB parameter group to return details for.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: Swift.String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p>An optional pagination token provided by a previous
    ///       <code>DescribeDBParameterGroups</code> request. If this parameter is specified, the response
    ///       includes only records beyond the marker, up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        dBParameterGroupName: Swift.String? = nil,
        filters: [NeptuneClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBParameterGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBParameterGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBParameterGroupsOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBParameterGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBParameterGroupsOutputResponse(dBParameterGroups: \(Swift.String(describing: dBParameterGroups)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBParameterGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBParameterGroups = output.dBParameterGroups
            self.marker = output.marker
        } else {
            self.dBParameterGroups = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBParameterGroupsOutputResponse: Swift.Equatable {
    /// <p>A list of <a>DBParameterGroup</a> instances.</p>
    public let dBParameterGroups: [NeptuneClientTypes.DBParameterGroup]?
    /// <p>An optional pagination token provided by a previous request. If this parameter is
    ///       specified, the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: Swift.String?

    public init (
        dBParameterGroups: [NeptuneClientTypes.DBParameterGroup]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBParameterGroups = dBParameterGroups
        self.marker = marker
    }
}

struct DescribeDBParameterGroupsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBParameterGroups: [NeptuneClientTypes.DBParameterGroup]?
}

extension DescribeDBParameterGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroups = "DBParameterGroups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBParameterGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBParameterGroups) {
            struct KeyVal0{struct DBParameterGroup{}}
            let dBParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBParameterGroup>.CodingKeys.self, forKey: .dBParameterGroups)
            if let dBParameterGroupsWrappedContainer = dBParameterGroupsWrappedContainer {
                let dBParameterGroupsContainer = try dBParameterGroupsWrappedContainer.decodeIfPresent([NeptuneClientTypes.DBParameterGroup].self, forKey: .member)
                var dBParameterGroupsBuffer:[NeptuneClientTypes.DBParameterGroup]? = nil
                if let dBParameterGroupsContainer = dBParameterGroupsContainer {
                    dBParameterGroupsBuffer = [NeptuneClientTypes.DBParameterGroup]()
                    for structureContainer0 in dBParameterGroupsContainer {
                        dBParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBParameterGroups = dBParameterGroupsBuffer
            } else {
                dBParameterGroups = []
            }
        } else {
            dBParameterGroups = nil
        }
    }
}

public struct DescribeDBParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBParametersOutputError>
}

extension DescribeDBParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBParametersInput(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), source: \(Swift.String(describing: source)))"}
}

extension DescribeDBParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let source = source {
            try container.encode(source, forKey: ClientRuntime.Key("Source"))
        }
        try container.encode("DescribeDBParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBParametersOutputError>
}

public struct DescribeDBParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBParametersOutputError>
}

public struct DescribeDBParametersInput: Swift.Equatable {
    /// <p>The name of a specific DB parameter group to return details for.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: Swift.String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p>An optional pagination token provided by a previous <code>DescribeDBParameters</code>
    ///       request. If this parameter is specified, the response includes only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The parameter types to return.</p>
    ///          <p>Default: All parameter types returned</p>
    ///          <p>Valid Values: <code>user | system | engine-default</code>
    ///          </p>
    public let source: Swift.String?

    public init (
        dBParameterGroupName: Swift.String? = nil,
        filters: [NeptuneClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        source: Swift.String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.source = source
    }
}

extension DescribeDBParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBParametersOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBParametersOutputResponse(marker: \(Swift.String(describing: marker)), parameters: \(Swift.String(describing: parameters)))"}
}

extension DescribeDBParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.parameters = output.parameters
        } else {
            self.marker = nil
            self.parameters = nil
        }
    }
}

public struct DescribeDBParametersOutputResponse: Swift.Equatable {
    /// <p>An optional pagination token provided by a previous request. If this parameter is
    ///       specified, the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p>A list of <a>Parameter</a> values.</p>
    public let parameters: [NeptuneClientTypes.Parameter]?

    public init (
        marker: Swift.String? = nil,
        parameters: [NeptuneClientTypes.Parameter]? = nil
    )
    {
        self.marker = marker
        self.parameters = parameters
    }
}

struct DescribeDBParametersOutputResponseBody: Swift.Equatable {
    public let parameters: [NeptuneClientTypes.Parameter]?
    public let marker: Swift.String?
}

extension DescribeDBParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBParametersResult"))
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([NeptuneClientTypes.Parameter].self, forKey: .member)
                var parametersBuffer:[NeptuneClientTypes.Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [NeptuneClientTypes.Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBSubnetGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSubnetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSubnetGroupsOutputError>
}

extension DescribeDBSubnetGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBSubnetGroupsInput(dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBSubnetGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBSubnetGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBSubnetGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSubnetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSubnetGroupsOutputError>
}

public struct DescribeDBSubnetGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSubnetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSubnetGroupsOutputError>
}

public struct DescribeDBSubnetGroupsInput: Swift.Equatable {
    /// <p>The name of the DB subnet group to return details for.</p>
    public let dBSubnetGroupName: Swift.String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous DescribeDBSubnetGroups request. If
    ///       this parameter is specified, the response includes only records beyond the marker, up to the
    ///       value specified by <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        dBSubnetGroupName: Swift.String? = nil,
        filters: [NeptuneClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBSubnetGroupName = dBSubnetGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBSubnetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBSubnetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBSubnetGroupsOutputError: Swift.Error, Swift.Equatable {
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBSubnetGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBSubnetGroupsOutputResponse(dBSubnetGroups: \(Swift.String(describing: dBSubnetGroups)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBSubnetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBSubnetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSubnetGroups = output.dBSubnetGroups
            self.marker = output.marker
        } else {
            self.dBSubnetGroups = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBSubnetGroupsOutputResponse: Swift.Equatable {
    /// <p> A list of <a>DBSubnetGroup</a> instances.</p>
    public let dBSubnetGroups: [NeptuneClientTypes.DBSubnetGroup]?
    /// <p> An optional pagination token provided by a previous request. If this parameter is
    ///       specified, the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: Swift.String?

    public init (
        dBSubnetGroups: [NeptuneClientTypes.DBSubnetGroup]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBSubnetGroups = dBSubnetGroups
        self.marker = marker
    }
}

struct DescribeDBSubnetGroupsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBSubnetGroups: [NeptuneClientTypes.DBSubnetGroup]?
}

extension DescribeDBSubnetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroups = "DBSubnetGroups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBSubnetGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBSubnetGroups) {
            struct KeyVal0{struct DBSubnetGroup{}}
            let dBSubnetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSubnetGroup>.CodingKeys.self, forKey: .dBSubnetGroups)
            if let dBSubnetGroupsWrappedContainer = dBSubnetGroupsWrappedContainer {
                let dBSubnetGroupsContainer = try dBSubnetGroupsWrappedContainer.decodeIfPresent([NeptuneClientTypes.DBSubnetGroup].self, forKey: .member)
                var dBSubnetGroupsBuffer:[NeptuneClientTypes.DBSubnetGroup]? = nil
                if let dBSubnetGroupsContainer = dBSubnetGroupsContainer {
                    dBSubnetGroupsBuffer = [NeptuneClientTypes.DBSubnetGroup]()
                    for structureContainer0 in dBSubnetGroupsContainer {
                        dBSubnetGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBSubnetGroups = dBSubnetGroupsBuffer
            } else {
                dBSubnetGroups = []
            }
        } else {
            dBSubnetGroups = nil
        }
    }
}

public struct DescribeEngineDefaultClusterParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngineDefaultClusterParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEngineDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEngineDefaultClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngineDefaultClusterParametersOutputError>
}

extension DescribeEngineDefaultClusterParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEngineDefaultClusterParametersInput(dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeEngineDefaultClusterParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeEngineDefaultClusterParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeEngineDefaultClusterParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngineDefaultClusterParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEngineDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEngineDefaultClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngineDefaultClusterParametersOutputError>
}

public struct DescribeEngineDefaultClusterParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngineDefaultClusterParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEngineDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEngineDefaultClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngineDefaultClusterParametersOutputError>
}

public struct DescribeEngineDefaultClusterParametersInput: Swift.Equatable {
    /// <p>The name of the DB cluster parameter group family to return engine parameter information
    ///       for.</p>
    public let dBParameterGroupFamily: Swift.String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribeEngineDefaultClusterParameters</code> request. If this parameter is specified,
    ///       the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        dBParameterGroupFamily: Swift.String? = nil,
        filters: [NeptuneClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeEngineDefaultClusterParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEngineDefaultClusterParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEngineDefaultClusterParametersOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEngineDefaultClusterParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEngineDefaultClusterParametersOutputResponse(engineDefaults: \(Swift.String(describing: engineDefaults)))"}
}

extension DescribeEngineDefaultClusterParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEngineDefaultClusterParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engineDefaults = output.engineDefaults
        } else {
            self.engineDefaults = nil
        }
    }
}

public struct DescribeEngineDefaultClusterParametersOutputResponse: Swift.Equatable {
    /// <p> Contains the result of a successful invocation of the <a>DescribeEngineDefaultParameters</a> action.</p>
    public let engineDefaults: NeptuneClientTypes.EngineDefaults?

    public init (
        engineDefaults: NeptuneClientTypes.EngineDefaults? = nil
    )
    {
        self.engineDefaults = engineDefaults
    }
}

struct DescribeEngineDefaultClusterParametersOutputResponseBody: Swift.Equatable {
    public let engineDefaults: NeptuneClientTypes.EngineDefaults?
}

extension DescribeEngineDefaultClusterParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineDefaults = "EngineDefaults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEngineDefaultClusterParametersResult"))
        let engineDefaultsDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.EngineDefaults.self, forKey: .engineDefaults)
        engineDefaults = engineDefaultsDecoded
    }
}

public struct DescribeEngineDefaultParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngineDefaultParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEngineDefaultParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngineDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEngineDefaultParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngineDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngineDefaultParametersOutputError>
}

extension DescribeEngineDefaultParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEngineDefaultParametersInput(dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeEngineDefaultParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeEngineDefaultParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeEngineDefaultParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngineDefaultParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEngineDefaultParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngineDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEngineDefaultParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngineDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngineDefaultParametersOutputError>
}

public struct DescribeEngineDefaultParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngineDefaultParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEngineDefaultParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngineDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEngineDefaultParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngineDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngineDefaultParametersOutputError>
}

public struct DescribeEngineDefaultParametersInput: Swift.Equatable {
    /// <p>The name of the DB parameter group family.</p>
    public let dBParameterGroupFamily: Swift.String?
    /// <p>Not currently supported.</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribeEngineDefaultParameters</code> request. If this parameter is specified, the
    ///       response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?

    public init (
        dBParameterGroupFamily: Swift.String? = nil,
        filters: [NeptuneClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeEngineDefaultParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEngineDefaultParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEngineDefaultParametersOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEngineDefaultParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEngineDefaultParametersOutputResponse(engineDefaults: \(Swift.String(describing: engineDefaults)))"}
}

extension DescribeEngineDefaultParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEngineDefaultParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engineDefaults = output.engineDefaults
        } else {
            self.engineDefaults = nil
        }
    }
}

public struct DescribeEngineDefaultParametersOutputResponse: Swift.Equatable {
    /// <p> Contains the result of a successful invocation of the <a>DescribeEngineDefaultParameters</a> action.</p>
    public let engineDefaults: NeptuneClientTypes.EngineDefaults?

    public init (
        engineDefaults: NeptuneClientTypes.EngineDefaults? = nil
    )
    {
        self.engineDefaults = engineDefaults
    }
}

struct DescribeEngineDefaultParametersOutputResponseBody: Swift.Equatable {
    public let engineDefaults: NeptuneClientTypes.EngineDefaults?
}

extension DescribeEngineDefaultParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineDefaults = "EngineDefaults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEngineDefaultParametersResult"))
        let engineDefaultsDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.EngineDefaults.self, forKey: .engineDefaults)
        engineDefaults = engineDefaultsDecoded
    }
}

public struct DescribeEventCategoriesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventCategoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventCategoriesOutputError>
}

extension DescribeEventCategoriesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventCategoriesInput(filters: \(Swift.String(describing: filters)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension DescribeEventCategoriesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        try container.encode("DescribeEventCategories", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeEventCategoriesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventCategoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventCategoriesOutputError>
}

public struct DescribeEventCategoriesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventCategoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventCategoriesOutputError>
}

public struct DescribeEventCategoriesInput: Swift.Equatable {
    /// <p>This parameter is not currently supported.</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p>The type of source that is generating the events.</p>
    ///          <p>Valid values: db-instance | db-parameter-group | db-security-group | db-snapshot</p>
    public let sourceType: Swift.String?

    public init (
        filters: [NeptuneClientTypes.Filter]? = nil,
        sourceType: Swift.String? = nil
    )
    {
        self.filters = filters
        self.sourceType = sourceType
    }
}

extension DescribeEventCategoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventCategoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventCategoriesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventCategoriesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventCategoriesOutputResponse(eventCategoriesMapList: \(Swift.String(describing: eventCategoriesMapList)))"}
}

extension DescribeEventCategoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventCategoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventCategoriesMapList = output.eventCategoriesMapList
        } else {
            self.eventCategoriesMapList = nil
        }
    }
}

public struct DescribeEventCategoriesOutputResponse: Swift.Equatable {
    /// <p>A list of EventCategoriesMap data types.</p>
    public let eventCategoriesMapList: [NeptuneClientTypes.EventCategoriesMap]?

    public init (
        eventCategoriesMapList: [NeptuneClientTypes.EventCategoriesMap]? = nil
    )
    {
        self.eventCategoriesMapList = eventCategoriesMapList
    }
}

struct DescribeEventCategoriesOutputResponseBody: Swift.Equatable {
    public let eventCategoriesMapList: [NeptuneClientTypes.EventCategoriesMap]?
}

extension DescribeEventCategoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventCategoriesMapList = "EventCategoriesMapList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEventCategoriesResult"))
        if containerValues.contains(.eventCategoriesMapList) {
            struct KeyVal0{struct EventCategoriesMap{}}
            let eventCategoriesMapListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategoriesMap>.CodingKeys.self, forKey: .eventCategoriesMapList)
            if let eventCategoriesMapListWrappedContainer = eventCategoriesMapListWrappedContainer {
                let eventCategoriesMapListContainer = try eventCategoriesMapListWrappedContainer.decodeIfPresent([NeptuneClientTypes.EventCategoriesMap].self, forKey: .member)
                var eventCategoriesMapListBuffer:[NeptuneClientTypes.EventCategoriesMap]? = nil
                if let eventCategoriesMapListContainer = eventCategoriesMapListContainer {
                    eventCategoriesMapListBuffer = [NeptuneClientTypes.EventCategoriesMap]()
                    for structureContainer0 in eventCategoriesMapListContainer {
                        eventCategoriesMapListBuffer?.append(structureContainer0)
                    }
                }
                eventCategoriesMapList = eventCategoriesMapListBuffer
            } else {
                eventCategoriesMapList = []
            }
        } else {
            eventCategoriesMapList = nil
        }
    }
}

public struct DescribeEventSubscriptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSubscriptionsOutputError>
}

extension DescribeEventSubscriptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventSubscriptionsInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), subscriptionName: \(Swift.String(describing: subscriptionName)))"}
}

extension DescribeEventSubscriptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("DescribeEventSubscriptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeEventSubscriptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSubscriptionsOutputError>
}

public struct DescribeEventSubscriptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSubscriptionsOutputError>
}

public struct DescribeEventSubscriptionsInput: Swift.Equatable {
    /// <p>This parameter is not currently supported.</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous DescribeOrderableDBInstanceOptions
    ///       request. If this parameter is specified, the response includes only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code> .</p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The name of the event notification subscription you want to describe.</p>
    public let subscriptionName: Swift.String?

    public init (
        filters: [NeptuneClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.subscriptionName = subscriptionName
    }
}

extension DescribeEventSubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventSubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventSubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventSubscriptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventSubscriptionsOutputResponse(eventSubscriptionsList: \(Swift.String(describing: eventSubscriptionsList)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeEventSubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscriptionsList = output.eventSubscriptionsList
            self.marker = output.marker
        } else {
            self.eventSubscriptionsList = nil
            self.marker = nil
        }
    }
}

public struct DescribeEventSubscriptionsOutputResponse: Swift.Equatable {
    /// <p>A list of EventSubscriptions data types.</p>
    public let eventSubscriptionsList: [NeptuneClientTypes.EventSubscription]?
    /// <p> An optional pagination token provided by a previous DescribeOrderableDBInstanceOptions
    ///       request. If this parameter is specified, the response includes only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code>.</p>
    public let marker: Swift.String?

    public init (
        eventSubscriptionsList: [NeptuneClientTypes.EventSubscription]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.eventSubscriptionsList = eventSubscriptionsList
        self.marker = marker
    }
}

struct DescribeEventSubscriptionsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let eventSubscriptionsList: [NeptuneClientTypes.EventSubscription]?
}

extension DescribeEventSubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscriptionsList = "EventSubscriptionsList"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEventSubscriptionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.eventSubscriptionsList) {
            struct KeyVal0{struct EventSubscription{}}
            let eventSubscriptionsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventSubscription>.CodingKeys.self, forKey: .eventSubscriptionsList)
            if let eventSubscriptionsListWrappedContainer = eventSubscriptionsListWrappedContainer {
                let eventSubscriptionsListContainer = try eventSubscriptionsListWrappedContainer.decodeIfPresent([NeptuneClientTypes.EventSubscription].self, forKey: .member)
                var eventSubscriptionsListBuffer:[NeptuneClientTypes.EventSubscription]? = nil
                if let eventSubscriptionsListContainer = eventSubscriptionsListContainer {
                    eventSubscriptionsListBuffer = [NeptuneClientTypes.EventSubscription]()
                    for structureContainer0 in eventSubscriptionsListContainer {
                        eventSubscriptionsListBuffer?.append(structureContainer0)
                    }
                }
                eventSubscriptionsList = eventSubscriptionsListBuffer
            } else {
                eventSubscriptionsList = []
            }
        } else {
            eventSubscriptionsList = nil
        }
    }
}

public struct DescribeEventsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

extension DescribeEventsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventsInput(duration: \(Swift.String(describing: duration)), endTime: \(Swift.String(describing: endTime)), eventCategories: \(Swift.String(describing: eventCategories)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), sourceIdentifier: \(Swift.String(describing: sourceIdentifier)), sourceType: \(Swift.String(describing: sourceType)), startTime: \(Swift.String(describing: startTime)))"}
}

extension DescribeEventsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let duration = duration {
            try container.encode(duration, forKey: ClientRuntime.Key("Duration"))
        }
        if let endTime = endTime {
            try container.encode(ClientRuntime.TimestampWrapper(endTime, format: .dateTime), forKey: ClientRuntime.Key("endTime"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: ClientRuntime.Key("SourceIdentifier"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let startTime = startTime {
            try container.encode(ClientRuntime.TimestampWrapper(startTime, format: .dateTime), forKey: ClientRuntime.Key("startTime"))
        }
        try container.encode("DescribeEvents", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeEventsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInput: Swift.Equatable {
    /// <p>The number of minutes to retrieve events for.</p>
    ///          <p>Default: 60</p>
    public let duration: Swift.Int?
    /// <p> The end of the time interval for which to retrieve events, specified in ISO 8601 format.
    ///       For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a>
    ///          </p>
    ///          <p>Example: 2009-07-08T18:00Z</p>
    public let endTime: ClientRuntime.Date?
    /// <p>A list of event categories that trigger notifications for a event notification
    ///       subscription.</p>
    public let eventCategories: [Swift.String]?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous DescribeEvents request. If this
    ///       parameter is specified, the response includes only records beyond the marker, up to the value
    ///       specified by <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The identifier of the event source for which events are returned. If not specified, then
    ///       all sources are included in the response.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If SourceIdentifier is supplied, SourceType must also be provided.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is <code>DBInstance</code>, then a
    ///           <code>DBInstanceIdentifier</code> must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is <code>DBSecurityGroup</code>, a <code>DBSecurityGroupName</code>
    ///           must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is <code>DBParameterGroup</code>, a
    ///           <code>DBParameterGroupName</code> must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the source type is <code>DBSnapshot</code>, a <code>DBSnapshotIdentifier</code>
    ///           must be supplied.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    public let sourceIdentifier: Swift.String?
    /// <p>The event source to retrieve events for. If no value is specified, all events are
    ///       returned.</p>
    public let sourceType: NeptuneClientTypes.SourceType?
    /// <p> The beginning of the time interval to retrieve events for, specified in ISO 8601 format.
    ///       For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a>
    ///          </p>
    ///          <p>Example: 2009-07-08T18:00Z</p>
    public let startTime: ClientRuntime.Date?

    public init (
        duration: Swift.Int? = nil,
        endTime: ClientRuntime.Date? = nil,
        eventCategories: [Swift.String]? = nil,
        filters: [NeptuneClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        sourceIdentifier: Swift.String? = nil,
        sourceType: NeptuneClientTypes.SourceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.eventCategories = eventCategories
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

extension DescribeEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventsOutputResponse(events: \(Swift.String(describing: events)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.marker = output.marker
        } else {
            self.events = nil
            self.marker = nil
        }
    }
}

public struct DescribeEventsOutputResponse: Swift.Equatable {
    /// <p> A list of <a>Event</a> instances.</p>
    public let events: [NeptuneClientTypes.Event]?
    /// <p> An optional pagination token provided by a previous Events request. If this parameter is
    ///       specified, the response includes only records beyond the marker, up to the value specified by
    ///       <code>MaxRecords</code> .</p>
    public let marker: Swift.String?

    public init (
        events: [NeptuneClientTypes.Event]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.events = events
        self.marker = marker
    }
}

struct DescribeEventsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let events: [NeptuneClientTypes.Event]?
}

extension DescribeEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEventsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.events) {
            struct KeyVal0{struct Event{}}
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Event>.CodingKeys.self, forKey: .events)
            if let eventsWrappedContainer = eventsWrappedContainer {
                let eventsContainer = try eventsWrappedContainer.decodeIfPresent([NeptuneClientTypes.Event].self, forKey: .member)
                var eventsBuffer:[NeptuneClientTypes.Event]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [NeptuneClientTypes.Event]()
                    for structureContainer0 in eventsContainer {
                        eventsBuffer?.append(structureContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
    }
}

public struct DescribeOrderableDBInstanceOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrderableDBInstanceOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrderableDBInstanceOptionsOutputError>
}

extension DescribeOrderableDBInstanceOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOrderableDBInstanceOptionsInput(dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), filters: \(Swift.String(describing: filters)), licenseModel: \(Swift.String(describing: licenseModel)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), vpc: \(Swift.String(describing: vpc)))"}
}

extension DescribeOrderableDBInstanceOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let vpc = vpc {
            try container.encode(vpc, forKey: ClientRuntime.Key("Vpc"))
        }
        try container.encode("DescribeOrderableDBInstanceOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeOrderableDBInstanceOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrderableDBInstanceOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrderableDBInstanceOptionsOutputError>
}

public struct DescribeOrderableDBInstanceOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrderableDBInstanceOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrderableDBInstanceOptionsOutputError>
}

public struct DescribeOrderableDBInstanceOptionsInput: Swift.Equatable {
    /// <p>The DB instance class filter value. Specify this parameter to show only the available
    ///       offerings matching the specified DB instance class.</p>
    public let dBInstanceClass: Swift.String?
    /// <p>The name of the engine to retrieve DB instance options for.</p>
    public let engine: Swift.String?
    /// <p>The engine version filter value. Specify this parameter to show only the available
    ///       offerings matching the specified engine version.</p>
    public let engineVersion: Swift.String?
    /// <p>This parameter is not currently supported.</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p>The license model filter value. Specify this parameter to show only the available
    ///       offerings matching the specified license model.</p>
    public let licenseModel: Swift.String?
    /// <p> An optional pagination token provided by a previous DescribeOrderableDBInstanceOptions
    ///       request. If this parameter is specified, the response includes only records beyond the marker,
    ///       up to the value specified by <code>MaxRecords</code> .</p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The VPC filter value. Specify this parameter to show only the available VPC or non-VPC
    ///       offerings.</p>
    public let vpc: Swift.Bool?

    public init (
        dBInstanceClass: Swift.String? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        filters: [NeptuneClientTypes.Filter]? = nil,
        licenseModel: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        vpc: Swift.Bool? = nil
    )
    {
        self.dBInstanceClass = dBInstanceClass
        self.engine = engine
        self.engineVersion = engineVersion
        self.filters = filters
        self.licenseModel = licenseModel
        self.marker = marker
        self.maxRecords = maxRecords
        self.vpc = vpc
    }
}

extension DescribeOrderableDBInstanceOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeOrderableDBInstanceOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrderableDBInstanceOptionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrderableDBInstanceOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOrderableDBInstanceOptionsOutputResponse(marker: \(Swift.String(describing: marker)), orderableDBInstanceOptions: \(Swift.String(describing: orderableDBInstanceOptions)))"}
}

extension DescribeOrderableDBInstanceOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOrderableDBInstanceOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.orderableDBInstanceOptions = output.orderableDBInstanceOptions
        } else {
            self.marker = nil
            self.orderableDBInstanceOptions = nil
        }
    }
}

public struct DescribeOrderableDBInstanceOptionsOutputResponse: Swift.Equatable {
    /// <p> An optional pagination token provided by a previous OrderableDBInstanceOptions request.
    ///       If this parameter is specified, the response includes only records beyond the marker, up to
    ///       the value specified by <code>MaxRecords</code> .</p>
    public let marker: Swift.String?
    /// <p>An <a>OrderableDBInstanceOption</a> structure
    ///       containing information about orderable options for the DB instance.</p>
    public let orderableDBInstanceOptions: [NeptuneClientTypes.OrderableDBInstanceOption]?

    public init (
        marker: Swift.String? = nil,
        orderableDBInstanceOptions: [NeptuneClientTypes.OrderableDBInstanceOption]? = nil
    )
    {
        self.marker = marker
        self.orderableDBInstanceOptions = orderableDBInstanceOptions
    }
}

struct DescribeOrderableDBInstanceOptionsOutputResponseBody: Swift.Equatable {
    public let orderableDBInstanceOptions: [NeptuneClientTypes.OrderableDBInstanceOption]?
    public let marker: Swift.String?
}

extension DescribeOrderableDBInstanceOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case orderableDBInstanceOptions = "OrderableDBInstanceOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeOrderableDBInstanceOptionsResult"))
        if containerValues.contains(.orderableDBInstanceOptions) {
            struct KeyVal0{struct OrderableDBInstanceOption{}}
            let orderableDBInstanceOptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OrderableDBInstanceOption>.CodingKeys.self, forKey: .orderableDBInstanceOptions)
            if let orderableDBInstanceOptionsWrappedContainer = orderableDBInstanceOptionsWrappedContainer {
                let orderableDBInstanceOptionsContainer = try orderableDBInstanceOptionsWrappedContainer.decodeIfPresent([NeptuneClientTypes.OrderableDBInstanceOption].self, forKey: .member)
                var orderableDBInstanceOptionsBuffer:[NeptuneClientTypes.OrderableDBInstanceOption]? = nil
                if let orderableDBInstanceOptionsContainer = orderableDBInstanceOptionsContainer {
                    orderableDBInstanceOptionsBuffer = [NeptuneClientTypes.OrderableDBInstanceOption]()
                    for structureContainer0 in orderableDBInstanceOptionsContainer {
                        orderableDBInstanceOptionsBuffer?.append(structureContainer0)
                    }
                }
                orderableDBInstanceOptions = orderableDBInstanceOptionsBuffer
            } else {
                orderableDBInstanceOptions = []
            }
        } else {
            orderableDBInstanceOptions = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribePendingMaintenanceActionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePendingMaintenanceActionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePendingMaintenanceActionsOutputError>
}

extension DescribePendingMaintenanceActionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePendingMaintenanceActionsInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)))"}
}

extension DescribePendingMaintenanceActionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let resourceIdentifier = resourceIdentifier {
            try container.encode(resourceIdentifier, forKey: ClientRuntime.Key("ResourceIdentifier"))
        }
        try container.encode("DescribePendingMaintenanceActions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribePendingMaintenanceActionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePendingMaintenanceActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePendingMaintenanceActionsOutputError>
}

public struct DescribePendingMaintenanceActionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePendingMaintenanceActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePendingMaintenanceActionsOutputError>
}

public struct DescribePendingMaintenanceActionsInput: Swift.Equatable {
    /// <p>A filter that specifies one or more resources to return pending maintenance actions
    ///       for.</p>
    ///          <p>Supported filters:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db-cluster-id</code> - Accepts DB cluster identifiers and DB cluster Amazon
    ///           Resource Names (ARNs). The results list will only include pending maintenance actions for
    ///           the DB clusters identified by these ARNs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db-instance-id</code> - Accepts DB instance identifiers and DB instance ARNs.
    ///           The results list will only include pending maintenance actions for the DB instances
    ///           identified by these ARNs.</p>
    ///             </li>
    ///          </ul>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribePendingMaintenanceActions</code> request. If this parameter is specified, the
    ///       response includes only records beyond the marker, up to a number of records specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p> The maximum number of records to include in the response. If more records exist than the
    ///       specified <code>MaxRecords</code> value, a pagination token called a marker is included in the
    ///       response so that the remaining results can be retrieved.</p>
    ///          <p>Default: 100</p>
    ///          <p>Constraints: Minimum 20, maximum 100.</p>
    public let maxRecords: Swift.Int?
    /// <p>The ARN of a resource to return pending maintenance actions for.</p>
    public let resourceIdentifier: Swift.String?

    public init (
        filters: [NeptuneClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.resourceIdentifier = resourceIdentifier
    }
}

extension DescribePendingMaintenanceActionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribePendingMaintenanceActionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePendingMaintenanceActionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePendingMaintenanceActionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePendingMaintenanceActionsOutputResponse(marker: \(Swift.String(describing: marker)), pendingMaintenanceActions: \(Swift.String(describing: pendingMaintenanceActions)))"}
}

extension DescribePendingMaintenanceActionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePendingMaintenanceActionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.pendingMaintenanceActions = output.pendingMaintenanceActions
        } else {
            self.marker = nil
            self.pendingMaintenanceActions = nil
        }
    }
}

public struct DescribePendingMaintenanceActionsOutputResponse: Swift.Equatable {
    /// <p> An optional pagination token provided by a previous
    ///       <code>DescribePendingMaintenanceActions</code> request. If this parameter is specified, the
    ///       response includes only records beyond the marker, up to a number of records specified by
    ///       <code>MaxRecords</code>.</p>
    public let marker: Swift.String?
    /// <p>A list of the pending maintenance actions for the resource.</p>
    public let pendingMaintenanceActions: [NeptuneClientTypes.ResourcePendingMaintenanceActions]?

    public init (
        marker: Swift.String? = nil,
        pendingMaintenanceActions: [NeptuneClientTypes.ResourcePendingMaintenanceActions]? = nil
    )
    {
        self.marker = marker
        self.pendingMaintenanceActions = pendingMaintenanceActions
    }
}

struct DescribePendingMaintenanceActionsOutputResponseBody: Swift.Equatable {
    public let pendingMaintenanceActions: [NeptuneClientTypes.ResourcePendingMaintenanceActions]?
    public let marker: Swift.String?
}

extension DescribePendingMaintenanceActionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case pendingMaintenanceActions = "PendingMaintenanceActions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribePendingMaintenanceActionsResult"))
        if containerValues.contains(.pendingMaintenanceActions) {
            struct KeyVal0{struct ResourcePendingMaintenanceActions{}}
            let pendingMaintenanceActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ResourcePendingMaintenanceActions>.CodingKeys.self, forKey: .pendingMaintenanceActions)
            if let pendingMaintenanceActionsWrappedContainer = pendingMaintenanceActionsWrappedContainer {
                let pendingMaintenanceActionsContainer = try pendingMaintenanceActionsWrappedContainer.decodeIfPresent([NeptuneClientTypes.ResourcePendingMaintenanceActions].self, forKey: .member)
                var pendingMaintenanceActionsBuffer:[NeptuneClientTypes.ResourcePendingMaintenanceActions]? = nil
                if let pendingMaintenanceActionsContainer = pendingMaintenanceActionsContainer {
                    pendingMaintenanceActionsBuffer = [NeptuneClientTypes.ResourcePendingMaintenanceActions]()
                    for structureContainer0 in pendingMaintenanceActionsContainer {
                        pendingMaintenanceActionsBuffer?.append(structureContainer0)
                    }
                }
                pendingMaintenanceActions = pendingMaintenanceActionsBuffer
            } else {
                pendingMaintenanceActions = []
            }
        } else {
            pendingMaintenanceActions = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeValidDBInstanceModificationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeValidDBInstanceModificationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeValidDBInstanceModificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeValidDBInstanceModificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeValidDBInstanceModificationsOutputError>
}

extension DescribeValidDBInstanceModificationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeValidDBInstanceModificationsInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)))"}
}

extension DescribeValidDBInstanceModificationsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        try container.encode("DescribeValidDBInstanceModifications", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeValidDBInstanceModificationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeValidDBInstanceModificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeValidDBInstanceModificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeValidDBInstanceModificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeValidDBInstanceModificationsOutputError>
}

public struct DescribeValidDBInstanceModificationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeValidDBInstanceModificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeValidDBInstanceModificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeValidDBInstanceModificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeValidDBInstanceModificationsOutputError>
}

public struct DescribeValidDBInstanceModificationsInput: Swift.Equatable {
    /// <p>The customer identifier or the ARN of your DB instance.</p>
    public let dBInstanceIdentifier: Swift.String?

    public init (
        dBInstanceIdentifier: Swift.String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
    }
}

extension DescribeValidDBInstanceModificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeValidDBInstanceModificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeValidDBInstanceModificationsOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeValidDBInstanceModificationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeValidDBInstanceModificationsOutputResponse(validDBInstanceModificationsMessage: \(Swift.String(describing: validDBInstanceModificationsMessage)))"}
}

extension DescribeValidDBInstanceModificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeValidDBInstanceModificationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.validDBInstanceModificationsMessage = output.validDBInstanceModificationsMessage
        } else {
            self.validDBInstanceModificationsMessage = nil
        }
    }
}

public struct DescribeValidDBInstanceModificationsOutputResponse: Swift.Equatable {
    /// <p>Information about valid modifications that you can make to your DB instance. Contains the
    ///       result of a successful call to the <a>DescribeValidDBInstanceModifications</a>
    ///       action. You can use this information when you call <a>ModifyDBInstance</a>.
    ///    </p>
    public let validDBInstanceModificationsMessage: NeptuneClientTypes.ValidDBInstanceModificationsMessage?

    public init (
        validDBInstanceModificationsMessage: NeptuneClientTypes.ValidDBInstanceModificationsMessage? = nil
    )
    {
        self.validDBInstanceModificationsMessage = validDBInstanceModificationsMessage
    }
}

struct DescribeValidDBInstanceModificationsOutputResponseBody: Swift.Equatable {
    public let validDBInstanceModificationsMessage: NeptuneClientTypes.ValidDBInstanceModificationsMessage?
}

extension DescribeValidDBInstanceModificationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case validDBInstanceModificationsMessage = "ValidDBInstanceModificationsMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeValidDBInstanceModificationsResult"))
        let validDBInstanceModificationsMessageDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.ValidDBInstanceModificationsMessage.self, forKey: .validDBInstanceModificationsMessage)
        validDBInstanceModificationsMessage = validDBInstanceModificationsMessageDecoded
    }
}

extension NeptuneClientTypes.DomainMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case fQDN = "FQDN"
        case iAMRoleName = "IAMRoleName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let fQDN = fQDN {
            try container.encode(fQDN, forKey: ClientRuntime.Key("FQDN"))
        }
        if let iAMRoleName = iAMRoleName {
            try container.encode(iAMRoleName, forKey: ClientRuntime.Key("IAMRoleName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let fQDNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fQDN)
        fQDN = fQDNDecoded
        let iAMRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iAMRoleName)
        iAMRoleName = iAMRoleNameDecoded
    }
}

extension NeptuneClientTypes.DomainMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainMembership(domain: \(Swift.String(describing: domain)), fQDN: \(Swift.String(describing: fQDN)), iAMRoleName: \(Swift.String(describing: iAMRoleName)), status: \(Swift.String(describing: status)))"}
}

extension NeptuneClientTypes {
    /// <p>An Active Directory Domain membership record associated with a DB instance.</p>
    public struct DomainMembership: Swift.Equatable {
        /// <p>The identifier of the Active Directory Domain.</p>
        public let domain: Swift.String?
        /// <p>The fully qualified domain name of the Active Directory Domain.</p>
        public let fQDN: Swift.String?
        /// <p>The name of the IAM role to be used when making API calls to the Directory Service.</p>
        public let iAMRoleName: Swift.String?
        /// <p>The status of the DB instance's Active Directory Domain membership, such as joined,
        ///       pending-join, failed etc).</p>
        public let status: Swift.String?

        public init (
            domain: Swift.String? = nil,
            fQDN: Swift.String? = nil,
            iAMRoleName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.domain = domain
            self.fQDN = fQDN
            self.iAMRoleName = iAMRoleName
            self.status = status
        }
    }

}

extension DomainNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DomainNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DomainNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>Domain</i> does not refer to an existing Active Directory Domain.</p>
public struct DomainNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DomainNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DomainNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.DoubleRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from = "From"
        case to = "To"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if from != 0.0 {
            try container.encode(Swift.String(from), forKey: ClientRuntime.Key("From"))
        }
        if to != 0.0 {
            try container.encode(Swift.String(to), forKey: ClientRuntime.Key("To"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decode(Swift.Double.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decode(Swift.Double.self, forKey: .to)
        to = toDecoded
    }
}

extension NeptuneClientTypes.DoubleRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DoubleRange(from: \(Swift.String(describing: from)), to: \(Swift.String(describing: to)))"}
}

extension NeptuneClientTypes {
    /// <p>A range of double values.</p>
    public struct DoubleRange: Swift.Equatable {
        /// <p>The minimum value in the range.</p>
        public let from: Swift.Double
        /// <p>The maximum value in the range.</p>
        public let to: Swift.Double

        public init (
            from: Swift.Double = 0.0,
            to: Swift.Double = 0.0
        )
        {
            self.from = from
            self.to = to
        }
    }

}

extension NeptuneClientTypes.Endpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case hostedZoneId = "HostedZoneId"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let address = address {
            try container.encode(address, forKey: ClientRuntime.Key("Address"))
        }
        if let hostedZoneId = hostedZoneId {
            try container.encode(hostedZoneId, forKey: ClientRuntime.Key("HostedZoneId"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension NeptuneClientTypes.Endpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Endpoint(address: \(Swift.String(describing: address)), hostedZoneId: \(Swift.String(describing: hostedZoneId)), port: \(Swift.String(describing: port)))"}
}

extension NeptuneClientTypes {
    /// <p>Specifies a connection endpoint.</p>
    ///
    ///          <p>For the data structure that represents Amazon Neptune DB cluster endpoints,
    ///       see <code>DBClusterEndpoint</code>.</p>
    public struct Endpoint: Swift.Equatable {
        /// <p>Specifies the DNS address of the DB instance.</p>
        public let address: Swift.String?
        /// <p>Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.</p>
        public let hostedZoneId: Swift.String?
        /// <p>Specifies the port that the database engine is listening on.</p>
        public let port: Swift.Int

        public init (
            address: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.address = address
            self.hostedZoneId = hostedZoneId
            self.port = port
        }
    }

}

extension NeptuneClientTypes.EngineDefaults: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([NeptuneClientTypes.Parameter].self, forKey: .member)
                var parametersBuffer:[NeptuneClientTypes.Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [NeptuneClientTypes.Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
    }
}

extension NeptuneClientTypes.EngineDefaults: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EngineDefaults(dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), marker: \(Swift.String(describing: marker)), parameters: \(Swift.String(describing: parameters)))"}
}

extension NeptuneClientTypes {
    /// <p> Contains the result of a successful invocation of the <a>DescribeEngineDefaultParameters</a> action.</p>
    public struct EngineDefaults: Swift.Equatable {
        /// <p>Specifies the name of the DB parameter group family that the engine default parameters
        ///       apply to.</p>
        public let dBParameterGroupFamily: Swift.String?
        /// <p> An optional pagination token provided by a previous EngineDefaults request. If this
        ///       parameter is specified, the response includes only records beyond the marker, up to the value
        ///       specified by <code>MaxRecords</code> .</p>
        public let marker: Swift.String?
        /// <p>Contains a list of engine default parameters.</p>
        public let parameters: [NeptuneClientTypes.Parameter]?

        public init (
            dBParameterGroupFamily: Swift.String? = nil,
            marker: Swift.String? = nil,
            parameters: [NeptuneClientTypes.Parameter]? = nil
        )
        {
            self.dBParameterGroupFamily = dBParameterGroupFamily
            self.marker = marker
            self.parameters = parameters
        }
    }

}

extension NeptuneClientTypes.Event: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case eventCategories = "EventCategories"
        case message = "Message"
        case sourceArn = "SourceArn"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let date = date {
            try container.encode(ClientRuntime.TimestampWrapper(date, format: .dateTime), forKey: ClientRuntime.Key("date"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: ClientRuntime.Key("SourceArn"))
        }
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: ClientRuntime.Key("SourceIdentifier"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var eventCategoriesBuffer:[Swift.String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [Swift.String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
        let dateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .date)
        var dateBuffer:ClientRuntime.Date? = nil
        if let dateDecoded = dateDecoded {
            dateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(dateDecoded, format: .dateTime)
        }
        date = dateBuffer
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
    }
}

extension NeptuneClientTypes.Event: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Event(date: \(Swift.String(describing: date)), eventCategories: \(Swift.String(describing: eventCategories)), message: \(Swift.String(describing: message)), sourceArn: \(Swift.String(describing: sourceArn)), sourceIdentifier: \(Swift.String(describing: sourceIdentifier)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension NeptuneClientTypes {
    /// <p> This data type is used as a response element in the <a>DescribeEvents</a>
    ///       action.</p>
    public struct Event: Swift.Equatable {
        /// <p>Specifies the date and time of the event.</p>
        public let date: ClientRuntime.Date?
        /// <p>Specifies the category for the event.</p>
        public let eventCategories: [Swift.String]?
        /// <p>Provides the text of this event.</p>
        public let message: Swift.String?
        /// <p>The Amazon Resource Name (ARN) for the event.</p>
        public let sourceArn: Swift.String?
        /// <p>Provides the identifier for the source of the event.</p>
        public let sourceIdentifier: Swift.String?
        /// <p>Specifies the source type for this event.</p>
        public let sourceType: NeptuneClientTypes.SourceType?

        public init (
            date: ClientRuntime.Date? = nil,
            eventCategories: [Swift.String]? = nil,
            message: Swift.String? = nil,
            sourceArn: Swift.String? = nil,
            sourceIdentifier: Swift.String? = nil,
            sourceType: NeptuneClientTypes.SourceType? = nil
        )
        {
            self.date = date
            self.eventCategories = eventCategories
            self.message = message
            self.sourceArn = sourceArn
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
        }
    }

}

extension NeptuneClientTypes.EventCategoriesMap: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventCategories = "EventCategories"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var eventCategoriesBuffer:[Swift.String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [Swift.String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
    }
}

extension NeptuneClientTypes.EventCategoriesMap: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventCategoriesMap(eventCategories: \(Swift.String(describing: eventCategories)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension NeptuneClientTypes {
    /// <p>Contains the results of a successful invocation of the <a>DescribeEventCategories</a> action.</p>
    public struct EventCategoriesMap: Swift.Equatable {
        /// <p>The event categories for the specified source type</p>
        public let eventCategories: [Swift.String]?
        /// <p>The source type that the returned categories belong to</p>
        public let sourceType: Swift.String?

        public init (
            eventCategories: [Swift.String]? = nil,
            sourceType: Swift.String? = nil
        )
        {
            self.eventCategories = eventCategories
            self.sourceType = sourceType
        }
    }

}

extension NeptuneClientTypes.EventSubscription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case custSubscriptionId = "CustSubscriptionId"
        case customerAwsId = "CustomerAwsId"
        case enabled = "Enabled"
        case eventCategoriesList = "EventCategoriesList"
        case eventSubscriptionArn = "EventSubscriptionArn"
        case snsTopicArn = "SnsTopicArn"
        case sourceIdsList = "SourceIdsList"
        case sourceType = "SourceType"
        case status = "Status"
        case subscriptionCreationTime = "SubscriptionCreationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let custSubscriptionId = custSubscriptionId {
            try container.encode(custSubscriptionId, forKey: ClientRuntime.Key("CustSubscriptionId"))
        }
        if let customerAwsId = customerAwsId {
            try container.encode(customerAwsId, forKey: ClientRuntime.Key("CustomerAwsId"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let eventCategoriesList = eventCategoriesList {
            var eventCategoriesListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategoriesList"))
            for (index0, string0) in eventCategoriesList.enumerated() {
                try eventCategoriesListContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let eventSubscriptionArn = eventSubscriptionArn {
            try container.encode(eventSubscriptionArn, forKey: ClientRuntime.Key("EventSubscriptionArn"))
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: ClientRuntime.Key("SnsTopicArn"))
        }
        if let sourceIdsList = sourceIdsList {
            var sourceIdsListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SourceIdsList"))
            for (index0, string0) in sourceIdsList.enumerated() {
                try sourceIdsListContainer.encode(string0, forKey: ClientRuntime.Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let subscriptionCreationTime = subscriptionCreationTime {
            try container.encode(subscriptionCreationTime, forKey: ClientRuntime.Key("SubscriptionCreationTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerAwsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAwsId)
        customerAwsId = customerAwsIdDecoded
        let custSubscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .custSubscriptionId)
        custSubscriptionId = custSubscriptionIdDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let subscriptionCreationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionCreationTime)
        subscriptionCreationTime = subscriptionCreationTimeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.sourceIdsList) {
            struct KeyVal0{struct SourceId{}}
            let sourceIdsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SourceId>.CodingKeys.self, forKey: .sourceIdsList)
            if let sourceIdsListWrappedContainer = sourceIdsListWrappedContainer {
                let sourceIdsListContainer = try sourceIdsListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var sourceIdsListBuffer:[Swift.String]? = nil
                if let sourceIdsListContainer = sourceIdsListContainer {
                    sourceIdsListBuffer = [Swift.String]()
                    for stringContainer0 in sourceIdsListContainer {
                        sourceIdsListBuffer?.append(stringContainer0)
                    }
                }
                sourceIdsList = sourceIdsListBuffer
            } else {
                sourceIdsList = []
            }
        } else {
            sourceIdsList = nil
        }
        if containerValues.contains(.eventCategoriesList) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategoriesList)
            if let eventCategoriesListWrappedContainer = eventCategoriesListWrappedContainer {
                let eventCategoriesListContainer = try eventCategoriesListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var eventCategoriesListBuffer:[Swift.String]? = nil
                if let eventCategoriesListContainer = eventCategoriesListContainer {
                    eventCategoriesListBuffer = [Swift.String]()
                    for stringContainer0 in eventCategoriesListContainer {
                        eventCategoriesListBuffer?.append(stringContainer0)
                    }
                }
                eventCategoriesList = eventCategoriesListBuffer
            } else {
                eventCategoriesList = []
            }
        } else {
            eventCategoriesList = nil
        }
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let eventSubscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSubscriptionArn)
        eventSubscriptionArn = eventSubscriptionArnDecoded
    }
}

extension NeptuneClientTypes.EventSubscription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventSubscription(custSubscriptionId: \(Swift.String(describing: custSubscriptionId)), customerAwsId: \(Swift.String(describing: customerAwsId)), enabled: \(Swift.String(describing: enabled)), eventCategoriesList: \(Swift.String(describing: eventCategoriesList)), eventSubscriptionArn: \(Swift.String(describing: eventSubscriptionArn)), snsTopicArn: \(Swift.String(describing: snsTopicArn)), sourceIdsList: \(Swift.String(describing: sourceIdsList)), sourceType: \(Swift.String(describing: sourceType)), status: \(Swift.String(describing: status)), subscriptionCreationTime: \(Swift.String(describing: subscriptionCreationTime)))"}
}

extension NeptuneClientTypes {
    /// <p>Contains the results of a successful invocation of the <a>DescribeEventSubscriptions</a> action.</p>
    public struct EventSubscription: Swift.Equatable {
        /// <p>The event notification subscription Id.</p>
        public let custSubscriptionId: Swift.String?
        /// <p>The Amazon customer account associated with the event notification subscription.</p>
        public let customerAwsId: Swift.String?
        /// <p>A Boolean value indicating if the subscription is enabled. True indicates the subscription
        ///       is enabled.</p>
        public let enabled: Swift.Bool
        /// <p>A list of event categories for the event notification subscription.</p>
        public let eventCategoriesList: [Swift.String]?
        /// <p>The Amazon Resource Name (ARN) for the event subscription.</p>
        public let eventSubscriptionArn: Swift.String?
        /// <p>The topic ARN of the event notification subscription.</p>
        public let snsTopicArn: Swift.String?
        /// <p>A list of source IDs for the event notification subscription.</p>
        public let sourceIdsList: [Swift.String]?
        /// <p>The source type for the event notification subscription.</p>
        public let sourceType: Swift.String?
        /// <p>The status of the event notification subscription.</p>
        ///          <p>Constraints:</p>
        ///          <p>Can be one of the following: creating | modifying | deleting | active | no-permission |
        ///       topic-not-exist</p>
        ///          <p>The status "no-permission" indicates that Neptune no longer has permission to post to the
        ///       SNS topic. The status "topic-not-exist" indicates that the topic was deleted after the
        ///       subscription was created.</p>
        public let status: Swift.String?
        /// <p>The time the event notification subscription was created.</p>
        public let subscriptionCreationTime: Swift.String?

        public init (
            custSubscriptionId: Swift.String? = nil,
            customerAwsId: Swift.String? = nil,
            enabled: Swift.Bool = false,
            eventCategoriesList: [Swift.String]? = nil,
            eventSubscriptionArn: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            sourceIdsList: [Swift.String]? = nil,
            sourceType: Swift.String? = nil,
            status: Swift.String? = nil,
            subscriptionCreationTime: Swift.String? = nil
        )
        {
            self.custSubscriptionId = custSubscriptionId
            self.customerAwsId = customerAwsId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.eventSubscriptionArn = eventSubscriptionArn
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
        }
    }

}

extension EventSubscriptionQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventSubscriptionQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension EventSubscriptionQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<EventSubscriptionQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the number of events you can subscribe to.</p>
public struct EventSubscriptionQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EventSubscriptionQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EventSubscriptionQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct FailoverDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FailoverDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<FailoverDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FailoverDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<FailoverDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<FailoverDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FailoverDBClusterOutputError>
}

extension FailoverDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailoverDBClusterInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), targetDBInstanceIdentifier: \(Swift.String(describing: targetDBInstanceIdentifier)))"}
}

extension FailoverDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let targetDBInstanceIdentifier = targetDBInstanceIdentifier {
            try container.encode(targetDBInstanceIdentifier, forKey: ClientRuntime.Key("TargetDBInstanceIdentifier"))
        }
        try container.encode("FailoverDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct FailoverDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FailoverDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<FailoverDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FailoverDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<FailoverDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<FailoverDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FailoverDBClusterOutputError>
}

public struct FailoverDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FailoverDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<FailoverDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FailoverDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<FailoverDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<FailoverDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FailoverDBClusterOutputError>
}

public struct FailoverDBClusterInput: Swift.Equatable {
    /// <p>A DB cluster identifier to force a failover for. This parameter is not
    ///       case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBCluster.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: Swift.String?
    /// <p>The name of the instance to promote to the primary instance.</p>
    ///          <p>You must specify the instance identifier for an Read Replica in the DB cluster. For
    ///       example, <code>mydbcluster-replica1</code>.</p>
    public let targetDBInstanceIdentifier: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        targetDBInstanceIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.targetDBInstanceIdentifier = targetDBInstanceIdentifier
    }
}

extension FailoverDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension FailoverDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FailoverDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension FailoverDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailoverDBClusterOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension FailoverDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FailoverDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct FailoverDBClusterOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: NeptuneClientTypes.DBCluster?

    public init (
        dBCluster: NeptuneClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct FailoverDBClusterOutputResponseBody: Swift.Equatable {
    public let dBCluster: NeptuneClientTypes.DBCluster?
}

extension FailoverDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("FailoverDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension NeptuneClientTypes.Filter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Values"))
            for (index0, string0) in values.enumerated() {
                try valuesContainer.encode(string0, forKey: ClientRuntime.Key("Value.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct Value{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Value>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var valuesBuffer:[Swift.String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [Swift.String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension NeptuneClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension NeptuneClientTypes {
    /// <p>This type is not currently supported.</p>
    public struct Filter: Swift.Equatable {
        /// <p>This parameter is not currently supported.</p>
        public let name: Swift.String?
        /// <p>This parameter is not currently supported.</p>
        public let values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension InstanceQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension InstanceQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InstanceQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would result in user exceeding the allowed number of DB instances.</p>
public struct InstanceQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InstanceQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InstanceQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientDBClusterCapacityFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InsufficientDBClusterCapacityFault(message: \(Swift.String(describing: message)))"}
}

extension InsufficientDBClusterCapacityFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InsufficientDBClusterCapacityFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB cluster does not have enough capacity for the current operation.</p>
public struct InsufficientDBClusterCapacityFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientDBClusterCapacityFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InsufficientDBClusterCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientDBInstanceCapacityFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InsufficientDBInstanceCapacityFault(message: \(Swift.String(describing: message)))"}
}

extension InsufficientDBInstanceCapacityFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InsufficientDBInstanceCapacityFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Specified DB instance class is not available in the specified Availability Zone.</p>
public struct InsufficientDBInstanceCapacityFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientDBInstanceCapacityFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InsufficientDBInstanceCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientStorageClusterCapacityFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InsufficientStorageClusterCapacityFault(message: \(Swift.String(describing: message)))"}
}

extension InsufficientStorageClusterCapacityFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InsufficientStorageClusterCapacityFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is insufficient storage available for the current action. You may
///        be able to resolve this error by updating your subnet group to use different
///        Availability Zones that have more storage available.</p>
public struct InsufficientStorageClusterCapacityFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientStorageClusterCapacityFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InsufficientStorageClusterCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterEndpointStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBClusterEndpointStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBClusterEndpointStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidDBClusterEndpointStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation cannot be performed on the endpoint while the endpoint is in this state.</p>
public struct InvalidDBClusterEndpointStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterEndpointStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBClusterEndpointStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterSnapshotStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBClusterSnapshotStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBClusterSnapshotStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidDBClusterSnapshotStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The supplied value is not a valid DB cluster snapshot state.</p>
public struct InvalidDBClusterSnapshotStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterSnapshotStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBClusterSnapshotStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBClusterStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBClusterStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidDBClusterStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB cluster is not in a valid state.</p>
public struct InvalidDBClusterStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBClusterStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBInstanceStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBInstanceStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBInstanceStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidDBInstanceStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified DB instance is not in the <i>available</i> state.</p>
public struct InvalidDBInstanceStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBInstanceStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBInstanceStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBParameterGroupStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBParameterGroupStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBParameterGroupStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidDBParameterGroupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB parameter group is in use or is in an invalid state. If you are attempting to
///       delete the parameter group, you cannot delete it when the parameter group is in this state.</p>
public struct InvalidDBParameterGroupStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBParameterGroupStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBParameterGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSecurityGroupStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBSecurityGroupStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBSecurityGroupStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidDBSecurityGroupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state of the DB security group does not allow deletion.</p>
public struct InvalidDBSecurityGroupStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSecurityGroupStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBSecurityGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSnapshotStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBSnapshotStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBSnapshotStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidDBSnapshotStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state of the DB snapshot does not allow deletion.</p>
public struct InvalidDBSnapshotStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSnapshotStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBSnapshotStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSubnetGroupStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBSubnetGroupStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBSubnetGroupStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidDBSubnetGroupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB subnet group cannot be deleted because it is in use.</p>
public struct InvalidDBSubnetGroupStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSubnetGroupStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBSubnetGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSubnetStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBSubnetStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBSubnetStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidDBSubnetStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB subnet is not in the <i>available</i> state.</p>
public struct InvalidDBSubnetStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSubnetStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBSubnetStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventSubscriptionStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidEventSubscriptionStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidEventSubscriptionStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidEventSubscriptionStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The event subscription is in an invalid state.</p>
public struct InvalidEventSubscriptionStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventSubscriptionStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidEventSubscriptionStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRestoreFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRestoreFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidRestoreFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidRestoreFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot restore from vpc backup to non-vpc DB instance.</p>
public struct InvalidRestoreFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRestoreFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRestoreFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSubnet(message: \(Swift.String(describing: message)))"}
}

extension InvalidSubnet: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidSubnetBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested subnet is invalid, or multiple subnets were requested that are
///       not all in a common VPC.</p>
public struct InvalidSubnet: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidSubnetBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVPCNetworkStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidVPCNetworkStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidVPCNetworkStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidVPCNetworkStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>DB subnet group does not cover all Availability Zones after it is created
///       because users' change.</p>
public struct InvalidVPCNetworkStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidVPCNetworkStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidVPCNetworkStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSKeyNotAccessibleFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSKeyNotAccessibleFault(message: \(Swift.String(describing: message)))"}
}

extension KMSKeyNotAccessibleFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<KMSKeyNotAccessibleFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Error accessing KMS key.</p>
public struct KMSKeyNotAccessibleFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSKeyNotAccessibleFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSKeyNotAccessibleFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(filters: \(Swift.String(describing: filters)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: ClientRuntime.Key("ResourceName"))
        }
        try container.encode("ListTagsForResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>This parameter is not currently supported.</p>
    public let filters: [NeptuneClientTypes.Filter]?
    /// <p>The Amazon Neptune resource with tags to be listed. This value is an Amazon Resource Name
    ///       (ARN). For information about creating an ARN, see <a href="https://docs.aws.amazon.com/neptune/latest/UserGuide/tagging.ARN.html#tagging.ARN.Constructing"> Constructing an
    ///       Amazon Resource Name (ARN)</a>.</p>
    public let resourceName: Swift.String?

    public init (
        filters: [NeptuneClientTypes.Filter]? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.resourceName = resourceName
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tagList: \(Swift.String(describing: tagList)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>List of tags returned by the ListTagsForResource operation.</p>
    public let tagList: [NeptuneClientTypes.Tag]?

    public init (
        tagList: [NeptuneClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tagList: [NeptuneClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListTagsForResourceResult"))
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([NeptuneClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[NeptuneClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [NeptuneClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
    }
}

public struct ModifyDBClusterEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterEndpointOutputError>
}

extension ModifyDBClusterEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterEndpointInput(dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)), endpointType: \(Swift.String(describing: endpointType)), excludedMembers: \(Swift.String(describing: excludedMembers)), staticMembers: \(Swift.String(describing: staticMembers)))"}
}

extension ModifyDBClusterEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointIdentifier"))
        }
        if let endpointType = endpointType {
            try container.encode(endpointType, forKey: ClientRuntime.Key("EndpointType"))
        }
        if let excludedMembers = excludedMembers {
            var excludedMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExcludedMembers"))
            for (index0, string0) in excludedMembers.enumerated() {
                try excludedMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let staticMembers = staticMembers {
            var staticMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("StaticMembers"))
            for (index0, string0) in staticMembers.enumerated() {
                try staticMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBClusterEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBClusterEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterEndpointOutputError>
}

public struct ModifyDBClusterEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterEndpointOutputError>
}

public struct ModifyDBClusterEndpointInput: Swift.Equatable {
    /// <p>The identifier of the endpoint to modify. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: Swift.String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>ANY</code>.</p>
    public let endpointType: Swift.String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///       All other eligible instances are reachable through the custom endpoint.
    ///       Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [Swift.String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [Swift.String]?

    public init (
        dBClusterEndpointIdentifier: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        excludedMembers: [Swift.String]? = nil,
        staticMembers: [Swift.String]? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
    }
}

extension ModifyDBClusterEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterEndpointNotFoundFault" : self = .dBClusterEndpointNotFoundFault(try DBClusterEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterEndpointStateFault" : self = .invalidDBClusterEndpointStateFault(try InvalidDBClusterEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterEndpointOutputError: Swift.Error, Swift.Equatable {
    case dBClusterEndpointNotFoundFault(DBClusterEndpointNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterEndpointStateFault(InvalidDBClusterEndpointStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterEndpointOutputResponse(customEndpointType: \(Swift.String(describing: customEndpointType)), dBClusterEndpointArn: \(Swift.String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(Swift.String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), endpoint: \(Swift.String(describing: endpoint)), endpointType: \(Swift.String(describing: endpointType)), excludedMembers: \(Swift.String(describing: excludedMembers)), staticMembers: \(Swift.String(describing: staticMembers)), status: \(Swift.String(describing: status)))"}
}

extension ModifyDBClusterEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBClusterEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customEndpointType = output.customEndpointType
            self.dBClusterEndpointArn = output.dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = output.dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = output.dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.endpoint = output.endpoint
            self.endpointType = output.endpointType
            self.excludedMembers = output.excludedMembers
            self.staticMembers = output.staticMembers
            self.status = output.status
        } else {
            self.customEndpointType = nil
            self.dBClusterEndpointArn = nil
            self.dBClusterEndpointIdentifier = nil
            self.dBClusterEndpointResourceIdentifier = nil
            self.dBClusterIdentifier = nil
            self.endpoint = nil
            self.endpointType = nil
            self.excludedMembers = nil
            self.staticMembers = nil
            self.status = nil
        }
    }
}

/// <p>This data type represents the information you need to connect to an Amazon Aurora DB cluster.
///       This data type is used as a response element in the following actions:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>CreateDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DescribeDBClusterEndpoints</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>ModifyDBClusterEndpoint</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>DeleteDBClusterEndpoint</code>
///                </p>
///             </li>
///          </ul>
///          <p>For the data structure that represents Amazon RDS DB instance endpoints,
///       see <code>Endpoint</code>.</p>
public struct ModifyDBClusterEndpointOutputResponse: Swift.Equatable {
    /// <p>The type associated with a custom endpoint. One of: <code>READER</code>,
    ///       <code>WRITER</code>, <code>ANY</code>.</p>
    public let customEndpointType: Swift.String?
    /// <p>The Amazon Resource Name (ARN) for the endpoint.</p>
    public let dBClusterEndpointArn: Swift.String?
    /// <p>The identifier associated with the endpoint. This parameter is stored as a lowercase string.</p>
    public let dBClusterEndpointIdentifier: Swift.String?
    /// <p>A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.</p>
    public let dBClusterEndpointResourceIdentifier: Swift.String?
    /// <p>The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///       stored as a lowercase string.</p>
    public let dBClusterIdentifier: Swift.String?
    /// <p>The DNS address of the endpoint.</p>
    public let endpoint: Swift.String?
    /// <p>The type of the endpoint. One of: <code>READER</code>, <code>WRITER</code>, <code>CUSTOM</code>.</p>
    public let endpointType: Swift.String?
    /// <p>List of DB instance identifiers that aren't part of the custom endpoint group.
    ///       All other eligible instances are reachable through the custom endpoint.
    ///       Only relevant if the list of static members is empty.</p>
    public let excludedMembers: [Swift.String]?
    /// <p>List of DB instance identifiers that are part of the custom endpoint group.</p>
    public let staticMembers: [Swift.String]?
    /// <p>The current status of the endpoint. One of: <code>creating</code>, <code>available</code>, <code>deleting</code>, <code>inactive</code>, <code>modifying</code>. The <code>inactive</code> state applies to an endpoint that cannot be used for a certain kind of cluster,
    ///       such as a <code>writer</code> endpoint for a read-only secondary cluster in a global database.</p>
    public let status: Swift.String?

    public init (
        customEndpointType: Swift.String? = nil,
        dBClusterEndpointArn: Swift.String? = nil,
        dBClusterEndpointIdentifier: Swift.String? = nil,
        dBClusterEndpointResourceIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        endpoint: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        excludedMembers: [Swift.String]? = nil,
        staticMembers: [Swift.String]? = nil,
        status: Swift.String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

struct ModifyDBClusterEndpointOutputResponseBody: Swift.Equatable {
    public let dBClusterEndpointIdentifier: Swift.String?
    public let dBClusterIdentifier: Swift.String?
    public let dBClusterEndpointResourceIdentifier: Swift.String?
    public let endpoint: Swift.String?
    public let status: Swift.String?
    public let endpointType: Swift.String?
    public let customEndpointType: Swift.String?
    public let staticMembers: [Swift.String]?
    public let excludedMembers: [Swift.String]?
    public let dBClusterEndpointArn: Swift.String?
}

extension ModifyDBClusterEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBClusterEndpointResult"))
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var staticMembersBuffer:[Swift.String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [Swift.String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedMembersBuffer:[Swift.String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [Swift.String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

public struct ModifyDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterOutputError>
}

extension ModifyDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterInput(applyImmediately: \(Swift.String(describing: applyImmediately)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), cloudwatchLogsExportConfiguration: \(Swift.String(describing: cloudwatchLogsExportConfiguration)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), deletionProtection: \(Swift.String(describing: deletionProtection)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), engineVersion: \(Swift.String(describing: engineVersion)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), newDBClusterIdentifier: \(Swift.String(describing: newDBClusterIdentifier)), optionGroupName: \(Swift.String(describing: optionGroupName)), port: \(Swift.String(describing: port)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if applyImmediately != false {
            try container.encode(applyImmediately, forKey: ClientRuntime.Key("ApplyImmediately"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration {
            try container.encode(cloudwatchLogsExportConfiguration, forKey: ClientRuntime.Key("CloudwatchLogsExportConfiguration"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let newDBClusterIdentifier = newDBClusterIdentifier {
            try container.encode(newDBClusterIdentifier, forKey: ClientRuntime.Key("NewDBClusterIdentifier"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterOutputError>
}

public struct ModifyDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterOutputError>
}

public struct ModifyDBClusterInput: Swift.Equatable {
    /// <p>A value that specifies whether the modifications in this request and any pending
    ///       modifications are asynchronously applied as soon as possible, regardless of the
    ///       <code>PreferredMaintenanceWindow</code> setting for the DB cluster. If this parameter is set
    ///       to <code>false</code>, changes to the DB cluster are applied during the next maintenance
    ///       window.</p>
    ///          <p>The <code>ApplyImmediately</code> parameter only affects <code>NewDBClusterIdentifier</code>
    ///       values. If you set the <code>ApplyImmediately</code> parameter value to false, then changes to
    ///       <code>NewDBClusterIdentifier</code> values are applied during the next maintenance window.
    ///       All other changes are applied immediately, regardless of the value of the
    ///       <code>ApplyImmediately</code> parameter.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let applyImmediately: Swift.Bool
    /// <p>The number of days for which automated backups are retained. You must specify a minimum
    ///       value of 1.</p>
    ///          <p>Default: 1</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be a value from 1 to 35</p>
    ///             </li>
    ///          </ul>
    public let backupRetentionPeriod: Swift.Int?
    /// <p>The configuration setting for the log types to be enabled for export to CloudWatch Logs
    ///       for a specific DB cluster.</p>
    public let cloudwatchLogsExportConfiguration: NeptuneClientTypes.CloudwatchLogsExportConfiguration?
    /// <p>
    ///             <i>If set to <code>true</code>, tags are copied to any snapshot of
    ///       the DB cluster that is created.</i>
    ///          </p>
    public let copyTagsToSnapshot: Swift.Bool?
    /// <p>The DB cluster identifier for the cluster being modified. This parameter is not
    ///       case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBCluster.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: Swift.String?
    /// <p>The name of the DB cluster parameter group to use for the DB cluster.</p>
    public let dBClusterParameterGroupName: Swift.String?
    /// <p>A value that indicates whether the DB cluster has deletion protection enabled.
    ///       The database can't be deleted when deletion protection is enabled. By default,
    ///       deletion protection is disabled.</p>
    public let deletionProtection: Swift.Bool?
    /// <p>True to enable mapping of Amazon Identity and Access Management (IAM) accounts to database
    ///       accounts, and otherwise false.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Swift.Bool?
    /// <p>The version number of the database engine to which you want to upgrade. Changing this
    ///       parameter results in an outage. The change is applied during the next maintenance window
    ///       unless the <code>ApplyImmediately</code> parameter is set to true.</p>
    ///          <p>For a list of valid engine versions, see <a href="https://docs.aws.amazon.com/neptune/latest/userguide/engine-releases.html">Engine Releases for Amazon
    ///       Neptune</a>, or call <a href="https://docs.aws.amazon.com/neptune/latest/userguide/api-other-apis.html#DescribeDBEngineVersions">DescribeDBEngineVersions</a>.</p>
    public let engineVersion: Swift.String?
    /// <p>Not supported by Neptune.</p>
    public let masterUserPassword: Swift.String?
    /// <p>The new DB cluster identifier for the DB cluster when renaming a DB cluster. This value is
    ///       stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>The first character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-cluster2</code>
    ///          </p>
    public let newDBClusterIdentifier: Swift.String?
    /// <p>
    ///             <i>Not supported by Neptune.</i>
    ///          </p>
    public let optionGroupName: Swift.String?
    /// <p>The port number on which the DB cluster accepts connections.</p>
    ///          <p>Constraints: Value must be <code>1150-65535</code>
    ///          </p>
    ///          <p>Default: The same port as the original DB cluster.</p>
    public let port: Swift.Int?
    /// <p>The daily time range during which automated backups are created if automated backups are
    ///       enabled, using the <code>BackupRetentionPeriod</code> parameter.</p>
    ///          <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    ///       Amazon Region.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be in the format <code>hh24:mi-hh24:mi</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be in Universal Coordinated Time (UTC).</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not conflict with the preferred maintenance window.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be at least 30 minutes.</p>
    ///             </li>
    ///          </ul>
    public let preferredBackupWindow: Swift.String?
    /// <p>The weekly time range during which system maintenance can occur, in Universal Coordinated
    ///       Time (UTC).</p>
    ///          <p>Format: <code>ddd:hh24:mi-ddd:hh24:mi</code>
    ///          </p>
    ///          <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    ///       Amazon Region, occurring on a random day of the
    ///       week.</p>
    ///          <p>Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
    ///          <p>Constraints: Minimum 30-minute window.</p>
    public let preferredMaintenanceWindow: Swift.String?
    /// <p>A list of VPC security groups that the DB cluster will belong to.</p>
    public let vpcSecurityGroupIds: [Swift.String]?

    public init (
        applyImmediately: Swift.Bool = false,
        backupRetentionPeriod: Swift.Int? = nil,
        cloudwatchLogsExportConfiguration: NeptuneClientTypes.CloudwatchLogsExportConfiguration? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterParameterGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        engineVersion: Swift.String? = nil,
        masterUserPassword: Swift.String? = nil,
        newDBClusterIdentifier: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.applyImmediately = applyImmediately
        self.backupRetentionPeriod = backupRetentionPeriod
        self.cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.deletionProtection = deletionProtection
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engineVersion = engineVersion
        self.masterUserPassword = masterUserPassword
        self.newDBClusterIdentifier = newDBClusterIdentifier
        self.optionGroupName = optionGroupName
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension ModifyDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFoundFault" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupStateFault" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension ModifyDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct ModifyDBClusterOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: NeptuneClientTypes.DBCluster?

    public init (
        dBCluster: NeptuneClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct ModifyDBClusterOutputResponseBody: Swift.Equatable {
    public let dBCluster: NeptuneClientTypes.DBCluster?
}

extension ModifyDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct ModifyDBClusterParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterParameterGroupOutputError>
}

extension ModifyDBClusterParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterParameterGroupInput(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), parameters: \(Swift.String(describing: parameters)))"}
}

extension ModifyDBClusterParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBClusterParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterParameterGroupOutputError>
}

public struct ModifyDBClusterParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterParameterGroupOutputError>
}

public struct ModifyDBClusterParameterGroupInput: Swift.Equatable {
    /// <p>The name of the DB cluster parameter group to modify.</p>
    public let dBClusterParameterGroupName: Swift.String?
    /// <p>A list of parameters in the DB cluster parameter group to modify.</p>
    public let parameters: [NeptuneClientTypes.Parameter]?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil,
        parameters: [NeptuneClientTypes.Parameter]? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.parameters = parameters
    }
}

extension ModifyDBClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterParameterGroupOutputResponse(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)))"}
}

extension ModifyDBClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterParameterGroupName = output.dBClusterParameterGroupName
        } else {
            self.dBClusterParameterGroupName = nil
        }
    }
}

public struct ModifyDBClusterParameterGroupOutputResponse: Swift.Equatable {
    /// <p>The name of the DB cluster parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>This value is stored as a lowercase string.</p>
    ///          </note>
    public let dBClusterParameterGroupName: Swift.String?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
    }
}

struct ModifyDBClusterParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBClusterParameterGroupName: Swift.String?
}

extension ModifyDBClusterParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBClusterParameterGroupResult"))
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
    }
}

public struct ModifyDBClusterSnapshotAttributeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterSnapshotAttributeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterSnapshotAttributeOutputError>
}

extension ModifyDBClusterSnapshotAttributeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterSnapshotAttributeInput(attributeName: \(Swift.String(describing: attributeName)), dBClusterSnapshotIdentifier: \(Swift.String(describing: dBClusterSnapshotIdentifier)), valuesToAdd: \(Swift.String(describing: valuesToAdd)), valuesToRemove: \(Swift.String(describing: valuesToRemove)))"}
}

extension ModifyDBClusterSnapshotAttributeInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        if let valuesToAdd = valuesToAdd {
            var valuesToAddContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValuesToAdd"))
            for (index0, string0) in valuesToAdd.enumerated() {
                try valuesToAddContainer.encode(string0, forKey: ClientRuntime.Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        if let valuesToRemove = valuesToRemove {
            var valuesToRemoveContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValuesToRemove"))
            for (index0, string0) in valuesToRemove.enumerated() {
                try valuesToRemoveContainer.encode(string0, forKey: ClientRuntime.Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBClusterSnapshotAttribute", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBClusterSnapshotAttributeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterSnapshotAttributeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterSnapshotAttributeOutputError>
}

public struct ModifyDBClusterSnapshotAttributeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterSnapshotAttributeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterSnapshotAttributeOutputError>
}

public struct ModifyDBClusterSnapshotAttributeInput: Swift.Equatable {
    /// <p>The name of the DB cluster snapshot attribute to modify.</p>
    ///          <p>To manage authorization for other Amazon accounts to copy or restore a manual DB cluster
    ///       snapshot, set this value to <code>restore</code>.</p>
    public let attributeName: Swift.String?
    /// <p>The identifier for the DB cluster snapshot to modify the attributes for.</p>
    public let dBClusterSnapshotIdentifier: Swift.String?
    /// <p>A list of DB cluster snapshot attributes to add to the attribute specified by
    ///       <code>AttributeName</code>.</p>
    ///          <p>To authorize other Amazon accounts to copy or restore a manual DB cluster snapshot, set this
    ///       list to include one or more Amazon account IDs, or <code>all</code> to make the manual DB cluster
    ///       snapshot restorable by any Amazon account. Do not add the <code>all</code> value for any manual
    ///       DB cluster snapshots that contain private information that you don't want available to all AWS
    ///       accounts.</p>
    public let valuesToAdd: [Swift.String]?
    /// <p>A list of DB cluster snapshot attributes to remove from the attribute specified by
    ///       <code>AttributeName</code>.</p>
    ///          <p>To remove authorization for other Amazon accounts to copy or restore a manual DB cluster
    ///       snapshot, set this list to include one or more Amazon account identifiers, or <code>all</code> to
    ///       remove authorization for any Amazon account to copy or restore the DB cluster snapshot. If you
    ///       specify <code>all</code>, an Amazon account whose account ID is explicitly added to the
    ///       <code>restore</code> attribute can still copy or restore a manual DB cluster snapshot.</p>
    public let valuesToRemove: [Swift.String]?

    public init (
        attributeName: Swift.String? = nil,
        dBClusterSnapshotIdentifier: Swift.String? = nil,
        valuesToAdd: [Swift.String]? = nil,
        valuesToRemove: [Swift.String]? = nil
    )
    {
        self.attributeName = attributeName
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.valuesToAdd = valuesToAdd
        self.valuesToRemove = valuesToRemove
    }
}

extension ModifyDBClusterSnapshotAttributeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterSnapshotAttributeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SharedSnapshotQuotaExceededFault" : self = .sharedSnapshotQuotaExceededFault(try SharedSnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterSnapshotAttributeOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case sharedSnapshotQuotaExceededFault(SharedSnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterSnapshotAttributeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterSnapshotAttributeOutputResponse(dBClusterSnapshotAttributesResult: \(Swift.String(describing: dBClusterSnapshotAttributesResult)))"}
}

extension ModifyDBClusterSnapshotAttributeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBClusterSnapshotAttributeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshotAttributesResult = output.dBClusterSnapshotAttributesResult
        } else {
            self.dBClusterSnapshotAttributesResult = nil
        }
    }
}

public struct ModifyDBClusterSnapshotAttributeOutputResponse: Swift.Equatable {
    /// <p>Contains the results of a successful call to the <a>DescribeDBClusterSnapshotAttributes</a> API action.</p>
    ///          <p>Manual DB cluster snapshot attributes are used to authorize other Amazon accounts to copy or
    ///       restore a manual DB cluster snapshot. For more information, see the <a>ModifyDBClusterSnapshotAttribute</a> API action.</p>
    public let dBClusterSnapshotAttributesResult: NeptuneClientTypes.DBClusterSnapshotAttributesResult?

    public init (
        dBClusterSnapshotAttributesResult: NeptuneClientTypes.DBClusterSnapshotAttributesResult? = nil
    )
    {
        self.dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResult
    }
}

struct ModifyDBClusterSnapshotAttributeOutputResponseBody: Swift.Equatable {
    public let dBClusterSnapshotAttributesResult: NeptuneClientTypes.DBClusterSnapshotAttributesResult?
}

extension ModifyDBClusterSnapshotAttributeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshotAttributesResult = "DBClusterSnapshotAttributesResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBClusterSnapshotAttributeResult"))
        let dBClusterSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBClusterSnapshotAttributesResult.self, forKey: .dBClusterSnapshotAttributesResult)
        dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResultDecoded
    }
}

public struct ModifyDBInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBInstanceOutputError>
}

extension ModifyDBInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBInstanceInput(allocatedStorage: \(Swift.String(describing: allocatedStorage)), allowMajorVersionUpgrade: \(Swift.String(describing: allowMajorVersionUpgrade)), applyImmediately: \(Swift.String(describing: applyImmediately)), autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), cACertificateIdentifier: \(Swift.String(describing: cACertificateIdentifier)), cloudwatchLogsExportConfiguration: \(Swift.String(describing: cloudwatchLogsExportConfiguration)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), dBPortNumber: \(Swift.String(describing: dBPortNumber)), dBSecurityGroups: \(Swift.String(describing: dBSecurityGroups)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), deletionProtection: \(Swift.String(describing: deletionProtection)), domain: \(Swift.String(describing: domain)), domainIAMRoleName: \(Swift.String(describing: domainIAMRoleName)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), enablePerformanceInsights: \(Swift.String(describing: enablePerformanceInsights)), engineVersion: \(Swift.String(describing: engineVersion)), iops: \(Swift.String(describing: iops)), licenseModel: \(Swift.String(describing: licenseModel)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), monitoringInterval: \(Swift.String(describing: monitoringInterval)), monitoringRoleArn: \(Swift.String(describing: monitoringRoleArn)), multiAZ: \(Swift.String(describing: multiAZ)), newDBInstanceIdentifier: \(Swift.String(describing: newDBInstanceIdentifier)), optionGroupName: \(Swift.String(describing: optionGroupName)), performanceInsightsKMSKeyId: \(Swift.String(describing: performanceInsightsKMSKeyId)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), promotionTier: \(Swift.String(describing: promotionTier)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), storageType: \(Swift.String(describing: storageType)), tdeCredentialArn: \(Swift.String(describing: tdeCredentialArn)), tdeCredentialPassword: \(Swift.String(describing: tdeCredentialPassword)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyDBInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if allowMajorVersionUpgrade != false {
            try container.encode(allowMajorVersionUpgrade, forKey: ClientRuntime.Key("AllowMajorVersionUpgrade"))
        }
        if applyImmediately != false {
            try container.encode(applyImmediately, forKey: ClientRuntime.Key("ApplyImmediately"))
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try container.encode(cACertificateIdentifier, forKey: ClientRuntime.Key("CACertificateIdentifier"))
        }
        if let cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration {
            try container.encode(cloudwatchLogsExportConfiguration, forKey: ClientRuntime.Key("CloudwatchLogsExportConfiguration"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let dBPortNumber = dBPortNumber {
            try container.encode(dBPortNumber, forKey: ClientRuntime.Key("DBPortNumber"))
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSecurityGroups"))
            for (index0, string0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(string0, forKey: ClientRuntime.Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: ClientRuntime.Key("EnablePerformanceInsights"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let newDBInstanceIdentifier = newDBInstanceIdentifier {
            try container.encode(newDBInstanceIdentifier, forKey: ClientRuntime.Key("NewDBInstanceIdentifier"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: ClientRuntime.Key("PromotionTier"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: ClientRuntime.Key("TdeCredentialPassword"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBInstanceOutputError>
}

public struct ModifyDBInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBInstanceOutputError>
}

public struct ModifyDBInstanceInput: Swift.Equatable {
    /// <p>Not supported by Neptune.</p>
    public let allocatedStorage: Swift.Int?
    /// <p>Indicates that major version upgrades are allowed. Changing this parameter doesn't result
    ///       in an outage and the change is asynchronously applied as soon as possible.</p>
    public let allowMajorVersionUpgrade: Swift.Bool
    /// <p>Specifies whether the modifications in this request and any pending modifications are
    ///       asynchronously applied as soon as possible, regardless of the
    ///       <code>PreferredMaintenanceWindow</code> setting for the DB instance.</p>
    ///          <p> If this parameter is set to <code>false</code>, changes to the DB instance are applied
    ///       during the next maintenance window. Some parameter changes can cause an outage and are applied
    ///       on the next call to <a>RebootDBInstance</a>, or the next
    ///       failure reboot.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let applyImmediately: Swift.Bool
    /// <p> Indicates that minor version upgrades are applied automatically to the DB instance during
    ///       the maintenance window. Changing this parameter doesn't result in an outage except in the
    ///       following case and the change is asynchronously applied as soon as possible. An outage will
    ///       result if this parameter is set to <code>true</code> during the maintenance window, and a
    ///       newer minor version is available, and Neptune has enabled auto patching for that engine
    ///       version.</p>
    public let autoMinorVersionUpgrade: Swift.Bool?
    /// <p>Not applicable. The retention period for automated backups is managed by the DB cluster.
    ///       For more information, see <a>ModifyDBCluster</a>.</p>
    ///          <p>Default: Uses existing setting</p>
    public let backupRetentionPeriod: Swift.Int?
    /// <p>Indicates the certificate that needs to be associated with the instance.</p>
    public let cACertificateIdentifier: Swift.String?
    /// <p>The configuration setting for the log types to be enabled for export to CloudWatch Logs
    ///       for a specific DB instance or DB cluster.</p>
    public let cloudwatchLogsExportConfiguration: NeptuneClientTypes.CloudwatchLogsExportConfiguration?
    /// <p>True to copy all tags from the DB instance to snapshots of the DB instance, and otherwise
    ///       false. The default is false.</p>
    public let copyTagsToSnapshot: Swift.Bool?
    /// <p>The new compute and memory capacity of the DB instance, for example,
    ///       <code>db.m4.large</code>. Not all DB instance classes are available in all AWS
    ///       Regions.</p>
    ///          <p>If you modify the DB instance class, an outage occurs during the change. The change is
    ///       applied during the next maintenance window, unless <code>ApplyImmediately</code> is specified
    ///       as <code>true</code> for this request.</p>
    ///          <p>Default: Uses existing setting</p>
    public let dBInstanceClass: Swift.String?
    /// <p>The DB instance identifier. This value is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBInstance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: Swift.String?
    /// <p>The name of the DB parameter group to apply to the DB instance. Changing this setting
    ///       doesn't result in an outage. The parameter group name itself is changed immediately, but the
    ///       actual parameter changes are not applied until you reboot the instance without failover. The
    ///       db instance will NOT be rebooted automatically and the parameter changes will NOT be applied
    ///       during the next maintenance window.</p>
    ///          <p>Default: Uses existing setting</p>
    ///          <p>Constraints: The DB parameter group must be in the same DB parameter group family as this
    ///       DB instance.</p>
    public let dBParameterGroupName: Swift.String?
    /// <p>The port number on which the database accepts connections.</p>
    ///          <p>The value of the <code>DBPortNumber</code> parameter must not match any of the port values
    ///       specified for options in the option group for the DB instance.</p>
    ///          <p>Your database will restart when you change the <code>DBPortNumber</code> value regardless
    ///       of the value of the <code>ApplyImmediately</code> parameter.</p>
    ///          <p> Default: <code>8182</code>
    ///          </p>
    public let dBPortNumber: Swift.Int?
    /// <p>A list of DB security groups to authorize on this DB instance. Changing this setting
    ///       doesn't result in an outage and the change is asynchronously applied as soon as
    ///       possible.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match existing DBSecurityGroups.</p>
    ///             </li>
    ///          </ul>
    public let dBSecurityGroups: [Swift.String]?
    /// <p>The new DB subnet group for the DB instance. You can use this parameter to move your DB
    ///       instance to a different VPC.</p>
    ///          <p>Changing the subnet group causes an outage during the change. The change is applied during
    ///       the next maintenance window, unless you specify <code>true</code> for the
    ///       <code>ApplyImmediately</code> parameter.</p>
    ///          <p>Constraints: If supplied, must match the name of an existing DBSubnetGroup.</p>
    ///          <p>Example: <code>mySubnetGroup</code>
    ///          </p>
    public let dBSubnetGroupName: Swift.String?
    /// <p>A value that indicates whether the DB instance has deletion protection enabled.
    ///       The database can't be deleted when deletion protection is enabled. By default,
    ///       deletion protection is disabled.  See <a href="https://docs.aws.amazon.com/neptune/latest/userguide/manage-console-instances-delete.html">Deleting
    ///       a DB Instance</a>.</p>
    public let deletionProtection: Swift.Bool?
    /// <p>Not supported.</p>
    public let domain: Swift.String?
    /// <p>Not supported</p>
    public let domainIAMRoleName: Swift.String?
    /// <p>True to enable mapping of Amazon Identity and Access Management (IAM) accounts to database
    ///       accounts, and otherwise false.</p>
    ///          <p>You can enable IAM database authentication for the following database engines</p>
    ///          <p>Not applicable. Mapping Amazon IAM accounts to database accounts is managed by the DB
    ///       cluster. For more information, see <a>ModifyDBCluster</a>.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Swift.Bool?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let enablePerformanceInsights: Swift.Bool?
    /// <p>The version number of the database engine to upgrade to. Currently, setting this
    ///       parameter has no effect. To upgrade your database engine to the most recent release,
    ///       use the <a>ApplyPendingMaintenanceAction</a> API.</p>
    public let engineVersion: Swift.String?
    /// <p>The new Provisioned IOPS (I/O operations per second) value for the instance.</p>
    ///          <p>Changing this setting doesn't result in an outage and the change is applied during the
    ///       next maintenance window unless the <code>ApplyImmediately</code> parameter is set to
    ///       <code>true</code> for this request.</p>
    ///          <p>Default: Uses existing setting</p>
    public let iops: Swift.Int?
    /// <p>Not supported by Neptune.</p>
    public let licenseModel: Swift.String?
    /// <p>Not supported by Neptune.</p>
    public let masterUserPassword: Swift.String?
    /// <p>The interval, in seconds, between points when Enhanced Monitoring metrics are collected
    ///       for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default
    ///       is 0.</p>
    ///          <p>If <code>MonitoringRoleArn</code> is specified, then you must also set
    ///       <code>MonitoringInterval</code> to a value other than 0.</p>
    ///          <p>Valid Values: <code>0, 1, 5, 10, 15, 30, 60</code>
    ///          </p>
    public let monitoringInterval: Swift.Int?
    /// <p>The ARN for the IAM role that permits Neptune to send enhanced monitoring metrics to
    ///       Amazon CloudWatch Logs. For example, <code>arn:aws:iam:123456789012:role/emaccess</code>.</p>
    ///          <p>If <code>MonitoringInterval</code> is set to a value other than 0, then you must supply a
    ///       <code>MonitoringRoleArn</code> value.</p>
    public let monitoringRoleArn: Swift.String?
    /// <p>Specifies if the DB instance is a Multi-AZ deployment. Changing this parameter doesn't
    ///       result in an outage and the change is applied during the next maintenance window unless the
    ///       <code>ApplyImmediately</code> parameter is set to <code>true</code> for this request.</p>
    public let multiAZ: Swift.Bool?
    /// <p> The new DB instance identifier for the DB instance when renaming a DB instance. When you
    ///       change the DB instance identifier, an instance reboot will occur immediately if you set
    ///       <code>Apply Immediately</code> to true, or will occur during the next maintenance window if
    ///       <code>Apply Immediately</code> to false. This value is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>The first character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>mydbinstance</code>
    ///          </p>
    public let newDBInstanceIdentifier: Swift.String?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let optionGroupName: Swift.String?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let performanceInsightsKMSKeyId: Swift.String?
    /// <p> The daily time range during which automated backups are created if automated backups are
    ///       enabled.</p>
    ///          <p>Not applicable. The daily time range for creating automated backups is managed by the DB
    ///       cluster. For more information, see <a>ModifyDBCluster</a>.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be in the format hh24:mi-hh24:mi</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be in Universal Time Coordinated (UTC)</p>
    ///             </li>
    ///             <li>
    ///                <p>Must not conflict with the preferred maintenance window</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be at least 30 minutes</p>
    ///             </li>
    ///          </ul>
    public let preferredBackupWindow: Swift.String?
    /// <p>The weekly time range (in UTC) during which system maintenance can occur, which might
    ///       result in an outage. Changing this parameter doesn't result in an outage, except in the
    ///       following situation, and the change is asynchronously applied as soon as possible. If there
    ///       are pending actions that cause a reboot, and the maintenance window is changed to include the
    ///       current time, then changing this parameter will cause a reboot of the DB instance. If moving
    ///       this window to the current time, there must be at least 30 minutes between the current time
    ///       and end of the window to ensure pending changes are applied.</p>
    ///          <p>Default: Uses existing setting</p>
    ///          <p>Format: ddd:hh24:mi-ddd:hh24:mi</p>
    ///          <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
    ///          <p>Constraints: Must be at least 30 minutes</p>
    public let preferredMaintenanceWindow: Swift.String?
    /// <p>A value that specifies the order in which a Read Replica is promoted to the primary
    ///       instance after a failure of the existing primary instance.</p>
    ///          <p>Default: 1</p>
    ///          <p>Valid Values: 0 - 15</p>
    public let promotionTier: Swift.Int?
    /// <p>This flag should no longer be used.</p>
    @available(*, deprecated)
    public let publiclyAccessible: Swift.Bool?
    /// <p>Not supported.</p>
    public let storageType: Swift.String?
    /// <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
    public let tdeCredentialArn: Swift.String?
    /// <p>The password for the given ARN from the key store in order to access the device.</p>
    public let tdeCredentialPassword: Swift.String?
    /// <p>A list of EC2 VPC security groups to authorize on this DB instance. This change is
    ///       asynchronously applied as soon as possible.</p>
    ///          <p>Not applicable. The associated list of EC2 VPC security groups is managed by the DB
    ///       cluster. For more information, see <a>ModifyDBCluster</a>.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match existing VpcSecurityGroupIds.</p>
    ///             </li>
    ///          </ul>
    public let vpcSecurityGroupIds: [Swift.String]?

    public init (
        allocatedStorage: Swift.Int? = nil,
        allowMajorVersionUpgrade: Swift.Bool = false,
        applyImmediately: Swift.Bool = false,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        backupRetentionPeriod: Swift.Int? = nil,
        cACertificateIdentifier: Swift.String? = nil,
        cloudwatchLogsExportConfiguration: NeptuneClientTypes.CloudwatchLogsExportConfiguration? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBInstanceClass: Swift.String? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        dBPortNumber: Swift.Int? = nil,
        dBSecurityGroups: [Swift.String]? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        enablePerformanceInsights: Swift.Bool? = nil,
        engineVersion: Swift.String? = nil,
        iops: Swift.Int? = nil,
        licenseModel: Swift.String? = nil,
        masterUserPassword: Swift.String? = nil,
        monitoringInterval: Swift.Int? = nil,
        monitoringRoleArn: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        newDBInstanceIdentifier: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        performanceInsightsKMSKeyId: Swift.String? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        promotionTier: Swift.Int? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        storageType: Swift.String? = nil,
        tdeCredentialArn: Swift.String? = nil,
        tdeCredentialPassword: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.applyImmediately = applyImmediately
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.backupRetentionPeriod = backupRetentionPeriod
        self.cACertificateIdentifier = cACertificateIdentifier
        self.cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBParameterGroupName = dBParameterGroupName
        self.dBPortNumber = dBPortNumber
        self.dBSecurityGroups = dBSecurityGroups
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.engineVersion = engineVersion
        self.iops = iops
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.newDBInstanceIdentifier = newDBInstanceIdentifier
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.promotionTier = promotionTier
        self.publiclyAccessible = publiclyAccessible
        self.storageType = storageType
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension ModifyDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFoundFault" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateNotFoundFault" : self = .certificateNotFoundFault(try CertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExistsFault" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFoundFault" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBUpgradeDependencyFailureFault" : self = .dBUpgradeDependencyFailureFault(try DBUpgradeDependencyFailureFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacityFault" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupStateFault" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupportedFault" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case certificateNotFoundFault(CertificateNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBUpgradeDependencyFailureFault(DBUpgradeDependencyFailureFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBInstanceOutputResponse(dBInstance: \(Swift.String(describing: dBInstance)))"}
}

extension ModifyDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct ModifyDBInstanceOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB instance.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBInstances</a> action.</p>
    public let dBInstance: NeptuneClientTypes.DBInstance?

    public init (
        dBInstance: NeptuneClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct ModifyDBInstanceOutputResponseBody: Swift.Equatable {
    public let dBInstance: NeptuneClientTypes.DBInstance?
}

extension ModifyDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct ModifyDBParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBParameterGroupOutputError>
}

extension ModifyDBParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBParameterGroupInput(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), parameters: \(Swift.String(describing: parameters)))"}
}

extension ModifyDBParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBParameterGroupOutputError>
}

public struct ModifyDBParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBParameterGroupOutputError>
}

public struct ModifyDBParameterGroupInput: Swift.Equatable {
    /// <p>The name of the DB parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: Swift.String?
    /// <p>An array of parameter names, values, and the apply method for the parameter update. At
    ///       least one parameter name, value, and apply method must be supplied; subsequent arguments are
    ///       optional. A maximum of 20 parameters can be modified in a single request.</p>
    ///          <p>Valid Values (for the application method): <code>immediate | pending-reboot</code>
    ///          </p>
    ///          <note>
    ///             <p>You can use the immediate value with dynamic parameters only. You can use the
    ///         pending-reboot value for both dynamic and static parameters, and changes are applied when
    ///         you reboot the DB instance without failover.</p>
    ///          </note>
    public let parameters: [NeptuneClientTypes.Parameter]?

    public init (
        dBParameterGroupName: Swift.String? = nil,
        parameters: [NeptuneClientTypes.Parameter]? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.parameters = parameters
    }
}

extension ModifyDBParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBParameterGroupOutputResponse(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)))"}
}

extension ModifyDBParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBParameterGroupName = output.dBParameterGroupName
        } else {
            self.dBParameterGroupName = nil
        }
    }
}

public struct ModifyDBParameterGroupOutputResponse: Swift.Equatable {
    /// <p>Provides the name of the DB parameter group.</p>
    public let dBParameterGroupName: Swift.String?

    public init (
        dBParameterGroupName: Swift.String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
    }
}

struct ModifyDBParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBParameterGroupName: Swift.String?
}

extension ModifyDBParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBParameterGroupResult"))
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
    }
}

public struct ModifyDBSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBSubnetGroupOutputError>
}

extension ModifyDBSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBSubnetGroupInput(dBSubnetGroupDescription: \(Swift.String(describing: dBSubnetGroupDescription)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), subnetIds: \(Swift.String(describing: subnetIds)))"}
}

extension ModifyDBSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSubnetGroupDescription = dBSubnetGroupDescription {
            try container.encode(dBSubnetGroupDescription, forKey: ClientRuntime.Key("DBSubnetGroupDescription"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SubnetIds"))
            for (index0, string0) in subnetIds.enumerated() {
                try subnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("SubnetIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBSubnetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBSubnetGroupOutputError>
}

public struct ModifyDBSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBSubnetGroupOutputError>
}

public struct ModifyDBSubnetGroupInput: Swift.Equatable {
    /// <p>The description for the DB subnet group.</p>
    public let dBSubnetGroupDescription: Swift.String?
    /// <p>The name for the DB subnet group. This value is stored as a lowercase string. You can't
    ///       modify the default subnet group.</p>
    ///          <p>Constraints: Must match the name of an existing DBSubnetGroup. Must not be default.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: Swift.String?
    /// <p>The EC2 subnet IDs for the DB subnet group.</p>
    public let subnetIds: [Swift.String]?

    public init (
        dBSubnetGroupDescription: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.dBSubnetGroupDescription = dBSubnetGroupDescription
        self.dBSubnetGroupName = dBSubnetGroupName
        self.subnetIds = subnetIds
    }
}

extension ModifyDBSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetQuotaExceededFault" : self = .dBSubnetQuotaExceededFault(try DBSubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetAlreadyInUse" : self = .subnetAlreadyInUse(try SubnetAlreadyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case dBSubnetQuotaExceededFault(DBSubnetQuotaExceededFault)
    case invalidSubnet(InvalidSubnet)
    case subnetAlreadyInUse(SubnetAlreadyInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBSubnetGroupOutputResponse(dBSubnetGroup: \(Swift.String(describing: dBSubnetGroup)))"}
}

extension ModifyDBSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSubnetGroup = output.dBSubnetGroup
        } else {
            self.dBSubnetGroup = nil
        }
    }
}

public struct ModifyDBSubnetGroupOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB subnet group.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBSubnetGroups</a> action.</p>
    public let dBSubnetGroup: NeptuneClientTypes.DBSubnetGroup?

    public init (
        dBSubnetGroup: NeptuneClientTypes.DBSubnetGroup? = nil
    )
    {
        self.dBSubnetGroup = dBSubnetGroup
    }
}

struct ModifyDBSubnetGroupOutputResponseBody: Swift.Equatable {
    public let dBSubnetGroup: NeptuneClientTypes.DBSubnetGroup?
}

extension ModifyDBSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroup = "DBSubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBSubnetGroupResult"))
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBSubnetGroup.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
    }
}

public struct ModifyEventSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEventSubscriptionOutputError>
}

extension ModifyEventSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyEventSubscriptionInput(enabled: \(Swift.String(describing: enabled)), eventCategories: \(Swift.String(describing: eventCategories)), snsTopicArn: \(Swift.String(describing: snsTopicArn)), sourceType: \(Swift.String(describing: sourceType)), subscriptionName: \(Swift.String(describing: subscriptionName)))"}
}

extension ModifyEventSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: ClientRuntime.Key("SnsTopicArn"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("ModifyEventSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyEventSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEventSubscriptionOutputError>
}

public struct ModifyEventSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEventSubscriptionOutputError>
}

public struct ModifyEventSubscriptionInput: Swift.Equatable {
    /// <p> A Boolean value; set to <b>true</b> to activate the
    ///       subscription.</p>
    public let enabled: Swift.Bool?
    /// <p> A list of event categories for a SourceType that you want to subscribe to. You can see a
    ///       list of the categories for a given SourceType
    ///
    ///       by using the <b>DescribeEventCategories</b> action.</p>
    public let eventCategories: [Swift.String]?
    /// <p>The Amazon Resource Name (ARN) of the SNS topic created for event notification. The ARN is
    ///       created by Amazon SNS when you create a topic and subscribe to it.</p>
    public let snsTopicArn: Swift.String?
    /// <p>The type of source that is generating the events. For example, if you want to be notified
    ///       of events generated by a DB instance, you would set this parameter to db-instance. if this
    ///       value is not specified, all events are returned.</p>
    ///          <p>Valid values: db-instance | db-parameter-group | db-security-group | db-snapshot</p>
    public let sourceType: Swift.String?
    /// <p>The name of the event notification subscription.</p>
    public let subscriptionName: Swift.String?

    public init (
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
    }
}

extension ModifyEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EventSubscriptionQuotaExceededFault" : self = .eventSubscriptionQuotaExceededFault(try EventSubscriptionQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSTopicArnNotFoundFault" : self = .sNSTopicArnNotFoundFault(try SNSTopicArnNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionCategoryNotFoundFault" : self = .subscriptionCategoryNotFoundFault(try SubscriptionCategoryNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case eventSubscriptionQuotaExceededFault(EventSubscriptionQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case sNSTopicArnNotFoundFault(SNSTopicArnNotFoundFault)
    case subscriptionCategoryNotFoundFault(SubscriptionCategoryNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyEventSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyEventSubscriptionOutputResponse(eventSubscription: \(Swift.String(describing: eventSubscription)))"}
}

extension ModifyEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct ModifyEventSubscriptionOutputResponse: Swift.Equatable {
    /// <p>Contains the results of a successful invocation of the <a>DescribeEventSubscriptions</a> action.</p>
    public let eventSubscription: NeptuneClientTypes.EventSubscription?

    public init (
        eventSubscription: NeptuneClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct ModifyEventSubscriptionOutputResponseBody: Swift.Equatable {
    public let eventSubscription: NeptuneClientTypes.EventSubscription?
}

extension ModifyEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

extension NeptuneClientTypes.OptionGroupMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optionGroupName = "OptionGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension NeptuneClientTypes.OptionGroupMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptionGroupMembership(optionGroupName: \(Swift.String(describing: optionGroupName)), status: \(Swift.String(describing: status)))"}
}

extension NeptuneClientTypes {
    /// <p>Not supported by Neptune.</p>
    public struct OptionGroupMembership: Swift.Equatable {
        /// <p>Not supported by Neptune.</p>
        public let optionGroupName: Swift.String?
        /// <p>Not supported by Neptune.</p>
        public let status: Swift.String?

        public init (
            optionGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.optionGroupName = optionGroupName
            self.status = status
        }
    }

}

extension OptionGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptionGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension OptionGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<OptionGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The designated option group could not be found.</p>
public struct OptionGroupNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OptionGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OptionGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.OrderableDBInstanceOption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case dBInstanceClass = "DBInstanceClass"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case licenseModel = "LicenseModel"
        case maxIopsPerDbInstance = "MaxIopsPerDbInstance"
        case maxIopsPerGib = "MaxIopsPerGib"
        case maxStorageSize = "MaxStorageSize"
        case minIopsPerDbInstance = "MinIopsPerDbInstance"
        case minIopsPerGib = "MinIopsPerGib"
        case minStorageSize = "MinStorageSize"
        case multiAZCapable = "MultiAZCapable"
        case readReplicaCapable = "ReadReplicaCapable"
        case storageType = "StorageType"
        case supportsEnhancedMonitoring = "SupportsEnhancedMonitoring"
        case supportsIAMDatabaseAuthentication = "SupportsIAMDatabaseAuthentication"
        case supportsIops = "SupportsIops"
        case supportsPerformanceInsights = "SupportsPerformanceInsights"
        case supportsStorageEncryption = "SupportsStorageEncryption"
        case vpc = "Vpc"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let maxIopsPerDbInstance = maxIopsPerDbInstance {
            try container.encode(maxIopsPerDbInstance, forKey: ClientRuntime.Key("MaxIopsPerDbInstance"))
        }
        if let maxIopsPerGib = maxIopsPerGib {
            try container.encode(maxIopsPerGib, forKey: ClientRuntime.Key("MaxIopsPerGib"))
        }
        if let maxStorageSize = maxStorageSize {
            try container.encode(maxStorageSize, forKey: ClientRuntime.Key("MaxStorageSize"))
        }
        if let minIopsPerDbInstance = minIopsPerDbInstance {
            try container.encode(minIopsPerDbInstance, forKey: ClientRuntime.Key("MinIopsPerDbInstance"))
        }
        if let minIopsPerGib = minIopsPerGib {
            try container.encode(minIopsPerGib, forKey: ClientRuntime.Key("MinIopsPerGib"))
        }
        if let minStorageSize = minStorageSize {
            try container.encode(minStorageSize, forKey: ClientRuntime.Key("MinStorageSize"))
        }
        if multiAZCapable != false {
            try container.encode(multiAZCapable, forKey: ClientRuntime.Key("MultiAZCapable"))
        }
        if readReplicaCapable != false {
            try container.encode(readReplicaCapable, forKey: ClientRuntime.Key("ReadReplicaCapable"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if supportsEnhancedMonitoring != false {
            try container.encode(supportsEnhancedMonitoring, forKey: ClientRuntime.Key("SupportsEnhancedMonitoring"))
        }
        if supportsIAMDatabaseAuthentication != false {
            try container.encode(supportsIAMDatabaseAuthentication, forKey: ClientRuntime.Key("SupportsIAMDatabaseAuthentication"))
        }
        if supportsIops != false {
            try container.encode(supportsIops, forKey: ClientRuntime.Key("SupportsIops"))
        }
        if supportsPerformanceInsights != false {
            try container.encode(supportsPerformanceInsights, forKey: ClientRuntime.Key("SupportsPerformanceInsights"))
        }
        if supportsStorageEncryption != false {
            try container.encode(supportsStorageEncryption, forKey: ClientRuntime.Key("SupportsStorageEncryption"))
        }
        if vpc != false {
            try container.encode(vpc, forKey: ClientRuntime.Key("Vpc"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([NeptuneClientTypes.AvailabilityZone].self, forKey: .member)
                var availabilityZonesBuffer:[NeptuneClientTypes.AvailabilityZone]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [NeptuneClientTypes.AvailabilityZone]()
                    for structureContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let multiAZCapableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .multiAZCapable)
        multiAZCapable = multiAZCapableDecoded
        let readReplicaCapableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .readReplicaCapable)
        readReplicaCapable = readReplicaCapableDecoded
        let vpcDecoded = try containerValues.decode(Swift.Bool.self, forKey: .vpc)
        vpc = vpcDecoded
        let supportsStorageEncryptionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsStorageEncryption)
        supportsStorageEncryption = supportsStorageEncryptionDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let supportsIopsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsIops)
        supportsIops = supportsIopsDecoded
        let supportsEnhancedMonitoringDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsEnhancedMonitoring)
        supportsEnhancedMonitoring = supportsEnhancedMonitoringDecoded
        let supportsIAMDatabaseAuthenticationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsIAMDatabaseAuthentication)
        supportsIAMDatabaseAuthentication = supportsIAMDatabaseAuthenticationDecoded
        let supportsPerformanceInsightsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsPerformanceInsights)
        supportsPerformanceInsights = supportsPerformanceInsightsDecoded
        let minStorageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minStorageSize)
        minStorageSize = minStorageSizeDecoded
        let maxStorageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxStorageSize)
        maxStorageSize = maxStorageSizeDecoded
        let minIopsPerDbInstanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minIopsPerDbInstance)
        minIopsPerDbInstance = minIopsPerDbInstanceDecoded
        let maxIopsPerDbInstanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxIopsPerDbInstance)
        maxIopsPerDbInstance = maxIopsPerDbInstanceDecoded
        let minIopsPerGibDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minIopsPerGib)
        minIopsPerGib = minIopsPerGibDecoded
        let maxIopsPerGibDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxIopsPerGib)
        maxIopsPerGib = maxIopsPerGibDecoded
    }
}

extension NeptuneClientTypes.OrderableDBInstanceOption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrderableDBInstanceOption(availabilityZones: \(Swift.String(describing: availabilityZones)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), licenseModel: \(Swift.String(describing: licenseModel)), maxIopsPerDbInstance: \(Swift.String(describing: maxIopsPerDbInstance)), maxIopsPerGib: \(Swift.String(describing: maxIopsPerGib)), maxStorageSize: \(Swift.String(describing: maxStorageSize)), minIopsPerDbInstance: \(Swift.String(describing: minIopsPerDbInstance)), minIopsPerGib: \(Swift.String(describing: minIopsPerGib)), minStorageSize: \(Swift.String(describing: minStorageSize)), multiAZCapable: \(Swift.String(describing: multiAZCapable)), readReplicaCapable: \(Swift.String(describing: readReplicaCapable)), storageType: \(Swift.String(describing: storageType)), supportsEnhancedMonitoring: \(Swift.String(describing: supportsEnhancedMonitoring)), supportsIAMDatabaseAuthentication: \(Swift.String(describing: supportsIAMDatabaseAuthentication)), supportsIops: \(Swift.String(describing: supportsIops)), supportsPerformanceInsights: \(Swift.String(describing: supportsPerformanceInsights)), supportsStorageEncryption: \(Swift.String(describing: supportsStorageEncryption)), vpc: \(Swift.String(describing: vpc)))"}
}

extension NeptuneClientTypes {
    /// <p>Contains a list of available options for a DB instance.</p>
    ///          <p> This data type is used as a response element in the <a>DescribeOrderableDBInstanceOptions</a> action.</p>
    public struct OrderableDBInstanceOption: Swift.Equatable {
        /// <p>A list of Availability Zones for a DB instance.</p>
        public let availabilityZones: [NeptuneClientTypes.AvailabilityZone]?
        /// <p>The DB instance class for a DB instance.</p>
        public let dBInstanceClass: Swift.String?
        /// <p>The engine type of a DB instance.</p>
        public let engine: Swift.String?
        /// <p>The engine version of a DB instance.</p>
        public let engineVersion: Swift.String?
        /// <p>The license model for a DB instance.</p>
        public let licenseModel: Swift.String?
        /// <p>Maximum total provisioned IOPS for a DB instance.</p>
        public let maxIopsPerDbInstance: Swift.Int?
        /// <p>Maximum provisioned IOPS per GiB for a DB instance.</p>
        public let maxIopsPerGib: Swift.Double?
        /// <p>Maximum storage size for a DB instance.</p>
        public let maxStorageSize: Swift.Int?
        /// <p>Minimum total provisioned IOPS for a DB instance.</p>
        public let minIopsPerDbInstance: Swift.Int?
        /// <p>Minimum provisioned IOPS per GiB for a DB instance.</p>
        public let minIopsPerGib: Swift.Double?
        /// <p>Minimum storage size for a DB instance.</p>
        public let minStorageSize: Swift.Int?
        /// <p>Indicates whether a DB instance is Multi-AZ capable.</p>
        public let multiAZCapable: Swift.Bool
        /// <p>Indicates whether a DB instance can have a Read Replica.</p>
        public let readReplicaCapable: Swift.Bool
        /// <p>Indicates the storage type for a DB instance.</p>
        public let storageType: Swift.String?
        /// <p>Indicates whether a DB instance supports Enhanced Monitoring at intervals from 1 to 60
        ///       seconds.</p>
        public let supportsEnhancedMonitoring: Swift.Bool
        /// <p>Indicates whether a DB instance supports IAM database authentication.</p>
        public let supportsIAMDatabaseAuthentication: Swift.Bool
        /// <p>Indicates whether a DB instance supports provisioned IOPS.</p>
        public let supportsIops: Swift.Bool
        /// <p>
        ///             <i>(Not supported by Neptune)</i>
        ///          </p>
        public let supportsPerformanceInsights: Swift.Bool
        /// <p>Indicates whether a DB instance supports encrypted storage.</p>
        public let supportsStorageEncryption: Swift.Bool
        /// <p>Indicates whether a DB instance is in a VPC.</p>
        public let vpc: Swift.Bool

        public init (
            availabilityZones: [NeptuneClientTypes.AvailabilityZone]? = nil,
            dBInstanceClass: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            maxIopsPerDbInstance: Swift.Int? = nil,
            maxIopsPerGib: Swift.Double? = nil,
            maxStorageSize: Swift.Int? = nil,
            minIopsPerDbInstance: Swift.Int? = nil,
            minIopsPerGib: Swift.Double? = nil,
            minStorageSize: Swift.Int? = nil,
            multiAZCapable: Swift.Bool = false,
            readReplicaCapable: Swift.Bool = false,
            storageType: Swift.String? = nil,
            supportsEnhancedMonitoring: Swift.Bool = false,
            supportsIAMDatabaseAuthentication: Swift.Bool = false,
            supportsIops: Swift.Bool = false,
            supportsPerformanceInsights: Swift.Bool = false,
            supportsStorageEncryption: Swift.Bool = false,
            vpc: Swift.Bool = false
        )
        {
            self.availabilityZones = availabilityZones
            self.dBInstanceClass = dBInstanceClass
            self.engine = engine
            self.engineVersion = engineVersion
            self.licenseModel = licenseModel
            self.maxIopsPerDbInstance = maxIopsPerDbInstance
            self.maxIopsPerGib = maxIopsPerGib
            self.maxStorageSize = maxStorageSize
            self.minIopsPerDbInstance = minIopsPerDbInstance
            self.minIopsPerGib = minIopsPerGib
            self.minStorageSize = minStorageSize
            self.multiAZCapable = multiAZCapable
            self.readReplicaCapable = readReplicaCapable
            self.storageType = storageType
            self.supportsEnhancedMonitoring = supportsEnhancedMonitoring
            self.supportsIAMDatabaseAuthentication = supportsIAMDatabaseAuthentication
            self.supportsIops = supportsIops
            self.supportsPerformanceInsights = supportsPerformanceInsights
            self.supportsStorageEncryption = supportsStorageEncryption
            self.vpc = vpc
        }
    }

}

extension NeptuneClientTypes.Parameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues = "AllowedValues"
        case applyMethod = "ApplyMethod"
        case applyType = "ApplyType"
        case dataType = "DataType"
        case description = "Description"
        case isModifiable = "IsModifiable"
        case minimumEngineVersion = "MinimumEngineVersion"
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: ClientRuntime.Key("AllowedValues"))
        }
        if let applyMethod = applyMethod {
            try container.encode(applyMethod, forKey: ClientRuntime.Key("ApplyMethod"))
        }
        if let applyType = applyType {
            try container.encode(applyType, forKey: ClientRuntime.Key("ApplyType"))
        }
        if let dataType = dataType {
            try container.encode(dataType, forKey: ClientRuntime.Key("DataType"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if isModifiable != false {
            try container.encode(isModifiable, forKey: ClientRuntime.Key("IsModifiable"))
        }
        if let minimumEngineVersion = minimumEngineVersion {
            try container.encode(minimumEngineVersion, forKey: ClientRuntime.Key("MinimumEngineVersion"))
        }
        if let parameterName = parameterName {
            try container.encode(parameterName, forKey: ClientRuntime.Key("ParameterName"))
        }
        if let parameterValue = parameterValue {
            try container.encode(parameterValue, forKey: ClientRuntime.Key("ParameterValue"))
        }
        if let source = source {
            try container.encode(source, forKey: ClientRuntime.Key("Source"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let applyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applyType)
        applyType = applyTypeDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let isModifiableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let minimumEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumEngineVersion)
        minimumEngineVersion = minimumEngineVersionDecoded
        let applyMethodDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.ApplyMethod.self, forKey: .applyMethod)
        applyMethod = applyMethodDecoded
    }
}

extension NeptuneClientTypes.Parameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Parameter(allowedValues: \(Swift.String(describing: allowedValues)), applyMethod: \(Swift.String(describing: applyMethod)), applyType: \(Swift.String(describing: applyType)), dataType: \(Swift.String(describing: dataType)), description: \(Swift.String(describing: description)), isModifiable: \(Swift.String(describing: isModifiable)), minimumEngineVersion: \(Swift.String(describing: minimumEngineVersion)), parameterName: \(Swift.String(describing: parameterName)), parameterValue: \(Swift.String(describing: parameterValue)), source: \(Swift.String(describing: source)))"}
}

extension NeptuneClientTypes {
    /// <p>Specifies a parameter.</p>
    public struct Parameter: Swift.Equatable {
        /// <p>Specifies the valid range of values for the parameter.</p>
        public let allowedValues: Swift.String?
        /// <p>Indicates when to apply parameter updates.</p>
        public let applyMethod: NeptuneClientTypes.ApplyMethod?
        /// <p>Specifies the engine specific parameters type.</p>
        public let applyType: Swift.String?
        /// <p>Specifies the valid data type for the parameter.</p>
        public let dataType: Swift.String?
        /// <p>Provides a description of the parameter.</p>
        public let description: Swift.String?
        /// <p> Indicates whether (<code>true</code>) or not (<code>false</code>) the parameter can be
        ///       modified. Some parameters have security or operational implications that prevent them from
        ///       being changed.</p>
        public let isModifiable: Swift.Bool
        /// <p>The earliest engine version to which the parameter can apply.</p>
        public let minimumEngineVersion: Swift.String?
        /// <p>Specifies the name of the parameter.</p>
        public let parameterName: Swift.String?
        /// <p>Specifies the value of the parameter.</p>
        public let parameterValue: Swift.String?
        /// <p>Indicates the source of the parameter value.</p>
        public let source: Swift.String?

        public init (
            allowedValues: Swift.String? = nil,
            applyMethod: NeptuneClientTypes.ApplyMethod? = nil,
            applyType: Swift.String? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            isModifiable: Swift.Bool = false,
            minimumEngineVersion: Swift.String? = nil,
            parameterName: Swift.String? = nil,
            parameterValue: Swift.String? = nil,
            source: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.applyMethod = applyMethod
            self.applyType = applyType
            self.dataType = dataType
            self.description = description
            self.isModifiable = isModifiable
            self.minimumEngineVersion = minimumEngineVersion
            self.parameterName = parameterName
            self.parameterValue = parameterValue
            self.source = source
        }
    }

}

extension NeptuneClientTypes.PendingCloudwatchLogsExports: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logTypesToDisable = "LogTypesToDisable"
        case logTypesToEnable = "LogTypesToEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let logTypesToDisable = logTypesToDisable {
            var logTypesToDisableContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LogTypesToDisable"))
            for (index0, string0) in logTypesToDisable.enumerated() {
                try logTypesToDisableContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let logTypesToEnable = logTypesToEnable {
            var logTypesToEnableContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LogTypesToEnable"))
            for (index0, string0) in logTypesToEnable.enumerated() {
                try logTypesToEnableContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.logTypesToEnable) {
            struct KeyVal0{struct member{}}
            let logTypesToEnableWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .logTypesToEnable)
            if let logTypesToEnableWrappedContainer = logTypesToEnableWrappedContainer {
                let logTypesToEnableContainer = try logTypesToEnableWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var logTypesToEnableBuffer:[Swift.String]? = nil
                if let logTypesToEnableContainer = logTypesToEnableContainer {
                    logTypesToEnableBuffer = [Swift.String]()
                    for stringContainer0 in logTypesToEnableContainer {
                        logTypesToEnableBuffer?.append(stringContainer0)
                    }
                }
                logTypesToEnable = logTypesToEnableBuffer
            } else {
                logTypesToEnable = []
            }
        } else {
            logTypesToEnable = nil
        }
        if containerValues.contains(.logTypesToDisable) {
            struct KeyVal0{struct member{}}
            let logTypesToDisableWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .logTypesToDisable)
            if let logTypesToDisableWrappedContainer = logTypesToDisableWrappedContainer {
                let logTypesToDisableContainer = try logTypesToDisableWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var logTypesToDisableBuffer:[Swift.String]? = nil
                if let logTypesToDisableContainer = logTypesToDisableContainer {
                    logTypesToDisableBuffer = [Swift.String]()
                    for stringContainer0 in logTypesToDisableContainer {
                        logTypesToDisableBuffer?.append(stringContainer0)
                    }
                }
                logTypesToDisable = logTypesToDisableBuffer
            } else {
                logTypesToDisable = []
            }
        } else {
            logTypesToDisable = nil
        }
    }
}

extension NeptuneClientTypes.PendingCloudwatchLogsExports: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PendingCloudwatchLogsExports(logTypesToDisable: \(Swift.String(describing: logTypesToDisable)), logTypesToEnable: \(Swift.String(describing: logTypesToEnable)))"}
}

extension NeptuneClientTypes {
    /// <p>A list of the log types whose configuration is still pending. In other
    ///       words, these log types are in the process of being activated or deactivated.</p>
    public struct PendingCloudwatchLogsExports: Swift.Equatable {
        /// <p>Log types that are in the process of being enabled. After they are
        ///       enabled, these log types are exported to CloudWatch Logs.</p>
        public let logTypesToDisable: [Swift.String]?
        /// <p>Log types that are in the process of being deactivated. After they are
        ///       deactivated, these log types aren't exported to CloudWatch Logs.</p>
        public let logTypesToEnable: [Swift.String]?

        public init (
            logTypesToDisable: [Swift.String]? = nil,
            logTypesToEnable: [Swift.String]? = nil
        )
        {
            self.logTypesToDisable = logTypesToDisable
            self.logTypesToEnable = logTypesToEnable
        }
    }

}

extension NeptuneClientTypes.PendingMaintenanceAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case autoAppliedAfterDate = "AutoAppliedAfterDate"
        case currentApplyDate = "CurrentApplyDate"
        case description = "Description"
        case forcedApplyDate = "ForcedApplyDate"
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let action = action {
            try container.encode(action, forKey: ClientRuntime.Key("Action"))
        }
        if let autoAppliedAfterDate = autoAppliedAfterDate {
            try container.encode(ClientRuntime.TimestampWrapper(autoAppliedAfterDate, format: .dateTime), forKey: ClientRuntime.Key("autoAppliedAfterDate"))
        }
        if let currentApplyDate = currentApplyDate {
            try container.encode(ClientRuntime.TimestampWrapper(currentApplyDate, format: .dateTime), forKey: ClientRuntime.Key("currentApplyDate"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let forcedApplyDate = forcedApplyDate {
            try container.encode(ClientRuntime.TimestampWrapper(forcedApplyDate, format: .dateTime), forKey: ClientRuntime.Key("forcedApplyDate"))
        }
        if let optInStatus = optInStatus {
            try container.encode(optInStatus, forKey: ClientRuntime.Key("OptInStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let autoAppliedAfterDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoAppliedAfterDate)
        var autoAppliedAfterDateBuffer:ClientRuntime.Date? = nil
        if let autoAppliedAfterDateDecoded = autoAppliedAfterDateDecoded {
            autoAppliedAfterDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(autoAppliedAfterDateDecoded, format: .dateTime)
        }
        autoAppliedAfterDate = autoAppliedAfterDateBuffer
        let forcedApplyDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forcedApplyDate)
        var forcedApplyDateBuffer:ClientRuntime.Date? = nil
        if let forcedApplyDateDecoded = forcedApplyDateDecoded {
            forcedApplyDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(forcedApplyDateDecoded, format: .dateTime)
        }
        forcedApplyDate = forcedApplyDateBuffer
        let optInStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
        let currentApplyDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentApplyDate)
        var currentApplyDateBuffer:ClientRuntime.Date? = nil
        if let currentApplyDateDecoded = currentApplyDateDecoded {
            currentApplyDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(currentApplyDateDecoded, format: .dateTime)
        }
        currentApplyDate = currentApplyDateBuffer
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension NeptuneClientTypes.PendingMaintenanceAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PendingMaintenanceAction(action: \(Swift.String(describing: action)), autoAppliedAfterDate: \(Swift.String(describing: autoAppliedAfterDate)), currentApplyDate: \(Swift.String(describing: currentApplyDate)), description: \(Swift.String(describing: description)), forcedApplyDate: \(Swift.String(describing: forcedApplyDate)), optInStatus: \(Swift.String(describing: optInStatus)))"}
}

extension NeptuneClientTypes {
    /// <p>Provides information about a pending maintenance action for a resource.</p>
    public struct PendingMaintenanceAction: Swift.Equatable {
        /// <p>The type of pending maintenance action that is available for the resource.</p>
        public let action: Swift.String?
        /// <p>The date of the maintenance window when the action is applied. The maintenance action is
        ///       applied to the resource during its first maintenance window after this date. If this date is
        ///       specified, any <code>next-maintenance</code> opt-in requests are ignored.</p>
        public let autoAppliedAfterDate: ClientRuntime.Date?
        /// <p>The effective date when the pending maintenance action is applied to the resource. This
        ///       date takes into account opt-in requests received from the <a>ApplyPendingMaintenanceAction</a> API, the <code>AutoAppliedAfterDate</code>, and the
        ///       <code>ForcedApplyDate</code>. This value is blank if an opt-in request has not been received
        ///       and nothing has been specified as <code>AutoAppliedAfterDate</code> or
        ///       <code>ForcedApplyDate</code>.</p>
        public let currentApplyDate: ClientRuntime.Date?
        /// <p>A description providing more detail about the maintenance action.</p>
        public let description: Swift.String?
        /// <p>The date when the maintenance action is automatically applied. The maintenance action is
        ///       applied to the resource on this date regardless of the maintenance window for the resource. If
        ///       this date is specified, any <code>immediate</code> opt-in requests are ignored.</p>
        public let forcedApplyDate: ClientRuntime.Date?
        /// <p>Indicates the type of opt-in request that has been received for the resource.</p>
        public let optInStatus: Swift.String?

        public init (
            action: Swift.String? = nil,
            autoAppliedAfterDate: ClientRuntime.Date? = nil,
            currentApplyDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            forcedApplyDate: ClientRuntime.Date? = nil,
            optInStatus: Swift.String? = nil
        )
        {
            self.action = action
            self.autoAppliedAfterDate = autoAppliedAfterDate
            self.currentApplyDate = currentApplyDate
            self.description = description
            self.forcedApplyDate = forcedApplyDate
            self.optInStatus = optInStatus
        }
    }

}

extension NeptuneClientTypes.PendingModifiedValues: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case cACertificateIdentifier = "CACertificateIdentifier"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case engineVersion = "EngineVersion"
        case iops = "Iops"
        case licenseModel = "LicenseModel"
        case masterUserPassword = "MasterUserPassword"
        case multiAZ = "MultiAZ"
        case pendingCloudwatchLogsExports = "PendingCloudwatchLogsExports"
        case port = "Port"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try container.encode(cACertificateIdentifier, forKey: ClientRuntime.Key("CACertificateIdentifier"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let pendingCloudwatchLogsExports = pendingCloudwatchLogsExports {
            try container.encode(pendingCloudwatchLogsExports, forKey: ClientRuntime.Key("PendingCloudwatchLogsExports"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let cACertificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cACertificateIdentifier)
        cACertificateIdentifier = cACertificateIdentifierDecoded
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let pendingCloudwatchLogsExportsDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.PendingCloudwatchLogsExports.self, forKey: .pendingCloudwatchLogsExports)
        pendingCloudwatchLogsExports = pendingCloudwatchLogsExportsDecoded
    }
}

extension NeptuneClientTypes.PendingModifiedValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PendingModifiedValues(allocatedStorage: \(Swift.String(describing: allocatedStorage)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), cACertificateIdentifier: \(Swift.String(describing: cACertificateIdentifier)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), engineVersion: \(Swift.String(describing: engineVersion)), iops: \(Swift.String(describing: iops)), licenseModel: \(Swift.String(describing: licenseModel)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), multiAZ: \(Swift.String(describing: multiAZ)), pendingCloudwatchLogsExports: \(Swift.String(describing: pendingCloudwatchLogsExports)), port: \(Swift.String(describing: port)), storageType: \(Swift.String(describing: storageType)))"}
}

extension NeptuneClientTypes {
    /// <p> This data type is used as a response element in the <a>ModifyDBInstance</a>
    ///       action.</p>
    public struct PendingModifiedValues: Swift.Equatable {
        /// <p> Contains the new <code>AllocatedStorage</code> size for the DB instance that will be
        ///       applied or is currently being applied.</p>
        public let allocatedStorage: Swift.Int?
        /// <p>Specifies the pending number of days for which automated backups are retained.</p>
        public let backupRetentionPeriod: Swift.Int?
        /// <p>Specifies the identifier of the CA certificate for the DB instance.</p>
        public let cACertificateIdentifier: Swift.String?
        /// <p> Contains the new <code>DBInstanceClass</code> for the DB instance that will be applied or
        ///       is currently being applied.</p>
        public let dBInstanceClass: Swift.String?
        /// <p> Contains the new <code>DBInstanceIdentifier</code> for the DB instance that will be
        ///       applied or is currently being applied.</p>
        public let dBInstanceIdentifier: Swift.String?
        /// <p>The new DB subnet group for the DB instance.</p>
        public let dBSubnetGroupName: Swift.String?
        /// <p>Indicates the database engine version.</p>
        public let engineVersion: Swift.String?
        /// <p>Specifies the new Provisioned IOPS value for the DB instance that will be applied or is
        ///       currently being applied.</p>
        public let iops: Swift.Int?
        /// <p>Not supported by Neptune.</p>
        public let licenseModel: Swift.String?
        /// <p>Not supported by Neptune.</p>
        public let masterUserPassword: Swift.String?
        /// <p>Indicates that the Single-AZ DB instance is to change to a Multi-AZ deployment.</p>
        public let multiAZ: Swift.Bool?
        /// <p>This <code>PendingCloudwatchLogsExports</code> structure specifies
        ///       pending changes to which CloudWatch logs are enabled and which are disabled.</p>
        public let pendingCloudwatchLogsExports: NeptuneClientTypes.PendingCloudwatchLogsExports?
        /// <p>Specifies the pending port for the DB instance.</p>
        public let port: Swift.Int?
        /// <p>Specifies the storage type to be associated with the DB instance.</p>
        public let storageType: Swift.String?

        public init (
            allocatedStorage: Swift.Int? = nil,
            backupRetentionPeriod: Swift.Int? = nil,
            cACertificateIdentifier: Swift.String? = nil,
            dBInstanceClass: Swift.String? = nil,
            dBInstanceIdentifier: Swift.String? = nil,
            dBSubnetGroupName: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iops: Swift.Int? = nil,
            licenseModel: Swift.String? = nil,
            masterUserPassword: Swift.String? = nil,
            multiAZ: Swift.Bool? = nil,
            pendingCloudwatchLogsExports: NeptuneClientTypes.PendingCloudwatchLogsExports? = nil,
            port: Swift.Int? = nil,
            storageType: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.backupRetentionPeriod = backupRetentionPeriod
            self.cACertificateIdentifier = cACertificateIdentifier
            self.dBInstanceClass = dBInstanceClass
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.dBSubnetGroupName = dBSubnetGroupName
            self.engineVersion = engineVersion
            self.iops = iops
            self.licenseModel = licenseModel
            self.masterUserPassword = masterUserPassword
            self.multiAZ = multiAZ
            self.pendingCloudwatchLogsExports = pendingCloudwatchLogsExports
            self.port = port
            self.storageType = storageType
        }
    }

}

public struct PromoteReadReplicaDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteReadReplicaDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PromoteReadReplicaDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteReadReplicaDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PromoteReadReplicaDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteReadReplicaDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteReadReplicaDBClusterOutputError>
}

extension PromoteReadReplicaDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromoteReadReplicaDBClusterInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)))"}
}

extension PromoteReadReplicaDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        try container.encode("PromoteReadReplicaDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct PromoteReadReplicaDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteReadReplicaDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PromoteReadReplicaDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteReadReplicaDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PromoteReadReplicaDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteReadReplicaDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteReadReplicaDBClusterOutputError>
}

public struct PromoteReadReplicaDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteReadReplicaDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PromoteReadReplicaDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteReadReplicaDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PromoteReadReplicaDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteReadReplicaDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteReadReplicaDBClusterOutputError>
}

public struct PromoteReadReplicaDBClusterInput: Swift.Equatable {
    /// <p>Not supported.</p>
    public let dBClusterIdentifier: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

extension PromoteReadReplicaDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PromoteReadReplicaDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PromoteReadReplicaDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension PromoteReadReplicaDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromoteReadReplicaDBClusterOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension PromoteReadReplicaDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PromoteReadReplicaDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct PromoteReadReplicaDBClusterOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: NeptuneClientTypes.DBCluster?

    public init (
        dBCluster: NeptuneClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct PromoteReadReplicaDBClusterOutputResponseBody: Swift.Equatable {
    public let dBCluster: NeptuneClientTypes.DBCluster?
}

extension PromoteReadReplicaDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("PromoteReadReplicaDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension ProvisionedIopsNotAvailableInAZFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionedIopsNotAvailableInAZFault(message: \(Swift.String(describing: message)))"}
}

extension ProvisionedIopsNotAvailableInAZFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ProvisionedIopsNotAvailableInAZFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provisioned IOPS not available in the specified Availability Zone.</p>
public struct ProvisionedIopsNotAvailableInAZFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ProvisionedIopsNotAvailableInAZFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ProvisionedIopsNotAvailableInAZFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.Range: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from = "From"
        case step = "Step"
        case to = "To"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if from != 0 {
            try container.encode(from, forKey: ClientRuntime.Key("From"))
        }
        if let step = step {
            try container.encode(step, forKey: ClientRuntime.Key("Step"))
        }
        if to != 0 {
            try container.encode(to, forKey: ClientRuntime.Key("To"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decode(Swift.Int.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decode(Swift.Int.self, forKey: .to)
        to = toDecoded
        let stepDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .step)
        step = stepDecoded
    }
}

extension NeptuneClientTypes.Range: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Range(from: \(Swift.String(describing: from)), step: \(Swift.String(describing: step)), to: \(Swift.String(describing: to)))"}
}

extension NeptuneClientTypes {
    /// <p>A range of integer values.</p>
    public struct Range: Swift.Equatable {
        /// <p>The minimum value in the range.</p>
        public let from: Swift.Int
        /// <p>The step value for the range. For example, if you have a range of 5,000 to 10,000, with a
        ///       step value of 1,000, the valid values start at 5,000 and step up by 1,000. Even though 7,500
        ///       is within the range, it isn't a valid value for the range. The valid values are 5,000, 6,000,
        ///       7,000, 8,000...</p>
        public let step: Swift.Int?
        /// <p>The maximum value in the range.</p>
        public let to: Swift.Int

        public init (
            from: Swift.Int = 0,
            step: Swift.Int? = nil,
            to: Swift.Int = 0
        )
        {
            self.from = from
            self.step = step
            self.to = to
        }
    }

}

public struct RebootDBInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootDBInstanceOutputError>
}

extension RebootDBInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootDBInstanceInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), forceFailover: \(Swift.String(describing: forceFailover)))"}
}

extension RebootDBInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let forceFailover = forceFailover {
            try container.encode(forceFailover, forKey: ClientRuntime.Key("ForceFailover"))
        }
        try container.encode("RebootDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RebootDBInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootDBInstanceOutputError>
}

public struct RebootDBInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootDBInstanceOutputError>
}

public struct RebootDBInstanceInput: Swift.Equatable {
    /// <p>The DB instance identifier. This parameter is stored as a lowercase string.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBInstance.</p>
    ///             </li>
    ///          </ul>
    public let dBInstanceIdentifier: Swift.String?
    /// <p> When <code>true</code>, the reboot is conducted through a MultiAZ failover.</p>
    ///          <p>Constraint: You can't specify <code>true</code> if the instance is not configured for
    ///       MultiAZ.</p>
    public let forceFailover: Swift.Bool?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        forceFailover: Swift.Bool? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.forceFailover = forceFailover
    }
}

extension RebootDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RebootDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootDBInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootDBInstanceOutputResponse(dBInstance: \(Swift.String(describing: dBInstance)))"}
}

extension RebootDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RebootDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct RebootDBInstanceOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB instance.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBInstances</a> action.</p>
    public let dBInstance: NeptuneClientTypes.DBInstance?

    public init (
        dBInstance: NeptuneClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct RebootDBInstanceOutputResponseBody: Swift.Equatable {
    public let dBInstance: NeptuneClientTypes.DBInstance?
}

extension RebootDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RebootDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct RemoveRoleFromDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRoleFromDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveRoleFromDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRoleFromDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveRoleFromDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRoleFromDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRoleFromDBClusterOutputError>
}

extension RemoveRoleFromDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveRoleFromDBClusterInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), featureName: \(Swift.String(describing: featureName)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension RemoveRoleFromDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: ClientRuntime.Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        try container.encode("RemoveRoleFromDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RemoveRoleFromDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRoleFromDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveRoleFromDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRoleFromDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveRoleFromDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRoleFromDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRoleFromDBClusterOutputError>
}

public struct RemoveRoleFromDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRoleFromDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveRoleFromDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRoleFromDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveRoleFromDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRoleFromDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRoleFromDBClusterOutputError>
}

public struct RemoveRoleFromDBClusterInput: Swift.Equatable {
    /// <p>The name of the DB cluster to disassociate the IAM role from.</p>
    public let dBClusterIdentifier: Swift.String?
    /// <p>The name of the feature for the DB cluster that the IAM role is to be disassociated from.
    ///       For the list of supported feature names, see <a>DBEngineVersion</a>.</p>
    public let featureName: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role to disassociate from the DB cluster, for
    ///       example <code>arn:aws:iam::123456789012:role/NeptuneAccessRole</code>.</p>
    public let roleArn: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        featureName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

extension RemoveRoleFromDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveRoleFromDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterRoleNotFoundFault" : self = .dBClusterRoleNotFoundFault(try DBClusterRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveRoleFromDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterRoleNotFoundFault(DBClusterRoleNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveRoleFromDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveRoleFromDBClusterOutputResponse()"}
}

extension RemoveRoleFromDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveRoleFromDBClusterOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemoveRoleFromDBClusterOutputResponseBody: Swift.Equatable {
}

extension RemoveRoleFromDBClusterOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct RemoveSourceIdentifierFromSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveSourceIdentifierFromSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveSourceIdentifierFromSubscriptionOutputError>
}

extension RemoveSourceIdentifierFromSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveSourceIdentifierFromSubscriptionInput(sourceIdentifier: \(Swift.String(describing: sourceIdentifier)), subscriptionName: \(Swift.String(describing: subscriptionName)))"}
}

extension RemoveSourceIdentifierFromSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: ClientRuntime.Key("SourceIdentifier"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("RemoveSourceIdentifierFromSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RemoveSourceIdentifierFromSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveSourceIdentifierFromSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveSourceIdentifierFromSubscriptionOutputError>
}

public struct RemoveSourceIdentifierFromSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveSourceIdentifierFromSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveSourceIdentifierFromSubscriptionOutputError>
}

public struct RemoveSourceIdentifierFromSubscriptionInput: Swift.Equatable {
    /// <p> The source identifier to be removed from the subscription, such as the <b>DB instance identifier</b> for a DB instance or the name of a security
    ///       group.</p>
    public let sourceIdentifier: Swift.String?
    /// <p>The name of the event notification subscription you want to remove a source identifier
    ///       from.</p>
    public let subscriptionName: Swift.String?

    public init (
        sourceIdentifier: Swift.String? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.sourceIdentifier = sourceIdentifier
        self.subscriptionName = subscriptionName
    }
}

extension RemoveSourceIdentifierFromSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveSourceIdentifierFromSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "SourceNotFoundFault" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFoundFault" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveSourceIdentifierFromSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveSourceIdentifierFromSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveSourceIdentifierFromSubscriptionOutputResponse(eventSubscription: \(Swift.String(describing: eventSubscription)))"}
}

extension RemoveSourceIdentifierFromSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveSourceIdentifierFromSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct RemoveSourceIdentifierFromSubscriptionOutputResponse: Swift.Equatable {
    /// <p>Contains the results of a successful invocation of the <a>DescribeEventSubscriptions</a> action.</p>
    public let eventSubscription: NeptuneClientTypes.EventSubscription?

    public init (
        eventSubscription: NeptuneClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct RemoveSourceIdentifierFromSubscriptionOutputResponseBody: Swift.Equatable {
    public let eventSubscription: NeptuneClientTypes.EventSubscription?
}

extension RemoveSourceIdentifierFromSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RemoveSourceIdentifierFromSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct RemoveTagsFromResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

extension RemoveTagsFromResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromResourceInput(resourceName: \(Swift.String(describing: resourceName)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension RemoveTagsFromResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: ClientRuntime.Key("ResourceName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RemoveTagsFromResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RemoveTagsFromResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInput: Swift.Equatable {
    /// <p>The Amazon Neptune resource that the tags are removed from. This value is an Amazon
    ///       Resource Name (ARN). For information about creating an ARN, see <a href="https://docs.aws.amazon.com/neptune/latest/UserGuide/tagging.ARN.html#tagging.ARN.Constructing"> Constructing an
    ///       Amazon Resource Name (ARN)</a>.</p>
    public let resourceName: Swift.String?
    /// <p>The tag key (name) of the tag to be removed.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceName = resourceName
        self.tagKeys = tagKeys
    }
}

extension RemoveTagsFromResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFoundFault" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromResourceOutputResponse()"}
}

extension RemoveTagsFromResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsFromResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemoveTagsFromResourceOutputResponseBody: Swift.Equatable {
}

extension RemoveTagsFromResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct ResetDBClusterParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetDBClusterParameterGroupOutputError>
}

extension ResetDBClusterParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetDBClusterParameterGroupInput(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), parameters: \(Swift.String(describing: parameters)), resetAllParameters: \(Swift.String(describing: resetAllParameters)))"}
}

extension ResetDBClusterParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        if resetAllParameters != false {
            try container.encode(resetAllParameters, forKey: ClientRuntime.Key("ResetAllParameters"))
        }
        try container.encode("ResetDBClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ResetDBClusterParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetDBClusterParameterGroupOutputError>
}

public struct ResetDBClusterParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetDBClusterParameterGroupOutputError>
}

public struct ResetDBClusterParameterGroupInput: Swift.Equatable {
    /// <p>The name of the DB cluster parameter group to reset.</p>
    public let dBClusterParameterGroupName: Swift.String?
    /// <p>A list of parameter names in the DB cluster parameter group to reset to the default
    ///       values. You can't use this parameter if the <code>ResetAllParameters</code> parameter is set
    ///       to <code>true</code>.</p>
    public let parameters: [NeptuneClientTypes.Parameter]?
    /// <p>A value that is set to <code>true</code> to reset all parameters in the DB cluster
    ///       parameter group to their default values, and <code>false</code> otherwise. You can't use this
    ///       parameter if there is a list of parameter names specified for the <code>Parameters</code>
    ///       parameter.</p>
    public let resetAllParameters: Swift.Bool

    public init (
        dBClusterParameterGroupName: Swift.String? = nil,
        parameters: [NeptuneClientTypes.Parameter]? = nil,
        resetAllParameters: Swift.Bool = false
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.parameters = parameters
        self.resetAllParameters = resetAllParameters
    }
}

extension ResetDBClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResetDBClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetDBClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetDBClusterParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetDBClusterParameterGroupOutputResponse(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)))"}
}

extension ResetDBClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResetDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterParameterGroupName = output.dBClusterParameterGroupName
        } else {
            self.dBClusterParameterGroupName = nil
        }
    }
}

public struct ResetDBClusterParameterGroupOutputResponse: Swift.Equatable {
    /// <p>The name of the DB cluster parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be 1 to 255 letters or numbers.</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>This value is stored as a lowercase string.</p>
    ///          </note>
    public let dBClusterParameterGroupName: Swift.String?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
    }
}

struct ResetDBClusterParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBClusterParameterGroupName: Swift.String?
}

extension ResetDBClusterParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ResetDBClusterParameterGroupResult"))
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
    }
}

public struct ResetDBParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetDBParameterGroupOutputError>
}

extension ResetDBParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetDBParameterGroupInput(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), parameters: \(Swift.String(describing: parameters)), resetAllParameters: \(Swift.String(describing: resetAllParameters)))"}
}

extension ResetDBParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        if resetAllParameters != false {
            try container.encode(resetAllParameters, forKey: ClientRuntime.Key("ResetAllParameters"))
        }
        try container.encode("ResetDBParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ResetDBParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetDBParameterGroupOutputError>
}

public struct ResetDBParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetDBParameterGroupOutputError>
}

public struct ResetDBParameterGroupInput: Swift.Equatable {
    /// <p>The name of the DB parameter group.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the name of an existing DBParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBParameterGroupName: Swift.String?
    /// <p>To reset the entire DB parameter group, specify the <code>DBParameterGroup</code> name and
    ///       <code>ResetAllParameters</code> parameters. To reset specific parameters, provide a list of
    ///       the following: <code>ParameterName</code> and <code>ApplyMethod</code>. A maximum of 20
    ///       parameters can be modified in a single request.</p>
    ///          <p>Valid Values (for Apply method): <code>pending-reboot</code>
    ///          </p>
    public let parameters: [NeptuneClientTypes.Parameter]?
    /// <p>Specifies whether (<code>true</code>) or not (<code>false</code>) to reset all parameters
    ///       in the DB parameter group to default values.</p>
    ///          <p>Default: <code>true</code>
    ///          </p>
    public let resetAllParameters: Swift.Bool

    public init (
        dBParameterGroupName: Swift.String? = nil,
        parameters: [NeptuneClientTypes.Parameter]? = nil,
        resetAllParameters: Swift.Bool = false
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.parameters = parameters
        self.resetAllParameters = resetAllParameters
    }
}

extension ResetDBParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResetDBParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFoundFault" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupStateFault" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetDBParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetDBParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetDBParameterGroupOutputResponse(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)))"}
}

extension ResetDBParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResetDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBParameterGroupName = output.dBParameterGroupName
        } else {
            self.dBParameterGroupName = nil
        }
    }
}

public struct ResetDBParameterGroupOutputResponse: Swift.Equatable {
    /// <p>Provides the name of the DB parameter group.</p>
    public let dBParameterGroupName: Swift.String?

    public init (
        dBParameterGroupName: Swift.String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
    }
}

struct ResetDBParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBParameterGroupName: Swift.String?
}

extension ResetDBParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ResetDBParameterGroupResult"))
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
    }
}

extension ResourceNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ResourceNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource ID was not found.</p>
public struct ResourceNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.ResourcePendingMaintenanceActions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pendingMaintenanceActionDetails = "PendingMaintenanceActionDetails"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let pendingMaintenanceActionDetails = pendingMaintenanceActionDetails {
            var pendingMaintenanceActionDetailsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PendingMaintenanceActionDetails"))
            for (index0, pendingmaintenanceaction0) in pendingMaintenanceActionDetails.enumerated() {
                try pendingMaintenanceActionDetailsContainer.encode(pendingmaintenanceaction0, forKey: ClientRuntime.Key("PendingMaintenanceAction.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceIdentifier = resourceIdentifier {
            try container.encode(resourceIdentifier, forKey: ClientRuntime.Key("ResourceIdentifier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        if containerValues.contains(.pendingMaintenanceActionDetails) {
            struct KeyVal0{struct PendingMaintenanceAction{}}
            let pendingMaintenanceActionDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PendingMaintenanceAction>.CodingKeys.self, forKey: .pendingMaintenanceActionDetails)
            if let pendingMaintenanceActionDetailsWrappedContainer = pendingMaintenanceActionDetailsWrappedContainer {
                let pendingMaintenanceActionDetailsContainer = try pendingMaintenanceActionDetailsWrappedContainer.decodeIfPresent([NeptuneClientTypes.PendingMaintenanceAction].self, forKey: .member)
                var pendingMaintenanceActionDetailsBuffer:[NeptuneClientTypes.PendingMaintenanceAction]? = nil
                if let pendingMaintenanceActionDetailsContainer = pendingMaintenanceActionDetailsContainer {
                    pendingMaintenanceActionDetailsBuffer = [NeptuneClientTypes.PendingMaintenanceAction]()
                    for structureContainer0 in pendingMaintenanceActionDetailsContainer {
                        pendingMaintenanceActionDetailsBuffer?.append(structureContainer0)
                    }
                }
                pendingMaintenanceActionDetails = pendingMaintenanceActionDetailsBuffer
            } else {
                pendingMaintenanceActionDetails = []
            }
        } else {
            pendingMaintenanceActionDetails = nil
        }
    }
}

extension NeptuneClientTypes.ResourcePendingMaintenanceActions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourcePendingMaintenanceActions(pendingMaintenanceActionDetails: \(Swift.String(describing: pendingMaintenanceActionDetails)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)))"}
}

extension NeptuneClientTypes {
    /// <p>Describes the pending maintenance actions for a resource.</p>
    public struct ResourcePendingMaintenanceActions: Swift.Equatable {
        /// <p>A list that provides details about the pending maintenance actions for the
        ///       resource.</p>
        public let pendingMaintenanceActionDetails: [NeptuneClientTypes.PendingMaintenanceAction]?
        /// <p>The ARN of the resource that has pending maintenance actions.</p>
        public let resourceIdentifier: Swift.String?

        public init (
            pendingMaintenanceActionDetails: [NeptuneClientTypes.PendingMaintenanceAction]? = nil,
            resourceIdentifier: Swift.String? = nil
        )
        {
            self.pendingMaintenanceActionDetails = pendingMaintenanceActionDetails
            self.resourceIdentifier = resourceIdentifier
        }
    }

}

public struct RestoreDBClusterFromSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterFromSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBClusterFromSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBClusterFromSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterFromSnapshotOutputError>
}

extension RestoreDBClusterFromSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBClusterFromSnapshotInput(availabilityZones: \(Swift.String(describing: availabilityZones)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), databaseName: \(Swift.String(describing: databaseName)), deletionProtection: \(Swift.String(describing: deletionProtection)), enableCloudwatchLogsExports: \(Swift.String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), optionGroupName: \(Swift.String(describing: optionGroupName)), port: \(Swift.String(describing: port)), snapshotIdentifier: \(Swift.String(describing: snapshotIdentifier)), tags: \(Swift.String(describing: tags)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBClusterFromSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBClusterFromSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RestoreDBClusterFromSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterFromSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBClusterFromSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBClusterFromSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterFromSnapshotOutputError>
}

public struct RestoreDBClusterFromSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterFromSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBClusterFromSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBClusterFromSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterFromSnapshotOutputError>
}

public struct RestoreDBClusterFromSnapshotInput: Swift.Equatable {
    /// <p>Provides the list of EC2 Availability Zones that instances in the restored DB cluster can
    ///       be created in.</p>
    public let availabilityZones: [Swift.String]?
    /// <p>
    ///             <i>If set to <code>true</code>, tags are copied to any snapshot of
    ///       the restored DB cluster that is created.</i>
    ///          </p>
    public let copyTagsToSnapshot: Swift.Bool?
    /// <p>The name of the DB cluster to create from the DB snapshot or DB cluster snapshot. This
    ///       parameter isn't case-sensitive.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>my-snapshot-id</code>
    ///          </p>
    public let dBClusterIdentifier: Swift.String?
    /// <p>The name of the DB cluster parameter group to associate with the new DB cluster.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: Swift.String?
    /// <p>The name of the DB subnet group to use for the new DB cluster.</p>
    ///          <p>Constraints: If supplied, must match the name of an existing DBSubnetGroup.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: Swift.String?
    /// <p>Not supported.</p>
    public let databaseName: Swift.String?
    /// <p>A value that indicates whether the DB cluster has deletion protection enabled.
    ///       The database can't be deleted when deletion protection is enabled. By default,
    ///       deletion protection is disabled.
    ///     </p>
    public let deletionProtection: Swift.Bool?
    /// <p>The list of logs that the restored DB cluster is to export to Amazon CloudWatch Logs.</p>
    public let enableCloudwatchLogsExports: [Swift.String]?
    /// <p>True to enable mapping of Amazon Identity and Access Management (IAM) accounts to database
    ///       accounts, and otherwise false.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Swift.Bool?
    /// <p>The database engine to use for the new DB cluster.</p>
    ///          <p>Default: The same as source</p>
    ///          <p>Constraint: Must be compatible with the engine of the source</p>
    public let engine: Swift.String?
    /// <p>The version of the database engine to use for the new DB cluster.</p>
    public let engineVersion: Swift.String?
    /// <p>The Amazon KMS key identifier to use when restoring an encrypted DB cluster from a DB
    ///       snapshot or DB cluster snapshot.</p>
    ///          <p>The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If
    ///       you are restoring a DB cluster with the same Amazon account that owns the KMS encryption key used
    ///       to encrypt the new DB cluster, then you can use the KMS key alias instead of the ARN for the
    ///       KMS encryption key.</p>
    ///          <p>If you do not specify a value for the <code>KmsKeyId</code> parameter, then the following
    ///       will occur:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the DB snapshot or DB cluster snapshot in <code>SnapshotIdentifier</code> is
    ///           encrypted, then the restored DB cluster is encrypted using the KMS key that was used to
    ///           encrypt the DB snapshot or DB cluster snapshot.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the DB snapshot or DB cluster snapshot in <code>SnapshotIdentifier</code> is not
    ///           encrypted, then the restored DB cluster is not encrypted.</p>
    ///             </li>
    ///          </ul>
    public let kmsKeyId: Swift.String?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let optionGroupName: Swift.String?
    /// <p>The port number on which the new DB cluster accepts connections.</p>
    ///          <p>Constraints: Value must be <code>1150-65535</code>
    ///          </p>
    ///          <p>Default: The same port as the original DB cluster.</p>
    public let port: Swift.Int?
    /// <p>The identifier for the DB snapshot or DB cluster snapshot to restore from.</p>
    ///          <p>You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster
    ///       snapshot. However, you can use only the ARN to specify a DB snapshot.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing Snapshot.</p>
    ///             </li>
    ///          </ul>
    public let snapshotIdentifier: Swift.String?
    /// <p>The tags to be assigned to the restored DB cluster.</p>
    public let tags: [NeptuneClientTypes.Tag]?
    /// <p>A list of VPC security groups that the new DB cluster will belong to.</p>
    public let vpcSecurityGroupIds: [Swift.String]?

    public init (
        availabilityZones: [Swift.String]? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterParameterGroupName: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        snapshotIdentifier: Swift.String? = nil,
        tags: [NeptuneClientTypes.Tag]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.optionGroupName = optionGroupName
        self.port = port
        self.snapshotIdentifier = snapshotIdentifier
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBClusterFromSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBClusterFromSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFoundFault" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFoundFault" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBClusterCapacityFault" : self = .insufficientDBClusterCapacityFault(try InsufficientDBClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacityFault" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotStateFault" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBClusterFromSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case insufficientDBClusterCapacityFault(InsufficientDBClusterCapacityFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBClusterFromSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBClusterFromSnapshotOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension RestoreDBClusterFromSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreDBClusterFromSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct RestoreDBClusterFromSnapshotOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: NeptuneClientTypes.DBCluster?

    public init (
        dBCluster: NeptuneClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct RestoreDBClusterFromSnapshotOutputResponseBody: Swift.Equatable {
    public let dBCluster: NeptuneClientTypes.DBCluster?
}

extension RestoreDBClusterFromSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreDBClusterFromSnapshotResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct RestoreDBClusterToPointInTimeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterToPointInTimeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBClusterToPointInTimeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBClusterToPointInTimeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterToPointInTimeOutputError>
}

extension RestoreDBClusterToPointInTimeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBClusterToPointInTimeInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), deletionProtection: \(Swift.String(describing: deletionProtection)), enableCloudwatchLogsExports: \(Swift.String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), optionGroupName: \(Swift.String(describing: optionGroupName)), port: \(Swift.String(describing: port)), restoreToTime: \(Swift.String(describing: restoreToTime)), restoreType: \(Swift.String(describing: restoreType)), sourceDBClusterIdentifier: \(Swift.String(describing: sourceDBClusterIdentifier)), tags: \(Swift.String(describing: tags)), useLatestRestorableTime: \(Swift.String(describing: useLatestRestorableTime)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBClusterToPointInTimeInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let restoreToTime = restoreToTime {
            try container.encode(ClientRuntime.TimestampWrapper(restoreToTime, format: .dateTime), forKey: ClientRuntime.Key("restoreToTime"))
        }
        if let restoreType = restoreType {
            try container.encode(restoreType, forKey: ClientRuntime.Key("RestoreType"))
        }
        if let sourceDBClusterIdentifier = sourceDBClusterIdentifier {
            try container.encode(sourceDBClusterIdentifier, forKey: ClientRuntime.Key("SourceDBClusterIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if useLatestRestorableTime != false {
            try container.encode(useLatestRestorableTime, forKey: ClientRuntime.Key("UseLatestRestorableTime"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBClusterToPointInTime", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RestoreDBClusterToPointInTimeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterToPointInTimeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBClusterToPointInTimeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBClusterToPointInTimeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterToPointInTimeOutputError>
}

public struct RestoreDBClusterToPointInTimeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterToPointInTimeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBClusterToPointInTimeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBClusterToPointInTimeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterToPointInTimeOutputError>
}

public struct RestoreDBClusterToPointInTimeInput: Swift.Equatable {
    /// <p>The name of the new DB cluster to be created.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must contain from 1 to 63 letters, numbers, or hyphens</p>
    ///             </li>
    ///             <li>
    ///                <p>First character must be a letter</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot end with a hyphen or contain two consecutive hyphens</p>
    ///             </li>
    ///          </ul>
    public let dBClusterIdentifier: Swift.String?
    /// <p>The name of the DB cluster parameter group to associate with the new DB cluster.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If supplied, must match the name of an existing DBClusterParameterGroup.</p>
    ///             </li>
    ///          </ul>
    public let dBClusterParameterGroupName: Swift.String?
    /// <p>The DB subnet group name to use for the new DB cluster.</p>
    ///          <p>Constraints: If supplied, must match the name of an existing DBSubnetGroup.</p>
    ///          <p>Example: <code>mySubnetgroup</code>
    ///          </p>
    public let dBSubnetGroupName: Swift.String?
    /// <p>A value that indicates whether the DB cluster has deletion protection enabled.
    ///       The database can't be deleted when deletion protection is enabled. By default,
    ///       deletion protection is disabled.
    ///     </p>
    public let deletionProtection: Swift.Bool?
    /// <p>The list of logs that the restored DB cluster is to export to CloudWatch Logs.</p>
    public let enableCloudwatchLogsExports: [Swift.String]?
    /// <p>True to enable mapping of Amazon Identity and Access Management (IAM) accounts to database
    ///       accounts, and otherwise false.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    public let enableIAMDatabaseAuthentication: Swift.Bool?
    /// <p>The Amazon KMS key identifier to use when restoring an encrypted DB cluster from an encrypted
    ///       DB cluster.</p>
    ///          <p>The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If
    ///       you are restoring a DB cluster with the same Amazon account that owns the KMS encryption key used
    ///       to encrypt the new DB cluster, then you can use the KMS key alias instead of the ARN for the
    ///       KMS encryption key.</p>
    ///          <p>You can restore to a new DB cluster and encrypt the new DB cluster with a KMS key that is
    ///       different than the KMS key used to encrypt the source DB cluster. The new DB cluster is
    ///       encrypted with the KMS key identified by the <code>KmsKeyId</code> parameter.</p>
    ///          <p>If you do not specify a value for the <code>KmsKeyId</code> parameter, then the following
    ///       will occur:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the DB cluster is encrypted, then the restored DB cluster is encrypted using the
    ///           KMS key that was used to encrypt the source DB cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the DB cluster is not encrypted, then the restored DB cluster is not
    ///           encrypted.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If <code>DBClusterIdentifier</code> refers to a DB cluster that is not encrypted, then the
    ///       restore request is rejected.</p>
    public let kmsKeyId: Swift.String?
    /// <p>
    ///             <i>(Not supported by Neptune)</i>
    ///          </p>
    public let optionGroupName: Swift.String?
    /// <p>The port number on which the new DB cluster accepts connections.</p>
    ///          <p>Constraints: Value must be <code>1150-65535</code>
    ///          </p>
    ///          <p>Default: The same port as the original DB cluster.</p>
    public let port: Swift.Int?
    /// <p>The date and time to restore the DB cluster to.</p>
    ///          <p>Valid Values: Value must be a time in Universal Coordinated Time (UTC) format</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must be before the latest restorable time for the DB instance</p>
    ///             </li>
    ///             <li>
    ///                <p>Must be specified if <code>UseLatestRestorableTime</code> parameter is not
    ///           provided</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot be specified if <code>UseLatestRestorableTime</code> parameter is true</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot be specified if <code>RestoreType</code> parameter is
    ///           <code>copy-on-write</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>Example: <code>2015-03-07T23:45:00Z</code>
    ///          </p>
    public let restoreToTime: ClientRuntime.Date?
    /// <p>The type of restore to be performed. You can specify one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>full-copy</code> - The new DB cluster is restored as a full copy of the source
    ///           DB cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>copy-on-write</code> - The new DB cluster is restored as a clone of the source
    ///           DB cluster.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you don't specify a <code>RestoreType</code> value, then the new DB cluster is restored
    ///       as a full copy of the source DB cluster.</p>
    public let restoreType: Swift.String?
    /// <p>The identifier of the source DB cluster from which to restore.</p>
    ///          <p>Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Must match the identifier of an existing DBCluster.</p>
    ///             </li>
    ///          </ul>
    public let sourceDBClusterIdentifier: Swift.String?
    /// <p>The tags to be applied to the restored DB cluster.</p>
    public let tags: [NeptuneClientTypes.Tag]?
    /// <p>A value that is set to <code>true</code> to restore the DB cluster to the latest
    ///       restorable backup time, and <code>false</code> otherwise.</p>
    ///          <p>Default: <code>false</code>
    ///          </p>
    ///          <p>Constraints: Cannot be specified if <code>RestoreToTime</code> parameter is
    ///       provided.</p>
    public let useLatestRestorableTime: Swift.Bool
    /// <p>A list of VPC security groups that the new DB cluster belongs to.</p>
    public let vpcSecurityGroupIds: [Swift.String]?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterParameterGroupName: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        restoreToTime: ClientRuntime.Date? = nil,
        restoreType: Swift.String? = nil,
        sourceDBClusterIdentifier: Swift.String? = nil,
        tags: [NeptuneClientTypes.Tag]? = nil,
        useLatestRestorableTime: Swift.Bool = false,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.kmsKeyId = kmsKeyId
        self.optionGroupName = optionGroupName
        self.port = port
        self.restoreToTime = restoreToTime
        self.restoreType = restoreType
        self.sourceDBClusterIdentifier = sourceDBClusterIdentifier
        self.tags = tags
        self.useLatestRestorableTime = useLatestRestorableTime
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBClusterToPointInTimeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBClusterToPointInTimeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFoundFault" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBClusterCapacityFault" : self = .insufficientDBClusterCapacityFault(try InsufficientDBClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacityFault" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotStateFault" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBClusterToPointInTimeOutputError: Swift.Error, Swift.Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case insufficientDBClusterCapacityFault(InsufficientDBClusterCapacityFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBClusterToPointInTimeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBClusterToPointInTimeOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension RestoreDBClusterToPointInTimeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreDBClusterToPointInTimeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct RestoreDBClusterToPointInTimeOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: NeptuneClientTypes.DBCluster?

    public init (
        dBCluster: NeptuneClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct RestoreDBClusterToPointInTimeOutputResponseBody: Swift.Equatable {
    public let dBCluster: NeptuneClientTypes.DBCluster?
}

extension RestoreDBClusterToPointInTimeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreDBClusterToPointInTimeResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension SNSInvalidTopicFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SNSInvalidTopicFault(message: \(Swift.String(describing: message)))"}
}

extension SNSInvalidTopicFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SNSInvalidTopicFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The SNS topic is invalid.</p>
public struct SNSInvalidTopicFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSInvalidTopicFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SNSInvalidTopicFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSNoAuthorizationFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SNSNoAuthorizationFault(message: \(Swift.String(describing: message)))"}
}

extension SNSNoAuthorizationFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SNSNoAuthorizationFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is no SNS authorization.</p>
public struct SNSNoAuthorizationFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSNoAuthorizationFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SNSNoAuthorizationFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSTopicArnNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SNSTopicArnNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SNSTopicArnNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SNSTopicArnNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The ARN of the SNS topic could not be found.</p>
public struct SNSTopicArnNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSTopicArnNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SNSTopicArnNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SharedSnapshotQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SharedSnapshotQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension SharedSnapshotQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SharedSnapshotQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the maximum number of accounts that you can share a manual DB snapshot with.</p>
public struct SharedSnapshotQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SharedSnapshotQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SharedSnapshotQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension SnapshotQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SnapshotQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would result in user exceeding the allowed number of DB snapshots.</p>
public struct SnapshotQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SnapshotQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SourceNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SourceNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The source could not be found.</p>
public struct SourceNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SourceNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SourceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dbCluster
        case dbClusterSnapshot
        case dbInstance
        case dbParameterGroup
        case dbSecurityGroup
        case dbSnapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .dbCluster,
                .dbClusterSnapshot,
                .dbInstance,
                .dbParameterGroup,
                .dbSecurityGroup,
                .dbSnapshot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dbCluster: return "db-cluster"
            case .dbClusterSnapshot: return "db-cluster-snapshot"
            case .dbInstance: return "db-instance"
            case .dbParameterGroup: return "db-parameter-group"
            case .dbSecurityGroup: return "db-security-group"
            case .dbSnapshot: return "db-snapshot"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

public struct StartDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDBClusterOutputError>
}

extension StartDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDBClusterInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)))"}
}

extension StartDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        try container.encode("StartDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct StartDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDBClusterOutputError>
}

public struct StartDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDBClusterOutputError>
}

public struct StartDBClusterInput: Swift.Equatable {
    /// <p>The DB cluster identifier of the Neptune DB cluster to be started.
    ///       This parameter is stored as a lowercase string.</p>
    public let dBClusterIdentifier: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

extension StartDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDBClusterOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension StartDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct StartDBClusterOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: NeptuneClientTypes.DBCluster?

    public init (
        dBCluster: NeptuneClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct StartDBClusterOutputResponseBody: Swift.Equatable {
    public let dBCluster: NeptuneClientTypes.DBCluster?
}

extension StartDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StartDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct StopDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDBClusterOutputError>
}

extension StopDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopDBClusterInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)))"}
}

extension StopDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        try container.encode("StopDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct StopDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDBClusterOutputError>
}

public struct StopDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDBClusterOutputError>
}

public struct StopDBClusterInput: Swift.Equatable {
    /// <p>The DB cluster identifier of the Neptune DB cluster to be stopped.
    ///       This parameter is stored as a lowercase string.</p>
    public let dBClusterIdentifier: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

extension StopDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StopDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceStateFault" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopDBClusterOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension StopDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct StopDBClusterOutputResponse: Swift.Equatable {
    /// <p>Contains the details of an Amazon Neptune DB cluster.</p>
    ///          <p>This data type is used as a response element in the <a>DescribeDBClusters</a> action.</p>
    public let dBCluster: NeptuneClientTypes.DBCluster?

    public init (
        dBCluster: NeptuneClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct StopDBClusterOutputResponseBody: Swift.Equatable {
    public let dBCluster: NeptuneClientTypes.DBCluster?
}

extension StopDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StopDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

extension StorageQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StorageQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension StorageQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<StorageQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would result in user exceeding the allowed amount of storage available across all DB instances.</p>
public struct StorageQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StorageQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension StorageQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StorageTypeNotSupportedFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StorageTypeNotSupportedFault(message: \(Swift.String(describing: message)))"}
}

extension StorageTypeNotSupportedFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<StorageTypeNotSupportedFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <i>StorageType</i> specified cannot be associated with the DB Instance.</p>
public struct StorageTypeNotSupportedFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StorageTypeNotSupportedFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension StorageTypeNotSupportedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.Subnet: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
        case subnetStatus = "SubnetStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let subnetAvailabilityZone = subnetAvailabilityZone {
            try container.encode(subnetAvailabilityZone, forKey: ClientRuntime.Key("SubnetAvailabilityZone"))
        }
        if let subnetIdentifier = subnetIdentifier {
            try container.encode(subnetIdentifier, forKey: ClientRuntime.Key("SubnetIdentifier"))
        }
        if let subnetStatus = subnetStatus {
            try container.encode(subnetStatus, forKey: ClientRuntime.Key("SubnetStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(NeptuneClientTypes.AvailabilityZone.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetStatus)
        subnetStatus = subnetStatusDecoded
    }
}

extension NeptuneClientTypes.Subnet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Subnet(subnetAvailabilityZone: \(Swift.String(describing: subnetAvailabilityZone)), subnetIdentifier: \(Swift.String(describing: subnetIdentifier)), subnetStatus: \(Swift.String(describing: subnetStatus)))"}
}

extension NeptuneClientTypes {
    /// <p>Specifies a subnet.</p>
    ///          <p> This data type is used as a response element in the <a>DescribeDBSubnetGroups</a> action.</p>
    public struct Subnet: Swift.Equatable {
        /// <p>Specifies the EC2 Availability Zone that the subnet is in.</p>
        public let subnetAvailabilityZone: NeptuneClientTypes.AvailabilityZone?
        /// <p>Specifies the identifier of the subnet.</p>
        public let subnetIdentifier: Swift.String?
        /// <p>Specifies the status of the subnet.</p>
        public let subnetStatus: Swift.String?

        public init (
            subnetAvailabilityZone: NeptuneClientTypes.AvailabilityZone? = nil,
            subnetIdentifier: Swift.String? = nil,
            subnetStatus: Swift.String? = nil
        )
        {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetStatus = subnetStatus
        }
    }

}

extension SubnetAlreadyInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetAlreadyInUse(message: \(Swift.String(describing: message)))"}
}

extension SubnetAlreadyInUse: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SubnetAlreadyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The DB subnet is already in use in the Availability Zone.</p>
public struct SubnetAlreadyInUse: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetAlreadyInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetAlreadyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionAlreadyExistFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionAlreadyExistFault(message: \(Swift.String(describing: message)))"}
}

extension SubscriptionAlreadyExistFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SubscriptionAlreadyExistFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This subscription already exists.</p>
public struct SubscriptionAlreadyExistFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionAlreadyExistFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubscriptionAlreadyExistFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionCategoryNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionCategoryNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SubscriptionCategoryNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SubscriptionCategoryNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The designated subscription category could not be found.</p>
public struct SubscriptionCategoryNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionCategoryNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubscriptionCategoryNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SubscriptionNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SubscriptionNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The designated subscription could not be found.</p>
public struct SubscriptionNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A message describing the details of the problem.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubscriptionNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NeptuneClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension NeptuneClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension NeptuneClientTypes {
    /// <p>Metadata assigned to an Amazon Neptune resource consisting of a key-value pair.</p>
    public struct Tag: Swift.Equatable {
        /// <p>A key is the required name of the tag. The string value can be from 1 to 128 Unicode
        ///       characters in length and can't be prefixed with "aws:" or "rds:". The string can only contain
        ///       only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java
        ///       regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").</p>
        public let key: Swift.String?
        /// <p>A value is the optional value of the tag. The string value can be from 1 to 256 Unicode
        ///       characters in length and can't be prefixed with "aws:" or "rds:". The string can only contain
        ///       only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java
        ///       regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension NeptuneClientTypes.Timezone: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timezoneName = "TimezoneName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let timezoneName = timezoneName {
            try container.encode(timezoneName, forKey: ClientRuntime.Key("TimezoneName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timezoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezoneName)
        timezoneName = timezoneNameDecoded
    }
}

extension NeptuneClientTypes.Timezone: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Timezone(timezoneName: \(Swift.String(describing: timezoneName)))"}
}

extension NeptuneClientTypes {
    /// <p>A time zone associated with a <a>DBInstance</a>.</p>
    public struct Timezone: Swift.Equatable {
        /// <p>The name of the time zone.</p>
        public let timezoneName: Swift.String?

        public init (
            timezoneName: Swift.String? = nil
        )
        {
            self.timezoneName = timezoneName
        }
    }

}

extension NeptuneClientTypes.UpgradeTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoUpgrade = "AutoUpgrade"
        case description = "Description"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case isMajorVersionUpgrade = "IsMajorVersionUpgrade"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if autoUpgrade != false {
            try container.encode(autoUpgrade, forKey: ClientRuntime.Key("AutoUpgrade"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if isMajorVersionUpgrade != false {
            try container.encode(isMajorVersionUpgrade, forKey: ClientRuntime.Key("IsMajorVersionUpgrade"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let autoUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoUpgrade)
        autoUpgrade = autoUpgradeDecoded
        let isMajorVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isMajorVersionUpgrade)
        isMajorVersionUpgrade = isMajorVersionUpgradeDecoded
    }
}

extension NeptuneClientTypes.UpgradeTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpgradeTarget(autoUpgrade: \(Swift.String(describing: autoUpgrade)), description: \(Swift.String(describing: description)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), isMajorVersionUpgrade: \(Swift.String(describing: isMajorVersionUpgrade)))"}
}

extension NeptuneClientTypes {
    /// <p>The version of the database engine that a DB instance can be upgraded to.</p>
    public struct UpgradeTarget: Swift.Equatable {
        /// <p>A value that indicates whether the target version is applied to any source DB instances
        ///       that have AutoMinorVersionUpgrade set to true.</p>
        public let autoUpgrade: Swift.Bool
        /// <p>The version of the database engine that a DB instance can be upgraded to.</p>
        public let description: Swift.String?
        /// <p>The name of the upgrade target database engine.</p>
        public let engine: Swift.String?
        /// <p>The version number of the upgrade target database engine.</p>
        public let engineVersion: Swift.String?
        /// <p>A value that indicates whether a database engine is upgraded to a major version.</p>
        public let isMajorVersionUpgrade: Swift.Bool

        public init (
            autoUpgrade: Swift.Bool = false,
            description: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            isMajorVersionUpgrade: Swift.Bool = false
        )
        {
            self.autoUpgrade = autoUpgrade
            self.description = description
            self.engine = engine
            self.engineVersion = engineVersion
            self.isMajorVersionUpgrade = isMajorVersionUpgrade
        }
    }

}

extension NeptuneClientTypes.ValidDBInstanceModificationsMessage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storage = "Storage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let storage = storage {
            var storageContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Storage"))
            for (index0, validstorageoptions0) in storage.enumerated() {
                try storageContainer.encode(validstorageoptions0, forKey: ClientRuntime.Key("ValidStorageOptions.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.storage) {
            struct KeyVal0{struct ValidStorageOptions{}}
            let storageWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ValidStorageOptions>.CodingKeys.self, forKey: .storage)
            if let storageWrappedContainer = storageWrappedContainer {
                let storageContainer = try storageWrappedContainer.decodeIfPresent([NeptuneClientTypes.ValidStorageOptions].self, forKey: .member)
                var storageBuffer:[NeptuneClientTypes.ValidStorageOptions]? = nil
                if let storageContainer = storageContainer {
                    storageBuffer = [NeptuneClientTypes.ValidStorageOptions]()
                    for structureContainer0 in storageContainer {
                        storageBuffer?.append(structureContainer0)
                    }
                }
                storage = storageBuffer
            } else {
                storage = []
            }
        } else {
            storage = nil
        }
    }
}

extension NeptuneClientTypes.ValidDBInstanceModificationsMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidDBInstanceModificationsMessage(storage: \(Swift.String(describing: storage)))"}
}

extension NeptuneClientTypes {
    /// <p>Information about valid modifications that you can make to your DB instance. Contains the
    ///       result of a successful call to the <a>DescribeValidDBInstanceModifications</a>
    ///       action. You can use this information when you call <a>ModifyDBInstance</a>.
    ///    </p>
    public struct ValidDBInstanceModificationsMessage: Swift.Equatable {
        /// <p>Valid storage options for your DB instance.</p>
        public let storage: [NeptuneClientTypes.ValidStorageOptions]?

        public init (
            storage: [NeptuneClientTypes.ValidStorageOptions]? = nil
        )
        {
            self.storage = storage
        }
    }

}

extension NeptuneClientTypes.ValidStorageOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iopsToStorageRatio = "IopsToStorageRatio"
        case provisionedIops = "ProvisionedIops"
        case storageSize = "StorageSize"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let iopsToStorageRatio = iopsToStorageRatio {
            var iopsToStorageRatioContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("IopsToStorageRatio"))
            for (index0, doublerange0) in iopsToStorageRatio.enumerated() {
                try iopsToStorageRatioContainer.encode(doublerange0, forKey: ClientRuntime.Key("DoubleRange.\(index0.advanced(by: 1))"))
            }
        }
        if let provisionedIops = provisionedIops {
            var provisionedIopsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProvisionedIops"))
            for (index0, range0) in provisionedIops.enumerated() {
                try provisionedIopsContainer.encode(range0, forKey: ClientRuntime.Key("Range.\(index0.advanced(by: 1))"))
            }
        }
        if let storageSize = storageSize {
            var storageSizeContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("StorageSize"))
            for (index0, range0) in storageSize.enumerated() {
                try storageSizeContainer.encode(range0, forKey: ClientRuntime.Key("Range.\(index0.advanced(by: 1))"))
            }
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        if containerValues.contains(.storageSize) {
            struct KeyVal0{struct Range{}}
            let storageSizeWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Range>.CodingKeys.self, forKey: .storageSize)
            if let storageSizeWrappedContainer = storageSizeWrappedContainer {
                let storageSizeContainer = try storageSizeWrappedContainer.decodeIfPresent([NeptuneClientTypes.Range].self, forKey: .member)
                var storageSizeBuffer:[NeptuneClientTypes.Range]? = nil
                if let storageSizeContainer = storageSizeContainer {
                    storageSizeBuffer = [NeptuneClientTypes.Range]()
                    for structureContainer0 in storageSizeContainer {
                        storageSizeBuffer?.append(structureContainer0)
                    }
                }
                storageSize = storageSizeBuffer
            } else {
                storageSize = []
            }
        } else {
            storageSize = nil
        }
        if containerValues.contains(.provisionedIops) {
            struct KeyVal0{struct Range{}}
            let provisionedIopsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Range>.CodingKeys.self, forKey: .provisionedIops)
            if let provisionedIopsWrappedContainer = provisionedIopsWrappedContainer {
                let provisionedIopsContainer = try provisionedIopsWrappedContainer.decodeIfPresent([NeptuneClientTypes.Range].self, forKey: .member)
                var provisionedIopsBuffer:[NeptuneClientTypes.Range]? = nil
                if let provisionedIopsContainer = provisionedIopsContainer {
                    provisionedIopsBuffer = [NeptuneClientTypes.Range]()
                    for structureContainer0 in provisionedIopsContainer {
                        provisionedIopsBuffer?.append(structureContainer0)
                    }
                }
                provisionedIops = provisionedIopsBuffer
            } else {
                provisionedIops = []
            }
        } else {
            provisionedIops = nil
        }
        if containerValues.contains(.iopsToStorageRatio) {
            struct KeyVal0{struct DoubleRange{}}
            let iopsToStorageRatioWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DoubleRange>.CodingKeys.self, forKey: .iopsToStorageRatio)
            if let iopsToStorageRatioWrappedContainer = iopsToStorageRatioWrappedContainer {
                let iopsToStorageRatioContainer = try iopsToStorageRatioWrappedContainer.decodeIfPresent([NeptuneClientTypes.DoubleRange].self, forKey: .member)
                var iopsToStorageRatioBuffer:[NeptuneClientTypes.DoubleRange]? = nil
                if let iopsToStorageRatioContainer = iopsToStorageRatioContainer {
                    iopsToStorageRatioBuffer = [NeptuneClientTypes.DoubleRange]()
                    for structureContainer0 in iopsToStorageRatioContainer {
                        iopsToStorageRatioBuffer?.append(structureContainer0)
                    }
                }
                iopsToStorageRatio = iopsToStorageRatioBuffer
            } else {
                iopsToStorageRatio = []
            }
        } else {
            iopsToStorageRatio = nil
        }
    }
}

extension NeptuneClientTypes.ValidStorageOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidStorageOptions(iopsToStorageRatio: \(Swift.String(describing: iopsToStorageRatio)), provisionedIops: \(Swift.String(describing: provisionedIops)), storageSize: \(Swift.String(describing: storageSize)), storageType: \(Swift.String(describing: storageType)))"}
}

extension NeptuneClientTypes {
    /// <p>Information about valid modifications that you can make to your DB
    ///       instance.</p>
    ///          <p>Contains the result of a successful call to the <a>DescribeValidDBInstanceModifications</a> action.</p>
    public struct ValidStorageOptions: Swift.Equatable {
        /// <p>The valid range of Provisioned IOPS to gibibytes of storage multiplier. For example, 3-10,
        ///       which means that provisioned IOPS can be between 3 and 10 times storage.</p>
        public let iopsToStorageRatio: [NeptuneClientTypes.DoubleRange]?
        /// <p>The valid range of provisioned IOPS. For example, 1000-20000.</p>
        public let provisionedIops: [NeptuneClientTypes.Range]?
        /// <p>The valid range of storage in gibibytes. For example, 100 to 16384.</p>
        public let storageSize: [NeptuneClientTypes.Range]?
        /// <p>The valid storage types for your DB instance. For example, gp2, io1.</p>
        public let storageType: Swift.String?

        public init (
            iopsToStorageRatio: [NeptuneClientTypes.DoubleRange]? = nil,
            provisionedIops: [NeptuneClientTypes.Range]? = nil,
            storageSize: [NeptuneClientTypes.Range]? = nil,
            storageType: Swift.String? = nil
        )
        {
            self.iopsToStorageRatio = iopsToStorageRatio
            self.provisionedIops = provisionedIops
            self.storageSize = storageSize
            self.storageType = storageType
        }
    }

}

extension NeptuneClientTypes.VpcSecurityGroupMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case vpcSecurityGroupId = "VpcSecurityGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let vpcSecurityGroupId = vpcSecurityGroupId {
            try container.encode(vpcSecurityGroupId, forKey: ClientRuntime.Key("VpcSecurityGroupId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension NeptuneClientTypes.VpcSecurityGroupMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VpcSecurityGroupMembership(status: \(Swift.String(describing: status)), vpcSecurityGroupId: \(Swift.String(describing: vpcSecurityGroupId)))"}
}

extension NeptuneClientTypes {
    /// <p>This data type is used as a response element for queries on VPC security group
    ///       membership.</p>
    public struct VpcSecurityGroupMembership: Swift.Equatable {
        /// <p>The status of the VPC security group.</p>
        public let status: Swift.String?
        /// <p>The name of the VPC security group.</p>
        public let vpcSecurityGroupId: Swift.String?

        public init (
            status: Swift.String? = nil,
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}
