// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountActionRequiredException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountActionRequiredException(message: \(Swift.String(describing: message)))"}
}

extension AccountActionRequiredException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccountActionRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             Account Action is required in order to continue the request.
///         </p>
public struct AccountActionRequiredException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccountActionRequiredExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccountActionRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequestException(message: \(Swift.String(describing: message)))"}
}

extension BadRequestException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             The request cannot be processed because some parameter is not valid or the project
///             state prevents the operation from being performed.
///         </p>
public struct BadRequestException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MobileClientTypes.BundleDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availablePlatforms
        case bundleId
        case description
        case iconUrl
        case title
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availablePlatforms = availablePlatforms {
            var availablePlatformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availablePlatforms)
            for platforms0 in availablePlatforms {
                try availablePlatformsContainer.encode(platforms0.rawValue)
            }
        }
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iconUrl = iconUrl {
            try encodeContainer.encode(iconUrl, forKey: .iconUrl)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let iconUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iconUrl)
        iconUrl = iconUrlDecoded
        let availablePlatformsContainer = try containerValues.decodeIfPresent([MobileClientTypes.Platform?].self, forKey: .availablePlatforms)
        var availablePlatformsDecoded0:[MobileClientTypes.Platform]? = nil
        if let availablePlatformsContainer = availablePlatformsContainer {
            availablePlatformsDecoded0 = [MobileClientTypes.Platform]()
            for string0 in availablePlatformsContainer {
                if let string0 = string0 {
                    availablePlatformsDecoded0?.append(string0)
                }
            }
        }
        availablePlatforms = availablePlatformsDecoded0
    }
}

extension MobileClientTypes.BundleDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BundleDetails(availablePlatforms: \(Swift.String(describing: availablePlatforms)), bundleId: \(Swift.String(describing: bundleId)), description: \(Swift.String(describing: description)), iconUrl: \(Swift.String(describing: iconUrl)), title: \(Swift.String(describing: title)), version: \(Swift.String(describing: version)))"}
}

extension MobileClientTypes {
    /// <p>
    ///             The details of the bundle.
    ///         </p>
    public struct BundleDetails: Swift.Equatable {
        /// <p>
        ///             Developer desktop or mobile app or website platforms.
        ///         </p>
        public let availablePlatforms: [MobileClientTypes.Platform]?
        /// <p>
        ///             Unique bundle identifier.
        ///         </p>
        public let bundleId: Swift.String?
        /// <p>
        ///             Description of the download bundle.
        ///         </p>
        public let description: Swift.String?
        /// <p>
        ///             Icon for the download bundle.
        ///         </p>
        public let iconUrl: Swift.String?
        /// <p>
        ///             Title of the download bundle.
        ///         </p>
        public let title: Swift.String?
        /// <p>
        ///             Version of the download bundle.
        ///         </p>
        public let version: Swift.String?

        public init (
            availablePlatforms: [MobileClientTypes.Platform]? = nil,
            bundleId: Swift.String? = nil,
            description: Swift.String? = nil,
            iconUrl: Swift.String? = nil,
            title: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.availablePlatforms = availablePlatforms
            self.bundleId = bundleId
            self.description = description
            self.iconUrl = iconUrl
            self.title = title
            self.version = version
        }
    }

}

public struct CreateProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contents = input.operationInput.contents {
            let contentsdata = contents
            let contentsbody = ClientRuntime.HttpBody.data(contentsdata)
            input.builder.withBody(contentsbody)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

extension CreateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectInput(contents: \(Swift.String(describing: contents)), name: \(Swift.String(describing: name)), region: \(Swift.String(describing: region)), snapshotId: \(Swift.String(describing: snapshotId)))"}
}

extension CreateProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contents = contents {
            try encodeContainer.encode(contents.base64EncodedString(), forKey: .contents)
        }
    }
}

public struct CreateProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let snapshotId = input.operationInput.snapshotId {
            let snapshotIdQueryItem = ClientRuntime.URLQueryItem(name: "snapshotId".urlPercentEncoding(), value: Swift.String(snapshotId).urlPercentEncoding())
            input.builder.withQueryItem(snapshotIdQueryItem)
        }
        if let name = input.operationInput.name {
            let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            input.builder.withQueryItem(nameQueryItem)
        }
        if let region = input.operationInput.region {
            let regionQueryItem = ClientRuntime.URLQueryItem(name: "region".urlPercentEncoding(), value: Swift.String(region).urlPercentEncoding())
            input.builder.withQueryItem(regionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

/// <p>
///             Request structure used to request a project be created.
///         </p>
public struct CreateProjectInput: Swift.Equatable {
    /// <p>
    ///             ZIP or YAML file which contains configuration settings to be used when creating
    ///             the project. This may be the contents of the file downloaded from the URL provided
    ///             in an export project operation.
    ///         </p>
    public let contents: ClientRuntime.Data?
    /// <p>
    ///             Name of the project.
    ///         </p>
    public let name: Swift.String?
    /// <p>
    ///             Default region where project resources should be created.
    ///         </p>
    public let region: Swift.String?
    /// <p>
    ///             Unique identifier for an exported snapshot of project configuration. This
    ///             snapshot identifier is included in the share URL when a project is exported.
    ///         </p>
    public let snapshotId: Swift.String?

    public init (
        contents: ClientRuntime.Data? = nil,
        name: Swift.String? = nil,
        region: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.contents = contents
        self.name = name
        self.region = region
        self.snapshotId = snapshotId
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    public let contents: ClientRuntime.Data?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contents
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentsDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .contents)
        contents = contentsDecoded
    }
}

extension CreateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProjectOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectOutputResponse(details: \(Swift.String(describing: details)))"}
}

extension CreateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// <p>
///             Result structure used in response to a request to create a project.
///         </p>
public struct CreateProjectOutputResponse: Swift.Equatable {
    /// <p>
    ///             Detailed information about the created AWS Mobile Hub project.
    ///         </p>
    public let details: MobileClientTypes.ProjectDetails?

    public init (
        details: MobileClientTypes.ProjectDetails? = nil
    )
    {
        self.details = details
    }
}

struct CreateProjectOutputResponseBody: Swift.Equatable {
    public let details: MobileClientTypes.ProjectDetails?
}

extension CreateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(MobileClientTypes.ProjectDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension DeleteProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProjectInput(projectId: \(Swift.String(describing: projectId)))"}
}

extension DeleteProjectInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

/// <p>
///             Request structure used to request a project be deleted.
///         </p>
public struct DeleteProjectInput: Swift.Equatable {
    /// <p>
    ///             Unique project identifier.
    ///         </p>
    public let projectId: Swift.String?

    public init (
        projectId: Swift.String? = nil
    )
    {
        self.projectId = projectId
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
}

extension DeleteProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProjectOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProjectOutputResponse(deletedResources: \(Swift.String(describing: deletedResources)), orphanedResources: \(Swift.String(describing: orphanedResources)))"}
}

extension DeleteProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deletedResources = output.deletedResources
            self.orphanedResources = output.orphanedResources
        } else {
            self.deletedResources = nil
            self.orphanedResources = nil
        }
    }
}

/// <p>
///             Result structure used in response to request to delete a project.
///         </p>
public struct DeleteProjectOutputResponse: Swift.Equatable {
    /// <p>
    ///             Resources which were deleted.
    ///         </p>
    public let deletedResources: [MobileClientTypes.Resource]?
    /// <p>
    ///             Resources which were not deleted, due to a risk of losing potentially
    ///             important data or files.
    ///         </p>
    public let orphanedResources: [MobileClientTypes.Resource]?

    public init (
        deletedResources: [MobileClientTypes.Resource]? = nil,
        orphanedResources: [MobileClientTypes.Resource]? = nil
    )
    {
        self.deletedResources = deletedResources
        self.orphanedResources = orphanedResources
    }
}

struct DeleteProjectOutputResponseBody: Swift.Equatable {
    public let deletedResources: [MobileClientTypes.Resource]?
    public let orphanedResources: [MobileClientTypes.Resource]?
}

extension DeleteProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletedResources
        case orphanedResources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletedResourcesContainer = try containerValues.decodeIfPresent([MobileClientTypes.Resource?].self, forKey: .deletedResources)
        var deletedResourcesDecoded0:[MobileClientTypes.Resource]? = nil
        if let deletedResourcesContainer = deletedResourcesContainer {
            deletedResourcesDecoded0 = [MobileClientTypes.Resource]()
            for structure0 in deletedResourcesContainer {
                if let structure0 = structure0 {
                    deletedResourcesDecoded0?.append(structure0)
                }
            }
        }
        deletedResources = deletedResourcesDecoded0
        let orphanedResourcesContainer = try containerValues.decodeIfPresent([MobileClientTypes.Resource?].self, forKey: .orphanedResources)
        var orphanedResourcesDecoded0:[MobileClientTypes.Resource]? = nil
        if let orphanedResourcesContainer = orphanedResourcesContainer {
            orphanedResourcesDecoded0 = [MobileClientTypes.Resource]()
            for structure0 in orphanedResourcesContainer {
                if let structure0 = structure0 {
                    orphanedResourcesDecoded0?.append(structure0)
                }
            }
        }
        orphanedResources = orphanedResourcesDecoded0
    }
}

extension DescribeBundleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBundleInput(bundleId: \(Swift.String(describing: bundleId)))"}
}

extension DescribeBundleInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeBundleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBundleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBundleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBundleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBundleOutputError>
}

public struct DescribeBundleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBundleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBundleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBundleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBundleOutputError>
}

/// <p>
///             Request structure to request the details of a specific bundle.
///         </p>
public struct DescribeBundleInput: Swift.Equatable {
    /// <p>
    ///             Unique bundle identifier.
    ///         </p>
    public let bundleId: Swift.String?

    public init (
        bundleId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
    }
}

struct DescribeBundleInputBody: Swift.Equatable {
}

extension DescribeBundleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBundleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBundleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBundleOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBundleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBundleOutputResponse(details: \(Swift.String(describing: details)))"}
}

extension DescribeBundleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBundleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// <p>
///             Result structure contains the details of the bundle.
///         </p>
public struct DescribeBundleOutputResponse: Swift.Equatable {
    /// <p>
    ///             The details of the bundle.
    ///         </p>
    public let details: MobileClientTypes.BundleDetails?

    public init (
        details: MobileClientTypes.BundleDetails? = nil
    )
    {
        self.details = details
    }
}

struct DescribeBundleOutputResponseBody: Swift.Equatable {
    public let details: MobileClientTypes.BundleDetails?
}

extension DescribeBundleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(MobileClientTypes.BundleDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension DescribeProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProjectInput(projectId: \(Swift.String(describing: projectId)), syncFromResources: \(Swift.String(describing: syncFromResources)))"}
}

extension DescribeProjectInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.syncFromResources != false {
            let syncFromResourcesQueryItem = ClientRuntime.URLQueryItem(name: "syncFromResources".urlPercentEncoding(), value: Swift.String(input.operationInput.syncFromResources).urlPercentEncoding())
            input.builder.withQueryItem(syncFromResourcesQueryItem)
        }
        if let projectId = input.operationInput.projectId {
            let projectIdQueryItem = ClientRuntime.URLQueryItem(name: "projectId".urlPercentEncoding(), value: Swift.String(projectId).urlPercentEncoding())
            input.builder.withQueryItem(projectIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProjectOutputError>
}

/// <p>
///             Request structure used to request details about a project.
///         </p>
public struct DescribeProjectInput: Swift.Equatable {
    /// <p>
    ///             Unique project identifier.
    ///         </p>
    public let projectId: Swift.String?
    /// <p>
    ///             If set to true, causes AWS Mobile Hub to synchronize information from other services, e.g., update state of AWS CloudFormation stacks in the AWS Mobile Hub project.
    ///         </p>
    public let syncFromResources: Swift.Bool

    public init (
        projectId: Swift.String? = nil,
        syncFromResources: Swift.Bool = false
    )
    {
        self.projectId = projectId
        self.syncFromResources = syncFromResources
    }
}

struct DescribeProjectInputBody: Swift.Equatable {
}

extension DescribeProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProjectOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProjectOutputResponse(details: \(Swift.String(describing: details)))"}
}

extension DescribeProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// <p>
///             Result structure used for requests of project details.
///         </p>
public struct DescribeProjectOutputResponse: Swift.Equatable {
    /// <p>
    ///             Detailed information about an AWS Mobile Hub project.
    ///         </p>
    public let details: MobileClientTypes.ProjectDetails?

    public init (
        details: MobileClientTypes.ProjectDetails? = nil
    )
    {
        self.details = details
    }
}

struct DescribeProjectOutputResponseBody: Swift.Equatable {
    public let details: MobileClientTypes.ProjectDetails?
}

extension DescribeProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(MobileClientTypes.ProjectDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension ExportBundleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportBundleInput(bundleId: \(Swift.String(describing: bundleId)), platform: \(Swift.String(describing: platform)), projectId: \(Swift.String(describing: projectId)))"}
}

extension ExportBundleInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ExportBundleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExportBundleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExportBundleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExportBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExportBundleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExportBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExportBundleOutputError>
}

public struct ExportBundleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExportBundleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExportBundleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExportBundleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let projectId = input.operationInput.projectId {
            let projectIdQueryItem = ClientRuntime.URLQueryItem(name: "projectId".urlPercentEncoding(), value: Swift.String(projectId).urlPercentEncoding())
            input.builder.withQueryItem(projectIdQueryItem)
        }
        if let platform = input.operationInput.platform {
            let platformQueryItem = ClientRuntime.URLQueryItem(name: "platform".urlPercentEncoding(), value: Swift.String(platform.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(platformQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExportBundleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExportBundleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExportBundleOutputError>
}

/// <p>
///             Request structure used to request generation of custom SDK and tool packages
///             required to integrate mobile web or app clients with backed AWS resources.
///         </p>
public struct ExportBundleInput: Swift.Equatable {
    /// <p>
    ///             Unique bundle identifier.
    ///         </p>
    public let bundleId: Swift.String?
    /// <p>
    ///             Developer desktop or target application platform.
    ///         </p>
    public let platform: MobileClientTypes.Platform?
    /// <p>
    ///             Unique project identifier.
    ///         </p>
    public let projectId: Swift.String?

    public init (
        bundleId: Swift.String? = nil,
        platform: MobileClientTypes.Platform? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
        self.platform = platform
        self.projectId = projectId
    }
}

struct ExportBundleInputBody: Swift.Equatable {
}

extension ExportBundleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportBundleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportBundleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportBundleOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportBundleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportBundleOutputResponse(downloadUrl: \(Swift.String(describing: downloadUrl)))"}
}

extension ExportBundleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExportBundleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.downloadUrl = output.downloadUrl
        } else {
            self.downloadUrl = nil
        }
    }
}

/// <p>
///             Result structure which contains link to download custom-generated SDK and
///             tool packages used to integrate mobile web or app clients with backed
///             AWS resources.
///         </p>
public struct ExportBundleOutputResponse: Swift.Equatable {
    /// <p>
    ///             URL which contains the custom-generated SDK and tool packages used
    ///             to integrate the client mobile app or web app with the AWS resources
    ///             created by the AWS Mobile Hub project.
    ///         </p>
    public let downloadUrl: Swift.String?

    public init (
        downloadUrl: Swift.String? = nil
    )
    {
        self.downloadUrl = downloadUrl
    }
}

struct ExportBundleOutputResponseBody: Swift.Equatable {
    public let downloadUrl: Swift.String?
}

extension ExportBundleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadUrl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let downloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
    }
}

extension ExportProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportProjectInput(projectId: \(Swift.String(describing: projectId)))"}
}

extension ExportProjectInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ExportProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExportProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExportProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExportProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExportProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExportProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExportProjectOutputError>
}

public struct ExportProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExportProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExportProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExportProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExportProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExportProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExportProjectOutputError>
}

/// <p>
///             Request structure used in requests to export project configuration details.
///         </p>
public struct ExportProjectInput: Swift.Equatable {
    /// <p>
    ///             Unique project identifier.
    ///         </p>
    public let projectId: Swift.String?

    public init (
        projectId: Swift.String? = nil
    )
    {
        self.projectId = projectId
    }
}

struct ExportProjectInputBody: Swift.Equatable {
}

extension ExportProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportProjectOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportProjectOutputResponse(downloadUrl: \(Swift.String(describing: downloadUrl)), shareUrl: \(Swift.String(describing: shareUrl)), snapshotId: \(Swift.String(describing: snapshotId)))"}
}

extension ExportProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExportProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.downloadUrl = output.downloadUrl
            self.shareUrl = output.shareUrl
            self.snapshotId = output.snapshotId
        } else {
            self.downloadUrl = nil
            self.shareUrl = nil
            self.snapshotId = nil
        }
    }
}

/// <p>
///             Result structure used for requests to export project configuration details.
///         </p>
public struct ExportProjectOutputResponse: Swift.Equatable {
    /// <p>
    ///             URL which can be used to download the exported project configuation file(s).
    ///         </p>
    public let downloadUrl: Swift.String?
    /// <p>
    ///             URL which can be shared to allow other AWS users to create their own project
    ///             in AWS Mobile Hub with the same configuration as the specified project. This
    ///             URL pertains to a snapshot in time of the project configuration that is created
    ///             when this API is called. If you want to share additional changes to your project
    ///             configuration, then you will need to create and share a new snapshot by calling
    ///             this method again.
    ///         </p>
    public let shareUrl: Swift.String?
    /// <p>
    ///             Unique identifier for the exported snapshot of the project configuration. This
    ///             snapshot identifier is included in the share URL.
    ///         </p>
    public let snapshotId: Swift.String?

    public init (
        downloadUrl: Swift.String? = nil,
        shareUrl: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.downloadUrl = downloadUrl
        self.shareUrl = shareUrl
        self.snapshotId = snapshotId
    }
}

struct ExportProjectOutputResponseBody: Swift.Equatable {
    public let downloadUrl: Swift.String?
    public let shareUrl: Swift.String?
    public let snapshotId: Swift.String?
}

extension ExportProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadUrl
        case shareUrl
        case snapshotId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let downloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
        let shareUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareUrl)
        shareUrl = shareUrlDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
    }
}

extension InternalFailureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalFailureException(message: \(Swift.String(describing: message)))"}
}

extension InternalFailureException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             The service has encountered an unexpected error condition which prevents it from
///             servicing the request.
///         </p>
public struct InternalFailureException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension LimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             There are too many AWS Mobile Hub projects in the account or the account has
///             exceeded the maximum number of resources in some AWS service. You should create
///             another sub-account using AWS Organizations or remove some resources and retry
///             your request.
///         </p>
public struct LimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: Swift.String?
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var retryAfterSeconds: Swift.String?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListBundlesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBundlesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBundlesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListBundlesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBundlesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBundlesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBundlesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBundlesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBundlesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBundlesOutputError>
}

public struct ListBundlesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBundlesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBundlesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBundlesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBundlesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBundlesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBundlesOutputError>
}

/// <p>
///             Request structure to request all available bundles.
///         </p>
public struct ListBundlesInput: Swift.Equatable {
    /// <p>
    ///             Maximum number of records to list in a single response.
    ///         </p>
    public let maxResults: Swift.Int
    /// <p>
    ///             Pagination token. Set to null to start listing bundles from start.
    ///             If non-null pagination token is returned in a result, then pass its
    ///             value in here in another request to list more bundles.
    ///         </p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBundlesInputBody: Swift.Equatable {
}

extension ListBundlesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBundlesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBundlesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBundlesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBundlesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBundlesOutputResponse(bundleList: \(Swift.String(describing: bundleList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBundlesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBundlesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bundleList = output.bundleList
            self.nextToken = output.nextToken
        } else {
            self.bundleList = nil
            self.nextToken = nil
        }
    }
}

/// <p>
///             Result structure contains a list of all available bundles with details.
///         </p>
public struct ListBundlesOutputResponse: Swift.Equatable {
    /// <p>
    ///             A list of bundles.
    ///         </p>
    public let bundleList: [MobileClientTypes.BundleDetails]?
    /// <p>
    ///             Pagination token. If non-null pagination token is returned in a result,
    ///             then pass its value in another request to fetch more entries.
    ///         </p>
    public let nextToken: Swift.String?

    public init (
        bundleList: [MobileClientTypes.BundleDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bundleList = bundleList
        self.nextToken = nextToken
    }
}

struct ListBundlesOutputResponseBody: Swift.Equatable {
    public let bundleList: [MobileClientTypes.BundleDetails]?
    public let nextToken: Swift.String?
}

extension ListBundlesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleListContainer = try containerValues.decodeIfPresent([MobileClientTypes.BundleDetails?].self, forKey: .bundleList)
        var bundleListDecoded0:[MobileClientTypes.BundleDetails]? = nil
        if let bundleListContainer = bundleListContainer {
            bundleListDecoded0 = [MobileClientTypes.BundleDetails]()
            for structure0 in bundleListContainer {
                if let structure0 = structure0 {
                    bundleListDecoded0?.append(structure0)
                }
            }
        }
        bundleList = bundleListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListProjectsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListProjectsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

/// <p>
///             Request structure used to request projects list in AWS Mobile Hub.
///         </p>
public struct ListProjectsInput: Swift.Equatable {
    /// <p>
    ///             Maximum number of records to list in a single response.
    ///         </p>
    public let maxResults: Swift.Int
    /// <p>
    ///             Pagination token. Set to null to start listing projects from start.
    ///             If non-null pagination token is returned in a result, then pass its
    ///             value in here in another request to list more projects.
    ///         </p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Swift.Equatable {
}

extension ListProjectsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), projects: \(Swift.String(describing: projects)))"}
}

extension ListProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

/// <p>
///             Result structure used for requests to list projects in AWS Mobile Hub.
///         </p>
public struct ListProjectsOutputResponse: Swift.Equatable {
    /// <p>
    ///             Pagination token. Set to null to start listing records from start.
    ///             If non-null pagination token is returned in a result, then pass its
    ///             value in here in another request to list more entries.
    ///         </p>
    public let nextToken: Swift.String?
    /// <p>
    ///             List of projects.
    ///         </p>
    public let projects: [MobileClientTypes.ProjectSummary]?

    public init (
        nextToken: Swift.String? = nil,
        projects: [MobileClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Swift.Equatable {
    public let projects: [MobileClientTypes.ProjectSummary]?
    public let nextToken: Swift.String?
}

extension ListProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([MobileClientTypes.ProjectSummary?].self, forKey: .projects)
        var projectsDecoded0:[MobileClientTypes.ProjectSummary]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [MobileClientTypes.ProjectSummary]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(message: \(Swift.String(describing: message)))"}
}

extension NotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             No entity can be found with the specified identifier.
///         </p>
public struct NotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MobileClientTypes {
    /// <p>
    ///             Developer desktop or target mobile app or website platform.
    ///         </p>
    public enum Platform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case android
        case javascript
        case linux
        case objc
        case osx
        case swift
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [Platform] {
            return [
                .android,
                .javascript,
                .linux,
                .objc,
                .osx,
                .swift,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .android: return "ANDROID"
            case .javascript: return "JAVASCRIPT"
            case .linux: return "LINUX"
            case .objc: return "OBJC"
            case .osx: return "OSX"
            case .swift: return "SWIFT"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Platform(rawValue: rawValue) ?? Platform.sdkUnknown(rawValue)
        }
    }
}

extension MobileClientTypes.ProjectDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleUrl
        case createdDate
        case lastUpdatedDate
        case name
        case projectId
        case region
        case resources
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleUrl = consoleUrl {
            try encodeContainer.encode(consoleUrl, forKey: .consoleUrl)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let lastUpdatedDate = lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate.timeIntervalSince1970, forKey: .lastUpdatedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resources0 in resources {
                try resourcesContainer.encode(resources0)
            }
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MobileClientTypes.ProjectState.self, forKey: .state)
        state = stateDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let consoleUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consoleUrl)
        consoleUrl = consoleUrlDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([MobileClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[MobileClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [MobileClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension MobileClientTypes.ProjectDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectDetails(consoleUrl: \(Swift.String(describing: consoleUrl)), createdDate: \(Swift.String(describing: createdDate)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), name: \(Swift.String(describing: name)), projectId: \(Swift.String(describing: projectId)), region: \(Swift.String(describing: region)), resources: \(Swift.String(describing: resources)), state: \(Swift.String(describing: state)))"}
}

extension MobileClientTypes {
    /// <p>
    ///             Detailed information about an AWS Mobile Hub project.
    ///         </p>
    public struct ProjectDetails: Swift.Equatable {
        /// <p>
        ///             Website URL for this project in the AWS Mobile Hub console.
        ///         </p>
        public let consoleUrl: Swift.String?
        /// <p>
        ///             Date the project was created.
        ///         </p>
        public let createdDate: ClientRuntime.Date?
        /// <p>
        ///             Date of the last modification of the project.
        ///         </p>
        public let lastUpdatedDate: ClientRuntime.Date?
        /// <p>
        ///             Name of the project.
        ///         </p>
        public let name: Swift.String?
        /// <p>
        ///             Unique project identifier.
        ///         </p>
        public let projectId: Swift.String?
        /// <p>
        ///             Default region to use for AWS resource creation in the AWS Mobile Hub project.
        ///         </p>
        public let region: Swift.String?
        /// <p>
        ///             List of AWS resources associated with a project.
        ///         </p>
        public let resources: [MobileClientTypes.Resource]?
        /// <p>
        ///             Synchronization state for a project.
        ///         </p>
        public let state: MobileClientTypes.ProjectState?

        public init (
            consoleUrl: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            lastUpdatedDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            projectId: Swift.String? = nil,
            region: Swift.String? = nil,
            resources: [MobileClientTypes.Resource]? = nil,
            state: MobileClientTypes.ProjectState? = nil
        )
        {
            self.consoleUrl = consoleUrl
            self.createdDate = createdDate
            self.lastUpdatedDate = lastUpdatedDate
            self.name = name
            self.projectId = projectId
            self.region = region
            self.resources = resources
            self.state = state
        }
    }

}

extension MobileClientTypes {
    /// <p>
    ///             Synchronization state for a project.
    ///         </p>
    public enum ProjectState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case importing
        case normal
        case syncing
        case sdkUnknown(Swift.String)

        public static var allCases: [ProjectState] {
            return [
                .importing,
                .normal,
                .syncing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .importing: return "IMPORTING"
            case .normal: return "NORMAL"
            case .syncing: return "SYNCING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProjectState(rawValue: rawValue) ?? ProjectState.sdkUnknown(rawValue)
        }
    }
}

extension MobileClientTypes.ProjectSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case projectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
    }
}

extension MobileClientTypes.ProjectSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectSummary(name: \(Swift.String(describing: name)), projectId: \(Swift.String(describing: projectId)))"}
}

extension MobileClientTypes {
    /// <p>
    ///             Summary information about an AWS Mobile Hub project.
    ///         </p>
    public struct ProjectSummary: Swift.Equatable {
        /// <p>
        ///             Name of the project.
        ///         </p>
        public let name: Swift.String?
        /// <p>
        ///             Unique project identifier.
        ///         </p>
        public let projectId: Swift.String?

        public init (
            name: Swift.String? = nil,
            projectId: Swift.String? = nil
        )
        {
            self.name = name
            self.projectId = projectId
        }
    }

}

extension MobileClientTypes.Resource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case attributes
        case feature
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let feature = feature {
            try encodeContainer.encode(feature, forKey: .feature)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let featureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feature)
        feature = featureDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension MobileClientTypes.Resource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Resource(arn: \(Swift.String(describing: arn)), attributes: \(Swift.String(describing: attributes)), feature: \(Swift.String(describing: feature)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension MobileClientTypes {
    /// <p>
    ///             Information about an instance of an AWS resource associated with a project.
    ///         </p>
    public struct Resource: Swift.Equatable {
        /// <p>
        ///             AWS resource name which uniquely identifies the resource in AWS systems.
        ///         </p>
        public let arn: Swift.String?
        /// <p>
        ///             Key-value attribute pairs.
        ///         </p>
        public let attributes: [Swift.String:Swift.String]?
        /// <p>
        ///             Identifies which feature in AWS Mobile Hub is associated with this AWS resource.
        ///         </p>
        public let feature: Swift.String?
        /// <p>
        ///             Name of the AWS resource (e.g., for an Amazon S3 bucket this is the name of the bucket).
        ///         </p>
        public let name: Swift.String?
        /// <p>
        ///             Simplified name for type of AWS resource (e.g., bucket is an Amazon S3 bucket).
        ///         </p>
        public let type: Swift.String?

        public init (
            arn: Swift.String? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            feature: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.attributes = attributes
            self.feature = feature
            self.name = name
            self.type = type
        }
    }

}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             The service is temporarily unavailable. The request should be retried after some
///             time delay.
///         </p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: Swift.String?
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var retryAfterSeconds: Swift.String?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequestsException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             Too many requests have been received for this AWS account in too short a time. The
///             request should be retried after some time delay.
///         </p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: Swift.String?
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var retryAfterSeconds: Swift.String?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnauthorizedException(message: \(Swift.String(describing: message)))"}
}

extension UnauthorizedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             Credentials of the caller are insufficient to authorize the request.
///         </p>
public struct UnauthorizedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>
    ///             The Exception Error Message.
    ///         </p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contents = input.operationInput.contents {
            let contentsdata = contents
            let contentsbody = ClientRuntime.HttpBody.data(contentsdata)
            input.builder.withBody(contentsbody)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

extension UpdateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectInput(contents: \(Swift.String(describing: contents)), projectId: \(Swift.String(describing: projectId)))"}
}

extension UpdateProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contents = contents {
            try encodeContainer.encode(contents.base64EncodedString(), forKey: .contents)
        }
    }
}

public struct UpdateProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let projectId = input.operationInput.projectId {
            let projectIdQueryItem = ClientRuntime.URLQueryItem(name: "projectId".urlPercentEncoding(), value: Swift.String(projectId).urlPercentEncoding())
            input.builder.withQueryItem(projectIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

/// <p>
///             Request structure used for requests to update project configuration.
///         </p>
public struct UpdateProjectInput: Swift.Equatable {
    /// <p>
    ///             ZIP or YAML file which contains project configuration to be updated. This should
    ///             be the contents of the file downloaded from the URL provided in an export project
    ///             operation.
    ///         </p>
    public let contents: ClientRuntime.Data?
    /// <p>
    ///             Unique project identifier.
    ///         </p>
    public let projectId: Swift.String?

    public init (
        contents: ClientRuntime.Data? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.contents = contents
        self.projectId = projectId
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    public let contents: ClientRuntime.Data?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contents
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentsDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .contents)
        contents = contentsDecoded
    }
}

extension UpdateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccountActionRequiredException" : self = .accountActionRequiredException(try AccountActionRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProjectOutputError: Swift.Error, Swift.Equatable {
    case accountActionRequiredException(AccountActionRequiredException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectOutputResponse(details: \(Swift.String(describing: details)))"}
}

extension UpdateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// <p>
///             Result structure used for requests to updated project configuration.
///         </p>
public struct UpdateProjectOutputResponse: Swift.Equatable {
    /// <p>
    ///             Detailed information about the updated AWS Mobile Hub project.
    ///         </p>
    public let details: MobileClientTypes.ProjectDetails?

    public init (
        details: MobileClientTypes.ProjectDetails? = nil
    )
    {
        self.details = details
    }
}

struct UpdateProjectOutputResponseBody: Swift.Equatable {
    public let details: MobileClientTypes.ProjectDetails?
}

extension UpdateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(MobileClientTypes.ProjectDetails.self, forKey: .details)
        details = detailsDecoded
    }
}
