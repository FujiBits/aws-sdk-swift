// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension OpsWorksClientTypes.AgentVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationManager = "ConfigurationManager"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationManager = configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
    }
}

extension OpsWorksClientTypes.AgentVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentVersion(configurationManager: \(Swift.String(describing: configurationManager)), version: \(Swift.String(describing: version)))"}
}

extension OpsWorksClientTypes {
    /// Describes an agent version.
    public struct AgentVersion: Swift.Equatable {
        /// The configuration manager.
        public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
        /// The agent version.
        public var version: Swift.String?

        public init (
            configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
            version: Swift.String? = nil
        )
        {
            self.configurationManager = configurationManager
            self.version = version
        }
    }

}

extension OpsWorksClientTypes.App: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case appSource = "AppSource"
        case attributes = "Attributes"
        case createdAt = "CreatedAt"
        case dataSources = "DataSources"
        case description = "Description"
        case domains = "Domains"
        case enableSsl = "EnableSsl"
        case environment = "Environment"
        case name = "Name"
        case shortname = "Shortname"
        case sslConfiguration = "SslConfiguration"
        case stackId = "StackId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let appSource = appSource {
            try encodeContainer.encode(appSource, forKey: .appSource)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, appattributes0) in attributes {
                try attributesContainer.encode(appattributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasources0 in dataSources {
                try dataSourcesContainer.encode(datasources0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for strings0 in domains {
                try domainsContainer.encode(strings0)
            }
        }
        if let enableSsl = enableSsl {
            try encodeContainer.encode(enableSsl, forKey: .enableSsl)
        }
        if let environment = environment {
            var environmentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environment)
            for environmentvariables0 in environment {
                try environmentContainer.encode(environmentvariables0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let shortname = shortname {
            try encodeContainer.encode(shortname, forKey: .shortname)
        }
        if let sslConfiguration = sslConfiguration {
            try encodeContainer.encode(sslConfiguration, forKey: .sslConfiguration)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let shortnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortname)
        shortname = shortnameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourcesContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[OpsWorksClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [OpsWorksClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AppType.self, forKey: .type)
        type = typeDecoded
        let appSourceDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Source.self, forKey: .appSource)
        appSource = appSourceDecoded
        let domainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domains)
        var domainsDecoded0:[Swift.String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [Swift.String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
        let enableSslDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSsl)
        enableSsl = enableSslDecoded
        let sslConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.SslConfiguration.self, forKey: .sslConfiguration)
        sslConfiguration = sslConfigurationDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let environmentContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.EnvironmentVariable?].self, forKey: .environment)
        var environmentDecoded0:[OpsWorksClientTypes.EnvironmentVariable]? = nil
        if let environmentContainer = environmentContainer {
            environmentDecoded0 = [OpsWorksClientTypes.EnvironmentVariable]()
            for structure0 in environmentContainer {
                if let structure0 = structure0 {
                    environmentDecoded0?.append(structure0)
                }
            }
        }
        environment = environmentDecoded0
    }
}

extension OpsWorksClientTypes.App: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "App(appId: \(Swift.String(describing: appId)), appSource: \(Swift.String(describing: appSource)), attributes: \(Swift.String(describing: attributes)), createdAt: \(Swift.String(describing: createdAt)), dataSources: \(Swift.String(describing: dataSources)), description: \(Swift.String(describing: description)), domains: \(Swift.String(describing: domains)), enableSsl: \(Swift.String(describing: enableSsl)), environment: \(Swift.String(describing: environment)), name: \(Swift.String(describing: name)), shortname: \(Swift.String(describing: shortname)), sslConfiguration: \(Swift.String(describing: sslConfiguration)), stackId: \(Swift.String(describing: stackId)), type: \(Swift.String(describing: type)))"}
}

extension OpsWorksClientTypes {
    /// A description of the app.
    public struct App: Swift.Equatable {
        /// The app ID.
        public var appId: Swift.String?
        /// A Source object that describes the app repository.
        public var appSource: OpsWorksClientTypes.Source?
        /// The stack attributes.
        public var attributes: [Swift.String:Swift.String]?
        /// When the app was created.
        public var createdAt: Swift.String?
        /// The app's data sources.
        public var dataSources: [OpsWorksClientTypes.DataSource]?
        /// A description of the app.
        public var description: Swift.String?
        /// The app vhost settings with multiple domains separated by commas. For example:
        ///         'www.example.com, example.com'
        ///
        public var domains: [Swift.String]?
        /// Whether to enable SSL for the app.
        public var enableSsl: Swift.Bool?
        /// An array of EnvironmentVariable objects that specify environment variables to be
        ///       associated with the app. After you deploy the app, these variables are defined on the
        ///       associated app server instances. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html#workingapps-creating-environment"> Environment Variables.
        ///
        ///             There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variable names, values, and protected flag values - cannot exceed 20 KB. This limit should accommodate most if not all use cases, but if you do exceed it, you will cause an exception (API) with an "Environment: is too large (maximum is 20 KB)" message.
        ///
        public var environment: [OpsWorksClientTypes.EnvironmentVariable]?
        /// The app name.
        public var name: Swift.String?
        /// The app's short name.
        public var shortname: Swift.String?
        /// An SslConfiguration object with the SSL configuration.
        public var sslConfiguration: OpsWorksClientTypes.SslConfiguration?
        /// The app stack ID.
        public var stackId: Swift.String?
        /// The app type.
        public var type: OpsWorksClientTypes.AppType?

        public init (
            appId: Swift.String? = nil,
            appSource: OpsWorksClientTypes.Source? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            createdAt: Swift.String? = nil,
            dataSources: [OpsWorksClientTypes.DataSource]? = nil,
            description: Swift.String? = nil,
            domains: [Swift.String]? = nil,
            enableSsl: Swift.Bool? = nil,
            environment: [OpsWorksClientTypes.EnvironmentVariable]? = nil,
            name: Swift.String? = nil,
            shortname: Swift.String? = nil,
            sslConfiguration: OpsWorksClientTypes.SslConfiguration? = nil,
            stackId: Swift.String? = nil,
            type: OpsWorksClientTypes.AppType? = nil
        )
        {
            self.appId = appId
            self.appSource = appSource
            self.attributes = attributes
            self.createdAt = createdAt
            self.dataSources = dataSources
            self.description = description
            self.domains = domains
            self.enableSsl = enableSsl
            self.environment = environment
            self.name = name
            self.shortname = shortname
            self.sslConfiguration = sslConfiguration
            self.stackId = stackId
            self.type = type
        }
    }

}

extension OpsWorksClientTypes {
    public enum AppAttributesKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case autobundleondeploy
        case awsflowrubysettings
        case documentroot
        case railsenv
        case sdkUnknown(Swift.String)

        public static var allCases: [AppAttributesKeys] {
            return [
                .autobundleondeploy,
                .awsflowrubysettings,
                .documentroot,
                .railsenv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .autobundleondeploy: return "AutoBundleOnDeploy"
            case .awsflowrubysettings: return "AwsFlowRubySettings"
            case .documentroot: return "DocumentRoot"
            case .railsenv: return "RailsEnv"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppAttributesKeys(rawValue: rawValue) ?? AppAttributesKeys.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes {
    public enum AppType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsFlowRuby
        case java
        case nodejs
        case other
        case php
        case rails
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [AppType] {
            return [
                .awsFlowRuby,
                .java,
                .nodejs,
                .other,
                .php,
                .rails,
                .static,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsFlowRuby: return "aws-flow-ruby"
            case .java: return "java"
            case .nodejs: return "nodejs"
            case .other: return "other"
            case .php: return "php"
            case .rails: return "rails"
            case .static: return "static"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppType(rawValue: rawValue) ?? AppType.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes {
    public enum Architecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case i386
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [Architecture] {
            return [
                .i386,
                .x8664,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .i386: return "i386"
            case .x8664: return "x86_64"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Architecture(rawValue: rawValue) ?? Architecture.sdkUnknown(rawValue)
        }
    }
}

public struct AssignInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssignInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssignInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssignInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssignInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssignInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssignInstanceOutputError>
}

extension AssignInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssignInstanceInput(instanceId: \(Swift.String(describing: instanceId)), layerIds: \(Swift.String(describing: layerIds)))"}
}

extension AssignInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case layerIds = "LayerIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
    }
}

public struct AssignInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssignInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssignInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssignInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssignInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssignInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssignInstanceOutputError>
}

public struct AssignInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssignInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssignInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssignInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssignInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssignInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssignInstanceOutputError>
}

public struct AssignInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssignInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssignInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssignInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssignInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssignInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssignInstanceOutputError>
}

public struct AssignInstanceInput: Swift.Equatable {
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The layer ID, which must correspond to a custom layer. You cannot assign a registered instance to a built-in layer.
    /// This member is required.
    public var layerIds: [Swift.String]?

    public init (
        instanceId: Swift.String? = nil,
        layerIds: [Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.layerIds = layerIds
    }
}

struct AssignInstanceInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let layerIds: [Swift.String]?
}

extension AssignInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case layerIds = "LayerIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
    }
}

extension AssignInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssignInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssignInstanceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssignInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssignInstanceOutputResponse()"}
}

extension AssignInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssignInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssignInstanceOutputResponseBody: Swift.Equatable {
}

extension AssignInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AssignVolumeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssignVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssignVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssignVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssignVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssignVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssignVolumeOutputError>
}

extension AssignVolumeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssignVolumeInput(instanceId: \(Swift.String(describing: instanceId)), volumeId: \(Swift.String(describing: volumeId)))"}
}

extension AssignVolumeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case volumeId = "VolumeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
    }
}

public struct AssignVolumeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssignVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssignVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssignVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssignVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssignVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssignVolumeOutputError>
}

public struct AssignVolumeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssignVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssignVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssignVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssignVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssignVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssignVolumeOutputError>
}

public struct AssignVolumeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssignVolumeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssignVolumeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssignVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssignVolumeInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssignVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssignVolumeOutputError>
}

public struct AssignVolumeInput: Swift.Equatable {
    /// The instance ID.
    public var instanceId: Swift.String?
    /// The volume ID.
    /// This member is required.
    public var volumeId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        volumeId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.volumeId = volumeId
    }
}

struct AssignVolumeInputBody: Swift.Equatable {
    public let volumeId: Swift.String?
    public let instanceId: Swift.String?
}

extension AssignVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case volumeId = "VolumeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension AssignVolumeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssignVolumeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssignVolumeOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssignVolumeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssignVolumeOutputResponse()"}
}

extension AssignVolumeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssignVolumeOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssignVolumeOutputResponseBody: Swift.Equatable {
}

extension AssignVolumeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AssociateElasticIpInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateElasticIpInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateElasticIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateElasticIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateElasticIpOutputError>
}

extension AssociateElasticIpInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateElasticIpInput(elasticIp: \(Swift.String(describing: elasticIp)), instanceId: \(Swift.String(describing: instanceId)))"}
}

extension AssociateElasticIpInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct AssociateElasticIpInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateElasticIpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateElasticIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateElasticIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateElasticIpOutputError>
}

public struct AssociateElasticIpInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateElasticIpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateElasticIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateElasticIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateElasticIpOutputError>
}

public struct AssociateElasticIpInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateElasticIpInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateElasticIpInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateElasticIpInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateElasticIpOutputError>
}

public struct AssociateElasticIpInput: Swift.Equatable {
    /// The Elastic IP address.
    /// This member is required.
    public var elasticIp: Swift.String?
    /// The instance ID.
    public var instanceId: Swift.String?

    public init (
        elasticIp: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
        self.instanceId = instanceId
    }
}

struct AssociateElasticIpInputBody: Swift.Equatable {
    public let elasticIp: Swift.String?
    public let instanceId: Swift.String?
}

extension AssociateElasticIpInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension AssociateElasticIpOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateElasticIpOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateElasticIpOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateElasticIpOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateElasticIpOutputResponse()"}
}

extension AssociateElasticIpOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateElasticIpOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateElasticIpOutputResponseBody: Swift.Equatable {
}

extension AssociateElasticIpOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AttachElasticLoadBalancerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachElasticLoadBalancerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachElasticLoadBalancerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachElasticLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachElasticLoadBalancerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachElasticLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachElasticLoadBalancerOutputError>
}

extension AttachElasticLoadBalancerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachElasticLoadBalancerInput(elasticLoadBalancerName: \(Swift.String(describing: elasticLoadBalancerName)), layerId: \(Swift.String(describing: layerId)))"}
}

extension AttachElasticLoadBalancerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticLoadBalancerName = "ElasticLoadBalancerName"
        case layerId = "LayerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticLoadBalancerName = elasticLoadBalancerName {
            try encodeContainer.encode(elasticLoadBalancerName, forKey: .elasticLoadBalancerName)
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
    }
}

public struct AttachElasticLoadBalancerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachElasticLoadBalancerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachElasticLoadBalancerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachElasticLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachElasticLoadBalancerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachElasticLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachElasticLoadBalancerOutputError>
}

public struct AttachElasticLoadBalancerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachElasticLoadBalancerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AttachElasticLoadBalancerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachElasticLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AttachElasticLoadBalancerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AttachElasticLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachElasticLoadBalancerOutputError>
}

public struct AttachElasticLoadBalancerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AttachElasticLoadBalancerInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AttachElasticLoadBalancerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AttachElasticLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AttachElasticLoadBalancerInput
    public typealias MOutput = ClientRuntime.OperationOutput<AttachElasticLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AttachElasticLoadBalancerOutputError>
}

public struct AttachElasticLoadBalancerInput: Swift.Equatable {
    /// The Elastic Load Balancing instance's name.
    /// This member is required.
    public var elasticLoadBalancerName: Swift.String?
    /// The ID of the layer to which the Elastic Load Balancing instance is to be attached.
    /// This member is required.
    public var layerId: Swift.String?

    public init (
        elasticLoadBalancerName: Swift.String? = nil,
        layerId: Swift.String? = nil
    )
    {
        self.elasticLoadBalancerName = elasticLoadBalancerName
        self.layerId = layerId
    }
}

struct AttachElasticLoadBalancerInputBody: Swift.Equatable {
    public let elasticLoadBalancerName: Swift.String?
    public let layerId: Swift.String?
}

extension AttachElasticLoadBalancerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticLoadBalancerName = "ElasticLoadBalancerName"
        case layerId = "LayerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticLoadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticLoadBalancerName)
        elasticLoadBalancerName = elasticLoadBalancerNameDecoded
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
    }
}

extension AttachElasticLoadBalancerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachElasticLoadBalancerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachElasticLoadBalancerOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachElasticLoadBalancerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachElasticLoadBalancerOutputResponse()"}
}

extension AttachElasticLoadBalancerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AttachElasticLoadBalancerOutputResponse: Swift.Equatable {

    public init() {}
}

struct AttachElasticLoadBalancerOutputResponseBody: Swift.Equatable {
}

extension AttachElasticLoadBalancerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension OpsWorksClientTypes.AutoScalingThresholds: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms = "Alarms"
        case cpuThreshold = "CpuThreshold"
        case ignoreMetricsTime = "IgnoreMetricsTime"
        case instanceCount = "InstanceCount"
        case loadThreshold = "LoadThreshold"
        case memoryThreshold = "MemoryThreshold"
        case thresholdsWaitTime = "ThresholdsWaitTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarms = alarms {
            var alarmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alarms)
            for strings0 in alarms {
                try alarmsContainer.encode(strings0)
            }
        }
        if let cpuThreshold = cpuThreshold {
            try encodeContainer.encode(cpuThreshold, forKey: .cpuThreshold)
        }
        if let ignoreMetricsTime = ignoreMetricsTime {
            try encodeContainer.encode(ignoreMetricsTime, forKey: .ignoreMetricsTime)
        }
        if let instanceCount = instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let loadThreshold = loadThreshold {
            try encodeContainer.encode(loadThreshold, forKey: .loadThreshold)
        }
        if let memoryThreshold = memoryThreshold {
            try encodeContainer.encode(memoryThreshold, forKey: .memoryThreshold)
        }
        if let thresholdsWaitTime = thresholdsWaitTime {
            try encodeContainer.encode(thresholdsWaitTime, forKey: .thresholdsWaitTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let thresholdsWaitTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .thresholdsWaitTime)
        thresholdsWaitTime = thresholdsWaitTimeDecoded
        let ignoreMetricsTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ignoreMetricsTime)
        ignoreMetricsTime = ignoreMetricsTimeDecoded
        let cpuThresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .cpuThreshold)
        cpuThreshold = cpuThresholdDecoded
        let memoryThresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .memoryThreshold)
        memoryThreshold = memoryThresholdDecoded
        let loadThresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .loadThreshold)
        loadThreshold = loadThresholdDecoded
        let alarmsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .alarms)
        var alarmsDecoded0:[Swift.String]? = nil
        if let alarmsContainer = alarmsContainer {
            alarmsDecoded0 = [Swift.String]()
            for string0 in alarmsContainer {
                if let string0 = string0 {
                    alarmsDecoded0?.append(string0)
                }
            }
        }
        alarms = alarmsDecoded0
    }
}

extension OpsWorksClientTypes.AutoScalingThresholds: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutoScalingThresholds(alarms: \(Swift.String(describing: alarms)), cpuThreshold: \(Swift.String(describing: cpuThreshold)), ignoreMetricsTime: \(Swift.String(describing: ignoreMetricsTime)), instanceCount: \(Swift.String(describing: instanceCount)), loadThreshold: \(Swift.String(describing: loadThreshold)), memoryThreshold: \(Swift.String(describing: memoryThreshold)), thresholdsWaitTime: \(Swift.String(describing: thresholdsWaitTime)))"}
}

extension OpsWorksClientTypes {
    /// Describes a load-based auto scaling upscaling or downscaling threshold configuration, which specifies when AWS OpsWorks Stacks starts or stops load-based instances.
    public struct AutoScalingThresholds: Swift.Equatable {
        /// Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names,
        ///           which are case sensitive and must be in the same region as the stack.
        ///
        ///             To use custom alarms, you must update your service role to allow
        ///         cloudwatch:DescribeAlarms. You can either have AWS OpsWorks Stacks update the role for
        ///       you when you first use this feature or you can edit the role manually. For more information,
        ///       see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/opsworks-security-servicerole.html">Allowing AWS OpsWorks Stacks to Act on Your Behalf.
        ///
        public var alarms: [Swift.String]?
        /// The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
        public var cpuThreshold: Swift.Double?
        /// The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics
        ///       and suppress additional scaling events. For example, AWS OpsWorks Stacks adds new instances following
        ///       an upscaling event but the instances won't start reducing the load until they have been booted
        ///       and configured. There is no point in raising additional scaling events during that operation,
        ///       which typically takes several minutes. IgnoreMetricsTime allows you to direct
        ///       AWS OpsWorks Stacks to suppress scaling events long enough to get the new instances online.
        public var ignoreMetricsTime: Swift.Int?
        /// The number of instances to add or remove when the load exceeds a threshold.
        public var instanceCount: Swift.Int?
        /// The load threshold. A value of -1 disables the threshold. For more information about how load is computed, see <a href="http://en.wikipedia.org/wiki/Load_%28computing%29">Load (computing).
        public var loadThreshold: Swift.Double?
        /// The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
        public var memoryThreshold: Swift.Double?
        /// The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
        public var thresholdsWaitTime: Swift.Int?

        public init (
            alarms: [Swift.String]? = nil,
            cpuThreshold: Swift.Double? = nil,
            ignoreMetricsTime: Swift.Int? = nil,
            instanceCount: Swift.Int? = nil,
            loadThreshold: Swift.Double? = nil,
            memoryThreshold: Swift.Double? = nil,
            thresholdsWaitTime: Swift.Int? = nil
        )
        {
            self.alarms = alarms
            self.cpuThreshold = cpuThreshold
            self.ignoreMetricsTime = ignoreMetricsTime
            self.instanceCount = instanceCount
            self.loadThreshold = loadThreshold
            self.memoryThreshold = memoryThreshold
            self.thresholdsWaitTime = thresholdsWaitTime
        }
    }

}

extension OpsWorksClientTypes {
    public enum AutoScalingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case load
        case timer
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoScalingType] {
            return [
                .load,
                .timer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .load: return "load"
            case .timer: return "timer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoScalingType(rawValue: rawValue) ?? AutoScalingType.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.BlockDeviceMapping: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName = "DeviceName"
        case ebs = "Ebs"
        case noDevice = "NoDevice"
        case virtualName = "VirtualName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let ebs = ebs {
            try encodeContainer.encode(ebs, forKey: .ebs)
        }
        if let noDevice = noDevice {
            try encodeContainer.encode(noDevice, forKey: .noDevice)
        }
        if let virtualName = virtualName {
            try encodeContainer.encode(virtualName, forKey: .virtualName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let noDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .noDevice)
        noDevice = noDeviceDecoded
        let virtualNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualName)
        virtualName = virtualNameDecoded
        let ebsDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.EbsBlockDevice.self, forKey: .ebs)
        ebs = ebsDecoded
    }
}

extension OpsWorksClientTypes.BlockDeviceMapping: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BlockDeviceMapping(deviceName: \(Swift.String(describing: deviceName)), ebs: \(Swift.String(describing: ebs)), noDevice: \(Swift.String(describing: noDevice)), virtualName: \(Swift.String(describing: virtualName)))"}
}

extension OpsWorksClientTypes {
    /// Describes a block device mapping. This data type maps directly to the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_BlockDeviceMapping.html">BlockDeviceMapping data type.
    public struct BlockDeviceMapping: Swift.Equatable {
        /// The device name that is exposed to the instance, such as /dev/sdh. For the root
        ///       device, you can use the explicit device name or you can set this parameter to
        ///         ROOT_DEVICE and AWS OpsWorks Stacks will provide the correct device name.
        public var deviceName: Swift.String?
        /// An EBSBlockDevice that defines how to configure an Amazon EBS volume when the
        ///       instance is launched.
        public var ebs: OpsWorksClientTypes.EbsBlockDevice?
        /// Suppresses the specified device included in the AMI's block device mapping.
        public var noDevice: Swift.String?
        /// The virtual device name. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_BlockDeviceMapping.html">BlockDeviceMapping.
        public var virtualName: Swift.String?

        public init (
            deviceName: Swift.String? = nil,
            ebs: OpsWorksClientTypes.EbsBlockDevice? = nil,
            noDevice: Swift.String? = nil,
            virtualName: Swift.String? = nil
        )
        {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }
    }

}

extension OpsWorksClientTypes.ChefConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case berkshelfVersion = "BerkshelfVersion"
        case manageBerkshelf = "ManageBerkshelf"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let berkshelfVersion = berkshelfVersion {
            try encodeContainer.encode(berkshelfVersion, forKey: .berkshelfVersion)
        }
        if let manageBerkshelf = manageBerkshelf {
            try encodeContainer.encode(manageBerkshelf, forKey: .manageBerkshelf)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manageBerkshelfDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .manageBerkshelf)
        manageBerkshelf = manageBerkshelfDecoded
        let berkshelfVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .berkshelfVersion)
        berkshelfVersion = berkshelfVersionDecoded
    }
}

extension OpsWorksClientTypes.ChefConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChefConfiguration(berkshelfVersion: \(Swift.String(describing: berkshelfVersion)), manageBerkshelf: \(Swift.String(describing: manageBerkshelf)))"}
}

extension OpsWorksClientTypes {
    /// Describes the Chef configuration.
    public struct ChefConfiguration: Swift.Equatable {
        /// The Berkshelf version.
        public var berkshelfVersion: Swift.String?
        /// Whether to enable Berkshelf.
        public var manageBerkshelf: Swift.Bool?

        public init (
            berkshelfVersion: Swift.String? = nil,
            manageBerkshelf: Swift.Bool? = nil
        )
        {
            self.berkshelfVersion = berkshelfVersion
            self.manageBerkshelf = manageBerkshelf
        }
    }

}

public struct CloneStackInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CloneStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CloneStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CloneStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CloneStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CloneStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CloneStackOutputError>
}

extension CloneStackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloneStackInput(agentVersion: \(Swift.String(describing: agentVersion)), attributes: \(Swift.String(describing: attributes)), chefConfiguration: \(Swift.String(describing: chefConfiguration)), cloneAppIds: \(Swift.String(describing: cloneAppIds)), clonePermissions: \(Swift.String(describing: clonePermissions)), configurationManager: \(Swift.String(describing: configurationManager)), customCookbooksSource: \(Swift.String(describing: customCookbooksSource)), customJson: \(Swift.String(describing: customJson)), defaultAvailabilityZone: \(Swift.String(describing: defaultAvailabilityZone)), defaultInstanceProfileArn: \(Swift.String(describing: defaultInstanceProfileArn)), defaultOs: \(Swift.String(describing: defaultOs)), defaultRootDeviceType: \(Swift.String(describing: defaultRootDeviceType)), defaultSshKeyName: \(Swift.String(describing: defaultSshKeyName)), defaultSubnetId: \(Swift.String(describing: defaultSubnetId)), hostnameTheme: \(Swift.String(describing: hostnameTheme)), name: \(Swift.String(describing: name)), region: \(Swift.String(describing: region)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), sourceStackId: \(Swift.String(describing: sourceStackId)), useCustomCookbooks: \(Swift.String(describing: useCustomCookbooks)), useOpsworksSecurityGroups: \(Swift.String(describing: useOpsworksSecurityGroups)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension CloneStackInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case cloneAppIds = "CloneAppIds"
        case clonePermissions = "ClonePermissions"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case region = "Region"
        case serviceRoleArn = "ServiceRoleArn"
        case sourceStackId = "SourceStackId"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, stackattributes0) in attributes {
                try attributesContainer.encode(stackattributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let chefConfiguration = chefConfiguration {
            try encodeContainer.encode(chefConfiguration, forKey: .chefConfiguration)
        }
        if let cloneAppIds = cloneAppIds {
            var cloneAppIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloneAppIds)
            for strings0 in cloneAppIds {
                try cloneAppIdsContainer.encode(strings0)
            }
        }
        if let clonePermissions = clonePermissions {
            try encodeContainer.encode(clonePermissions, forKey: .clonePermissions)
        }
        if let configurationManager = configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let customCookbooksSource = customCookbooksSource {
            try encodeContainer.encode(customCookbooksSource, forKey: .customCookbooksSource)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let defaultAvailabilityZone = defaultAvailabilityZone {
            try encodeContainer.encode(defaultAvailabilityZone, forKey: .defaultAvailabilityZone)
        }
        if let defaultInstanceProfileArn = defaultInstanceProfileArn {
            try encodeContainer.encode(defaultInstanceProfileArn, forKey: .defaultInstanceProfileArn)
        }
        if let defaultOs = defaultOs {
            try encodeContainer.encode(defaultOs, forKey: .defaultOs)
        }
        if let defaultRootDeviceType = defaultRootDeviceType {
            try encodeContainer.encode(defaultRootDeviceType.rawValue, forKey: .defaultRootDeviceType)
        }
        if let defaultSshKeyName = defaultSshKeyName {
            try encodeContainer.encode(defaultSshKeyName, forKey: .defaultSshKeyName)
        }
        if let defaultSubnetId = defaultSubnetId {
            try encodeContainer.encode(defaultSubnetId, forKey: .defaultSubnetId)
        }
        if let hostnameTheme = hostnameTheme {
            try encodeContainer.encode(hostnameTheme, forKey: .hostnameTheme)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let sourceStackId = sourceStackId {
            try encodeContainer.encode(sourceStackId, forKey: .sourceStackId)
        }
        if let useCustomCookbooks = useCustomCookbooks {
            try encodeContainer.encode(useCustomCookbooks, forKey: .useCustomCookbooks)
        }
        if let useOpsworksSecurityGroups = useOpsworksSecurityGroups {
            try encodeContainer.encode(useOpsworksSecurityGroups, forKey: .useOpsworksSecurityGroups)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

public struct CloneStackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CloneStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CloneStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CloneStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CloneStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CloneStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CloneStackOutputError>
}

public struct CloneStackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CloneStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CloneStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CloneStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CloneStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CloneStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CloneStackOutputError>
}

public struct CloneStackInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CloneStackInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CloneStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CloneStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CloneStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<CloneStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CloneStackOutputError>
}

public struct CloneStackInput: Swift.Equatable {
    /// The default AWS OpsWorks Stacks agent version. You have the following options:
    ///
    ///
    ///                Auto-update - Set this parameter to LATEST. AWS OpsWorks Stacks
    ///       automatically installs new agent versions on the stack's instances as soon as
    ///       they are available.
    ///
    ///
    ///                Fixed version - Set this parameter to your preferred agent version. To update
    ///              the agent version, you must edit the stack configuration and specify a new version.
    ///              AWS OpsWorks Stacks then automatically installs that version on the stack's instances.
    ///
    ///
    ///          The default setting is LATEST. To specify an agent version,
    ///       you must use the complete version number, not the abbreviated number shown on the console.
    ///       For a list of available agent version numbers, call DescribeAgentVersions. AgentVersion cannot be set to Chef 12.2.
    ///
    ///             You can also specify an agent version when you create or update an instance, which overrides the stack's default setting.
    ///
    public var agentVersion: Swift.String?
    /// A list of stack attributes and values as key/value pairs to be added to the cloned stack.
    public var attributes: [Swift.String:Swift.String]?
    /// A ChefConfiguration object that specifies whether to enable Berkshelf and the
    ///       Berkshelf version on Chef 11.10 stacks. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html">Create a New Stack.
    public var chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
    /// A list of source stack app IDs to be included in the cloned stack.
    public var cloneAppIds: [Swift.String]?
    /// Whether to clone the source stack's permissions.
    public var clonePermissions: Swift.Bool?
    /// The configuration manager. When you clone a stack we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 12.
    public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    /// Contains the information required to retrieve an app or cookbook from a repository. For more information,
    ///             see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html">Adding Apps or <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html">Cookbooks and Recipes.
    public var customCookbooksSource: OpsWorksClientTypes.Source?
    /// A string that contains user-defined, custom JSON. It is used to override the corresponding default stack configuration JSON values. The string should be in the following format:
    ///
    ///             "{\"key1\": \"value1\", \"key2\": \"value2\",...}"
    ///
    ///          For more information about custom JSON, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html">Use Custom JSON to
    ///         Modify the Stack Configuration Attributes
    ///
    public var customJson: Swift.String?
    /// The cloned stack's default Availability Zone, which must be in the specified region. For more
    ///       information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and
    ///         Endpoints. If you also specify a value for DefaultSubnetId, the subnet must
    ///       be in the same zone. For more information, see the VpcId parameter description.
    ///
    public var defaultAvailabilityZone: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM profile that is the default profile for all of the stack's EC2 instances.
    ///       For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers.
    public var defaultInstanceProfileArn: Swift.String?
    /// The stack's operating system, which must be set to one of the following.
    ///
    ///
    ///                A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2018.03, Amazon Linux 2017.09, Amazon Linux 2017.03, Amazon Linux
    ///         2016.09, Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.
    ///
    ///
    ///                A supported Ubuntu operating system, such as Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.
    ///
    ///
    ///
    ///                   CentOS Linux 7
    ///
    ///
    ///
    ///
    ///                   Red Hat Enterprise Linux 7
    ///
    ///
    ///
    ///
    ///                   Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express,
    ///               Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.
    ///
    ///
    ///                A custom AMI: Custom. You specify the custom AMI you want to use when
    ///         you create instances. For more information about how to use custom AMIs with OpsWorks, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html">Using
    ///           Custom AMIs.
    ///
    ///
    ///          The default option is the parent stack's operating system.
    ///       For more information about supported operating systems,
    ///       see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html">AWS OpsWorks Stacks Operating Systems.
    ///
    ///             You can specify a different Linux operating system for the cloned stack, but you cannot change from Linux to Windows or Windows to Linux.
    ///
    public var defaultOs: Swift.String?
    /// The default root device type. This value is used by default for all instances in the cloned
    ///       stack, but you can override it when you create an instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device">Storage for the Root Device.
    public var defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
    /// A default Amazon EC2 key pair name. The default value is none. If you specify a key pair name, AWS
    ///       OpsWorks installs the public key on the instance and you can use the private key with an SSH
    ///       client to log in to the instance. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-ssh.html"> Using SSH to
    ///         Communicate with an Instance and <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/security-ssh-access.html"> Managing SSH
    ///         Access. You can override this setting by specifying a different key pair, or no key
    ///       pair, when you <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-add.html">
    ///         create an instance.
    public var defaultSshKeyName: Swift.String?
    /// The stack's default VPC subnet ID. This parameter is required if you specify a value for the
    ///         VpcId parameter. All instances are launched into this subnet unless you specify
    ///       otherwise when you create the instance. If you also specify a value for
    ///         DefaultAvailabilityZone, the subnet must be in that zone. For information on
    ///       default values and when this parameter is required, see the VpcId parameter
    ///       description.
    public var defaultSubnetId: Swift.String?
    /// The stack's host name theme, with spaces are replaced by underscores. The theme is used to
    ///       generate host names for the stack's instances. By default, HostnameTheme is set
    ///       to Layer_Dependent, which creates host names by appending integers to the layer's
    ///       short name. The other themes are:
    ///
    ///
    ///
    ///                   Baked_Goods
    ///
    ///
    ///
    ///
    ///                   Clouds
    ///
    ///
    ///
    ///
    ///                   Europe_Cities
    ///
    ///
    ///
    ///
    ///                   Fruits
    ///
    ///
    ///
    ///
    ///                   Greek_Deities_and_Titans
    ///
    ///
    ///
    ///
    ///                   Legendary_creatures_from_Japan
    ///
    ///
    ///
    ///
    ///                   Planets_and_Moons
    ///
    ///
    ///
    ///
    ///                   Roman_Deities
    ///
    ///
    ///
    ///
    ///                   Scottish_Islands
    ///
    ///
    ///
    ///
    ///                   US_Cities
    ///
    ///
    ///
    ///
    ///                   Wild_Cats
    ///
    ///
    ///
    ///          To obtain a generated host name, call GetHostNameSuggestion, which returns a
    ///       host name based on the current theme.
    public var hostnameTheme: Swift.String?
    /// The cloned stack name.
    public var name: Swift.String?
    /// The cloned stack AWS region, such as "ap-northeast-2". For more information about AWS regions, see
    ///         <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints.
    public var region: Swift.String?
    /// The stack AWS Identity and Access Management (IAM) role, which allows AWS OpsWorks Stacks to work with AWS
    ///       resources on your behalf. You must set this parameter to the Amazon Resource Name (ARN) for an
    ///       existing IAM role. If you create a stack by using the AWS OpsWorks Stacks console, it creates the role for
    ///       you. You can obtain an existing stack's IAM ARN programmatically by calling
    ///         DescribePermissions. For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers.
    ///
    ///             You must set this parameter to a valid service role ARN or the action will fail; there is no default value. You can specify the source stack's service role ARN, if you prefer, but you must do so explicitly.
    ///
    /// This member is required.
    public var serviceRoleArn: Swift.String?
    /// The source stack ID.
    /// This member is required.
    public var sourceStackId: Swift.String?
    /// Whether to use custom cookbooks.
    public var useCustomCookbooks: Swift.Bool?
    /// Whether to associate the AWS OpsWorks Stacks built-in security groups with the stack's layers.
    ///          AWS OpsWorks Stacks provides a standard set of built-in security groups, one for each layer, which are
    ///       associated with layers by default. With UseOpsworksSecurityGroups you can instead
    ///       provide your own custom security groups. UseOpsworksSecurityGroups has the
    ///       following settings:
    ///
    ///
    ///                True - AWS OpsWorks Stacks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it but you cannot delete the built-in security group.
    ///
    ///
    ///                False - AWS OpsWorks Stacks does not associate built-in security groups with layers. You must create appropriate Amazon Elastic Compute Cloud (Amazon EC2) security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on creation; custom security groups are required only for those layers that need custom settings.
    ///
    ///
    ///          For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html">Create a New
    ///         Stack.
    public var useOpsworksSecurityGroups: Swift.Bool?
    /// The ID of the VPC that the cloned stack is to be launched into. It must be in the specified region. All
    ///           instances are launched into this VPC, and you cannot change the ID later.
    ///
    ///
    ///                If your account supports EC2 Classic, the default value is no VPC.
    ///
    ///
    ///                If your account does not support EC2 Classic, the default value is the default VPC for the specified region.
    ///
    ///
    ///          If the VPC ID corresponds to a default VPC and you have specified either the
    ///         DefaultAvailabilityZone or the DefaultSubnetId parameter only,
    ///       AWS OpsWorks Stacks infers the value of the other parameter. If you specify neither parameter, AWS OpsWorks Stacks sets
    ///       these parameters to the first valid Availability Zone for the specified region and the
    ///       corresponding default VPC subnet ID, respectively.
    ///          If you specify a nondefault VPC ID, note the following:
    ///
    ///
    ///                It must belong to a VPC in your account that is in the specified region.
    ///
    ///
    ///                You must specify a value for DefaultSubnetId.
    ///
    ///
    ///          For more information about how to use AWS OpsWorks Stacks with a VPC, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-vpc.html">Running a Stack in a
    ///         VPC. For more information about default VPC and EC2 Classic, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html">Supported
    ///         Platforms.
    public var vpcId: Swift.String?

    public init (
        agentVersion: Swift.String? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        chefConfiguration: OpsWorksClientTypes.ChefConfiguration? = nil,
        cloneAppIds: [Swift.String]? = nil,
        clonePermissions: Swift.Bool? = nil,
        configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
        customCookbooksSource: OpsWorksClientTypes.Source? = nil,
        customJson: Swift.String? = nil,
        defaultAvailabilityZone: Swift.String? = nil,
        defaultInstanceProfileArn: Swift.String? = nil,
        defaultOs: Swift.String? = nil,
        defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
        defaultSshKeyName: Swift.String? = nil,
        defaultSubnetId: Swift.String? = nil,
        hostnameTheme: Swift.String? = nil,
        name: Swift.String? = nil,
        region: Swift.String? = nil,
        serviceRoleArn: Swift.String? = nil,
        sourceStackId: Swift.String? = nil,
        useCustomCookbooks: Swift.Bool? = nil,
        useOpsworksSecurityGroups: Swift.Bool? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.attributes = attributes
        self.chefConfiguration = chefConfiguration
        self.cloneAppIds = cloneAppIds
        self.clonePermissions = clonePermissions
        self.configurationManager = configurationManager
        self.customCookbooksSource = customCookbooksSource
        self.customJson = customJson
        self.defaultAvailabilityZone = defaultAvailabilityZone
        self.defaultInstanceProfileArn = defaultInstanceProfileArn
        self.defaultOs = defaultOs
        self.defaultRootDeviceType = defaultRootDeviceType
        self.defaultSshKeyName = defaultSshKeyName
        self.defaultSubnetId = defaultSubnetId
        self.hostnameTheme = hostnameTheme
        self.name = name
        self.region = region
        self.serviceRoleArn = serviceRoleArn
        self.sourceStackId = sourceStackId
        self.useCustomCookbooks = useCustomCookbooks
        self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
        self.vpcId = vpcId
    }
}

struct CloneStackInputBody: Swift.Equatable {
    public let sourceStackId: Swift.String?
    public let name: Swift.String?
    public let region: Swift.String?
    public let vpcId: Swift.String?
    public let attributes: [Swift.String:Swift.String]?
    public let serviceRoleArn: Swift.String?
    public let defaultInstanceProfileArn: Swift.String?
    public let defaultOs: Swift.String?
    public let hostnameTheme: Swift.String?
    public let defaultAvailabilityZone: Swift.String?
    public let defaultSubnetId: Swift.String?
    public let customJson: Swift.String?
    public let configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    public let chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
    public let useCustomCookbooks: Swift.Bool?
    public let useOpsworksSecurityGroups: Swift.Bool?
    public let customCookbooksSource: OpsWorksClientTypes.Source?
    public let defaultSshKeyName: Swift.String?
    public let clonePermissions: Swift.Bool?
    public let cloneAppIds: [Swift.String]?
    public let defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
    public let agentVersion: Swift.String?
}

extension CloneStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case cloneAppIds = "CloneAppIds"
        case clonePermissions = "ClonePermissions"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case region = "Region"
        case serviceRoleArn = "ServiceRoleArn"
        case sourceStackId = "SourceStackId"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceStackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceStackId)
        sourceStackId = sourceStackIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let defaultInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultInstanceProfileArn)
        defaultInstanceProfileArn = defaultInstanceProfileArnDecoded
        let defaultOsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOs)
        defaultOs = defaultOsDecoded
        let hostnameThemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostnameTheme)
        hostnameTheme = hostnameThemeDecoded
        let defaultAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultAvailabilityZone)
        defaultAvailabilityZone = defaultAvailabilityZoneDecoded
        let defaultSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSubnetId)
        defaultSubnetId = defaultSubnetIdDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
        let chefConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.ChefConfiguration.self, forKey: .chefConfiguration)
        chefConfiguration = chefConfigurationDecoded
        let useCustomCookbooksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useCustomCookbooks)
        useCustomCookbooks = useCustomCookbooksDecoded
        let useOpsworksSecurityGroupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useOpsworksSecurityGroups)
        useOpsworksSecurityGroups = useOpsworksSecurityGroupsDecoded
        let customCookbooksSourceDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Source.self, forKey: .customCookbooksSource)
        customCookbooksSource = customCookbooksSourceDecoded
        let defaultSshKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSshKeyName)
        defaultSshKeyName = defaultSshKeyNameDecoded
        let clonePermissionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clonePermissions)
        clonePermissions = clonePermissionsDecoded
        let cloneAppIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cloneAppIds)
        var cloneAppIdsDecoded0:[Swift.String]? = nil
        if let cloneAppIdsContainer = cloneAppIdsContainer {
            cloneAppIdsDecoded0 = [Swift.String]()
            for string0 in cloneAppIdsContainer {
                if let string0 = string0 {
                    cloneAppIdsDecoded0?.append(string0)
                }
            }
        }
        cloneAppIds = cloneAppIdsDecoded0
        let defaultRootDeviceTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.RootDeviceType.self, forKey: .defaultRootDeviceType)
        defaultRootDeviceType = defaultRootDeviceTypeDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension CloneStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CloneStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CloneStackOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CloneStackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloneStackOutputResponse(stackId: \(Swift.String(describing: stackId)))"}
}

extension CloneStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CloneStackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stackId = output.stackId
        } else {
            self.stackId = nil
        }
    }
}

/// Contains the response to a CloneStack request.
public struct CloneStackOutputResponse: Swift.Equatable {
    /// The cloned stack ID.
    public var stackId: Swift.String?

    public init (
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct CloneStackOutputResponseBody: Swift.Equatable {
    public let stackId: Swift.String?
}

extension CloneStackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension OpsWorksClientTypes.CloudWatchLogsConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case logStreams = "LogStreams"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let logStreams = logStreams {
            var logStreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logStreams)
            for cloudwatchlogslogstreams0 in logStreams {
                try logStreamsContainer.encode(cloudwatchlogslogstreams0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let logStreamsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.CloudWatchLogsLogStream?].self, forKey: .logStreams)
        var logStreamsDecoded0:[OpsWorksClientTypes.CloudWatchLogsLogStream]? = nil
        if let logStreamsContainer = logStreamsContainer {
            logStreamsDecoded0 = [OpsWorksClientTypes.CloudWatchLogsLogStream]()
            for structure0 in logStreamsContainer {
                if let structure0 = structure0 {
                    logStreamsDecoded0?.append(structure0)
                }
            }
        }
        logStreams = logStreamsDecoded0
    }
}

extension OpsWorksClientTypes.CloudWatchLogsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudWatchLogsConfiguration(enabled: \(Swift.String(describing: enabled)), logStreams: \(Swift.String(describing: logStreams)))"}
}

extension OpsWorksClientTypes {
    /// Describes the Amazon CloudWatch logs configuration for a layer.
    public struct CloudWatchLogsConfiguration: Swift.Equatable {
        /// Whether CloudWatch Logs is enabled for a layer.
        public var enabled: Swift.Bool?
        /// A list of configuration options for CloudWatch Logs.
        public var logStreams: [OpsWorksClientTypes.CloudWatchLogsLogStream]?

        public init (
            enabled: Swift.Bool? = nil,
            logStreams: [OpsWorksClientTypes.CloudWatchLogsLogStream]? = nil
        )
        {
            self.enabled = enabled
            self.logStreams = logStreams
        }
    }

}

extension OpsWorksClientTypes {
    /// Specifies the encoding of the log file so that the file can be read correctly. The default is utf_8. Encodings supported by Python codecs.decode() can be used here.
    public enum CloudWatchLogsEncoding: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascii
        case big5
        case big5hkscs
        case cp037
        case cp1006
        case cp1026
        case cp1140
        case cp1250
        case cp1251
        case cp1252
        case cp1253
        case cp1254
        case cp1255
        case cp1256
        case cp1257
        case cp1258
        case cp424
        case cp437
        case cp500
        case cp720
        case cp737
        case cp775
        case cp850
        case cp852
        case cp855
        case cp856
        case cp857
        case cp858
        case cp860
        case cp861
        case cp862
        case cp863
        case cp864
        case cp865
        case cp866
        case cp869
        case cp874
        case cp875
        case cp932
        case cp949
        case cp950
        case eucJis2004
        case eucJisx0213
        case eucJp
        case eucKr
        case gb18030
        case gb2312
        case gbk
        case hz
        case iso2022Jp
        case iso2022Jp1
        case iso2022Jp2
        case iso2022Jp2004
        case iso2022Jp3
        case iso2022JpExt
        case iso2022Kr
        case iso885910
        case iso885913
        case iso885914
        case iso885915
        case iso885916
        case iso88592
        case iso88593
        case iso88594
        case iso88595
        case iso88596
        case iso88597
        case iso88598
        case iso88599
        case johab
        case koi8R
        case koi8U
        case latin1
        case macCyrillic
        case macGreek
        case macIceland
        case macLatin2
        case macRoman
        case macTurkish
        case ptcp154
        case shiftJis
        case shiftJis2004
        case shiftJisx0213
        case utf16
        case utf16Be
        case utf16Le
        case utf32
        case utf32Be
        case utf32Le
        case utf7
        case utf8
        case utf8Sig
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchLogsEncoding] {
            return [
                .ascii,
                .big5,
                .big5hkscs,
                .cp037,
                .cp1006,
                .cp1026,
                .cp1140,
                .cp1250,
                .cp1251,
                .cp1252,
                .cp1253,
                .cp1254,
                .cp1255,
                .cp1256,
                .cp1257,
                .cp1258,
                .cp424,
                .cp437,
                .cp500,
                .cp720,
                .cp737,
                .cp775,
                .cp850,
                .cp852,
                .cp855,
                .cp856,
                .cp857,
                .cp858,
                .cp860,
                .cp861,
                .cp862,
                .cp863,
                .cp864,
                .cp865,
                .cp866,
                .cp869,
                .cp874,
                .cp875,
                .cp932,
                .cp949,
                .cp950,
                .eucJis2004,
                .eucJisx0213,
                .eucJp,
                .eucKr,
                .gb18030,
                .gb2312,
                .gbk,
                .hz,
                .iso2022Jp,
                .iso2022Jp1,
                .iso2022Jp2,
                .iso2022Jp2004,
                .iso2022Jp3,
                .iso2022JpExt,
                .iso2022Kr,
                .iso885910,
                .iso885913,
                .iso885914,
                .iso885915,
                .iso885916,
                .iso88592,
                .iso88593,
                .iso88594,
                .iso88595,
                .iso88596,
                .iso88597,
                .iso88598,
                .iso88599,
                .johab,
                .koi8R,
                .koi8U,
                .latin1,
                .macCyrillic,
                .macGreek,
                .macIceland,
                .macLatin2,
                .macRoman,
                .macTurkish,
                .ptcp154,
                .shiftJis,
                .shiftJis2004,
                .shiftJisx0213,
                .utf16,
                .utf16Be,
                .utf16Le,
                .utf32,
                .utf32Be,
                .utf32Le,
                .utf7,
                .utf8,
                .utf8Sig,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascii: return "ascii"
            case .big5: return "big5"
            case .big5hkscs: return "big5hkscs"
            case .cp037: return "cp037"
            case .cp1006: return "cp1006"
            case .cp1026: return "cp1026"
            case .cp1140: return "cp1140"
            case .cp1250: return "cp1250"
            case .cp1251: return "cp1251"
            case .cp1252: return "cp1252"
            case .cp1253: return "cp1253"
            case .cp1254: return "cp1254"
            case .cp1255: return "cp1255"
            case .cp1256: return "cp1256"
            case .cp1257: return "cp1257"
            case .cp1258: return "cp1258"
            case .cp424: return "cp424"
            case .cp437: return "cp437"
            case .cp500: return "cp500"
            case .cp720: return "cp720"
            case .cp737: return "cp737"
            case .cp775: return "cp775"
            case .cp850: return "cp850"
            case .cp852: return "cp852"
            case .cp855: return "cp855"
            case .cp856: return "cp856"
            case .cp857: return "cp857"
            case .cp858: return "cp858"
            case .cp860: return "cp860"
            case .cp861: return "cp861"
            case .cp862: return "cp862"
            case .cp863: return "cp863"
            case .cp864: return "cp864"
            case .cp865: return "cp865"
            case .cp866: return "cp866"
            case .cp869: return "cp869"
            case .cp874: return "cp874"
            case .cp875: return "cp875"
            case .cp932: return "cp932"
            case .cp949: return "cp949"
            case .cp950: return "cp950"
            case .eucJis2004: return "euc_jis_2004"
            case .eucJisx0213: return "euc_jisx0213"
            case .eucJp: return "euc_jp"
            case .eucKr: return "euc_kr"
            case .gb18030: return "gb18030"
            case .gb2312: return "gb2312"
            case .gbk: return "gbk"
            case .hz: return "hz"
            case .iso2022Jp: return "iso2022_jp"
            case .iso2022Jp1: return "iso2022_jp_1"
            case .iso2022Jp2: return "iso2022_jp_2"
            case .iso2022Jp2004: return "iso2022_jp_2004"
            case .iso2022Jp3: return "iso2022_jp_3"
            case .iso2022JpExt: return "iso2022_jp_ext"
            case .iso2022Kr: return "iso2022_kr"
            case .iso885910: return "iso8859_10"
            case .iso885913: return "iso8859_13"
            case .iso885914: return "iso8859_14"
            case .iso885915: return "iso8859_15"
            case .iso885916: return "iso8859_16"
            case .iso88592: return "iso8859_2"
            case .iso88593: return "iso8859_3"
            case .iso88594: return "iso8859_4"
            case .iso88595: return "iso8859_5"
            case .iso88596: return "iso8859_6"
            case .iso88597: return "iso8859_7"
            case .iso88598: return "iso8859_8"
            case .iso88599: return "iso8859_9"
            case .johab: return "johab"
            case .koi8R: return "koi8_r"
            case .koi8U: return "koi8_u"
            case .latin1: return "latin_1"
            case .macCyrillic: return "mac_cyrillic"
            case .macGreek: return "mac_greek"
            case .macIceland: return "mac_iceland"
            case .macLatin2: return "mac_latin2"
            case .macRoman: return "mac_roman"
            case .macTurkish: return "mac_turkish"
            case .ptcp154: return "ptcp154"
            case .shiftJis: return "shift_jis"
            case .shiftJis2004: return "shift_jis_2004"
            case .shiftJisx0213: return "shift_jisx0213"
            case .utf16: return "utf_16"
            case .utf16Be: return "utf_16_be"
            case .utf16Le: return "utf_16_le"
            case .utf32: return "utf_32"
            case .utf32Be: return "utf_32_be"
            case .utf32Le: return "utf_32_le"
            case .utf7: return "utf_7"
            case .utf8: return "utf_8"
            case .utf8Sig: return "utf_8_sig"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudWatchLogsEncoding(rawValue: rawValue) ?? CloudWatchLogsEncoding.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes {
    /// Specifies where to start to read data (start_of_file or end_of_file). The default is start_of_file. It's only used if there is no state persisted for that log stream.
    public enum CloudWatchLogsInitialPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case endOfFile
        case startOfFile
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchLogsInitialPosition] {
            return [
                .endOfFile,
                .startOfFile,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .endOfFile: return "end_of_file"
            case .startOfFile: return "start_of_file"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudWatchLogsInitialPosition(rawValue: rawValue) ?? CloudWatchLogsInitialPosition.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.CloudWatchLogsLogStream: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchCount = "BatchCount"
        case batchSize = "BatchSize"
        case bufferDuration = "BufferDuration"
        case datetimeFormat = "DatetimeFormat"
        case encoding = "Encoding"
        case file = "File"
        case fileFingerprintLines = "FileFingerprintLines"
        case initialPosition = "InitialPosition"
        case logGroupName = "LogGroupName"
        case multiLineStartPattern = "MultiLineStartPattern"
        case timeZone = "TimeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchCount = batchCount {
            try encodeContainer.encode(batchCount, forKey: .batchCount)
        }
        if let batchSize = batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let bufferDuration = bufferDuration {
            try encodeContainer.encode(bufferDuration, forKey: .bufferDuration)
        }
        if let datetimeFormat = datetimeFormat {
            try encodeContainer.encode(datetimeFormat, forKey: .datetimeFormat)
        }
        if let encoding = encoding {
            try encodeContainer.encode(encoding.rawValue, forKey: .encoding)
        }
        if let file = file {
            try encodeContainer.encode(file, forKey: .file)
        }
        if let fileFingerprintLines = fileFingerprintLines {
            try encodeContainer.encode(fileFingerprintLines, forKey: .fileFingerprintLines)
        }
        if let initialPosition = initialPosition {
            try encodeContainer.encode(initialPosition.rawValue, forKey: .initialPosition)
        }
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let multiLineStartPattern = multiLineStartPattern {
            try encodeContainer.encode(multiLineStartPattern, forKey: .multiLineStartPattern)
        }
        if let timeZone = timeZone {
            try encodeContainer.encode(timeZone.rawValue, forKey: .timeZone)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let datetimeFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datetimeFormat)
        datetimeFormat = datetimeFormatDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.CloudWatchLogsTimeZone.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let fileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .file)
        file = fileDecoded
        let fileFingerprintLinesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileFingerprintLines)
        fileFingerprintLines = fileFingerprintLinesDecoded
        let multiLineStartPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multiLineStartPattern)
        multiLineStartPattern = multiLineStartPatternDecoded
        let initialPositionDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.CloudWatchLogsInitialPosition.self, forKey: .initialPosition)
        initialPosition = initialPositionDecoded
        let encodingDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.CloudWatchLogsEncoding.self, forKey: .encoding)
        encoding = encodingDecoded
        let bufferDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bufferDuration)
        bufferDuration = bufferDurationDecoded
        let batchCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchCount)
        batchCount = batchCountDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
    }
}

extension OpsWorksClientTypes.CloudWatchLogsLogStream: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudWatchLogsLogStream(batchCount: \(Swift.String(describing: batchCount)), batchSize: \(Swift.String(describing: batchSize)), bufferDuration: \(Swift.String(describing: bufferDuration)), datetimeFormat: \(Swift.String(describing: datetimeFormat)), encoding: \(Swift.String(describing: encoding)), file: \(Swift.String(describing: file)), fileFingerprintLines: \(Swift.String(describing: fileFingerprintLines)), initialPosition: \(Swift.String(describing: initialPosition)), logGroupName: \(Swift.String(describing: logGroupName)), multiLineStartPattern: \(Swift.String(describing: multiLineStartPattern)), timeZone: \(Swift.String(describing: timeZone)))"}
}

extension OpsWorksClientTypes {
    /// Describes the Amazon CloudWatch logs configuration for a layer. For detailed information about members of this data type, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AgentReference.html">CloudWatch Logs Agent Reference.
    public struct CloudWatchLogsLogStream: Swift.Equatable {
        /// Specifies the max number of log events in a batch, up to 10000. The default value is 1000.
        public var batchCount: Swift.Int?
        /// Specifies the maximum size of log events in a batch, in bytes, up to 1048576 bytes.
        ///             The default value is 32768 bytes. This size is calculated as the sum of all event messages
        ///             in UTF-8, plus 26 bytes for each log event.
        public var batchSize: Swift.Int?
        /// Specifies the time duration for the batching of log events. The minimum value is 5000ms and default value is 5000ms.
        public var bufferDuration: Swift.Int?
        /// Specifies how the time stamp is extracted from logs. For more information, see the
        ///             <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AgentReference.html">CloudWatch Logs Agent Reference.
        public var datetimeFormat: Swift.String?
        /// Specifies the encoding of the log file so that the file can be read correctly.
        ///             The default is utf_8. Encodings supported by Python codecs.decode() can be used here.
        public var encoding: OpsWorksClientTypes.CloudWatchLogsEncoding?
        /// Specifies log files that you want to push to CloudWatch Logs.
        ///
        ///             File can point to a specific file or multiple files (by using wild card characters such as /var/log/system.log*).
        ///             Only the latest file is pushed to CloudWatch Logs, based on file modification time. We recommend that you use wild card characters to specify a series
        ///             of files of the same type, such as access_log.2014-06-01-01, access_log.2014-06-01-02, and so on
        ///             by using a pattern like access_log.*. Don't use a wildcard to match multiple file types,
        ///             such as access_log_80 and access_log_443. To specify multiple, different file types, add another
        ///             log stream entry to the configuration file, so that each log file type is stored in a different log group.
        ///         Zipped files are not supported.
        public var file: Swift.String?
        /// Specifies the range of lines for identifying a file. The valid values are one number, or two dash-delimited numbers,
        ///             such as '1', '2-5'. The default value is '1', meaning the first line is used to calculate the fingerprint. Fingerprint lines are
        ///             not sent to CloudWatch Logs unless all specified lines are available.
        public var fileFingerprintLines: Swift.String?
        /// Specifies where to start to read data (start_of_file or end_of_file). The default is start_of_file.
        ///             This setting is only used if there is no state persisted for that log stream.
        public var initialPosition: OpsWorksClientTypes.CloudWatchLogsInitialPosition?
        /// Specifies the destination log group. A log group is created automatically if it doesn't already exist.
        ///             Log group names can be between 1 and 512 characters long. Allowed characters include a-z, A-Z, 0-9, '_' (underscore),
        ///             '-' (hyphen), '/' (forward slash), and '.' (period).
        public var logGroupName: Swift.String?
        /// Specifies the pattern for identifying the start of a log message.
        public var multiLineStartPattern: Swift.String?
        /// Specifies the time zone of log event time stamps.
        public var timeZone: OpsWorksClientTypes.CloudWatchLogsTimeZone?

        public init (
            batchCount: Swift.Int? = nil,
            batchSize: Swift.Int? = nil,
            bufferDuration: Swift.Int? = nil,
            datetimeFormat: Swift.String? = nil,
            encoding: OpsWorksClientTypes.CloudWatchLogsEncoding? = nil,
            file: Swift.String? = nil,
            fileFingerprintLines: Swift.String? = nil,
            initialPosition: OpsWorksClientTypes.CloudWatchLogsInitialPosition? = nil,
            logGroupName: Swift.String? = nil,
            multiLineStartPattern: Swift.String? = nil,
            timeZone: OpsWorksClientTypes.CloudWatchLogsTimeZone? = nil
        )
        {
            self.batchCount = batchCount
            self.batchSize = batchSize
            self.bufferDuration = bufferDuration
            self.datetimeFormat = datetimeFormat
            self.encoding = encoding
            self.file = file
            self.fileFingerprintLines = fileFingerprintLines
            self.initialPosition = initialPosition
            self.logGroupName = logGroupName
            self.multiLineStartPattern = multiLineStartPattern
            self.timeZone = timeZone
        }
    }

}

extension OpsWorksClientTypes {
    /// The preferred time zone for logs streamed to CloudWatch Logs. Valid values are LOCAL and UTC, for Coordinated Universal Time.
    public enum CloudWatchLogsTimeZone: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case local
        case utc
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchLogsTimeZone] {
            return [
                .local,
                .utc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .local: return "LOCAL"
            case .utc: return "UTC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudWatchLogsTimeZone(rawValue: rawValue) ?? CloudWatchLogsTimeZone.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.Command: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acknowledgedAt = "AcknowledgedAt"
        case commandId = "CommandId"
        case completedAt = "CompletedAt"
        case createdAt = "CreatedAt"
        case deploymentId = "DeploymentId"
        case exitCode = "ExitCode"
        case instanceId = "InstanceId"
        case logUrl = "LogUrl"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acknowledgedAt = acknowledgedAt {
            try encodeContainer.encode(acknowledgedAt, forKey: .acknowledgedAt)
        }
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let completedAt = completedAt {
            try encodeContainer.encode(completedAt, forKey: .completedAt)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let exitCode = exitCode {
            try encodeContainer.encode(exitCode, forKey: .exitCode)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let logUrl = logUrl {
            try encodeContainer.encode(logUrl, forKey: .logUrl)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let acknowledgedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acknowledgedAt)
        acknowledgedAt = acknowledgedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .completedAt)
        completedAt = completedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let exitCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .exitCode)
        exitCode = exitCodeDecoded
        let logUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logUrl)
        logUrl = logUrlDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension OpsWorksClientTypes.Command: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Command(acknowledgedAt: \(Swift.String(describing: acknowledgedAt)), commandId: \(Swift.String(describing: commandId)), completedAt: \(Swift.String(describing: completedAt)), createdAt: \(Swift.String(describing: createdAt)), deploymentId: \(Swift.String(describing: deploymentId)), exitCode: \(Swift.String(describing: exitCode)), instanceId: \(Swift.String(describing: instanceId)), logUrl: \(Swift.String(describing: logUrl)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)))"}
}

extension OpsWorksClientTypes {
    /// Describes a command.
    public struct Command: Swift.Equatable {
        /// Date and time when the command was acknowledged.
        public var acknowledgedAt: Swift.String?
        /// The command ID.
        public var commandId: Swift.String?
        /// Date when the command completed.
        public var completedAt: Swift.String?
        /// Date and time when the command was run.
        public var createdAt: Swift.String?
        /// The command deployment ID.
        public var deploymentId: Swift.String?
        /// The command exit code.
        public var exitCode: Swift.Int?
        /// The ID of the instance where the command was executed.
        public var instanceId: Swift.String?
        /// The URL of the command log.
        public var logUrl: Swift.String?
        /// The command status:
        ///
        ///
        ///                failed
        ///
        ///
        ///                successful
        ///
        ///
        ///                skipped
        ///
        ///
        ///                pending
        ///
        ///
        public var status: Swift.String?
        /// The command type:
        ///
        ///
        ///
        ///                   configure
        ///
        ///
        ///
        ///
        ///                   deploy
        ///
        ///
        ///
        ///
        ///                   execute_recipes
        ///
        ///
        ///
        ///
        ///                   install_dependencies
        ///
        ///
        ///
        ///
        ///                   restart
        ///
        ///
        ///
        ///
        ///                   rollback
        ///
        ///
        ///
        ///
        ///                   setup
        ///
        ///
        ///
        ///
        ///                   start
        ///
        ///
        ///
        ///
        ///                   stop
        ///
        ///
        ///
        ///
        ///                   undeploy
        ///
        ///
        ///
        ///
        ///                   update_custom_cookbooks
        ///
        ///
        ///
        ///
        ///                   update_dependencies
        ///
        ///
        ///
        public var type: Swift.String?

        public init (
            acknowledgedAt: Swift.String? = nil,
            commandId: Swift.String? = nil,
            completedAt: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            exitCode: Swift.Int? = nil,
            instanceId: Swift.String? = nil,
            logUrl: Swift.String? = nil,
            status: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.acknowledgedAt = acknowledgedAt
            self.commandId = commandId
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.deploymentId = deploymentId
            self.exitCode = exitCode
            self.instanceId = instanceId
            self.logUrl = logUrl
            self.status = status
            self.type = type
        }
    }

}

public struct CreateAppInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppOutputError>
}

extension CreateAppInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInput(appSource: \(Swift.String(describing: appSource)), attributes: \(Swift.String(describing: attributes)), dataSources: \(Swift.String(describing: dataSources)), description: \(Swift.String(describing: description)), domains: \(Swift.String(describing: domains)), enableSsl: \(Swift.String(describing: enableSsl)), environment: \(Swift.String(describing: environment)), name: \(Swift.String(describing: name)), shortname: \(Swift.String(describing: shortname)), sslConfiguration: \(Swift.String(describing: sslConfiguration)), stackId: \(Swift.String(describing: stackId)), type: \(Swift.String(describing: type)))"}
}

extension CreateAppInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSource = "AppSource"
        case attributes = "Attributes"
        case dataSources = "DataSources"
        case description = "Description"
        case domains = "Domains"
        case enableSsl = "EnableSsl"
        case environment = "Environment"
        case name = "Name"
        case shortname = "Shortname"
        case sslConfiguration = "SslConfiguration"
        case stackId = "StackId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appSource = appSource {
            try encodeContainer.encode(appSource, forKey: .appSource)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, appattributes0) in attributes {
                try attributesContainer.encode(appattributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasources0 in dataSources {
                try dataSourcesContainer.encode(datasources0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for strings0 in domains {
                try domainsContainer.encode(strings0)
            }
        }
        if let enableSsl = enableSsl {
            try encodeContainer.encode(enableSsl, forKey: .enableSsl)
        }
        if let environment = environment {
            var environmentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environment)
            for environmentvariables0 in environment {
                try environmentContainer.encode(environmentvariables0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let shortname = shortname {
            try encodeContainer.encode(shortname, forKey: .shortname)
        }
        if let sslConfiguration = sslConfiguration {
            try encodeContainer.encode(sslConfiguration, forKey: .sslConfiguration)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateAppInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppOutputError>
}

public struct CreateAppInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppOutputError>
}

public struct CreateAppInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateAppInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAppInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppOutputError>
}

public struct CreateAppInput: Swift.Equatable {
    /// A Source object that specifies the app repository.
    public var appSource: OpsWorksClientTypes.Source?
    /// One or more user-defined key/value pairs to be added to the stack attributes.
    public var attributes: [Swift.String:Swift.String]?
    /// The app's data source.
    public var dataSources: [OpsWorksClientTypes.DataSource]?
    /// A description of the app.
    public var description: Swift.String?
    /// The app virtual host settings, with multiple domains separated by commas. For example:
    ///         'www.example.com, example.com'
    ///
    public var domains: [Swift.String]?
    /// Whether to enable SSL for the app.
    public var enableSsl: Swift.Bool?
    /// An array of EnvironmentVariable objects that specify environment variables to be
    ///       associated with the app. After you deploy the app, these variables are defined on the
    ///       associated app server instance. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html#workingapps-creating-environment"> Environment Variables.
    ///          There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variables' names, values, and protected flag values - cannot exceed 20 KB. This limit should accommodate most if not all use cases. Exceeding it will cause an exception with the message, "Environment: is too large (maximum is 20KB)."
    ///
    ///             If you have specified one or more environment variables, you cannot modify the stack's Chef version.
    ///
    public var environment: [OpsWorksClientTypes.EnvironmentVariable]?
    /// The app name.
    /// This member is required.
    public var name: Swift.String?
    /// The app's short name.
    public var shortname: Swift.String?
    /// An SslConfiguration object with the SSL configuration.
    public var sslConfiguration: OpsWorksClientTypes.SslConfiguration?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?
    /// The app type. Each supported type is associated with a particular layer. For example, PHP
    ///       applications are associated with a PHP layer. AWS OpsWorks Stacks deploys an application to those instances
    ///       that are members of the corresponding layer. If your app isn't one of the standard types, or
    ///       you prefer to implement your own Deploy recipes, specify other.
    /// This member is required.
    public var type: OpsWorksClientTypes.AppType?

    public init (
        appSource: OpsWorksClientTypes.Source? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        dataSources: [OpsWorksClientTypes.DataSource]? = nil,
        description: Swift.String? = nil,
        domains: [Swift.String]? = nil,
        enableSsl: Swift.Bool? = nil,
        environment: [OpsWorksClientTypes.EnvironmentVariable]? = nil,
        name: Swift.String? = nil,
        shortname: Swift.String? = nil,
        sslConfiguration: OpsWorksClientTypes.SslConfiguration? = nil,
        stackId: Swift.String? = nil,
        type: OpsWorksClientTypes.AppType? = nil
    )
    {
        self.appSource = appSource
        self.attributes = attributes
        self.dataSources = dataSources
        self.description = description
        self.domains = domains
        self.enableSsl = enableSsl
        self.environment = environment
        self.name = name
        self.shortname = shortname
        self.sslConfiguration = sslConfiguration
        self.stackId = stackId
        self.type = type
    }
}

struct CreateAppInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let shortname: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let dataSources: [OpsWorksClientTypes.DataSource]?
    public let type: OpsWorksClientTypes.AppType?
    public let appSource: OpsWorksClientTypes.Source?
    public let domains: [Swift.String]?
    public let enableSsl: Swift.Bool?
    public let sslConfiguration: OpsWorksClientTypes.SslConfiguration?
    public let attributes: [Swift.String:Swift.String]?
    public let environment: [OpsWorksClientTypes.EnvironmentVariable]?
}

extension CreateAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSource = "AppSource"
        case attributes = "Attributes"
        case dataSources = "DataSources"
        case description = "Description"
        case domains = "Domains"
        case enableSsl = "EnableSsl"
        case environment = "Environment"
        case name = "Name"
        case shortname = "Shortname"
        case sslConfiguration = "SslConfiguration"
        case stackId = "StackId"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let shortnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortname)
        shortname = shortnameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourcesContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[OpsWorksClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [OpsWorksClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AppType.self, forKey: .type)
        type = typeDecoded
        let appSourceDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Source.self, forKey: .appSource)
        appSource = appSourceDecoded
        let domainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domains)
        var domainsDecoded0:[Swift.String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [Swift.String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
        let enableSslDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSsl)
        enableSsl = enableSslDecoded
        let sslConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.SslConfiguration.self, forKey: .sslConfiguration)
        sslConfiguration = sslConfigurationDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let environmentContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.EnvironmentVariable?].self, forKey: .environment)
        var environmentDecoded0:[OpsWorksClientTypes.EnvironmentVariable]? = nil
        if let environmentContainer = environmentContainer {
            environmentDecoded0 = [OpsWorksClientTypes.EnvironmentVariable]()
            for structure0 in environmentContainer {
                if let structure0 = structure0 {
                    environmentDecoded0?.append(structure0)
                }
            }
        }
        environment = environmentDecoded0
    }
}

extension CreateAppOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppOutputResponse(appId: \(Swift.String(describing: appId)))"}
}

extension CreateAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAppOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
        } else {
            self.appId = nil
        }
    }
}

/// Contains the response to a CreateApp request.
public struct CreateAppOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?

    public init (
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct CreateAppOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
}

extension CreateAppOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

public struct CreateDeploymentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentOutputError>
}

extension CreateDeploymentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeploymentInput(appId: \(Swift.String(describing: appId)), command: \(Swift.String(describing: command)), comment: \(Swift.String(describing: comment)), customJson: \(Swift.String(describing: customJson)), instanceIds: \(Swift.String(describing: instanceIds)), layerIds: \(Swift.String(describing: layerIds)), stackId: \(Swift.String(describing: stackId)))"}
}

extension CreateDeploymentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case command = "Command"
        case comment = "Comment"
        case customJson = "CustomJson"
        case instanceIds = "InstanceIds"
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let command = command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for strings0 in instanceIds {
                try instanceIdsContainer.encode(strings0)
            }
        }
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct CreateDeploymentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentOutputError>
}

public struct CreateDeploymentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentOutputError>
}

public struct CreateDeploymentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentOutputError>
}

public struct CreateDeploymentInput: Swift.Equatable {
    /// The app ID. This parameter is required for app deployments, but not for other deployment commands.
    public var appId: Swift.String?
    /// A DeploymentCommand object that specifies the deployment command and any
    ///       associated arguments.
    /// This member is required.
    public var command: OpsWorksClientTypes.DeploymentCommand?
    /// A user-defined comment.
    public var comment: Swift.String?
    /// A string that contains user-defined, custom JSON. You can use this parameter to override some corresponding default stack configuration JSON values. The string should be in the following format:
    ///
    ///             "{\"key1\": \"value1\", \"key2\": \"value2\",...}"
    ///
    ///          For more information about custom JSON, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html">Use Custom JSON to
    ///           Modify the Stack Configuration Attributes and
    ///           <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook-json-override.html">Overriding Attributes With Custom JSON.
    public var customJson: Swift.String?
    /// The instance IDs for the deployment targets.
    public var instanceIds: [Swift.String]?
    /// The layer IDs for the deployment targets.
    public var layerIds: [Swift.String]?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init (
        appId: Swift.String? = nil,
        command: OpsWorksClientTypes.DeploymentCommand? = nil,
        comment: Swift.String? = nil,
        customJson: Swift.String? = nil,
        instanceIds: [Swift.String]? = nil,
        layerIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.command = command
        self.comment = comment
        self.customJson = customJson
        self.instanceIds = instanceIds
        self.layerIds = layerIds
        self.stackId = stackId
    }
}

struct CreateDeploymentInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let appId: Swift.String?
    public let instanceIds: [Swift.String]?
    public let layerIds: [Swift.String]?
    public let command: OpsWorksClientTypes.DeploymentCommand?
    public let comment: Swift.String?
    public let customJson: Swift.String?
}

extension CreateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case command = "Command"
        case comment = "Comment"
        case customJson = "CustomJson"
        case instanceIds = "InstanceIds"
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
        let commandDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.DeploymentCommand.self, forKey: .command)
        command = commandDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
    }
}

extension CreateDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeploymentOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeploymentOutputResponse(deploymentId: \(Swift.String(describing: deploymentId)))"}
}

extension CreateDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentId = output.deploymentId
        } else {
            self.deploymentId = nil
        }
    }
}

/// Contains the response to a CreateDeployment request.
public struct CreateDeploymentOutputResponse: Swift.Equatable {
    /// The deployment ID, which can be used with other requests to identify the deployment.
    public var deploymentId: Swift.String?

    public init (
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

struct CreateDeploymentOutputResponseBody: Swift.Equatable {
    public let deploymentId: Swift.String?
}

extension CreateDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId = "DeploymentId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

public struct CreateInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInstanceOutputError>
}

extension CreateInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInstanceInput(agentVersion: \(Swift.String(describing: agentVersion)), amiId: \(Swift.String(describing: amiId)), architecture: \(Swift.String(describing: architecture)), autoScalingType: \(Swift.String(describing: autoScalingType)), availabilityZone: \(Swift.String(describing: availabilityZone)), blockDeviceMappings: \(Swift.String(describing: blockDeviceMappings)), ebsOptimized: \(Swift.String(describing: ebsOptimized)), hostname: \(Swift.String(describing: hostname)), installUpdatesOnBoot: \(Swift.String(describing: installUpdatesOnBoot)), instanceType: \(Swift.String(describing: instanceType)), layerIds: \(Swift.String(describing: layerIds)), os: \(Swift.String(describing: os)), rootDeviceType: \(Swift.String(describing: rootDeviceType)), sshKeyName: \(Swift.String(describing: sshKeyName)), stackId: \(Swift.String(describing: stackId)), subnetId: \(Swift.String(describing: subnetId)), tenancy: \(Swift.String(describing: tenancy)), virtualizationType: \(Swift.String(describing: virtualizationType)))"}
}

extension CreateInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case amiId = "AmiId"
        case architecture = "Architecture"
        case autoScalingType = "AutoScalingType"
        case availabilityZone = "AvailabilityZone"
        case blockDeviceMappings = "BlockDeviceMappings"
        case ebsOptimized = "EbsOptimized"
        case hostname = "Hostname"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case instanceType = "InstanceType"
        case layerIds = "LayerIds"
        case os = "Os"
        case rootDeviceType = "RootDeviceType"
        case sshKeyName = "SshKeyName"
        case stackId = "StackId"
        case subnetId = "SubnetId"
        case tenancy = "Tenancy"
        case virtualizationType = "VirtualizationType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let amiId = amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let architecture = architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let autoScalingType = autoScalingType {
            try encodeContainer.encode(autoScalingType.rawValue, forKey: .autoScalingType)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for blockdevicemappings0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(blockdevicemappings0)
            }
        }
        if let ebsOptimized = ebsOptimized {
            try encodeContainer.encode(ebsOptimized, forKey: .ebsOptimized)
        }
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let installUpdatesOnBoot = installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
        if let os = os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if let rootDeviceType = rootDeviceType {
            try encodeContainer.encode(rootDeviceType.rawValue, forKey: .rootDeviceType)
        }
        if let sshKeyName = sshKeyName {
            try encodeContainer.encode(sshKeyName, forKey: .sshKeyName)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tenancy = tenancy {
            try encodeContainer.encode(tenancy, forKey: .tenancy)
        }
        if let virtualizationType = virtualizationType {
            try encodeContainer.encode(virtualizationType, forKey: .virtualizationType)
        }
    }
}

public struct CreateInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInstanceOutputError>
}

public struct CreateInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInstanceOutputError>
}

public struct CreateInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInstanceOutputError>
}

public struct CreateInstanceInput: Swift.Equatable {
    /// The default AWS OpsWorks Stacks agent version. You have the following options:
    ///
    ///
    ///
    ///                   INHERIT - Use the stack's default agent version setting.
    ///
    ///
    ///
    ///                   version_number - Use the specified agent version.
    ///         This value overrides the stack's default setting.
    ///         To update the agent version, edit the instance configuration and specify a
    ///         new version.
    ///         AWS OpsWorks Stacks then automatically installs that version on the instance.
    ///
    ///
    ///          The default setting is INHERIT. To specify an agent version,
    ///       you must use the complete version number, not the abbreviated number shown on the console.
    ///       For a list of available agent version numbers, call DescribeAgentVersions. AgentVersion cannot be set to Chef 12.2.
    public var agentVersion: Swift.String?
    /// A custom AMI ID to be used to create the instance. The AMI should be based on one of the
    ///       supported operating systems.
    ///       For more information, see
    ///       <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html">Using Custom AMIs.
    ///
    ///             If you specify a custom AMI, you must set Os to Custom.
    ///
    public var amiId: Swift.String?
    /// The instance architecture. The default option is x86_64. Instance types do not
    ///       necessarily support both architectures. For a list of the architectures that are supported by
    ///       the different instance types, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Families and
    ///         Types.
    public var architecture: OpsWorksClientTypes.Architecture?
    /// For load-based or time-based instances, the type. Windows stacks can use only time-based instances.
    public var autoScalingType: OpsWorksClientTypes.AutoScalingType?
    /// The instance Availability Zone. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints.
    public var availabilityZone: Swift.String?
    /// An array of BlockDeviceMapping objects that specify the instance's block
    ///       devices. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html">Block
    ///         Device Mapping. Note that block device mappings are not supported for custom AMIs.
    public var blockDeviceMappings: [OpsWorksClientTypes.BlockDeviceMapping]?
    /// Whether to create an Amazon EBS-optimized instance.
    public var ebsOptimized: Swift.Bool?
    /// The instance host name.
    public var hostname: Swift.String?
    /// Whether to install operating system and package updates when the instance boots. The default
    ///       value is true. To control when updates are installed, set this value to
    ///         false. You must then update your instances manually by using
    ///         CreateDeployment to run the update_dependencies stack command or
    ///       by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the
    ///       instances.
    ///
    ///             We strongly recommend using the default value of true to ensure that your
    ///         instances have the latest security updates.
    ///
    public var installUpdatesOnBoot: Swift.Bool?
    /// The instance type, such as t2.micro. For a list of supported instance types,
    ///       open the stack in the console, choose Instances, and choose + Instance.
    ///       The Size list contains the currently supported types. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance
    ///         Families and Types. The parameter values that you use to specify the various types are
    ///       in the API Name column of the Available Instance Types table.
    /// This member is required.
    public var instanceType: Swift.String?
    /// An array that contains the instance's layer IDs.
    /// This member is required.
    public var layerIds: [Swift.String]?
    /// The instance's operating system, which must be set to one of the following.
    ///
    ///
    ///                A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2018.03, Amazon Linux 2017.09, Amazon Linux 2017.03, Amazon Linux 2016.09,
    ///               Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.
    ///
    ///
    ///                A supported Ubuntu operating system, such as Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.
    ///
    ///
    ///
    ///                   CentOS Linux 7
    ///
    ///
    ///
    ///
    ///                   Red Hat Enterprise Linux 7
    ///
    ///
    ///
    ///                A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express,
    /// 			   Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.
    ///
    ///
    ///                A custom AMI: Custom.
    ///
    ///
    ///          For more information about the supported operating systems,
    ///       see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html">AWS OpsWorks Stacks Operating Systems.
    ///          The default option is the current Amazon Linux version. If you set this parameter to
    ///         Custom, you must use the CreateInstance action's AmiId parameter to
    ///       specify the custom AMI that you want to use. Block device mappings are not supported if the value is Custom. For more information about supported operating
    ///       systems, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html">Operating SystemsFor more information about how to use custom AMIs with AWS OpsWorks Stacks, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html">Using
    ///         Custom AMIs.
    public var os: Swift.String?
    /// The instance root device type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device">Storage for the Root Device.
    public var rootDeviceType: OpsWorksClientTypes.RootDeviceType?
    /// The instance's Amazon EC2 key-pair name.
    public var sshKeyName: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?
    /// The ID of the instance's subnet. If the stack is running in a VPC, you can use this parameter to override the stack's default subnet ID value and direct AWS OpsWorks Stacks to launch the instance in a different subnet.
    public var subnetId: Swift.String?
    /// The instance's tenancy option. The default option is no tenancy, or if the instance is running in a VPC, inherit tenancy settings from the VPC. The following are valid values for this parameter:  dedicated, default, or host. Because there are costs associated with changes in tenancy options, we recommend that you research tenancy options before choosing them for your instances. For more information about dedicated hosts, see <a href="http://aws.amazon.com/ec2/dedicated-hosts/">Dedicated Hosts Overview and <a href="http://aws.amazon.com/ec2/dedicated-hosts/">Amazon EC2 Dedicated Hosts. For more information about dedicated instances, see <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/dedicated-instance.html">Dedicated Instances and <a href="http://aws.amazon.com/ec2/purchasing-options/dedicated-instances/">Amazon EC2 Dedicated Instances.
    public var tenancy: Swift.String?
    /// The instance's virtualization type, paravirtual or hvm.
    public var virtualizationType: Swift.String?

    public init (
        agentVersion: Swift.String? = nil,
        amiId: Swift.String? = nil,
        architecture: OpsWorksClientTypes.Architecture? = nil,
        autoScalingType: OpsWorksClientTypes.AutoScalingType? = nil,
        availabilityZone: Swift.String? = nil,
        blockDeviceMappings: [OpsWorksClientTypes.BlockDeviceMapping]? = nil,
        ebsOptimized: Swift.Bool? = nil,
        hostname: Swift.String? = nil,
        installUpdatesOnBoot: Swift.Bool? = nil,
        instanceType: Swift.String? = nil,
        layerIds: [Swift.String]? = nil,
        os: Swift.String? = nil,
        rootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
        sshKeyName: Swift.String? = nil,
        stackId: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        tenancy: Swift.String? = nil,
        virtualizationType: Swift.String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.amiId = amiId
        self.architecture = architecture
        self.autoScalingType = autoScalingType
        self.availabilityZone = availabilityZone
        self.blockDeviceMappings = blockDeviceMappings
        self.ebsOptimized = ebsOptimized
        self.hostname = hostname
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.instanceType = instanceType
        self.layerIds = layerIds
        self.os = os
        self.rootDeviceType = rootDeviceType
        self.sshKeyName = sshKeyName
        self.stackId = stackId
        self.subnetId = subnetId
        self.tenancy = tenancy
        self.virtualizationType = virtualizationType
    }
}

struct CreateInstanceInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let layerIds: [Swift.String]?
    public let instanceType: Swift.String?
    public let autoScalingType: OpsWorksClientTypes.AutoScalingType?
    public let hostname: Swift.String?
    public let os: Swift.String?
    public let amiId: Swift.String?
    public let sshKeyName: Swift.String?
    public let availabilityZone: Swift.String?
    public let virtualizationType: Swift.String?
    public let subnetId: Swift.String?
    public let architecture: OpsWorksClientTypes.Architecture?
    public let rootDeviceType: OpsWorksClientTypes.RootDeviceType?
    public let blockDeviceMappings: [OpsWorksClientTypes.BlockDeviceMapping]?
    public let installUpdatesOnBoot: Swift.Bool?
    public let ebsOptimized: Swift.Bool?
    public let agentVersion: Swift.String?
    public let tenancy: Swift.String?
}

extension CreateInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case amiId = "AmiId"
        case architecture = "Architecture"
        case autoScalingType = "AutoScalingType"
        case availabilityZone = "AvailabilityZone"
        case blockDeviceMappings = "BlockDeviceMappings"
        case ebsOptimized = "EbsOptimized"
        case hostname = "Hostname"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case instanceType = "InstanceType"
        case layerIds = "LayerIds"
        case os = "Os"
        case rootDeviceType = "RootDeviceType"
        case sshKeyName = "SshKeyName"
        case stackId = "StackId"
        case subnetId = "SubnetId"
        case tenancy = "Tenancy"
        case virtualizationType = "VirtualizationType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let autoScalingTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AutoScalingType.self, forKey: .autoScalingType)
        autoScalingType = autoScalingTypeDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let osDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .os)
        os = osDecoded
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let sshKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshKeyName)
        sshKeyName = sshKeyNameDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let virtualizationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualizationType)
        virtualizationType = virtualizationTypeDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let rootDeviceTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.RootDeviceType.self, forKey: .rootDeviceType)
        rootDeviceType = rootDeviceTypeDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.BlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[OpsWorksClientTypes.BlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [OpsWorksClientTypes.BlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenancy)
        tenancy = tenancyDecoded
    }
}

extension CreateInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInstanceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInstanceOutputResponse(instanceId: \(Swift.String(describing: instanceId)))"}
}

extension CreateInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceId = output.instanceId
        } else {
            self.instanceId = nil
        }
    }
}

/// Contains the response to a CreateInstance request.
public struct CreateInstanceOutputResponse: Swift.Equatable {
    /// The instance ID.
    public var instanceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct CreateInstanceOutputResponseBody: Swift.Equatable {
    public let instanceId: Swift.String?
}

extension CreateInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

public struct CreateLayerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLayerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLayerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLayerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLayerOutputError>
}

extension CreateLayerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLayerInput(attributes: \(Swift.String(describing: attributes)), autoAssignElasticIps: \(Swift.String(describing: autoAssignElasticIps)), autoAssignPublicIps: \(Swift.String(describing: autoAssignPublicIps)), cloudWatchLogsConfiguration: \(Swift.String(describing: cloudWatchLogsConfiguration)), customInstanceProfileArn: \(Swift.String(describing: customInstanceProfileArn)), customJson: \(Swift.String(describing: customJson)), customRecipes: \(Swift.String(describing: customRecipes)), customSecurityGroupIds: \(Swift.String(describing: customSecurityGroupIds)), enableAutoHealing: \(Swift.String(describing: enableAutoHealing)), installUpdatesOnBoot: \(Swift.String(describing: installUpdatesOnBoot)), lifecycleEventConfiguration: \(Swift.String(describing: lifecycleEventConfiguration)), name: \(Swift.String(describing: name)), packages: \(Swift.String(describing: packages)), shortname: \(Swift.String(describing: shortname)), stackId: \(Swift.String(describing: stackId)), type: \(Swift.String(describing: type)), useEbsOptimizedInstances: \(Swift.String(describing: useEbsOptimizedInstances)), volumeConfigurations: \(Swift.String(describing: volumeConfigurations)))"}
}

extension CreateLayerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case autoAssignElasticIps = "AutoAssignElasticIps"
        case autoAssignPublicIps = "AutoAssignPublicIps"
        case cloudWatchLogsConfiguration = "CloudWatchLogsConfiguration"
        case customInstanceProfileArn = "CustomInstanceProfileArn"
        case customJson = "CustomJson"
        case customRecipes = "CustomRecipes"
        case customSecurityGroupIds = "CustomSecurityGroupIds"
        case enableAutoHealing = "EnableAutoHealing"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case lifecycleEventConfiguration = "LifecycleEventConfiguration"
        case name = "Name"
        case packages = "Packages"
        case shortname = "Shortname"
        case stackId = "StackId"
        case type = "Type"
        case useEbsOptimizedInstances = "UseEbsOptimizedInstances"
        case volumeConfigurations = "VolumeConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, layerattributes0) in attributes {
                try attributesContainer.encode(layerattributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let autoAssignElasticIps = autoAssignElasticIps {
            try encodeContainer.encode(autoAssignElasticIps, forKey: .autoAssignElasticIps)
        }
        if let autoAssignPublicIps = autoAssignPublicIps {
            try encodeContainer.encode(autoAssignPublicIps, forKey: .autoAssignPublicIps)
        }
        if let cloudWatchLogsConfiguration = cloudWatchLogsConfiguration {
            try encodeContainer.encode(cloudWatchLogsConfiguration, forKey: .cloudWatchLogsConfiguration)
        }
        if let customInstanceProfileArn = customInstanceProfileArn {
            try encodeContainer.encode(customInstanceProfileArn, forKey: .customInstanceProfileArn)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let customRecipes = customRecipes {
            try encodeContainer.encode(customRecipes, forKey: .customRecipes)
        }
        if let customSecurityGroupIds = customSecurityGroupIds {
            var customSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customSecurityGroupIds)
            for strings0 in customSecurityGroupIds {
                try customSecurityGroupIdsContainer.encode(strings0)
            }
        }
        if let enableAutoHealing = enableAutoHealing {
            try encodeContainer.encode(enableAutoHealing, forKey: .enableAutoHealing)
        }
        if let installUpdatesOnBoot = installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let lifecycleEventConfiguration = lifecycleEventConfiguration {
            try encodeContainer.encode(lifecycleEventConfiguration, forKey: .lifecycleEventConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packages = packages {
            var packagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .packages)
            for strings0 in packages {
                try packagesContainer.encode(strings0)
            }
        }
        if let shortname = shortname {
            try encodeContainer.encode(shortname, forKey: .shortname)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let useEbsOptimizedInstances = useEbsOptimizedInstances {
            try encodeContainer.encode(useEbsOptimizedInstances, forKey: .useEbsOptimizedInstances)
        }
        if let volumeConfigurations = volumeConfigurations {
            var volumeConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeConfigurations)
            for volumeconfigurations0 in volumeConfigurations {
                try volumeConfigurationsContainer.encode(volumeconfigurations0)
            }
        }
    }
}

public struct CreateLayerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLayerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLayerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLayerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLayerOutputError>
}

public struct CreateLayerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLayerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLayerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLayerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLayerOutputError>
}

public struct CreateLayerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLayerInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateLayerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLayerInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLayerOutputError>
}

public struct CreateLayerInput: Swift.Equatable {
    /// One or more user-defined key-value pairs to be added to the stack attributes.
    ///          To create a cluster layer, set the EcsClusterArn attribute to the cluster's ARN.
    public var attributes: [Swift.String:Swift.String]?
    /// Whether to automatically assign an <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html">Elastic IP
    ///         address to the layer's instances. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html">How to Edit
    ///         a Layer.
    public var autoAssignElasticIps: Swift.Bool?
    /// For stacks that are running in a VPC, whether to automatically assign a public IP address to
    ///       the layer's instances. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html">How to Edit
    ///         a Layer.
    public var autoAssignPublicIps: Swift.Bool?
    /// Specifies CloudWatch Logs configuration options for the layer. For more information, see CloudWatchLogsLogStream.
    public var cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration?
    /// The ARN of an IAM profile to be used for the layer's EC2 instances. For more information
    ///       about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using Identifiers.
    public var customInstanceProfileArn: Swift.String?
    /// A JSON-formatted string containing custom stack configuration and deployment attributes
    ///      to be installed on the layer's instances. For more information, see
    ///       <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook-json-override.html">
    ///         Using Custom JSON. This feature is supported as of version 1.7.42 of the AWS CLI.
    ///
    public var customJson: Swift.String?
    /// A LayerCustomRecipes object that specifies the layer custom recipes.
    public var customRecipes: OpsWorksClientTypes.Recipes?
    /// An array containing the layer custom security group IDs.
    public var customSecurityGroupIds: [Swift.String]?
    /// Whether to disable auto healing for the layer.
    public var enableAutoHealing: Swift.Bool?
    /// Whether to install operating system and package updates when the instance boots. The default
    ///       value is true. To control when updates are installed, set this value to
    ///         false. You must then update your instances manually by using
    ///         CreateDeployment to run the update_dependencies stack command or
    ///       by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the
    ///       instances.
    ///
    ///             To ensure that your
    ///         instances have the latest security updates, we strongly recommend using the default value of true.
    ///
    public var installUpdatesOnBoot: Swift.Bool?
    /// A LifeCycleEventConfiguration object that you can use to configure the Shutdown event to
    ///       specify an execution timeout and enable or disable Elastic Load Balancer connection
    ///       draining.
    public var lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration?
    /// The layer name, which is used by the console.
    /// This member is required.
    public var name: Swift.String?
    /// An array of Package objects that describes the layer packages.
    public var packages: [Swift.String]?
    /// For custom layers only, use this parameter to specify the layer's short name, which is used internally by AWS OpsWorks Stacks and by Chef recipes. The short name is also used as the name for the directory where your app files are installed. It can have a maximum of 200 characters, which are limited to the alphanumeric characters, '-', '_', and '.'.
    ///          The built-in layers' short names are defined by AWS OpsWorks Stacks. For more information, see the <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/layers.html">Layer Reference.
    /// This member is required.
    public var shortname: Swift.String?
    /// The layer stack ID.
    /// This member is required.
    public var stackId: Swift.String?
    /// The layer type. A stack cannot have more than one built-in layer of the same type. It can have any number of custom layers. Built-in layers are not available in Chef 12 stacks.
    /// This member is required.
    public var type: OpsWorksClientTypes.LayerType?
    /// Whether to use Amazon EBS-optimized instances.
    public var useEbsOptimizedInstances: Swift.Bool?
    /// A VolumeConfigurations object that describes the layer's Amazon EBS volumes.
    public var volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        autoAssignElasticIps: Swift.Bool? = nil,
        autoAssignPublicIps: Swift.Bool? = nil,
        cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration? = nil,
        customInstanceProfileArn: Swift.String? = nil,
        customJson: Swift.String? = nil,
        customRecipes: OpsWorksClientTypes.Recipes? = nil,
        customSecurityGroupIds: [Swift.String]? = nil,
        enableAutoHealing: Swift.Bool? = nil,
        installUpdatesOnBoot: Swift.Bool? = nil,
        lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration? = nil,
        name: Swift.String? = nil,
        packages: [Swift.String]? = nil,
        shortname: Swift.String? = nil,
        stackId: Swift.String? = nil,
        type: OpsWorksClientTypes.LayerType? = nil,
        useEbsOptimizedInstances: Swift.Bool? = nil,
        volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]? = nil
    )
    {
        self.attributes = attributes
        self.autoAssignElasticIps = autoAssignElasticIps
        self.autoAssignPublicIps = autoAssignPublicIps
        self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
        self.customInstanceProfileArn = customInstanceProfileArn
        self.customJson = customJson
        self.customRecipes = customRecipes
        self.customSecurityGroupIds = customSecurityGroupIds
        self.enableAutoHealing = enableAutoHealing
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.lifecycleEventConfiguration = lifecycleEventConfiguration
        self.name = name
        self.packages = packages
        self.shortname = shortname
        self.stackId = stackId
        self.type = type
        self.useEbsOptimizedInstances = useEbsOptimizedInstances
        self.volumeConfigurations = volumeConfigurations
    }
}

struct CreateLayerInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let type: OpsWorksClientTypes.LayerType?
    public let name: Swift.String?
    public let shortname: Swift.String?
    public let attributes: [Swift.String:Swift.String]?
    public let cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration?
    public let customInstanceProfileArn: Swift.String?
    public let customJson: Swift.String?
    public let customSecurityGroupIds: [Swift.String]?
    public let packages: [Swift.String]?
    public let volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]?
    public let enableAutoHealing: Swift.Bool?
    public let autoAssignElasticIps: Swift.Bool?
    public let autoAssignPublicIps: Swift.Bool?
    public let customRecipes: OpsWorksClientTypes.Recipes?
    public let installUpdatesOnBoot: Swift.Bool?
    public let useEbsOptimizedInstances: Swift.Bool?
    public let lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration?
}

extension CreateLayerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case autoAssignElasticIps = "AutoAssignElasticIps"
        case autoAssignPublicIps = "AutoAssignPublicIps"
        case cloudWatchLogsConfiguration = "CloudWatchLogsConfiguration"
        case customInstanceProfileArn = "CustomInstanceProfileArn"
        case customJson = "CustomJson"
        case customRecipes = "CustomRecipes"
        case customSecurityGroupIds = "CustomSecurityGroupIds"
        case enableAutoHealing = "EnableAutoHealing"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case lifecycleEventConfiguration = "LifecycleEventConfiguration"
        case name = "Name"
        case packages = "Packages"
        case shortname = "Shortname"
        case stackId = "StackId"
        case type = "Type"
        case useEbsOptimizedInstances = "UseEbsOptimizedInstances"
        case volumeConfigurations = "VolumeConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.LayerType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let shortnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortname)
        shortname = shortnameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let cloudWatchLogsConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.CloudWatchLogsConfiguration.self, forKey: .cloudWatchLogsConfiguration)
        cloudWatchLogsConfiguration = cloudWatchLogsConfigurationDecoded
        let customInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customInstanceProfileArn)
        customInstanceProfileArn = customInstanceProfileArnDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let customSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .customSecurityGroupIds)
        var customSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let customSecurityGroupIdsContainer = customSecurityGroupIdsContainer {
            customSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in customSecurityGroupIdsContainer {
                if let string0 = string0 {
                    customSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        customSecurityGroupIds = customSecurityGroupIdsDecoded0
        let packagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .packages)
        var packagesDecoded0:[Swift.String]? = nil
        if let packagesContainer = packagesContainer {
            packagesDecoded0 = [Swift.String]()
            for string0 in packagesContainer {
                if let string0 = string0 {
                    packagesDecoded0?.append(string0)
                }
            }
        }
        packages = packagesDecoded0
        let volumeConfigurationsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.VolumeConfiguration?].self, forKey: .volumeConfigurations)
        var volumeConfigurationsDecoded0:[OpsWorksClientTypes.VolumeConfiguration]? = nil
        if let volumeConfigurationsContainer = volumeConfigurationsContainer {
            volumeConfigurationsDecoded0 = [OpsWorksClientTypes.VolumeConfiguration]()
            for structure0 in volumeConfigurationsContainer {
                if let structure0 = structure0 {
                    volumeConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        volumeConfigurations = volumeConfigurationsDecoded0
        let enableAutoHealingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoHealing)
        enableAutoHealing = enableAutoHealingDecoded
        let autoAssignElasticIpsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssignElasticIps)
        autoAssignElasticIps = autoAssignElasticIpsDecoded
        let autoAssignPublicIpsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssignPublicIps)
        autoAssignPublicIps = autoAssignPublicIpsDecoded
        let customRecipesDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Recipes.self, forKey: .customRecipes)
        customRecipes = customRecipesDecoded
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let useEbsOptimizedInstancesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useEbsOptimizedInstances)
        useEbsOptimizedInstances = useEbsOptimizedInstancesDecoded
        let lifecycleEventConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.LifecycleEventConfiguration.self, forKey: .lifecycleEventConfiguration)
        lifecycleEventConfiguration = lifecycleEventConfigurationDecoded
    }
}

extension CreateLayerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLayerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLayerOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLayerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLayerOutputResponse(layerId: \(Swift.String(describing: layerId)))"}
}

extension CreateLayerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLayerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.layerId = output.layerId
        } else {
            self.layerId = nil
        }
    }
}

/// Contains the response to a CreateLayer request.
public struct CreateLayerOutputResponse: Swift.Equatable {
    /// The layer ID.
    public var layerId: Swift.String?

    public init (
        layerId: Swift.String? = nil
    )
    {
        self.layerId = layerId
    }
}

struct CreateLayerOutputResponseBody: Swift.Equatable {
    public let layerId: Swift.String?
}

extension CreateLayerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerId = "LayerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
    }
}

public struct CreateStackInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStackOutputError>
}

extension CreateStackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStackInput(agentVersion: \(Swift.String(describing: agentVersion)), attributes: \(Swift.String(describing: attributes)), chefConfiguration: \(Swift.String(describing: chefConfiguration)), configurationManager: \(Swift.String(describing: configurationManager)), customCookbooksSource: \(Swift.String(describing: customCookbooksSource)), customJson: \(Swift.String(describing: customJson)), defaultAvailabilityZone: \(Swift.String(describing: defaultAvailabilityZone)), defaultInstanceProfileArn: \(Swift.String(describing: defaultInstanceProfileArn)), defaultOs: \(Swift.String(describing: defaultOs)), defaultRootDeviceType: \(Swift.String(describing: defaultRootDeviceType)), defaultSshKeyName: \(Swift.String(describing: defaultSshKeyName)), defaultSubnetId: \(Swift.String(describing: defaultSubnetId)), hostnameTheme: \(Swift.String(describing: hostnameTheme)), name: \(Swift.String(describing: name)), region: \(Swift.String(describing: region)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), useCustomCookbooks: \(Swift.String(describing: useCustomCookbooks)), useOpsworksSecurityGroups: \(Swift.String(describing: useOpsworksSecurityGroups)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension CreateStackInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case region = "Region"
        case serviceRoleArn = "ServiceRoleArn"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, stackattributes0) in attributes {
                try attributesContainer.encode(stackattributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let chefConfiguration = chefConfiguration {
            try encodeContainer.encode(chefConfiguration, forKey: .chefConfiguration)
        }
        if let configurationManager = configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let customCookbooksSource = customCookbooksSource {
            try encodeContainer.encode(customCookbooksSource, forKey: .customCookbooksSource)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let defaultAvailabilityZone = defaultAvailabilityZone {
            try encodeContainer.encode(defaultAvailabilityZone, forKey: .defaultAvailabilityZone)
        }
        if let defaultInstanceProfileArn = defaultInstanceProfileArn {
            try encodeContainer.encode(defaultInstanceProfileArn, forKey: .defaultInstanceProfileArn)
        }
        if let defaultOs = defaultOs {
            try encodeContainer.encode(defaultOs, forKey: .defaultOs)
        }
        if let defaultRootDeviceType = defaultRootDeviceType {
            try encodeContainer.encode(defaultRootDeviceType.rawValue, forKey: .defaultRootDeviceType)
        }
        if let defaultSshKeyName = defaultSshKeyName {
            try encodeContainer.encode(defaultSshKeyName, forKey: .defaultSshKeyName)
        }
        if let defaultSubnetId = defaultSubnetId {
            try encodeContainer.encode(defaultSubnetId, forKey: .defaultSubnetId)
        }
        if let hostnameTheme = hostnameTheme {
            try encodeContainer.encode(hostnameTheme, forKey: .hostnameTheme)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let useCustomCookbooks = useCustomCookbooks {
            try encodeContainer.encode(useCustomCookbooks, forKey: .useCustomCookbooks)
        }
        if let useOpsworksSecurityGroups = useOpsworksSecurityGroups {
            try encodeContainer.encode(useOpsworksSecurityGroups, forKey: .useOpsworksSecurityGroups)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

public struct CreateStackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStackOutputError>
}

public struct CreateStackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStackOutputError>
}

public struct CreateStackInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStackInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStackOutputError>
}

public struct CreateStackInput: Swift.Equatable {
    /// The default AWS OpsWorks Stacks agent version. You have the following options:
    ///
    ///
    ///                Auto-update - Set this parameter to LATEST. AWS OpsWorks Stacks
    ///         automatically installs new agent versions on the stack's instances as soon as
    ///         they are available.
    ///
    ///
    ///                Fixed version - Set this parameter to your preferred agent version. To update the agent version, you must edit the stack configuration and specify a new version. AWS OpsWorks Stacks then automatically installs that version on the stack's instances.
    ///
    ///
    ///          The default setting is the most recent release of the agent. To specify an agent version,
    ///       you must use the complete version number, not the abbreviated number shown on the console.
    ///       For a list of available agent version numbers, call DescribeAgentVersions. AgentVersion cannot be set to Chef 12.2.
    ///
    ///             You can also specify an agent version when you create or update an instance, which overrides the stack's default setting.
    ///
    public var agentVersion: Swift.String?
    /// One or more user-defined key-value pairs to be added to the stack attributes.
    public var attributes: [Swift.String:Swift.String]?
    /// A ChefConfiguration object that specifies whether to enable Berkshelf and the
    ///       Berkshelf version on Chef 11.10 stacks. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html">Create a New Stack.
    public var chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
    /// The configuration manager. When you create a stack we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 12.
    public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    /// Contains the information required to retrieve an app or cookbook from a repository. For more information,
    ///             see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html">Adding Apps or
    ///             <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html">Cookbooks and Recipes.
    public var customCookbooksSource: OpsWorksClientTypes.Source?
    /// A string that contains user-defined, custom JSON. It can be used to override the corresponding default stack configuration attribute values or to pass data to recipes. The string should be in the following format:
    ///
    ///             "{\"key1\": \"value1\", \"key2\": \"value2\",...}"
    ///
    ///          For more information about custom JSON, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html">Use Custom JSON to
    ///         Modify the Stack Configuration Attributes.
    public var customJson: Swift.String?
    /// The stack's default Availability Zone, which must be in the specified region. For more
    ///       information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and
    ///         Endpoints. If you also specify a value for DefaultSubnetId, the subnet must
    ///       be in the same zone. For more information, see the VpcId parameter description.
    ///
    public var defaultAvailabilityZone: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM profile that is the default profile for all of the stack's EC2 instances.
    ///       For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers.
    /// This member is required.
    public var defaultInstanceProfileArn: Swift.String?
    /// The stack's default operating system, which is installed on every instance unless you specify a different operating system when you create the instance. You can specify one of the following.
    ///
    ///
    ///                A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2018.03, Amazon Linux 2017.09, Amazon Linux 2017.03, Amazon Linux 2016.09,
    ///               Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.
    ///
    ///
    ///                A supported Ubuntu operating system, such as Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.
    ///
    ///
    ///
    ///                   CentOS Linux 7
    ///
    ///
    ///
    ///
    ///                   Red Hat Enterprise Linux 7
    ///
    ///
    ///
    ///                A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base,
    ///               Microsoft Windows Server 2012 R2 with SQL Server Express,
    ///               Microsoft Windows Server 2012 R2 with SQL Server Standard, or
    ///               Microsoft Windows Server 2012 R2 with SQL Server Web.
    ///
    ///
    ///                A custom AMI: Custom. You specify the custom AMI you want to use when
    ///         you create instances. For more
    ///         information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html">
    ///         Using Custom AMIs.
    ///
    ///
    ///          The default option is the current Amazon Linux version.
    ///       For more information about supported operating systems,
    ///       see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html">AWS OpsWorks Stacks Operating Systems.
    public var defaultOs: Swift.String?
    /// The default root device type. This value is the default for all instances in the stack,
    ///       but you can override it when you create an instance. The default option is
    ///         instance-store. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device">Storage for the Root Device.
    public var defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
    /// A default Amazon EC2 key pair name. The default value is none. If you specify a key pair name, AWS
    ///       OpsWorks installs the public key on the instance and you can use the private key with an SSH
    ///       client to log in to the instance. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-ssh.html"> Using SSH to
    ///         Communicate with an Instance and <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/security-ssh-access.html"> Managing SSH
    ///         Access. You can override this setting by specifying a different key pair, or no key
    ///       pair, when you <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-add.html">
    ///         create an instance.
    public var defaultSshKeyName: Swift.String?
    /// The stack's default VPC subnet ID. This parameter is required if you specify a value for the
    ///         VpcId parameter. All instances are launched into this subnet unless you specify
    ///       otherwise when you create the instance. If you also specify a value for
    ///         DefaultAvailabilityZone, the subnet must be in that zone. For information on
    ///       default values and when this parameter is required, see the VpcId parameter
    ///       description.
    public var defaultSubnetId: Swift.String?
    /// The stack's host name theme, with spaces replaced by underscores. The theme is used to
    ///       generate host names for the stack's instances. By default, HostnameTheme is set
    ///       to Layer_Dependent, which creates host names by appending integers to the layer's
    ///       short name. The other themes are:
    ///
    ///
    ///
    ///                   Baked_Goods
    ///
    ///
    ///
    ///
    ///                   Clouds
    ///
    ///
    ///
    ///
    ///                   Europe_Cities
    ///
    ///
    ///
    ///
    ///                   Fruits
    ///
    ///
    ///
    ///
    ///                   Greek_Deities_and_Titans
    ///
    ///
    ///
    ///
    ///                   Legendary_creatures_from_Japan
    ///
    ///
    ///
    ///
    ///                   Planets_and_Moons
    ///
    ///
    ///
    ///
    ///                   Roman_Deities
    ///
    ///
    ///
    ///
    ///                   Scottish_Islands
    ///
    ///
    ///
    ///
    ///                   US_Cities
    ///
    ///
    ///
    ///
    ///                   Wild_Cats
    ///
    ///
    ///
    ///          To obtain a generated host name, call GetHostNameSuggestion, which returns a
    ///       host name based on the current theme.
    public var hostnameTheme: Swift.String?
    /// The stack name.
    /// This member is required.
    public var name: Swift.String?
    /// The stack's AWS region, such as ap-south-1. For more information about
    ///             Amazon regions, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints.
    ///
    ///             In the AWS CLI, this API maps to the --stack-region parameter. If the
    ///                     --stack-region parameter and the AWS CLI common parameter
    ///                     --region are set to the same value, the stack uses a
    ///                     regional endpoint. If the --stack-region
    ///                 parameter is not set, but the AWS CLI --region parameter is, this also
    ///                 results in a stack with a regional endpoint. However, if the
    ///                     --region parameter is set to us-east-1, and the
    ///                     --stack-region parameter is set to one of the following, then the
    ///                 stack uses a legacy or classic region: us-west-1,
    ///                     us-west-2, sa-east-1, eu-central-1, eu-west-1, ap-northeast-1, ap-southeast-1,
    ///                     ap-southeast-2. In this case, the actual API endpoint of the stack is in
    ///                     us-east-1. Only the preceding regions are supported as classic
    ///                 regions in the us-east-1 API endpoint. Because it is a best practice to
    ///                 choose the regional endpoint that is closest to where you manage AWS, we recommend
    ///                 that you use regional endpoints for new stacks. The AWS CLI common
    ///                     --region parameter always specifies a regional API endpoint; it
    ///                 cannot be used to specify a classic AWS OpsWorks Stacks region.
    ///
    /// This member is required.
    public var region: Swift.String?
    /// The stack's AWS Identity and Access Management (IAM) role, which allows AWS OpsWorks Stacks to work with AWS
    ///       resources on your behalf. You must set this parameter to the Amazon Resource Name (ARN) for an
    ///       existing IAM role. For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers.
    /// This member is required.
    public var serviceRoleArn: Swift.String?
    /// Whether the stack uses custom cookbooks.
    public var useCustomCookbooks: Swift.Bool?
    /// Whether to associate the AWS OpsWorks Stacks built-in security groups with the stack's layers.
    ///          AWS OpsWorks Stacks provides a standard set of built-in security groups, one for each layer, which are
    ///       associated with layers by default. With UseOpsworksSecurityGroups you can instead
    ///       provide your own custom security groups. UseOpsworksSecurityGroups has the
    ///       following settings:
    ///
    ///
    ///                True - AWS OpsWorks Stacks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it, but you cannot delete the built-in security group.
    ///
    ///
    ///                False - AWS OpsWorks Stacks does not associate built-in security groups with layers. You must create appropriate EC2 security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on creation; custom security groups are required only for those layers that need custom settings.
    ///
    ///
    ///          For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html">Create a New
    ///         Stack.
    public var useOpsworksSecurityGroups: Swift.Bool?
    /// The ID of the VPC that the stack is to be launched into. The VPC must be in the stack's region. All instances are launched into this VPC. You cannot change the ID later.
    ///
    ///
    ///                If your account supports EC2-Classic, the default value is no VPC.
    ///
    ///
    ///                If your account does not support EC2-Classic, the default value is the default VPC for the specified region.
    ///
    ///
    ///          If the VPC ID corresponds to a default VPC and you have specified either the
    ///         DefaultAvailabilityZone or the DefaultSubnetId parameter only,
    ///       AWS OpsWorks Stacks infers the value of the
    ///       other parameter. If you specify neither parameter, AWS OpsWorks Stacks sets
    ///       these parameters to the first valid Availability Zone for the specified region and the
    ///       corresponding default VPC subnet ID, respectively.
    ///          If you specify a nondefault VPC ID, note the following:
    ///
    ///
    ///                It must belong to a VPC in your account that is in the specified region.
    ///
    ///
    ///                You must specify a value for DefaultSubnetId.
    ///
    ///
    ///          For more information about how to use AWS OpsWorks Stacks with a VPC, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-vpc.html">Running a Stack in a
    ///         VPC. For more information about default VPC and EC2-Classic, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html">Supported
    ///         Platforms.
    public var vpcId: Swift.String?

    public init (
        agentVersion: Swift.String? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        chefConfiguration: OpsWorksClientTypes.ChefConfiguration? = nil,
        configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
        customCookbooksSource: OpsWorksClientTypes.Source? = nil,
        customJson: Swift.String? = nil,
        defaultAvailabilityZone: Swift.String? = nil,
        defaultInstanceProfileArn: Swift.String? = nil,
        defaultOs: Swift.String? = nil,
        defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
        defaultSshKeyName: Swift.String? = nil,
        defaultSubnetId: Swift.String? = nil,
        hostnameTheme: Swift.String? = nil,
        name: Swift.String? = nil,
        region: Swift.String? = nil,
        serviceRoleArn: Swift.String? = nil,
        useCustomCookbooks: Swift.Bool? = nil,
        useOpsworksSecurityGroups: Swift.Bool? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.attributes = attributes
        self.chefConfiguration = chefConfiguration
        self.configurationManager = configurationManager
        self.customCookbooksSource = customCookbooksSource
        self.customJson = customJson
        self.defaultAvailabilityZone = defaultAvailabilityZone
        self.defaultInstanceProfileArn = defaultInstanceProfileArn
        self.defaultOs = defaultOs
        self.defaultRootDeviceType = defaultRootDeviceType
        self.defaultSshKeyName = defaultSshKeyName
        self.defaultSubnetId = defaultSubnetId
        self.hostnameTheme = hostnameTheme
        self.name = name
        self.region = region
        self.serviceRoleArn = serviceRoleArn
        self.useCustomCookbooks = useCustomCookbooks
        self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
        self.vpcId = vpcId
    }
}

struct CreateStackInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let region: Swift.String?
    public let vpcId: Swift.String?
    public let attributes: [Swift.String:Swift.String]?
    public let serviceRoleArn: Swift.String?
    public let defaultInstanceProfileArn: Swift.String?
    public let defaultOs: Swift.String?
    public let hostnameTheme: Swift.String?
    public let defaultAvailabilityZone: Swift.String?
    public let defaultSubnetId: Swift.String?
    public let customJson: Swift.String?
    public let configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    public let chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
    public let useCustomCookbooks: Swift.Bool?
    public let useOpsworksSecurityGroups: Swift.Bool?
    public let customCookbooksSource: OpsWorksClientTypes.Source?
    public let defaultSshKeyName: Swift.String?
    public let defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
    public let agentVersion: Swift.String?
}

extension CreateStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case region = "Region"
        case serviceRoleArn = "ServiceRoleArn"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let defaultInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultInstanceProfileArn)
        defaultInstanceProfileArn = defaultInstanceProfileArnDecoded
        let defaultOsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOs)
        defaultOs = defaultOsDecoded
        let hostnameThemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostnameTheme)
        hostnameTheme = hostnameThemeDecoded
        let defaultAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultAvailabilityZone)
        defaultAvailabilityZone = defaultAvailabilityZoneDecoded
        let defaultSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSubnetId)
        defaultSubnetId = defaultSubnetIdDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
        let chefConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.ChefConfiguration.self, forKey: .chefConfiguration)
        chefConfiguration = chefConfigurationDecoded
        let useCustomCookbooksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useCustomCookbooks)
        useCustomCookbooks = useCustomCookbooksDecoded
        let useOpsworksSecurityGroupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useOpsworksSecurityGroups)
        useOpsworksSecurityGroups = useOpsworksSecurityGroupsDecoded
        let customCookbooksSourceDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Source.self, forKey: .customCookbooksSource)
        customCookbooksSource = customCookbooksSourceDecoded
        let defaultSshKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSshKeyName)
        defaultSshKeyName = defaultSshKeyNameDecoded
        let defaultRootDeviceTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.RootDeviceType.self, forKey: .defaultRootDeviceType)
        defaultRootDeviceType = defaultRootDeviceTypeDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension CreateStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStackOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStackOutputResponse(stackId: \(Swift.String(describing: stackId)))"}
}

extension CreateStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stackId = output.stackId
        } else {
            self.stackId = nil
        }
    }
}

/// Contains the response to a CreateStack request.
public struct CreateStackOutputResponse: Swift.Equatable {
    /// The stack ID, which is an opaque string that you use to identify the stack when performing
    ///       actions such as DescribeStacks.
    public var stackId: Swift.String?

    public init (
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct CreateStackOutputResponseBody: Swift.Equatable {
    public let stackId: Swift.String?
}

extension CreateStackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

public struct CreateUserProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserProfileOutputError>
}

extension CreateUserProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserProfileInput(allowSelfManagement: \(Swift.String(describing: allowSelfManagement)), iamUserArn: \(Swift.String(describing: iamUserArn)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), sshUsername: \(Swift.String(describing: sshUsername)))"}
}

extension CreateUserProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSelfManagement = "AllowSelfManagement"
        case iamUserArn = "IamUserArn"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSelfManagement = allowSelfManagement {
            try encodeContainer.encode(allowSelfManagement, forKey: .allowSelfManagement)
        }
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let sshUsername = sshUsername {
            try encodeContainer.encode(sshUsername, forKey: .sshUsername)
        }
    }
}

public struct CreateUserProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserProfileOutputError>
}

public struct CreateUserProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserProfileOutputError>
}

public struct CreateUserProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateUserProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUserProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserProfileOutputError>
}

public struct CreateUserProfileInput: Swift.Equatable {
    /// Whether users can specify their own SSH public key through the My Settings page. For more
    ///       information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/security-settingsshkey.html">Setting an IAM
    ///         User's Public SSH Key.
    public var allowSelfManagement: Swift.Bool?
    /// The user's IAM ARN; this can also be a federated user's ARN.
    /// This member is required.
    public var iamUserArn: Swift.String?
    /// The user's public SSH key.
    public var sshPublicKey: Swift.String?
    /// The user's SSH user name. The allowable characters are [a-z], [A-Z], [0-9], '-', and '_'. If
    ///       the specified name includes other punctuation marks, AWS OpsWorks Stacks removes them. For example,
    ///         my.name will be changed to myname. If you do not specify an SSH
    ///       user name, AWS OpsWorks Stacks generates one from the IAM user name.
    public var sshUsername: Swift.String?

    public init (
        allowSelfManagement: Swift.Bool? = nil,
        iamUserArn: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        sshUsername: Swift.String? = nil
    )
    {
        self.allowSelfManagement = allowSelfManagement
        self.iamUserArn = iamUserArn
        self.sshPublicKey = sshPublicKey
        self.sshUsername = sshUsername
    }
}

struct CreateUserProfileInputBody: Swift.Equatable {
    public let iamUserArn: Swift.String?
    public let sshUsername: Swift.String?
    public let sshPublicKey: Swift.String?
    public let allowSelfManagement: Swift.Bool?
}

extension CreateUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSelfManagement = "AllowSelfManagement"
        case iamUserArn = "IamUserArn"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let sshUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshUsername)
        sshUsername = sshUsernameDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let allowSelfManagementDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSelfManagement)
        allowSelfManagement = allowSelfManagementDecoded
    }
}

extension CreateUserProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserProfileOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserProfileOutputResponse(iamUserArn: \(Swift.String(describing: iamUserArn)))"}
}

extension CreateUserProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.iamUserArn = output.iamUserArn
        } else {
            self.iamUserArn = nil
        }
    }
}

/// Contains the response to a CreateUserProfile request.
public struct CreateUserProfileOutputResponse: Swift.Equatable {
    /// The user's IAM ARN.
    public var iamUserArn: Swift.String?

    public init (
        iamUserArn: Swift.String? = nil
    )
    {
        self.iamUserArn = iamUserArn
    }
}

struct CreateUserProfileOutputResponseBody: Swift.Equatable {
    public let iamUserArn: Swift.String?
}

extension CreateUserProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArn = "IamUserArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
    }
}

extension OpsWorksClientTypes.DataSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case databaseName = "DatabaseName"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension OpsWorksClientTypes.DataSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSource(arn: \(Swift.String(describing: arn)), databaseName: \(Swift.String(describing: databaseName)), type: \(Swift.String(describing: type)))"}
}

extension OpsWorksClientTypes {
    /// Describes an app's data source.
    public struct DataSource: Swift.Equatable {
        /// The data source's ARN.
        public var arn: Swift.String?
        /// The database name.
        public var databaseName: Swift.String?
        /// The data source's type, AutoSelectOpsworksMysqlInstance,
        ///         OpsworksMysqlInstance, RdsDbInstance, or None.
        public var type: Swift.String?

        public init (
            arn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.databaseName = databaseName
            self.type = type
        }
    }

}

public struct DeleteAppInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppOutputError>
}

extension DeleteAppInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInput(appId: \(Swift.String(describing: appId)))"}
}

extension DeleteAppInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

public struct DeleteAppInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppOutputError>
}

public struct DeleteAppInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppOutputError>
}

public struct DeleteAppInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteAppInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppOutputError>
}

public struct DeleteAppInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?

    public init (
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct DeleteAppInputBody: Swift.Equatable {
    public let appId: Swift.String?
}

extension DeleteAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension DeleteAppOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppOutputResponse()"}
}

extension DeleteAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAppOutputResponseBody: Swift.Equatable {
}

extension DeleteAppOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInstanceOutputError>
}

extension DeleteInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteInstanceInput(deleteElasticIp: \(Swift.String(describing: deleteElasticIp)), deleteVolumes: \(Swift.String(describing: deleteVolumes)), instanceId: \(Swift.String(describing: instanceId)))"}
}

extension DeleteInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteElasticIp = "DeleteElasticIp"
        case deleteVolumes = "DeleteVolumes"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteElasticIp = deleteElasticIp {
            try encodeContainer.encode(deleteElasticIp, forKey: .deleteElasticIp)
        }
        if let deleteVolumes = deleteVolumes {
            try encodeContainer.encode(deleteVolumes, forKey: .deleteVolumes)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct DeleteInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInstanceOutputError>
}

public struct DeleteInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInstanceOutputError>
}

public struct DeleteInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInstanceOutputError>
}

public struct DeleteInstanceInput: Swift.Equatable {
    /// Whether to delete the instance Elastic IP address.
    public var deleteElasticIp: Swift.Bool?
    /// Whether to delete the instance's Amazon EBS volumes.
    public var deleteVolumes: Swift.Bool?
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        deleteElasticIp: Swift.Bool? = nil,
        deleteVolumes: Swift.Bool? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.deleteElasticIp = deleteElasticIp
        self.deleteVolumes = deleteVolumes
        self.instanceId = instanceId
    }
}

struct DeleteInstanceInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let deleteElasticIp: Swift.Bool?
    public let deleteVolumes: Swift.Bool?
}

extension DeleteInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteElasticIp = "DeleteElasticIp"
        case deleteVolumes = "DeleteVolumes"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let deleteElasticIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteElasticIp)
        deleteElasticIp = deleteElasticIpDecoded
        let deleteVolumesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteVolumes)
        deleteVolumes = deleteVolumesDecoded
    }
}

extension DeleteInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInstanceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteInstanceOutputResponse()"}
}

extension DeleteInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteInstanceOutputResponseBody: Swift.Equatable {
}

extension DeleteInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteLayerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLayerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLayerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLayerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLayerOutputError>
}

extension DeleteLayerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLayerInput(layerId: \(Swift.String(describing: layerId)))"}
}

extension DeleteLayerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerId = "LayerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
    }
}

public struct DeleteLayerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLayerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLayerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLayerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLayerOutputError>
}

public struct DeleteLayerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLayerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLayerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLayerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLayerOutputError>
}

public struct DeleteLayerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLayerInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteLayerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLayerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLayerOutputError>
}

public struct DeleteLayerInput: Swift.Equatable {
    /// The layer ID.
    /// This member is required.
    public var layerId: Swift.String?

    public init (
        layerId: Swift.String? = nil
    )
    {
        self.layerId = layerId
    }
}

struct DeleteLayerInputBody: Swift.Equatable {
    public let layerId: Swift.String?
}

extension DeleteLayerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerId = "LayerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
    }
}

extension DeleteLayerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLayerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLayerOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLayerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLayerOutputResponse()"}
}

extension DeleteLayerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLayerOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteLayerOutputResponseBody: Swift.Equatable {
}

extension DeleteLayerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteStackInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStackOutputError>
}

extension DeleteStackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStackInput(stackId: \(Swift.String(describing: stackId)))"}
}

extension DeleteStackInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DeleteStackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStackOutputError>
}

public struct DeleteStackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStackOutputError>
}

public struct DeleteStackInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStackInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStackOutputError>
}

public struct DeleteStackInput: Swift.Equatable {
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init (
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct DeleteStackInputBody: Swift.Equatable {
    public let stackId: Swift.String?
}

extension DeleteStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension DeleteStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStackOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStackOutputResponse()"}
}

extension DeleteStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStackOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteStackOutputResponseBody: Swift.Equatable {
}

extension DeleteStackOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteUserProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserProfileOutputError>
}

extension DeleteUserProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserProfileInput(iamUserArn: \(Swift.String(describing: iamUserArn)))"}
}

extension DeleteUserProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArn = "IamUserArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
    }
}

public struct DeleteUserProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserProfileOutputError>
}

public struct DeleteUserProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserProfileOutputError>
}

public struct DeleteUserProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteUserProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteUserProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserProfileOutputError>
}

public struct DeleteUserProfileInput: Swift.Equatable {
    /// The user's IAM ARN. This can also be a federated user's ARN.
    /// This member is required.
    public var iamUserArn: Swift.String?

    public init (
        iamUserArn: Swift.String? = nil
    )
    {
        self.iamUserArn = iamUserArn
    }
}

struct DeleteUserProfileInputBody: Swift.Equatable {
    public let iamUserArn: Swift.String?
}

extension DeleteUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArn = "IamUserArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
    }
}

extension DeleteUserProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserProfileOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserProfileOutputResponse()"}
}

extension DeleteUserProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserProfileOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteUserProfileOutputResponseBody: Swift.Equatable {
}

extension DeleteUserProfileOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension OpsWorksClientTypes.Deployment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case command = "Command"
        case comment = "Comment"
        case completedAt = "CompletedAt"
        case createdAt = "CreatedAt"
        case customJson = "CustomJson"
        case deploymentId = "DeploymentId"
        case duration = "Duration"
        case iamUserArn = "IamUserArn"
        case instanceIds = "InstanceIds"
        case stackId = "StackId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let command = command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let completedAt = completedAt {
            try encodeContainer.encode(completedAt, forKey: .completedAt)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for strings0 in instanceIds {
                try instanceIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .completedAt)
        completedAt = completedAtDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let commandDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.DeploymentCommand.self, forKey: .command)
        command = commandDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension OpsWorksClientTypes.Deployment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Deployment(appId: \(Swift.String(describing: appId)), command: \(Swift.String(describing: command)), comment: \(Swift.String(describing: comment)), completedAt: \(Swift.String(describing: completedAt)), createdAt: \(Swift.String(describing: createdAt)), customJson: \(Swift.String(describing: customJson)), deploymentId: \(Swift.String(describing: deploymentId)), duration: \(Swift.String(describing: duration)), iamUserArn: \(Swift.String(describing: iamUserArn)), instanceIds: \(Swift.String(describing: instanceIds)), stackId: \(Swift.String(describing: stackId)), status: \(Swift.String(describing: status)))"}
}

extension OpsWorksClientTypes {
    /// Describes a deployment of a stack or app.
    public struct Deployment: Swift.Equatable {
        /// The app ID.
        public var appId: Swift.String?
        /// Used to specify a stack or deployment command.
        public var command: OpsWorksClientTypes.DeploymentCommand?
        /// A user-defined comment.
        public var comment: Swift.String?
        /// Date when the deployment completed.
        public var completedAt: Swift.String?
        /// Date when the deployment was created.
        public var createdAt: Swift.String?
        /// A string that contains user-defined custom JSON. It can be used to override the corresponding default stack configuration attribute values for stack or to pass data to recipes. The string should be in the following format:
        ///
        ///             "{\"key1\": \"value1\", \"key2\": \"value2\",...}"
        ///
        ///          For more information on custom JSON, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html">Use Custom JSON to
        ///         Modify the Stack Configuration Attributes.
        public var customJson: Swift.String?
        /// The deployment ID.
        public var deploymentId: Swift.String?
        /// The deployment duration.
        public var duration: Swift.Int?
        /// The user's IAM ARN.
        public var iamUserArn: Swift.String?
        /// The IDs of the target instances.
        public var instanceIds: [Swift.String]?
        /// The stack ID.
        public var stackId: Swift.String?
        /// The deployment status:
        ///
        ///
        ///                running
        ///
        ///
        ///                successful
        ///
        ///
        ///                failed
        ///
        ///
        public var status: Swift.String?

        public init (
            appId: Swift.String? = nil,
            command: OpsWorksClientTypes.DeploymentCommand? = nil,
            comment: Swift.String? = nil,
            completedAt: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            customJson: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            duration: Swift.Int? = nil,
            iamUserArn: Swift.String? = nil,
            instanceIds: [Swift.String]? = nil,
            stackId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.appId = appId
            self.command = command
            self.comment = comment
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.customJson = customJson
            self.deploymentId = deploymentId
            self.duration = duration
            self.iamUserArn = iamUserArn
            self.instanceIds = instanceIds
            self.stackId = stackId
            self.status = status
        }
    }

}

extension OpsWorksClientTypes.DeploymentCommand: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case args = "Args"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let args = args {
            var argsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .args)
            for (dictKey0, deploymentcommandargs0) in args {
                try argsContainer.encode(deploymentcommandargs0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.DeploymentCommandName.self, forKey: .name)
        name = nameDecoded
        let argsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .args)
        var argsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let argsContainer = argsContainer {
            argsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, strings0) in argsContainer {
                var strings0Decoded0: [Swift.String]? = nil
                if let strings0 = strings0 {
                    strings0Decoded0 = [Swift.String]()
                    for string1 in strings0 {
                        if let string1 = string1 {
                            strings0Decoded0?.append(string1)
                        }
                    }
                }
                argsDecoded0?[key0] = strings0Decoded0
            }
        }
        args = argsDecoded0
    }
}

extension OpsWorksClientTypes.DeploymentCommand: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeploymentCommand(args: \(Swift.String(describing: args)), name: \(Swift.String(describing: name)))"}
}

extension OpsWorksClientTypes {
    /// Used to specify a stack or deployment command.
    public struct DeploymentCommand: Swift.Equatable {
        /// The arguments of those commands that take arguments. It should be set to a JSON object with the following format:
        ///
        ///             {"arg_name1" : ["value1", "value2", ...], "arg_name2" : ["value1", "value2", ...],
        ///         ...}
        ///
        ///          The update_dependencies command takes two arguments:
        ///
        ///
        ///
        ///                   upgrade_os_to - Specifies the desired Amazon Linux version for instances
        ///         whose OS you want to upgrade, such as Amazon Linux 2016.09. You must also set
        ///         the allow_reboot argument to true.
        ///
        ///
        ///
        ///                   allow_reboot - Specifies whether to allow AWS OpsWorks Stacks to reboot the instances if
        ///         necessary, after installing the updates. This argument can be set to either
        ///           true or false. The default value is false.
        ///
        ///
        ///          For example, to upgrade an instance to Amazon Linux 2016.09, set Args to the
        ///       following.
        ///
        ///              { "upgrade_os_to":["Amazon Linux 2016.09"], "allow_reboot":["true"] }
        ///
        public var args: [Swift.String:[Swift.String]]?
        /// Specifies the operation. You can specify only one command.
        ///          For stacks, the following commands are available:
        ///
        ///
        ///
        ///                   execute_recipes: Execute one or more recipes. To specify the recipes, set an
        ///           Args parameter named recipes to the list of recipes to be
        ///         executed. For example, to execute phpapp::appsetup, set Args to
        ///           {"recipes":["phpapp::appsetup"]}.
        ///
        ///
        ///
        ///                   install_dependencies: Install the stack's dependencies.
        ///
        ///
        ///
        ///                   update_custom_cookbooks: Update the stack's custom cookbooks.
        ///
        ///
        ///
        ///                   update_dependencies: Update the stack's dependencies.
        ///
        ///
        ///
        ///             The update_dependencies and install_dependencies commands are supported only for Linux instances. You can run the commands successfully on Windows instances, but they do nothing.
        ///
        ///          For apps, the following commands are available:
        ///
        ///
        ///
        ///                   deploy: Deploy an app. Ruby on Rails apps have an optional Args
        ///         parameter named migrate. Set Args to {"migrate":["true"]} to
        ///         migrate the database. The default setting is {"migrate":["false"]}.
        ///
        ///
        ///
        ///                   rollback Roll the app back to the previous version. When you update an app,
        ///         AWS OpsWorks Stacks stores the previous version, up to a maximum of five versions. You can use this
        ///         command to roll an app back as many as four versions.
        ///
        ///
        ///
        ///                   start: Start the app's web or application server.
        ///
        ///
        ///
        ///                   stop: Stop the app's web or application server.
        ///
        ///
        ///
        ///                   restart: Restart the app's web or application server.
        ///
        ///
        ///
        ///                   undeploy: Undeploy the app.
        ///
        ///
        /// This member is required.
        public var name: OpsWorksClientTypes.DeploymentCommandName?

        public init (
            args: [Swift.String:[Swift.String]]? = nil,
            name: OpsWorksClientTypes.DeploymentCommandName? = nil
        )
        {
            self.args = args
            self.name = name
        }
    }

}

extension OpsWorksClientTypes {
    public enum DeploymentCommandName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configure
        case deploy
        case executeRecipes
        case installDependencies
        case restart
        case rollback
        case setup
        case start
        case stop
        case undeploy
        case updateCustomCookbooks
        case updateDependencies
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentCommandName] {
            return [
                .configure,
                .deploy,
                .executeRecipes,
                .installDependencies,
                .restart,
                .rollback,
                .setup,
                .start,
                .stop,
                .undeploy,
                .updateCustomCookbooks,
                .updateDependencies,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configure: return "configure"
            case .deploy: return "deploy"
            case .executeRecipes: return "execute_recipes"
            case .installDependencies: return "install_dependencies"
            case .restart: return "restart"
            case .rollback: return "rollback"
            case .setup: return "setup"
            case .start: return "start"
            case .stop: return "stop"
            case .undeploy: return "undeploy"
            case .updateCustomCookbooks: return "update_custom_cookbooks"
            case .updateDependencies: return "update_dependencies"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentCommandName(rawValue: rawValue) ?? DeploymentCommandName.sdkUnknown(rawValue)
        }
    }
}

public struct DeregisterEcsClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterEcsClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterEcsClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterEcsClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterEcsClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterEcsClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterEcsClusterOutputError>
}

extension DeregisterEcsClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterEcsClusterInput(ecsClusterArn: \(Swift.String(describing: ecsClusterArn)))"}
}

extension DeregisterEcsClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArn = "EcsClusterArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecsClusterArn = ecsClusterArn {
            try encodeContainer.encode(ecsClusterArn, forKey: .ecsClusterArn)
        }
    }
}

public struct DeregisterEcsClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterEcsClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterEcsClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterEcsClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterEcsClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterEcsClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterEcsClusterOutputError>
}

public struct DeregisterEcsClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterEcsClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterEcsClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterEcsClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterEcsClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterEcsClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterEcsClusterOutputError>
}

public struct DeregisterEcsClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterEcsClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeregisterEcsClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterEcsClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterEcsClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterEcsClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterEcsClusterOutputError>
}

public struct DeregisterEcsClusterInput: Swift.Equatable {
    /// The cluster's Amazon Resource Number (ARN).
    /// This member is required.
    public var ecsClusterArn: Swift.String?

    public init (
        ecsClusterArn: Swift.String? = nil
    )
    {
        self.ecsClusterArn = ecsClusterArn
    }
}

struct DeregisterEcsClusterInputBody: Swift.Equatable {
    public let ecsClusterArn: Swift.String?
}

extension DeregisterEcsClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArn = "EcsClusterArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecsClusterArn)
        ecsClusterArn = ecsClusterArnDecoded
    }
}

extension DeregisterEcsClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterEcsClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterEcsClusterOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterEcsClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterEcsClusterOutputResponse()"}
}

extension DeregisterEcsClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterEcsClusterOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeregisterEcsClusterOutputResponseBody: Swift.Equatable {
}

extension DeregisterEcsClusterOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeregisterElasticIpInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterElasticIpInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterElasticIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterElasticIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterElasticIpOutputError>
}

extension DeregisterElasticIpInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterElasticIpInput(elasticIp: \(Swift.String(describing: elasticIp)))"}
}

extension DeregisterElasticIpInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
    }
}

public struct DeregisterElasticIpInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterElasticIpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterElasticIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterElasticIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterElasticIpOutputError>
}

public struct DeregisterElasticIpInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterElasticIpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterElasticIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterElasticIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterElasticIpOutputError>
}

public struct DeregisterElasticIpInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterElasticIpInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeregisterElasticIpInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterElasticIpInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterElasticIpOutputError>
}

public struct DeregisterElasticIpInput: Swift.Equatable {
    /// The Elastic IP address.
    /// This member is required.
    public var elasticIp: Swift.String?

    public init (
        elasticIp: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
    }
}

struct DeregisterElasticIpInputBody: Swift.Equatable {
    public let elasticIp: Swift.String?
}

extension DeregisterElasticIpInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
    }
}

extension DeregisterElasticIpOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterElasticIpOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterElasticIpOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterElasticIpOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterElasticIpOutputResponse()"}
}

extension DeregisterElasticIpOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterElasticIpOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeregisterElasticIpOutputResponseBody: Swift.Equatable {
}

extension DeregisterElasticIpOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeregisterInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterInstanceOutputError>
}

extension DeregisterInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterInstanceInput(instanceId: \(Swift.String(describing: instanceId)))"}
}

extension DeregisterInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct DeregisterInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterInstanceOutputError>
}

public struct DeregisterInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterInstanceOutputError>
}

public struct DeregisterInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeregisterInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterInstanceOutputError>
}

public struct DeregisterInstanceInput: Swift.Equatable {
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct DeregisterInstanceInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
}

extension DeregisterInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension DeregisterInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterInstanceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterInstanceOutputResponse()"}
}

extension DeregisterInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeregisterInstanceOutputResponseBody: Swift.Equatable {
}

extension DeregisterInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeregisterRdsDbInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterRdsDbInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterRdsDbInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterRdsDbInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterRdsDbInstanceOutputError>
}

extension DeregisterRdsDbInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterRdsDbInstanceInput(rdsDbInstanceArn: \(Swift.String(describing: rdsDbInstanceArn)))"}
}

extension DeregisterRdsDbInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rdsDbInstanceArn = "RdsDbInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rdsDbInstanceArn = rdsDbInstanceArn {
            try encodeContainer.encode(rdsDbInstanceArn, forKey: .rdsDbInstanceArn)
        }
    }
}

public struct DeregisterRdsDbInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterRdsDbInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterRdsDbInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterRdsDbInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterRdsDbInstanceOutputError>
}

public struct DeregisterRdsDbInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterRdsDbInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterRdsDbInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterRdsDbInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterRdsDbInstanceOutputError>
}

public struct DeregisterRdsDbInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterRdsDbInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeregisterRdsDbInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterRdsDbInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterRdsDbInstanceOutputError>
}

public struct DeregisterRdsDbInstanceInput: Swift.Equatable {
    /// The Amazon RDS instance's ARN.
    /// This member is required.
    public var rdsDbInstanceArn: Swift.String?

    public init (
        rdsDbInstanceArn: Swift.String? = nil
    )
    {
        self.rdsDbInstanceArn = rdsDbInstanceArn
    }
}

struct DeregisterRdsDbInstanceInputBody: Swift.Equatable {
    public let rdsDbInstanceArn: Swift.String?
}

extension DeregisterRdsDbInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rdsDbInstanceArn = "RdsDbInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rdsDbInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rdsDbInstanceArn)
        rdsDbInstanceArn = rdsDbInstanceArnDecoded
    }
}

extension DeregisterRdsDbInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterRdsDbInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterRdsDbInstanceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterRdsDbInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterRdsDbInstanceOutputResponse()"}
}

extension DeregisterRdsDbInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterRdsDbInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeregisterRdsDbInstanceOutputResponseBody: Swift.Equatable {
}

extension DeregisterRdsDbInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeregisterVolumeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterVolumeOutputError>
}

extension DeregisterVolumeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterVolumeInput(volumeId: \(Swift.String(describing: volumeId)))"}
}

extension DeregisterVolumeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeId = "VolumeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
    }
}

public struct DeregisterVolumeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterVolumeOutputError>
}

public struct DeregisterVolumeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterVolumeOutputError>
}

public struct DeregisterVolumeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterVolumeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeregisterVolumeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterVolumeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterVolumeOutputError>
}

public struct DeregisterVolumeInput: Swift.Equatable {
    /// The AWS OpsWorks Stacks volume ID, which is the GUID that AWS OpsWorks Stacks assigned to the instance when you registered the volume with the stack, not the Amazon EC2 volume ID.
    /// This member is required.
    public var volumeId: Swift.String?

    public init (
        volumeId: Swift.String? = nil
    )
    {
        self.volumeId = volumeId
    }
}

struct DeregisterVolumeInputBody: Swift.Equatable {
    public let volumeId: Swift.String?
}

extension DeregisterVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeId = "VolumeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
    }
}

extension DeregisterVolumeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterVolumeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterVolumeOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterVolumeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterVolumeOutputResponse()"}
}

extension DeregisterVolumeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterVolumeOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeregisterVolumeOutputResponseBody: Swift.Equatable {
}

extension DeregisterVolumeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeAgentVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAgentVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAgentVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAgentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAgentVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAgentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAgentVersionsOutputError>
}

extension DescribeAgentVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAgentVersionsInput(configurationManager: \(Swift.String(describing: configurationManager)), stackId: \(Swift.String(describing: stackId)))"}
}

extension DescribeAgentVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationManager = "ConfigurationManager"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationManager = configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeAgentVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAgentVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAgentVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAgentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAgentVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAgentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAgentVersionsOutputError>
}

public struct DescribeAgentVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAgentVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAgentVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAgentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAgentVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAgentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAgentVersionsOutputError>
}

public struct DescribeAgentVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAgentVersionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeAgentVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAgentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAgentVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAgentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAgentVersionsOutputError>
}

public struct DescribeAgentVersionsInput: Swift.Equatable {
    /// The configuration manager.
    public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    /// The stack ID.
    public var stackId: Swift.String?

    public init (
        configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.configurationManager = configurationManager
        self.stackId = stackId
    }
}

struct DescribeAgentVersionsInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let configurationManager: OpsWorksClientTypes.StackConfigurationManager?
}

extension DescribeAgentVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationManager = "ConfigurationManager"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
    }
}

extension DescribeAgentVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAgentVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAgentVersionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAgentVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAgentVersionsOutputResponse(agentVersions: \(Swift.String(describing: agentVersions)))"}
}

extension DescribeAgentVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAgentVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agentVersions = output.agentVersions
        } else {
            self.agentVersions = nil
        }
    }
}

/// Contains the response to a DescribeAgentVersions request.
public struct DescribeAgentVersionsOutputResponse: Swift.Equatable {
    /// The agent versions for the specified stack or configuration manager. Note that this value is the complete version number, not the abbreviated number used by the console.
    public var agentVersions: [OpsWorksClientTypes.AgentVersion]?

    public init (
        agentVersions: [OpsWorksClientTypes.AgentVersion]? = nil
    )
    {
        self.agentVersions = agentVersions
    }
}

struct DescribeAgentVersionsOutputResponseBody: Swift.Equatable {
    public let agentVersions: [OpsWorksClientTypes.AgentVersion]?
}

extension DescribeAgentVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersions = "AgentVersions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentVersionsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.AgentVersion?].self, forKey: .agentVersions)
        var agentVersionsDecoded0:[OpsWorksClientTypes.AgentVersion]? = nil
        if let agentVersionsContainer = agentVersionsContainer {
            agentVersionsDecoded0 = [OpsWorksClientTypes.AgentVersion]()
            for structure0 in agentVersionsContainer {
                if let structure0 = structure0 {
                    agentVersionsDecoded0?.append(structure0)
                }
            }
        }
        agentVersions = agentVersionsDecoded0
    }
}

public struct DescribeAppsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppsOutputError>
}

extension DescribeAppsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppsInput(appIds: \(Swift.String(describing: appIds)), stackId: \(Swift.String(describing: stackId)))"}
}

extension DescribeAppsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appIds = "AppIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIds = appIds {
            var appIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appIds)
            for strings0 in appIds {
                try appIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeAppsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppsOutputError>
}

public struct DescribeAppsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppsOutputError>
}

public struct DescribeAppsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeAppsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppsOutputError>
}

public struct DescribeAppsInput: Swift.Equatable {
    /// An array of app IDs for the apps to be described. If you use this parameter,
    ///         DescribeApps returns a description of the specified apps. Otherwise, it returns
    ///       a description of every app.
    public var appIds: [Swift.String]?
    /// The app stack ID. If you use this parameter, DescribeApps returns a description
    ///       of the apps in the specified stack.
    public var stackId: Swift.String?

    public init (
        appIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.appIds = appIds
        self.stackId = stackId
    }
}

struct DescribeAppsInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let appIds: [Swift.String]?
}

extension DescribeAppsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appIds = "AppIds"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let appIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .appIds)
        var appIdsDecoded0:[Swift.String]? = nil
        if let appIdsContainer = appIdsContainer {
            appIdsDecoded0 = [Swift.String]()
            for string0 in appIdsContainer {
                if let string0 = string0 {
                    appIdsDecoded0?.append(string0)
                }
            }
        }
        appIds = appIdsDecoded0
    }
}

extension DescribeAppsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppsOutputResponse(apps: \(Swift.String(describing: apps)))"}
}

extension DescribeAppsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apps = output.apps
        } else {
            self.apps = nil
        }
    }
}

/// Contains the response to a DescribeApps request.
public struct DescribeAppsOutputResponse: Swift.Equatable {
    /// An array of App objects that describe the specified apps.
    public var apps: [OpsWorksClientTypes.App]?

    public init (
        apps: [OpsWorksClientTypes.App]? = nil
    )
    {
        self.apps = apps
    }
}

struct DescribeAppsOutputResponseBody: Swift.Equatable {
    public let apps: [OpsWorksClientTypes.App]?
}

extension DescribeAppsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apps = "Apps"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.App?].self, forKey: .apps)
        var appsDecoded0:[OpsWorksClientTypes.App]? = nil
        if let appsContainer = appsContainer {
            appsDecoded0 = [OpsWorksClientTypes.App]()
            for structure0 in appsContainer {
                if let structure0 = structure0 {
                    appsDecoded0?.append(structure0)
                }
            }
        }
        apps = appsDecoded0
    }
}

public struct DescribeCommandsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCommandsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCommandsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCommandsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCommandsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCommandsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCommandsOutputError>
}

extension DescribeCommandsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCommandsInput(commandIds: \(Swift.String(describing: commandIds)), deploymentId: \(Swift.String(describing: deploymentId)), instanceId: \(Swift.String(describing: instanceId)))"}
}

extension DescribeCommandsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandIds = "CommandIds"
        case deploymentId = "DeploymentId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commandIds = commandIds {
            var commandIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .commandIds)
            for strings0 in commandIds {
                try commandIdsContainer.encode(strings0)
            }
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct DescribeCommandsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCommandsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCommandsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCommandsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCommandsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCommandsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCommandsOutputError>
}

public struct DescribeCommandsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCommandsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCommandsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCommandsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCommandsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCommandsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCommandsOutputError>
}

public struct DescribeCommandsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCommandsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeCommandsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCommandsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCommandsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCommandsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCommandsOutputError>
}

public struct DescribeCommandsInput: Swift.Equatable {
    /// An array of command IDs. If you include this parameter, DescribeCommands returns
    ///       a description of the specified commands. Otherwise, it returns a description of every
    ///       command.
    public var commandIds: [Swift.String]?
    /// The deployment ID. If you include this parameter, DescribeCommands returns a
    ///       description of the commands associated with the specified deployment.
    public var deploymentId: Swift.String?
    /// The instance ID. If you include this parameter, DescribeCommands returns a
    ///       description of the commands associated with the specified instance.
    public var instanceId: Swift.String?

    public init (
        commandIds: [Swift.String]? = nil,
        deploymentId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.commandIds = commandIds
        self.deploymentId = deploymentId
        self.instanceId = instanceId
    }
}

struct DescribeCommandsInputBody: Swift.Equatable {
    public let deploymentId: Swift.String?
    public let instanceId: Swift.String?
    public let commandIds: [Swift.String]?
}

extension DescribeCommandsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandIds = "CommandIds"
        case deploymentId = "DeploymentId"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let commandIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .commandIds)
        var commandIdsDecoded0:[Swift.String]? = nil
        if let commandIdsContainer = commandIdsContainer {
            commandIdsDecoded0 = [Swift.String]()
            for string0 in commandIdsContainer {
                if let string0 = string0 {
                    commandIdsDecoded0?.append(string0)
                }
            }
        }
        commandIds = commandIdsDecoded0
    }
}

extension DescribeCommandsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCommandsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCommandsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCommandsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCommandsOutputResponse(commands: \(Swift.String(describing: commands)))"}
}

extension DescribeCommandsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCommandsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.commands = output.commands
        } else {
            self.commands = nil
        }
    }
}

/// Contains the response to a DescribeCommands request.
public struct DescribeCommandsOutputResponse: Swift.Equatable {
    /// An array of Command objects that describe each of the specified commands.
    public var commands: [OpsWorksClientTypes.Command]?

    public init (
        commands: [OpsWorksClientTypes.Command]? = nil
    )
    {
        self.commands = commands
    }
}

struct DescribeCommandsOutputResponseBody: Swift.Equatable {
    public let commands: [OpsWorksClientTypes.Command]?
}

extension DescribeCommandsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commands = "Commands"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.Command?].self, forKey: .commands)
        var commandsDecoded0:[OpsWorksClientTypes.Command]? = nil
        if let commandsContainer = commandsContainer {
            commandsDecoded0 = [OpsWorksClientTypes.Command]()
            for structure0 in commandsContainer {
                if let structure0 = structure0 {
                    commandsDecoded0?.append(structure0)
                }
            }
        }
        commands = commandsDecoded0
    }
}

public struct DescribeDeploymentsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDeploymentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDeploymentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDeploymentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDeploymentsOutputError>
}

extension DescribeDeploymentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDeploymentsInput(appId: \(Swift.String(describing: appId)), deploymentIds: \(Swift.String(describing: deploymentIds)), stackId: \(Swift.String(describing: stackId)))"}
}

extension DescribeDeploymentsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case deploymentIds = "DeploymentIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let deploymentIds = deploymentIds {
            var deploymentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deploymentIds)
            for strings0 in deploymentIds {
                try deploymentIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeDeploymentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDeploymentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDeploymentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDeploymentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDeploymentsOutputError>
}

public struct DescribeDeploymentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDeploymentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDeploymentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDeploymentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDeploymentsOutputError>
}

public struct DescribeDeploymentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDeploymentsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDeploymentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDeploymentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDeploymentsOutputError>
}

public struct DescribeDeploymentsInput: Swift.Equatable {
    /// The app ID. If you include this parameter, the command returns a
    ///       description of the commands associated with the specified app.
    public var appId: Swift.String?
    /// An array of deployment IDs to be described. If you include this parameter,
    ///         the command returns a description of the specified deployments.
    ///       Otherwise, it returns a description of every deployment.
    public var deploymentIds: [Swift.String]?
    /// The stack ID. If you include this parameter, the command returns a
    ///       description of the commands associated with the specified stack.
    public var stackId: Swift.String?

    public init (
        appId: Swift.String? = nil,
        deploymentIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.deploymentIds = deploymentIds
        self.stackId = stackId
    }
}

struct DescribeDeploymentsInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let appId: Swift.String?
    public let deploymentIds: [Swift.String]?
}

extension DescribeDeploymentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case deploymentIds = "DeploymentIds"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let deploymentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deploymentIds)
        var deploymentIdsDecoded0:[Swift.String]? = nil
        if let deploymentIdsContainer = deploymentIdsContainer {
            deploymentIdsDecoded0 = [Swift.String]()
            for string0 in deploymentIdsContainer {
                if let string0 = string0 {
                    deploymentIdsDecoded0?.append(string0)
                }
            }
        }
        deploymentIds = deploymentIdsDecoded0
    }
}

extension DescribeDeploymentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeploymentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDeploymentsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeploymentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDeploymentsOutputResponse(deployments: \(Swift.String(describing: deployments)))"}
}

extension DescribeDeploymentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deployments = output.deployments
        } else {
            self.deployments = nil
        }
    }
}

/// Contains the response to a DescribeDeployments request.
public struct DescribeDeploymentsOutputResponse: Swift.Equatable {
    /// An array of Deployment objects that describe the deployments.
    public var deployments: [OpsWorksClientTypes.Deployment]?

    public init (
        deployments: [OpsWorksClientTypes.Deployment]? = nil
    )
    {
        self.deployments = deployments
    }
}

struct DescribeDeploymentsOutputResponseBody: Swift.Equatable {
    public let deployments: [OpsWorksClientTypes.Deployment]?
}

extension DescribeDeploymentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployments = "Deployments"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.Deployment?].self, forKey: .deployments)
        var deploymentsDecoded0:[OpsWorksClientTypes.Deployment]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [OpsWorksClientTypes.Deployment]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
    }
}

public struct DescribeEcsClustersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEcsClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEcsClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEcsClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEcsClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEcsClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEcsClustersOutputError>
}

extension DescribeEcsClustersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEcsClustersInput(ecsClusterArns: \(Swift.String(describing: ecsClusterArns)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), stackId: \(Swift.String(describing: stackId)))"}
}

extension DescribeEcsClustersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArns = "EcsClusterArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecsClusterArns = ecsClusterArns {
            var ecsClusterArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecsClusterArns)
            for strings0 in ecsClusterArns {
                try ecsClusterArnsContainer.encode(strings0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeEcsClustersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEcsClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEcsClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEcsClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEcsClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEcsClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEcsClustersOutputError>
}

public struct DescribeEcsClustersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEcsClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEcsClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEcsClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEcsClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEcsClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEcsClustersOutputError>
}

public struct DescribeEcsClustersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEcsClustersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeEcsClustersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEcsClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEcsClustersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEcsClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEcsClustersOutputError>
}

public struct DescribeEcsClustersInput: Swift.Equatable {
    /// A list of ARNs, one for each cluster to be described.
    public var ecsClusterArns: [Swift.String]?
    /// To receive a paginated response, use this parameter to specify the maximum number
    ///       of results to be returned with a single call. If the number of available results exceeds this maximum, the
    ///       response includes a NextToken value that you can assign
    ///       to the NextToken request parameter to get the next set of results.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results,
    ///       the response object'sNextToken parameter value is set to a token.
    ///       To retrieve the next set of results, call DescribeEcsClusters
    ///       again and assign that token to the request object's NextToken parameter.
    ///       If there are no remaining results, the previous response
    ///       object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A stack ID.
    ///       DescribeEcsClusters returns a description of the cluster that is registered with the stack.
    public var stackId: Swift.String?

    public init (
        ecsClusterArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.ecsClusterArns = ecsClusterArns
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stackId = stackId
    }
}

struct DescribeEcsClustersInputBody: Swift.Equatable {
    public let ecsClusterArns: [Swift.String]?
    public let stackId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeEcsClustersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArns = "EcsClusterArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClusterArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ecsClusterArns)
        var ecsClusterArnsDecoded0:[Swift.String]? = nil
        if let ecsClusterArnsContainer = ecsClusterArnsContainer {
            ecsClusterArnsDecoded0 = [Swift.String]()
            for string0 in ecsClusterArnsContainer {
                if let string0 = string0 {
                    ecsClusterArnsDecoded0?.append(string0)
                }
            }
        }
        ecsClusterArns = ecsClusterArnsDecoded0
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeEcsClustersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEcsClustersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEcsClustersOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEcsClustersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEcsClustersOutputResponse(ecsClusters: \(Swift.String(describing: ecsClusters)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeEcsClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEcsClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ecsClusters = output.ecsClusters
            self.nextToken = output.nextToken
        } else {
            self.ecsClusters = nil
            self.nextToken = nil
        }
    }
}

/// Contains the response to a DescribeEcsClusters request.
public struct DescribeEcsClustersOutputResponse: Swift.Equatable {
    /// A list of EcsCluster objects containing the cluster descriptions.
    public var ecsClusters: [OpsWorksClientTypes.EcsCluster]?
    /// If a paginated request does not return all of the remaining results, this parameter is set to a token that
    ///       you can assign to the request object's NextToken parameter to retrieve the next set of results.
    ///       If the previous paginated request returned all of the remaining results,
    ///       this parameter is set to null.
    public var nextToken: Swift.String?

    public init (
        ecsClusters: [OpsWorksClientTypes.EcsCluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ecsClusters = ecsClusters
        self.nextToken = nextToken
    }
}

struct DescribeEcsClustersOutputResponseBody: Swift.Equatable {
    public let ecsClusters: [OpsWorksClientTypes.EcsCluster]?
    public let nextToken: Swift.String?
}

extension DescribeEcsClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusters = "EcsClusters"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClustersContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.EcsCluster?].self, forKey: .ecsClusters)
        var ecsClustersDecoded0:[OpsWorksClientTypes.EcsCluster]? = nil
        if let ecsClustersContainer = ecsClustersContainer {
            ecsClustersDecoded0 = [OpsWorksClientTypes.EcsCluster]()
            for structure0 in ecsClustersContainer {
                if let structure0 = structure0 {
                    ecsClustersDecoded0?.append(structure0)
                }
            }
        }
        ecsClusters = ecsClustersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeElasticIpsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeElasticIpsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeElasticIpsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeElasticIpsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeElasticIpsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeElasticIpsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeElasticIpsOutputError>
}

extension DescribeElasticIpsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeElasticIpsInput(instanceId: \(Swift.String(describing: instanceId)), ips: \(Swift.String(describing: ips)), stackId: \(Swift.String(describing: stackId)))"}
}

extension DescribeElasticIpsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case ips = "Ips"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let ips = ips {
            var ipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ips)
            for strings0 in ips {
                try ipsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeElasticIpsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeElasticIpsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeElasticIpsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeElasticIpsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeElasticIpsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeElasticIpsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeElasticIpsOutputError>
}

public struct DescribeElasticIpsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeElasticIpsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeElasticIpsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeElasticIpsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeElasticIpsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeElasticIpsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeElasticIpsOutputError>
}

public struct DescribeElasticIpsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeElasticIpsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeElasticIpsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeElasticIpsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeElasticIpsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeElasticIpsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeElasticIpsOutputError>
}

public struct DescribeElasticIpsInput: Swift.Equatable {
    /// The instance ID. If you include this parameter, DescribeElasticIps returns a
    ///       description of the Elastic IP addresses associated with the specified instance.
    public var instanceId: Swift.String?
    /// An array of Elastic IP addresses to be described. If you include this parameter,
    ///         DescribeElasticIps returns a description of the specified Elastic IP addresses.
    ///       Otherwise, it returns a description of every Elastic IP address.
    public var ips: [Swift.String]?
    /// A stack ID. If you include this parameter, DescribeElasticIps returns a
    ///       description of the Elastic IP addresses that are registered with the specified stack.
    public var stackId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        ips: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.ips = ips
        self.stackId = stackId
    }
}

struct DescribeElasticIpsInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let stackId: Swift.String?
    public let ips: [Swift.String]?
}

extension DescribeElasticIpsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case ips = "Ips"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let ipsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ips)
        var ipsDecoded0:[Swift.String]? = nil
        if let ipsContainer = ipsContainer {
            ipsDecoded0 = [Swift.String]()
            for string0 in ipsContainer {
                if let string0 = string0 {
                    ipsDecoded0?.append(string0)
                }
            }
        }
        ips = ipsDecoded0
    }
}

extension DescribeElasticIpsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeElasticIpsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeElasticIpsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeElasticIpsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeElasticIpsOutputResponse(elasticIps: \(Swift.String(describing: elasticIps)))"}
}

extension DescribeElasticIpsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeElasticIpsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.elasticIps = output.elasticIps
        } else {
            self.elasticIps = nil
        }
    }
}

/// Contains the response to a DescribeElasticIps request.
public struct DescribeElasticIpsOutputResponse: Swift.Equatable {
    /// An ElasticIps object that describes the specified Elastic IP addresses.
    public var elasticIps: [OpsWorksClientTypes.ElasticIp]?

    public init (
        elasticIps: [OpsWorksClientTypes.ElasticIp]? = nil
    )
    {
        self.elasticIps = elasticIps
    }
}

struct DescribeElasticIpsOutputResponseBody: Swift.Equatable {
    public let elasticIps: [OpsWorksClientTypes.ElasticIp]?
}

extension DescribeElasticIpsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIps = "ElasticIps"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.ElasticIp?].self, forKey: .elasticIps)
        var elasticIpsDecoded0:[OpsWorksClientTypes.ElasticIp]? = nil
        if let elasticIpsContainer = elasticIpsContainer {
            elasticIpsDecoded0 = [OpsWorksClientTypes.ElasticIp]()
            for structure0 in elasticIpsContainer {
                if let structure0 = structure0 {
                    elasticIpsDecoded0?.append(structure0)
                }
            }
        }
        elasticIps = elasticIpsDecoded0
    }
}

public struct DescribeElasticLoadBalancersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeElasticLoadBalancersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeElasticLoadBalancersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeElasticLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeElasticLoadBalancersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeElasticLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeElasticLoadBalancersOutputError>
}

extension DescribeElasticLoadBalancersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeElasticLoadBalancersInput(layerIds: \(Swift.String(describing: layerIds)), stackId: \(Swift.String(describing: stackId)))"}
}

extension DescribeElasticLoadBalancersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeElasticLoadBalancersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeElasticLoadBalancersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeElasticLoadBalancersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeElasticLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeElasticLoadBalancersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeElasticLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeElasticLoadBalancersOutputError>
}

public struct DescribeElasticLoadBalancersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeElasticLoadBalancersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeElasticLoadBalancersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeElasticLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeElasticLoadBalancersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeElasticLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeElasticLoadBalancersOutputError>
}

public struct DescribeElasticLoadBalancersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeElasticLoadBalancersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeElasticLoadBalancersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeElasticLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeElasticLoadBalancersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeElasticLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeElasticLoadBalancersOutputError>
}

public struct DescribeElasticLoadBalancersInput: Swift.Equatable {
    /// A list of layer IDs. The action describes the Elastic Load Balancing instances for the specified layers.
    public var layerIds: [Swift.String]?
    /// A stack ID. The action describes the stack's Elastic Load Balancing instances.
    public var stackId: Swift.String?

    public init (
        layerIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.layerIds = layerIds
        self.stackId = stackId
    }
}

struct DescribeElasticLoadBalancersInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let layerIds: [Swift.String]?
}

extension DescribeElasticLoadBalancersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
    }
}

extension DescribeElasticLoadBalancersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeElasticLoadBalancersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeElasticLoadBalancersOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeElasticLoadBalancersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeElasticLoadBalancersOutputResponse(elasticLoadBalancers: \(Swift.String(describing: elasticLoadBalancers)))"}
}

extension DescribeElasticLoadBalancersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeElasticLoadBalancersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.elasticLoadBalancers = output.elasticLoadBalancers
        } else {
            self.elasticLoadBalancers = nil
        }
    }
}

/// Contains the response to a DescribeElasticLoadBalancers request.
public struct DescribeElasticLoadBalancersOutputResponse: Swift.Equatable {
    /// A list of ElasticLoadBalancer objects that describe the specified Elastic Load Balancing
    ///       instances.
    public var elasticLoadBalancers: [OpsWorksClientTypes.ElasticLoadBalancer]?

    public init (
        elasticLoadBalancers: [OpsWorksClientTypes.ElasticLoadBalancer]? = nil
    )
    {
        self.elasticLoadBalancers = elasticLoadBalancers
    }
}

struct DescribeElasticLoadBalancersOutputResponseBody: Swift.Equatable {
    public let elasticLoadBalancers: [OpsWorksClientTypes.ElasticLoadBalancer]?
}

extension DescribeElasticLoadBalancersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticLoadBalancers = "ElasticLoadBalancers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticLoadBalancersContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.ElasticLoadBalancer?].self, forKey: .elasticLoadBalancers)
        var elasticLoadBalancersDecoded0:[OpsWorksClientTypes.ElasticLoadBalancer]? = nil
        if let elasticLoadBalancersContainer = elasticLoadBalancersContainer {
            elasticLoadBalancersDecoded0 = [OpsWorksClientTypes.ElasticLoadBalancer]()
            for structure0 in elasticLoadBalancersContainer {
                if let structure0 = structure0 {
                    elasticLoadBalancersDecoded0?.append(structure0)
                }
            }
        }
        elasticLoadBalancers = elasticLoadBalancersDecoded0
    }
}

public struct DescribeInstancesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancesOutputError>
}

extension DescribeInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInstancesInput(instanceIds: \(Swift.String(describing: instanceIds)), layerId: \(Swift.String(describing: layerId)), stackId: \(Swift.String(describing: stackId)))"}
}

extension DescribeInstancesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceIds = "InstanceIds"
        case layerId = "LayerId"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for strings0 in instanceIds {
                try instanceIdsContainer.encode(strings0)
            }
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeInstancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancesOutputError>
}

public struct DescribeInstancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancesOutputError>
}

public struct DescribeInstancesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstancesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeInstancesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeInstancesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstancesOutputError>
}

public struct DescribeInstancesInput: Swift.Equatable {
    /// An array of instance IDs to be described. If you use this parameter,
    ///         DescribeInstances returns a description of the specified instances. Otherwise,
    ///       it returns a description of every instance.
    public var instanceIds: [Swift.String]?
    /// A layer ID. If you use this parameter, DescribeInstances returns descriptions of
    ///       the instances associated with the specified layer.
    public var layerId: Swift.String?
    /// A stack ID. If you use this parameter, DescribeInstances returns descriptions of
    ///       the instances associated with the specified stack.
    public var stackId: Swift.String?

    public init (
        instanceIds: [Swift.String]? = nil,
        layerId: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.instanceIds = instanceIds
        self.layerId = layerId
        self.stackId = stackId
    }
}

struct DescribeInstancesInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let layerId: Swift.String?
    public let instanceIds: [Swift.String]?
}

extension DescribeInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceIds = "InstanceIds"
        case layerId = "LayerId"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension DescribeInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstancesOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInstancesOutputResponse(instances: \(Swift.String(describing: instances)))"}
}

extension DescribeInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
        } else {
            self.instances = nil
        }
    }
}

/// Contains the response to a DescribeInstances request.
public struct DescribeInstancesOutputResponse: Swift.Equatable {
    /// An array of Instance objects that describe the instances.
    public var instances: [OpsWorksClientTypes.Instance]?

    public init (
        instances: [OpsWorksClientTypes.Instance]? = nil
    )
    {
        self.instances = instances
    }
}

struct DescribeInstancesOutputResponseBody: Swift.Equatable {
    public let instances: [OpsWorksClientTypes.Instance]?
}

extension DescribeInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.Instance?].self, forKey: .instances)
        var instancesDecoded0:[OpsWorksClientTypes.Instance]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [OpsWorksClientTypes.Instance]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
    }
}

public struct DescribeLayersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLayersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLayersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLayersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLayersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLayersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLayersOutputError>
}

extension DescribeLayersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLayersInput(layerIds: \(Swift.String(describing: layerIds)), stackId: \(Swift.String(describing: stackId)))"}
}

extension DescribeLayersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeLayersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLayersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLayersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLayersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLayersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLayersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLayersOutputError>
}

public struct DescribeLayersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLayersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLayersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLayersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLayersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLayersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLayersOutputError>
}

public struct DescribeLayersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLayersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeLayersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLayersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeLayersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLayersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLayersOutputError>
}

public struct DescribeLayersInput: Swift.Equatable {
    /// An array of layer IDs that specify the layers to be described. If you omit this parameter,
    ///         DescribeLayers returns a description of every layer in the specified stack.
    public var layerIds: [Swift.String]?
    /// The stack ID.
    public var stackId: Swift.String?

    public init (
        layerIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.layerIds = layerIds
        self.stackId = stackId
    }
}

struct DescribeLayersInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let layerIds: [Swift.String]?
}

extension DescribeLayersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
    }
}

extension DescribeLayersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLayersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLayersOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLayersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLayersOutputResponse(layers: \(Swift.String(describing: layers)))"}
}

extension DescribeLayersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLayersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.layers = output.layers
        } else {
            self.layers = nil
        }
    }
}

/// Contains the response to a DescribeLayers request.
public struct DescribeLayersOutputResponse: Swift.Equatable {
    /// An array of Layer objects that describe the layers.
    public var layers: [OpsWorksClientTypes.Layer]?

    public init (
        layers: [OpsWorksClientTypes.Layer]? = nil
    )
    {
        self.layers = layers
    }
}

struct DescribeLayersOutputResponseBody: Swift.Equatable {
    public let layers: [OpsWorksClientTypes.Layer]?
}

extension DescribeLayersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layers = "Layers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layersContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[OpsWorksClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [OpsWorksClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
    }
}

public struct DescribeLoadBasedAutoScalingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoadBasedAutoScalingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoadBasedAutoScalingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoadBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoadBasedAutoScalingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoadBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoadBasedAutoScalingOutputError>
}

extension DescribeLoadBasedAutoScalingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLoadBasedAutoScalingInput(layerIds: \(Swift.String(describing: layerIds)))"}
}

extension DescribeLoadBasedAutoScalingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerIds = "LayerIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
    }
}

public struct DescribeLoadBasedAutoScalingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoadBasedAutoScalingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoadBasedAutoScalingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoadBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoadBasedAutoScalingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoadBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoadBasedAutoScalingOutputError>
}

public struct DescribeLoadBasedAutoScalingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoadBasedAutoScalingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoadBasedAutoScalingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoadBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoadBasedAutoScalingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoadBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoadBasedAutoScalingOutputError>
}

public struct DescribeLoadBasedAutoScalingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoadBasedAutoScalingInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeLoadBasedAutoScalingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoadBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeLoadBasedAutoScalingInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoadBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoadBasedAutoScalingOutputError>
}

public struct DescribeLoadBasedAutoScalingInput: Swift.Equatable {
    /// An array of layer IDs.
    /// This member is required.
    public var layerIds: [Swift.String]?

    public init (
        layerIds: [Swift.String]? = nil
    )
    {
        self.layerIds = layerIds
    }
}

struct DescribeLoadBasedAutoScalingInputBody: Swift.Equatable {
    public let layerIds: [Swift.String]?
}

extension DescribeLoadBasedAutoScalingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerIds = "LayerIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
    }
}

extension DescribeLoadBasedAutoScalingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLoadBasedAutoScalingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoadBasedAutoScalingOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoadBasedAutoScalingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLoadBasedAutoScalingOutputResponse(loadBasedAutoScalingConfigurations: \(Swift.String(describing: loadBasedAutoScalingConfigurations)))"}
}

extension DescribeLoadBasedAutoScalingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLoadBasedAutoScalingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loadBasedAutoScalingConfigurations = output.loadBasedAutoScalingConfigurations
        } else {
            self.loadBasedAutoScalingConfigurations = nil
        }
    }
}

/// Contains the response to a DescribeLoadBasedAutoScaling request.
public struct DescribeLoadBasedAutoScalingOutputResponse: Swift.Equatable {
    /// An array of LoadBasedAutoScalingConfiguration objects that describe each layer's
    ///       configuration.
    public var loadBasedAutoScalingConfigurations: [OpsWorksClientTypes.LoadBasedAutoScalingConfiguration]?

    public init (
        loadBasedAutoScalingConfigurations: [OpsWorksClientTypes.LoadBasedAutoScalingConfiguration]? = nil
    )
    {
        self.loadBasedAutoScalingConfigurations = loadBasedAutoScalingConfigurations
    }
}

struct DescribeLoadBasedAutoScalingOutputResponseBody: Swift.Equatable {
    public let loadBasedAutoScalingConfigurations: [OpsWorksClientTypes.LoadBasedAutoScalingConfiguration]?
}

extension DescribeLoadBasedAutoScalingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBasedAutoScalingConfigurations = "LoadBasedAutoScalingConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBasedAutoScalingConfigurationsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.LoadBasedAutoScalingConfiguration?].self, forKey: .loadBasedAutoScalingConfigurations)
        var loadBasedAutoScalingConfigurationsDecoded0:[OpsWorksClientTypes.LoadBasedAutoScalingConfiguration]? = nil
        if let loadBasedAutoScalingConfigurationsContainer = loadBasedAutoScalingConfigurationsContainer {
            loadBasedAutoScalingConfigurationsDecoded0 = [OpsWorksClientTypes.LoadBasedAutoScalingConfiguration]()
            for structure0 in loadBasedAutoScalingConfigurationsContainer {
                if let structure0 = structure0 {
                    loadBasedAutoScalingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        loadBasedAutoScalingConfigurations = loadBasedAutoScalingConfigurationsDecoded0
    }
}

extension DescribeMyUserProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMyUserProfileInput()"}
}

extension DescribeMyUserProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeMyUserProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMyUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMyUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMyUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMyUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMyUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMyUserProfileOutputError>
}

public struct DescribeMyUserProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMyUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMyUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMyUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMyUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMyUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMyUserProfileOutputError>
}

public struct DescribeMyUserProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMyUserProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeMyUserProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMyUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMyUserProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMyUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMyUserProfileOutputError>
}

public struct DescribeMyUserProfileInput: Swift.Equatable {

    public init() {}
}

struct DescribeMyUserProfileInputBody: Swift.Equatable {
}

extension DescribeMyUserProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeMyUserProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMyUserProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMyUserProfileOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMyUserProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMyUserProfileOutputResponse(userProfile: \(Swift.String(describing: userProfile)))"}
}

extension DescribeMyUserProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMyUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userProfile = output.userProfile
        } else {
            self.userProfile = nil
        }
    }
}

/// Contains the response to a DescribeMyUserProfile request.
public struct DescribeMyUserProfileOutputResponse: Swift.Equatable {
    /// A UserProfile object that describes the user's SSH information.
    public var userProfile: OpsWorksClientTypes.SelfUserProfile?

    public init (
        userProfile: OpsWorksClientTypes.SelfUserProfile? = nil
    )
    {
        self.userProfile = userProfile
    }
}

struct DescribeMyUserProfileOutputResponseBody: Swift.Equatable {
    public let userProfile: OpsWorksClientTypes.SelfUserProfile?
}

extension DescribeMyUserProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userProfile = "UserProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userProfileDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.SelfUserProfile.self, forKey: .userProfile)
        userProfile = userProfileDecoded
    }
}

extension DescribeOperatingSystemsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOperatingSystemsInput()"}
}

extension DescribeOperatingSystemsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeOperatingSystemsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOperatingSystemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOperatingSystemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOperatingSystemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOperatingSystemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOperatingSystemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOperatingSystemsOutputError>
}

public struct DescribeOperatingSystemsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOperatingSystemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOperatingSystemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOperatingSystemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOperatingSystemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOperatingSystemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOperatingSystemsOutputError>
}

public struct DescribeOperatingSystemsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOperatingSystemsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeOperatingSystemsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOperatingSystemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeOperatingSystemsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOperatingSystemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOperatingSystemsOutputError>
}

public struct DescribeOperatingSystemsInput: Swift.Equatable {

    public init() {}
}

struct DescribeOperatingSystemsInputBody: Swift.Equatable {
}

extension DescribeOperatingSystemsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeOperatingSystemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOperatingSystemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOperatingSystemsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOperatingSystemsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOperatingSystemsOutputResponse(operatingSystems: \(Swift.String(describing: operatingSystems)))"}
}

extension DescribeOperatingSystemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOperatingSystemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operatingSystems = output.operatingSystems
        } else {
            self.operatingSystems = nil
        }
    }
}

/// The response to a DescribeOperatingSystems request.
public struct DescribeOperatingSystemsOutputResponse: Swift.Equatable {
    /// Contains information in response to a DescribeOperatingSystems request.
    public var operatingSystems: [OpsWorksClientTypes.OperatingSystem]?

    public init (
        operatingSystems: [OpsWorksClientTypes.OperatingSystem]? = nil
    )
    {
        self.operatingSystems = operatingSystems
    }
}

struct DescribeOperatingSystemsOutputResponseBody: Swift.Equatable {
    public let operatingSystems: [OpsWorksClientTypes.OperatingSystem]?
}

extension DescribeOperatingSystemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operatingSystems = "OperatingSystems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.OperatingSystem?].self, forKey: .operatingSystems)
        var operatingSystemsDecoded0:[OpsWorksClientTypes.OperatingSystem]? = nil
        if let operatingSystemsContainer = operatingSystemsContainer {
            operatingSystemsDecoded0 = [OpsWorksClientTypes.OperatingSystem]()
            for structure0 in operatingSystemsContainer {
                if let structure0 = structure0 {
                    operatingSystemsDecoded0?.append(structure0)
                }
            }
        }
        operatingSystems = operatingSystemsDecoded0
    }
}

public struct DescribePermissionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePermissionsOutputError>
}

extension DescribePermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePermissionsInput(iamUserArn: \(Swift.String(describing: iamUserArn)), stackId: \(Swift.String(describing: stackId)))"}
}

extension DescribePermissionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArn = "IamUserArn"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribePermissionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePermissionsOutputError>
}

public struct DescribePermissionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePermissionsOutputError>
}

public struct DescribePermissionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePermissionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribePermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePermissionsOutputError>
}

public struct DescribePermissionsInput: Swift.Equatable {
    /// The user's IAM ARN. This can also be a federated user's ARN. For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers.
    public var iamUserArn: Swift.String?
    /// The stack ID.
    public var stackId: Swift.String?

    public init (
        iamUserArn: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.iamUserArn = iamUserArn
        self.stackId = stackId
    }
}

struct DescribePermissionsInputBody: Swift.Equatable {
    public let iamUserArn: Swift.String?
    public let stackId: Swift.String?
}

extension DescribePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArn = "IamUserArn"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension DescribePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePermissionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePermissionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePermissionsOutputResponse(permissions: \(Swift.String(describing: permissions)))"}
}

extension DescribePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissions = output.permissions
        } else {
            self.permissions = nil
        }
    }
}

/// Contains the response to a DescribePermissions request.
public struct DescribePermissionsOutputResponse: Swift.Equatable {
    /// An array of Permission objects that describe the stack permissions.
    ///
    ///
    ///                If the request object contains only a stack ID, the array contains a
    ///           Permission object with permissions for each of the stack IAM ARNs.
    ///
    ///
    ///                If the request object contains only an IAM ARN, the array contains a
    ///           Permission object with permissions for each of the user's stack IDs.
    ///
    ///
    ///                If the request contains a stack ID and an IAM ARN, the array contains a single
    ///           Permission object with permissions for the specified stack and IAM ARN.
    ///
    ///
    public var permissions: [OpsWorksClientTypes.Permission]?

    public init (
        permissions: [OpsWorksClientTypes.Permission]? = nil
    )
    {
        self.permissions = permissions
    }
}

struct DescribePermissionsOutputResponseBody: Swift.Equatable {
    public let permissions: [OpsWorksClientTypes.Permission]?
}

extension DescribePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissions = "Permissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[OpsWorksClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [OpsWorksClientTypes.Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

public struct DescribeRaidArraysInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRaidArraysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRaidArraysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRaidArraysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRaidArraysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRaidArraysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRaidArraysOutputError>
}

extension DescribeRaidArraysInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRaidArraysInput(instanceId: \(Swift.String(describing: instanceId)), raidArrayIds: \(Swift.String(describing: raidArrayIds)), stackId: \(Swift.String(describing: stackId)))"}
}

extension DescribeRaidArraysInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case raidArrayIds = "RaidArrayIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let raidArrayIds = raidArrayIds {
            var raidArrayIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .raidArrayIds)
            for strings0 in raidArrayIds {
                try raidArrayIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeRaidArraysInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRaidArraysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRaidArraysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRaidArraysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRaidArraysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRaidArraysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRaidArraysOutputError>
}

public struct DescribeRaidArraysInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRaidArraysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRaidArraysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRaidArraysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRaidArraysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRaidArraysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRaidArraysOutputError>
}

public struct DescribeRaidArraysInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRaidArraysInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeRaidArraysInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRaidArraysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRaidArraysInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRaidArraysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRaidArraysOutputError>
}

public struct DescribeRaidArraysInput: Swift.Equatable {
    /// The instance ID. If you use this parameter, DescribeRaidArrays returns
    ///       descriptions of the RAID arrays associated with the specified instance.
    public var instanceId: Swift.String?
    /// An array of RAID array IDs. If you use this parameter, DescribeRaidArrays
    ///       returns descriptions of the specified arrays. Otherwise, it returns a description of every
    ///       array.
    public var raidArrayIds: [Swift.String]?
    /// The stack ID.
    public var stackId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        raidArrayIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.raidArrayIds = raidArrayIds
        self.stackId = stackId
    }
}

struct DescribeRaidArraysInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let stackId: Swift.String?
    public let raidArrayIds: [Swift.String]?
}

extension DescribeRaidArraysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case raidArrayIds = "RaidArrayIds"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let raidArrayIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .raidArrayIds)
        var raidArrayIdsDecoded0:[Swift.String]? = nil
        if let raidArrayIdsContainer = raidArrayIdsContainer {
            raidArrayIdsDecoded0 = [Swift.String]()
            for string0 in raidArrayIdsContainer {
                if let string0 = string0 {
                    raidArrayIdsDecoded0?.append(string0)
                }
            }
        }
        raidArrayIds = raidArrayIdsDecoded0
    }
}

extension DescribeRaidArraysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRaidArraysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRaidArraysOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRaidArraysOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRaidArraysOutputResponse(raidArrays: \(Swift.String(describing: raidArrays)))"}
}

extension DescribeRaidArraysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRaidArraysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.raidArrays = output.raidArrays
        } else {
            self.raidArrays = nil
        }
    }
}

/// Contains the response to a DescribeRaidArrays request.
public struct DescribeRaidArraysOutputResponse: Swift.Equatable {
    /// A RaidArrays object that describes the specified RAID arrays.
    public var raidArrays: [OpsWorksClientTypes.RaidArray]?

    public init (
        raidArrays: [OpsWorksClientTypes.RaidArray]? = nil
    )
    {
        self.raidArrays = raidArrays
    }
}

struct DescribeRaidArraysOutputResponseBody: Swift.Equatable {
    public let raidArrays: [OpsWorksClientTypes.RaidArray]?
}

extension DescribeRaidArraysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case raidArrays = "RaidArrays"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let raidArraysContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.RaidArray?].self, forKey: .raidArrays)
        var raidArraysDecoded0:[OpsWorksClientTypes.RaidArray]? = nil
        if let raidArraysContainer = raidArraysContainer {
            raidArraysDecoded0 = [OpsWorksClientTypes.RaidArray]()
            for structure0 in raidArraysContainer {
                if let structure0 = structure0 {
                    raidArraysDecoded0?.append(structure0)
                }
            }
        }
        raidArrays = raidArraysDecoded0
    }
}

public struct DescribeRdsDbInstancesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRdsDbInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRdsDbInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRdsDbInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRdsDbInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRdsDbInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRdsDbInstancesOutputError>
}

extension DescribeRdsDbInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRdsDbInstancesInput(rdsDbInstanceArns: \(Swift.String(describing: rdsDbInstanceArns)), stackId: \(Swift.String(describing: stackId)))"}
}

extension DescribeRdsDbInstancesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rdsDbInstanceArns = "RdsDbInstanceArns"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rdsDbInstanceArns = rdsDbInstanceArns {
            var rdsDbInstanceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rdsDbInstanceArns)
            for strings0 in rdsDbInstanceArns {
                try rdsDbInstanceArnsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeRdsDbInstancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRdsDbInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRdsDbInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRdsDbInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRdsDbInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRdsDbInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRdsDbInstancesOutputError>
}

public struct DescribeRdsDbInstancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRdsDbInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRdsDbInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRdsDbInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRdsDbInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRdsDbInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRdsDbInstancesOutputError>
}

public struct DescribeRdsDbInstancesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRdsDbInstancesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeRdsDbInstancesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRdsDbInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRdsDbInstancesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRdsDbInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRdsDbInstancesOutputError>
}

public struct DescribeRdsDbInstancesInput: Swift.Equatable {
    /// An array containing the ARNs of the instances to be described.
    public var rdsDbInstanceArns: [Swift.String]?
    /// The ID of the stack with which the instances are registered. The operation returns descriptions of all registered Amazon RDS instances.
    /// This member is required.
    public var stackId: Swift.String?

    public init (
        rdsDbInstanceArns: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.rdsDbInstanceArns = rdsDbInstanceArns
        self.stackId = stackId
    }
}

struct DescribeRdsDbInstancesInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let rdsDbInstanceArns: [Swift.String]?
}

extension DescribeRdsDbInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rdsDbInstanceArns = "RdsDbInstanceArns"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let rdsDbInstanceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rdsDbInstanceArns)
        var rdsDbInstanceArnsDecoded0:[Swift.String]? = nil
        if let rdsDbInstanceArnsContainer = rdsDbInstanceArnsContainer {
            rdsDbInstanceArnsDecoded0 = [Swift.String]()
            for string0 in rdsDbInstanceArnsContainer {
                if let string0 = string0 {
                    rdsDbInstanceArnsDecoded0?.append(string0)
                }
            }
        }
        rdsDbInstanceArns = rdsDbInstanceArnsDecoded0
    }
}

extension DescribeRdsDbInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRdsDbInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRdsDbInstancesOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRdsDbInstancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRdsDbInstancesOutputResponse(rdsDbInstances: \(Swift.String(describing: rdsDbInstances)))"}
}

extension DescribeRdsDbInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRdsDbInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.rdsDbInstances = output.rdsDbInstances
        } else {
            self.rdsDbInstances = nil
        }
    }
}

/// Contains the response to a DescribeRdsDbInstances request.
public struct DescribeRdsDbInstancesOutputResponse: Swift.Equatable {
    /// An a array of RdsDbInstance objects that describe the instances.
    public var rdsDbInstances: [OpsWorksClientTypes.RdsDbInstance]?

    public init (
        rdsDbInstances: [OpsWorksClientTypes.RdsDbInstance]? = nil
    )
    {
        self.rdsDbInstances = rdsDbInstances
    }
}

struct DescribeRdsDbInstancesOutputResponseBody: Swift.Equatable {
    public let rdsDbInstances: [OpsWorksClientTypes.RdsDbInstance]?
}

extension DescribeRdsDbInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rdsDbInstances = "RdsDbInstances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rdsDbInstancesContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.RdsDbInstance?].self, forKey: .rdsDbInstances)
        var rdsDbInstancesDecoded0:[OpsWorksClientTypes.RdsDbInstance]? = nil
        if let rdsDbInstancesContainer = rdsDbInstancesContainer {
            rdsDbInstancesDecoded0 = [OpsWorksClientTypes.RdsDbInstance]()
            for structure0 in rdsDbInstancesContainer {
                if let structure0 = structure0 {
                    rdsDbInstancesDecoded0?.append(structure0)
                }
            }
        }
        rdsDbInstances = rdsDbInstancesDecoded0
    }
}

public struct DescribeServiceErrorsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceErrorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceErrorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceErrorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceErrorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceErrorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceErrorsOutputError>
}

extension DescribeServiceErrorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServiceErrorsInput(instanceId: \(Swift.String(describing: instanceId)), serviceErrorIds: \(Swift.String(describing: serviceErrorIds)), stackId: \(Swift.String(describing: stackId)))"}
}

extension DescribeServiceErrorsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceErrorIds = "ServiceErrorIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceErrorIds = serviceErrorIds {
            var serviceErrorIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceErrorIds)
            for strings0 in serviceErrorIds {
                try serviceErrorIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeServiceErrorsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceErrorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceErrorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceErrorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceErrorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceErrorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceErrorsOutputError>
}

public struct DescribeServiceErrorsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceErrorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceErrorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceErrorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceErrorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceErrorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceErrorsOutputError>
}

public struct DescribeServiceErrorsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceErrorsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeServiceErrorsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceErrorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeServiceErrorsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceErrorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceErrorsOutputError>
}

public struct DescribeServiceErrorsInput: Swift.Equatable {
    /// The instance ID. If you use this parameter, DescribeServiceErrors returns
    ///       descriptions of the errors associated with the specified instance.
    public var instanceId: Swift.String?
    /// An array of service error IDs. If you use this parameter, DescribeServiceErrors
    ///       returns descriptions of the specified errors. Otherwise, it returns a description of every
    ///       error.
    public var serviceErrorIds: [Swift.String]?
    /// The stack ID. If you use this parameter, DescribeServiceErrors returns
    ///       descriptions of the errors associated with the specified stack.
    public var stackId: Swift.String?

    public init (
        instanceId: Swift.String? = nil,
        serviceErrorIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceErrorIds = serviceErrorIds
        self.stackId = stackId
    }
}

struct DescribeServiceErrorsInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let instanceId: Swift.String?
    public let serviceErrorIds: [Swift.String]?
}

extension DescribeServiceErrorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceErrorIds = "ServiceErrorIds"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let serviceErrorIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .serviceErrorIds)
        var serviceErrorIdsDecoded0:[Swift.String]? = nil
        if let serviceErrorIdsContainer = serviceErrorIdsContainer {
            serviceErrorIdsDecoded0 = [Swift.String]()
            for string0 in serviceErrorIdsContainer {
                if let string0 = string0 {
                    serviceErrorIdsDecoded0?.append(string0)
                }
            }
        }
        serviceErrorIds = serviceErrorIdsDecoded0
    }
}

extension DescribeServiceErrorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServiceErrorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServiceErrorsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServiceErrorsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServiceErrorsOutputResponse(serviceErrors: \(Swift.String(describing: serviceErrors)))"}
}

extension DescribeServiceErrorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeServiceErrorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceErrors = output.serviceErrors
        } else {
            self.serviceErrors = nil
        }
    }
}

/// Contains the response to a DescribeServiceErrors request.
public struct DescribeServiceErrorsOutputResponse: Swift.Equatable {
    /// An array of ServiceError objects that describe the specified service errors.
    public var serviceErrors: [OpsWorksClientTypes.ServiceError]?

    public init (
        serviceErrors: [OpsWorksClientTypes.ServiceError]? = nil
    )
    {
        self.serviceErrors = serviceErrors
    }
}

struct DescribeServiceErrorsOutputResponseBody: Swift.Equatable {
    public let serviceErrors: [OpsWorksClientTypes.ServiceError]?
}

extension DescribeServiceErrorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceErrors = "ServiceErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceErrorsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.ServiceError?].self, forKey: .serviceErrors)
        var serviceErrorsDecoded0:[OpsWorksClientTypes.ServiceError]? = nil
        if let serviceErrorsContainer = serviceErrorsContainer {
            serviceErrorsDecoded0 = [OpsWorksClientTypes.ServiceError]()
            for structure0 in serviceErrorsContainer {
                if let structure0 = structure0 {
                    serviceErrorsDecoded0?.append(structure0)
                }
            }
        }
        serviceErrors = serviceErrorsDecoded0
    }
}

public struct DescribeStackProvisioningParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStackProvisioningParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStackProvisioningParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStackProvisioningParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStackProvisioningParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStackProvisioningParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStackProvisioningParametersOutputError>
}

extension DescribeStackProvisioningParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStackProvisioningParametersInput(stackId: \(Swift.String(describing: stackId)))"}
}

extension DescribeStackProvisioningParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeStackProvisioningParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStackProvisioningParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStackProvisioningParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStackProvisioningParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStackProvisioningParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStackProvisioningParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStackProvisioningParametersOutputError>
}

public struct DescribeStackProvisioningParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStackProvisioningParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStackProvisioningParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStackProvisioningParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStackProvisioningParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStackProvisioningParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStackProvisioningParametersOutputError>
}

public struct DescribeStackProvisioningParametersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStackProvisioningParametersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeStackProvisioningParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStackProvisioningParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeStackProvisioningParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStackProvisioningParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStackProvisioningParametersOutputError>
}

public struct DescribeStackProvisioningParametersInput: Swift.Equatable {
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init (
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct DescribeStackProvisioningParametersInputBody: Swift.Equatable {
    public let stackId: Swift.String?
}

extension DescribeStackProvisioningParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension DescribeStackProvisioningParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStackProvisioningParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStackProvisioningParametersOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStackProvisioningParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStackProvisioningParametersOutputResponse(agentInstallerUrl: \(Swift.String(describing: agentInstallerUrl)), parameters: \(Swift.String(describing: parameters)))"}
}

extension DescribeStackProvisioningParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStackProvisioningParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agentInstallerUrl = output.agentInstallerUrl
            self.parameters = output.parameters
        } else {
            self.agentInstallerUrl = nil
            self.parameters = nil
        }
    }
}

/// Contains the response to a DescribeStackProvisioningParameters request.
public struct DescribeStackProvisioningParametersOutputResponse: Swift.Equatable {
    /// The AWS OpsWorks Stacks agent installer's URL.
    public var agentInstallerUrl: Swift.String?
    /// An embedded object that contains the provisioning parameters.
    public var parameters: [Swift.String:Swift.String]?

    public init (
        agentInstallerUrl: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil
    )
    {
        self.agentInstallerUrl = agentInstallerUrl
        self.parameters = parameters
    }
}

struct DescribeStackProvisioningParametersOutputResponseBody: Swift.Equatable {
    public let agentInstallerUrl: Swift.String?
    public let parameters: [Swift.String:Swift.String]?
}

extension DescribeStackProvisioningParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentInstallerUrl = "AgentInstallerUrl"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentInstallerUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentInstallerUrl)
        agentInstallerUrl = agentInstallerUrlDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in parametersContainer {
                if let string0 = string0 {
                    parametersDecoded0?[key0] = string0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

public struct DescribeStackSummaryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStackSummaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStackSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStackSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStackSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStackSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStackSummaryOutputError>
}

extension DescribeStackSummaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStackSummaryInput(stackId: \(Swift.String(describing: stackId)))"}
}

extension DescribeStackSummaryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeStackSummaryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStackSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStackSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStackSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStackSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStackSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStackSummaryOutputError>
}

public struct DescribeStackSummaryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStackSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStackSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStackSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStackSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStackSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStackSummaryOutputError>
}

public struct DescribeStackSummaryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStackSummaryInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeStackSummaryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStackSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeStackSummaryInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStackSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStackSummaryOutputError>
}

public struct DescribeStackSummaryInput: Swift.Equatable {
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init (
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct DescribeStackSummaryInputBody: Swift.Equatable {
    public let stackId: Swift.String?
}

extension DescribeStackSummaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension DescribeStackSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStackSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStackSummaryOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStackSummaryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStackSummaryOutputResponse(stackSummary: \(Swift.String(describing: stackSummary)))"}
}

extension DescribeStackSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStackSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stackSummary = output.stackSummary
        } else {
            self.stackSummary = nil
        }
    }
}

/// Contains the response to a DescribeStackSummary request.
public struct DescribeStackSummaryOutputResponse: Swift.Equatable {
    /// A StackSummary object that contains the results.
    public var stackSummary: OpsWorksClientTypes.StackSummary?

    public init (
        stackSummary: OpsWorksClientTypes.StackSummary? = nil
    )
    {
        self.stackSummary = stackSummary
    }
}

struct DescribeStackSummaryOutputResponseBody: Swift.Equatable {
    public let stackSummary: OpsWorksClientTypes.StackSummary?
}

extension DescribeStackSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackSummary = "StackSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSummaryDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.StackSummary.self, forKey: .stackSummary)
        stackSummary = stackSummaryDecoded
    }
}

public struct DescribeStacksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStacksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStacksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStacksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStacksOutputError>
}

extension DescribeStacksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStacksInput(stackIds: \(Swift.String(describing: stackIds)))"}
}

extension DescribeStacksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackIds = "StackIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackIds = stackIds {
            var stackIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackIds)
            for strings0 in stackIds {
                try stackIdsContainer.encode(strings0)
            }
        }
    }
}

public struct DescribeStacksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStacksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStacksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStacksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStacksOutputError>
}

public struct DescribeStacksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStacksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStacksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStacksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStacksOutputError>
}

public struct DescribeStacksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStacksInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeStacksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeStacksInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStacksOutputError>
}

public struct DescribeStacksInput: Swift.Equatable {
    /// An array of stack IDs that specify the stacks to be described. If you omit this parameter,
    ///         DescribeStacks returns a description of every stack.
    public var stackIds: [Swift.String]?

    public init (
        stackIds: [Swift.String]? = nil
    )
    {
        self.stackIds = stackIds
    }
}

struct DescribeStacksInputBody: Swift.Equatable {
    public let stackIds: [Swift.String]?
}

extension DescribeStacksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackIds = "StackIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackIds)
        var stackIdsDecoded0:[Swift.String]? = nil
        if let stackIdsContainer = stackIdsContainer {
            stackIdsDecoded0 = [Swift.String]()
            for string0 in stackIdsContainer {
                if let string0 = string0 {
                    stackIdsDecoded0?.append(string0)
                }
            }
        }
        stackIds = stackIdsDecoded0
    }
}

extension DescribeStacksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStacksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStacksOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStacksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStacksOutputResponse(stacks: \(Swift.String(describing: stacks)))"}
}

extension DescribeStacksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStacksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stacks = output.stacks
        } else {
            self.stacks = nil
        }
    }
}

/// Contains the response to a DescribeStacks request.
public struct DescribeStacksOutputResponse: Swift.Equatable {
    /// An array of Stack objects that describe the stacks.
    public var stacks: [OpsWorksClientTypes.Stack]?

    public init (
        stacks: [OpsWorksClientTypes.Stack]? = nil
    )
    {
        self.stacks = stacks
    }
}

struct DescribeStacksOutputResponseBody: Swift.Equatable {
    public let stacks: [OpsWorksClientTypes.Stack]?
}

extension DescribeStacksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stacks = "Stacks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stacksContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.Stack?].self, forKey: .stacks)
        var stacksDecoded0:[OpsWorksClientTypes.Stack]? = nil
        if let stacksContainer = stacksContainer {
            stacksDecoded0 = [OpsWorksClientTypes.Stack]()
            for structure0 in stacksContainer {
                if let structure0 = structure0 {
                    stacksDecoded0?.append(structure0)
                }
            }
        }
        stacks = stacksDecoded0
    }
}

public struct DescribeTimeBasedAutoScalingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTimeBasedAutoScalingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTimeBasedAutoScalingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTimeBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTimeBasedAutoScalingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTimeBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTimeBasedAutoScalingOutputError>
}

extension DescribeTimeBasedAutoScalingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTimeBasedAutoScalingInput(instanceIds: \(Swift.String(describing: instanceIds)))"}
}

extension DescribeTimeBasedAutoScalingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceIds = "InstanceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for strings0 in instanceIds {
                try instanceIdsContainer.encode(strings0)
            }
        }
    }
}

public struct DescribeTimeBasedAutoScalingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTimeBasedAutoScalingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTimeBasedAutoScalingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTimeBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTimeBasedAutoScalingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTimeBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTimeBasedAutoScalingOutputError>
}

public struct DescribeTimeBasedAutoScalingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTimeBasedAutoScalingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTimeBasedAutoScalingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTimeBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTimeBasedAutoScalingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTimeBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTimeBasedAutoScalingOutputError>
}

public struct DescribeTimeBasedAutoScalingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTimeBasedAutoScalingInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeTimeBasedAutoScalingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTimeBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTimeBasedAutoScalingInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTimeBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTimeBasedAutoScalingOutputError>
}

public struct DescribeTimeBasedAutoScalingInput: Swift.Equatable {
    /// An array of instance IDs.
    /// This member is required.
    public var instanceIds: [Swift.String]?

    public init (
        instanceIds: [Swift.String]? = nil
    )
    {
        self.instanceIds = instanceIds
    }
}

struct DescribeTimeBasedAutoScalingInputBody: Swift.Equatable {
    public let instanceIds: [Swift.String]?
}

extension DescribeTimeBasedAutoScalingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceIds = "InstanceIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension DescribeTimeBasedAutoScalingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTimeBasedAutoScalingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTimeBasedAutoScalingOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTimeBasedAutoScalingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTimeBasedAutoScalingOutputResponse(timeBasedAutoScalingConfigurations: \(Swift.String(describing: timeBasedAutoScalingConfigurations)))"}
}

extension DescribeTimeBasedAutoScalingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTimeBasedAutoScalingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.timeBasedAutoScalingConfigurations = output.timeBasedAutoScalingConfigurations
        } else {
            self.timeBasedAutoScalingConfigurations = nil
        }
    }
}

/// Contains the response to a DescribeTimeBasedAutoScaling request.
public struct DescribeTimeBasedAutoScalingOutputResponse: Swift.Equatable {
    /// An array of TimeBasedAutoScalingConfiguration objects that describe the
    ///       configuration for the specified instances.
    public var timeBasedAutoScalingConfigurations: [OpsWorksClientTypes.TimeBasedAutoScalingConfiguration]?

    public init (
        timeBasedAutoScalingConfigurations: [OpsWorksClientTypes.TimeBasedAutoScalingConfiguration]? = nil
    )
    {
        self.timeBasedAutoScalingConfigurations = timeBasedAutoScalingConfigurations
    }
}

struct DescribeTimeBasedAutoScalingOutputResponseBody: Swift.Equatable {
    public let timeBasedAutoScalingConfigurations: [OpsWorksClientTypes.TimeBasedAutoScalingConfiguration]?
}

extension DescribeTimeBasedAutoScalingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeBasedAutoScalingConfigurations = "TimeBasedAutoScalingConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeBasedAutoScalingConfigurationsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.TimeBasedAutoScalingConfiguration?].self, forKey: .timeBasedAutoScalingConfigurations)
        var timeBasedAutoScalingConfigurationsDecoded0:[OpsWorksClientTypes.TimeBasedAutoScalingConfiguration]? = nil
        if let timeBasedAutoScalingConfigurationsContainer = timeBasedAutoScalingConfigurationsContainer {
            timeBasedAutoScalingConfigurationsDecoded0 = [OpsWorksClientTypes.TimeBasedAutoScalingConfiguration]()
            for structure0 in timeBasedAutoScalingConfigurationsContainer {
                if let structure0 = structure0 {
                    timeBasedAutoScalingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        timeBasedAutoScalingConfigurations = timeBasedAutoScalingConfigurationsDecoded0
    }
}

public struct DescribeUserProfilesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserProfilesOutputError>
}

extension DescribeUserProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserProfilesInput(iamUserArns: \(Swift.String(describing: iamUserArns)))"}
}

extension DescribeUserProfilesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArns = "IamUserArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamUserArns = iamUserArns {
            var iamUserArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iamUserArns)
            for strings0 in iamUserArns {
                try iamUserArnsContainer.encode(strings0)
            }
        }
    }
}

public struct DescribeUserProfilesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserProfilesOutputError>
}

public struct DescribeUserProfilesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserProfilesOutputError>
}

public struct DescribeUserProfilesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserProfilesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeUserProfilesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeUserProfilesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserProfilesOutputError>
}

public struct DescribeUserProfilesInput: Swift.Equatable {
    /// An array of IAM or federated user ARNs that identify the users to be described.
    public var iamUserArns: [Swift.String]?

    public init (
        iamUserArns: [Swift.String]? = nil
    )
    {
        self.iamUserArns = iamUserArns
    }
}

struct DescribeUserProfilesInputBody: Swift.Equatable {
    public let iamUserArns: [Swift.String]?
}

extension DescribeUserProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArns = "IamUserArns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .iamUserArns)
        var iamUserArnsDecoded0:[Swift.String]? = nil
        if let iamUserArnsContainer = iamUserArnsContainer {
            iamUserArnsDecoded0 = [Swift.String]()
            for string0 in iamUserArnsContainer {
                if let string0 = string0 {
                    iamUserArnsDecoded0?.append(string0)
                }
            }
        }
        iamUserArns = iamUserArnsDecoded0
    }
}

extension DescribeUserProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserProfilesOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserProfilesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserProfilesOutputResponse(userProfiles: \(Swift.String(describing: userProfiles)))"}
}

extension DescribeUserProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUserProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userProfiles = output.userProfiles
        } else {
            self.userProfiles = nil
        }
    }
}

/// Contains the response to a DescribeUserProfiles request.
public struct DescribeUserProfilesOutputResponse: Swift.Equatable {
    /// A Users object that describes the specified users.
    public var userProfiles: [OpsWorksClientTypes.UserProfile]?

    public init (
        userProfiles: [OpsWorksClientTypes.UserProfile]? = nil
    )
    {
        self.userProfiles = userProfiles
    }
}

struct DescribeUserProfilesOutputResponseBody: Swift.Equatable {
    public let userProfiles: [OpsWorksClientTypes.UserProfile]?
}

extension DescribeUserProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userProfiles = "UserProfiles"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userProfilesContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.UserProfile?].self, forKey: .userProfiles)
        var userProfilesDecoded0:[OpsWorksClientTypes.UserProfile]? = nil
        if let userProfilesContainer = userProfilesContainer {
            userProfilesDecoded0 = [OpsWorksClientTypes.UserProfile]()
            for structure0 in userProfilesContainer {
                if let structure0 = structure0 {
                    userProfilesDecoded0?.append(structure0)
                }
            }
        }
        userProfiles = userProfilesDecoded0
    }
}

public struct DescribeVolumesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVolumesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeVolumesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeVolumesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVolumesOutputError>
}

extension DescribeVolumesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeVolumesInput(instanceId: \(Swift.String(describing: instanceId)), raidArrayId: \(Swift.String(describing: raidArrayId)), stackId: \(Swift.String(describing: stackId)), volumeIds: \(Swift.String(describing: volumeIds)))"}
}

extension DescribeVolumesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case raidArrayId = "RaidArrayId"
        case stackId = "StackId"
        case volumeIds = "VolumeIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let raidArrayId = raidArrayId {
            try encodeContainer.encode(raidArrayId, forKey: .raidArrayId)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let volumeIds = volumeIds {
            var volumeIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeIds)
            for strings0 in volumeIds {
                try volumeIdsContainer.encode(strings0)
            }
        }
    }
}

public struct DescribeVolumesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVolumesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeVolumesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeVolumesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVolumesOutputError>
}

public struct DescribeVolumesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVolumesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeVolumesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeVolumesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVolumesOutputError>
}

public struct DescribeVolumesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVolumesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeVolumesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeVolumesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVolumesOutputError>
}

public struct DescribeVolumesInput: Swift.Equatable {
    /// The instance ID. If you use this parameter, DescribeVolumes returns descriptions
    ///       of the volumes associated with the specified instance.
    public var instanceId: Swift.String?
    /// The RAID array ID. If you use this parameter, DescribeVolumes returns
    ///       descriptions of the volumes associated with the specified RAID array.
    public var raidArrayId: Swift.String?
    /// A stack ID. The action describes the stack's registered Amazon EBS volumes.
    public var stackId: Swift.String?
    /// Am array of volume IDs. If you use this parameter, DescribeVolumes returns
    ///       descriptions of the specified volumes. Otherwise, it returns a description of every
    ///       volume.
    public var volumeIds: [Swift.String]?

    public init (
        instanceId: Swift.String? = nil,
        raidArrayId: Swift.String? = nil,
        stackId: Swift.String? = nil,
        volumeIds: [Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.raidArrayId = raidArrayId
        self.stackId = stackId
        self.volumeIds = volumeIds
    }
}

struct DescribeVolumesInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let stackId: Swift.String?
    public let raidArrayId: Swift.String?
    public let volumeIds: [Swift.String]?
}

extension DescribeVolumesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case raidArrayId = "RaidArrayId"
        case stackId = "StackId"
        case volumeIds = "VolumeIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let raidArrayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .raidArrayId)
        raidArrayId = raidArrayIdDecoded
        let volumeIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .volumeIds)
        var volumeIdsDecoded0:[Swift.String]? = nil
        if let volumeIdsContainer = volumeIdsContainer {
            volumeIdsDecoded0 = [Swift.String]()
            for string0 in volumeIdsContainer {
                if let string0 = string0 {
                    volumeIdsDecoded0?.append(string0)
                }
            }
        }
        volumeIds = volumeIdsDecoded0
    }
}

extension DescribeVolumesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVolumesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVolumesOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVolumesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeVolumesOutputResponse(volumes: \(Swift.String(describing: volumes)))"}
}

extension DescribeVolumesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeVolumesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.volumes = output.volumes
        } else {
            self.volumes = nil
        }
    }
}

/// Contains the response to a DescribeVolumes request.
public struct DescribeVolumesOutputResponse: Swift.Equatable {
    /// An array of volume IDs.
    public var volumes: [OpsWorksClientTypes.Volume]?

    public init (
        volumes: [OpsWorksClientTypes.Volume]? = nil
    )
    {
        self.volumes = volumes
    }
}

struct DescribeVolumesOutputResponseBody: Swift.Equatable {
    public let volumes: [OpsWorksClientTypes.Volume]?
}

extension DescribeVolumesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumes = "Volumes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumesContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.Volume?].self, forKey: .volumes)
        var volumesDecoded0:[OpsWorksClientTypes.Volume]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [OpsWorksClientTypes.Volume]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
    }
}

public struct DetachElasticLoadBalancerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachElasticLoadBalancerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachElasticLoadBalancerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachElasticLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachElasticLoadBalancerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachElasticLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachElasticLoadBalancerOutputError>
}

extension DetachElasticLoadBalancerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetachElasticLoadBalancerInput(elasticLoadBalancerName: \(Swift.String(describing: elasticLoadBalancerName)), layerId: \(Swift.String(describing: layerId)))"}
}

extension DetachElasticLoadBalancerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticLoadBalancerName = "ElasticLoadBalancerName"
        case layerId = "LayerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticLoadBalancerName = elasticLoadBalancerName {
            try encodeContainer.encode(elasticLoadBalancerName, forKey: .elasticLoadBalancerName)
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
    }
}

public struct DetachElasticLoadBalancerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachElasticLoadBalancerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachElasticLoadBalancerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachElasticLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachElasticLoadBalancerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachElasticLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachElasticLoadBalancerOutputError>
}

public struct DetachElasticLoadBalancerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachElasticLoadBalancerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DetachElasticLoadBalancerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachElasticLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DetachElasticLoadBalancerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DetachElasticLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachElasticLoadBalancerOutputError>
}

public struct DetachElasticLoadBalancerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DetachElasticLoadBalancerInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DetachElasticLoadBalancerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DetachElasticLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DetachElasticLoadBalancerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DetachElasticLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DetachElasticLoadBalancerOutputError>
}

public struct DetachElasticLoadBalancerInput: Swift.Equatable {
    /// The Elastic Load Balancing instance's name.
    /// This member is required.
    public var elasticLoadBalancerName: Swift.String?
    /// The ID of the layer that the Elastic Load Balancing instance is attached to.
    /// This member is required.
    public var layerId: Swift.String?

    public init (
        elasticLoadBalancerName: Swift.String? = nil,
        layerId: Swift.String? = nil
    )
    {
        self.elasticLoadBalancerName = elasticLoadBalancerName
        self.layerId = layerId
    }
}

struct DetachElasticLoadBalancerInputBody: Swift.Equatable {
    public let elasticLoadBalancerName: Swift.String?
    public let layerId: Swift.String?
}

extension DetachElasticLoadBalancerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticLoadBalancerName = "ElasticLoadBalancerName"
        case layerId = "LayerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticLoadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticLoadBalancerName)
        elasticLoadBalancerName = elasticLoadBalancerNameDecoded
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
    }
}

extension DetachElasticLoadBalancerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachElasticLoadBalancerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachElasticLoadBalancerOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachElasticLoadBalancerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetachElasticLoadBalancerOutputResponse()"}
}

extension DetachElasticLoadBalancerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DetachElasticLoadBalancerOutputResponse: Swift.Equatable {

    public init() {}
}

struct DetachElasticLoadBalancerOutputResponseBody: Swift.Equatable {
}

extension DetachElasticLoadBalancerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DisassociateElasticIpInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateElasticIpInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateElasticIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateElasticIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateElasticIpOutputError>
}

extension DisassociateElasticIpInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateElasticIpInput(elasticIp: \(Swift.String(describing: elasticIp)))"}
}

extension DisassociateElasticIpInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
    }
}

public struct DisassociateElasticIpInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateElasticIpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateElasticIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateElasticIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateElasticIpOutputError>
}

public struct DisassociateElasticIpInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateElasticIpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateElasticIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateElasticIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateElasticIpOutputError>
}

public struct DisassociateElasticIpInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateElasticIpInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateElasticIpInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateElasticIpInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateElasticIpOutputError>
}

public struct DisassociateElasticIpInput: Swift.Equatable {
    /// The Elastic IP address.
    /// This member is required.
    public var elasticIp: Swift.String?

    public init (
        elasticIp: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
    }
}

struct DisassociateElasticIpInputBody: Swift.Equatable {
    public let elasticIp: Swift.String?
}

extension DisassociateElasticIpInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
    }
}

extension DisassociateElasticIpOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateElasticIpOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateElasticIpOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateElasticIpOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateElasticIpOutputResponse()"}
}

extension DisassociateElasticIpOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateElasticIpOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateElasticIpOutputResponseBody: Swift.Equatable {
}

extension DisassociateElasticIpOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension OpsWorksClientTypes.EbsBlockDevice: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteOnTermination = "DeleteOnTermination"
        case iops = "Iops"
        case snapshotId = "SnapshotId"
        case volumeSize = "VolumeSize"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteOnTermination = deleteOnTermination {
            try encodeContainer.encode(deleteOnTermination, forKey: .deleteOnTermination)
        }
        if let iops = iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let volumeSize = volumeSize {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType.rawValue, forKey: .volumeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.VolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let deleteOnTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteOnTermination)
        deleteOnTermination = deleteOnTerminationDecoded
    }
}

extension OpsWorksClientTypes.EbsBlockDevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EbsBlockDevice(deleteOnTermination: \(Swift.String(describing: deleteOnTermination)), iops: \(Swift.String(describing: iops)), snapshotId: \(Swift.String(describing: snapshotId)), volumeSize: \(Swift.String(describing: volumeSize)), volumeType: \(Swift.String(describing: volumeType)))"}
}

extension OpsWorksClientTypes {
    /// Describes an Amazon EBS volume. This data type maps directly to the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EbsBlockDevice.html">EbsBlockDevice
    ///       data type.
    public struct EbsBlockDevice: Swift.Equatable {
        /// Whether the volume is deleted on instance termination.
        public var deleteOnTermination: Swift.Bool?
        /// The number of I/O operations per second (IOPS) that the volume supports. For more
        ///       information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EbsBlockDevice.html">EbsBlockDevice.
        public var iops: Swift.Int?
        /// The snapshot ID.
        public var snapshotId: Swift.String?
        /// The volume size, in GiB. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EbsBlockDevice.html">EbsBlockDevice.
        public var volumeSize: Swift.Int?
        /// The volume type. gp2 for General Purpose (SSD) volumes, io1 for
        ///           Provisioned IOPS (SSD) volumes, st1 for Throughput Optimized hard disk drives (HDD), sc1 for Cold HDD,and standard for Magnetic volumes.
        ///          If you specify the io1 volume type, you must also specify a value for the Iops attribute.
        ///           The maximum ratio of provisioned IOPS to requested volume size (in GiB) is 50:1. AWS uses the default volume size (in GiB)
        ///           specified in the AMI attributes to set IOPS to 50 x (volume size).
        public var volumeType: OpsWorksClientTypes.VolumeType?

        public init (
            deleteOnTermination: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            snapshotId: Swift.String? = nil,
            volumeSize: Swift.Int? = nil,
            volumeType: OpsWorksClientTypes.VolumeType? = nil
        )
        {
            self.deleteOnTermination = deleteOnTermination
            self.iops = iops
            self.snapshotId = snapshotId
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }
    }

}

extension OpsWorksClientTypes.EcsCluster: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArn = "EcsClusterArn"
        case ecsClusterName = "EcsClusterName"
        case registeredAt = "RegisteredAt"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecsClusterArn = ecsClusterArn {
            try encodeContainer.encode(ecsClusterArn, forKey: .ecsClusterArn)
        }
        if let ecsClusterName = ecsClusterName {
            try encodeContainer.encode(ecsClusterName, forKey: .ecsClusterName)
        }
        if let registeredAt = registeredAt {
            try encodeContainer.encode(registeredAt, forKey: .registeredAt)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecsClusterArn)
        ecsClusterArn = ecsClusterArnDecoded
        let ecsClusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecsClusterName)
        ecsClusterName = ecsClusterNameDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let registeredAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredAt)
        registeredAt = registeredAtDecoded
    }
}

extension OpsWorksClientTypes.EcsCluster: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EcsCluster(ecsClusterArn: \(Swift.String(describing: ecsClusterArn)), ecsClusterName: \(Swift.String(describing: ecsClusterName)), registeredAt: \(Swift.String(describing: registeredAt)), stackId: \(Swift.String(describing: stackId)))"}
}

extension OpsWorksClientTypes {
    /// Describes a registered Amazon ECS cluster.
    public struct EcsCluster: Swift.Equatable {
        /// The cluster's ARN.
        public var ecsClusterArn: Swift.String?
        /// The cluster name.
        public var ecsClusterName: Swift.String?
        /// The time and date that the cluster was registered with the stack.
        public var registeredAt: Swift.String?
        /// The stack ID.
        public var stackId: Swift.String?

        public init (
            ecsClusterArn: Swift.String? = nil,
            ecsClusterName: Swift.String? = nil,
            registeredAt: Swift.String? = nil,
            stackId: Swift.String? = nil
        )
        {
            self.ecsClusterArn = ecsClusterArn
            self.ecsClusterName = ecsClusterName
            self.registeredAt = registeredAt
            self.stackId = stackId
        }
    }

}

extension OpsWorksClientTypes.ElasticIp: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case instanceId = "InstanceId"
        case ip = "Ip"
        case name = "Name"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let ip = ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ip)
        ip = ipDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension OpsWorksClientTypes.ElasticIp: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ElasticIp(domain: \(Swift.String(describing: domain)), instanceId: \(Swift.String(describing: instanceId)), ip: \(Swift.String(describing: ip)), name: \(Swift.String(describing: name)), region: \(Swift.String(describing: region)))"}
}

extension OpsWorksClientTypes {
    /// Describes an Elastic IP address.
    public struct ElasticIp: Swift.Equatable {
        /// The domain.
        public var domain: Swift.String?
        /// The ID of the instance that the address is attached to.
        public var instanceId: Swift.String?
        /// The IP address.
        public var ip: Swift.String?
        /// The name.
        public var name: Swift.String?
        /// The AWS region. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints.
        public var region: Swift.String?

        public init (
            domain: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            ip: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.domain = domain
            self.instanceId = instanceId
            self.ip = ip
            self.name = name
            self.region = region
        }
    }

}

extension OpsWorksClientTypes.ElasticLoadBalancer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case dnsName = "DnsName"
        case ec2InstanceIds = "Ec2InstanceIds"
        case elasticLoadBalancerName = "ElasticLoadBalancerName"
        case layerId = "LayerId"
        case region = "Region"
        case stackId = "StackId"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for strings0 in availabilityZones {
                try availabilityZonesContainer.encode(strings0)
            }
        }
        if let dnsName = dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let ec2InstanceIds = ec2InstanceIds {
            var ec2InstanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceIds)
            for strings0 in ec2InstanceIds {
                try ec2InstanceIdsContainer.encode(strings0)
            }
        }
        if let elasticLoadBalancerName = elasticLoadBalancerName {
            try encodeContainer.encode(elasticLoadBalancerName, forKey: .elasticLoadBalancerName)
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for strings0 in subnetIds {
                try subnetIdsContainer.encode(strings0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticLoadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticLoadBalancerName)
        elasticLoadBalancerName = elasticLoadBalancerNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let dnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let ec2InstanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2InstanceIds)
        var ec2InstanceIdsDecoded0:[Swift.String]? = nil
        if let ec2InstanceIdsContainer = ec2InstanceIdsContainer {
            ec2InstanceIdsDecoded0 = [Swift.String]()
            for string0 in ec2InstanceIdsContainer {
                if let string0 = string0 {
                    ec2InstanceIdsDecoded0?.append(string0)
                }
            }
        }
        ec2InstanceIds = ec2InstanceIdsDecoded0
    }
}

extension OpsWorksClientTypes.ElasticLoadBalancer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ElasticLoadBalancer(availabilityZones: \(Swift.String(describing: availabilityZones)), dnsName: \(Swift.String(describing: dnsName)), ec2InstanceIds: \(Swift.String(describing: ec2InstanceIds)), elasticLoadBalancerName: \(Swift.String(describing: elasticLoadBalancerName)), layerId: \(Swift.String(describing: layerId)), region: \(Swift.String(describing: region)), stackId: \(Swift.String(describing: stackId)), subnetIds: \(Swift.String(describing: subnetIds)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension OpsWorksClientTypes {
    /// Describes an Elastic Load Balancing instance.
    public struct ElasticLoadBalancer: Swift.Equatable {
        /// A list of Availability Zones.
        public var availabilityZones: [Swift.String]?
        /// The instance's public DNS name.
        public var dnsName: Swift.String?
        /// A list of the EC2 instances that the Elastic Load Balancing instance is managing traffic for.
        public var ec2InstanceIds: [Swift.String]?
        /// The Elastic Load Balancing instance's name.
        public var elasticLoadBalancerName: Swift.String?
        /// The ID of the layer that the instance is attached to.
        public var layerId: Swift.String?
        /// The instance's AWS region.
        public var region: Swift.String?
        /// The ID of the stack that the instance is associated with.
        public var stackId: Swift.String?
        /// A list of subnet IDs, if the stack is running in a VPC.
        public var subnetIds: [Swift.String]?
        /// The VPC ID.
        public var vpcId: Swift.String?

        public init (
            availabilityZones: [Swift.String]? = nil,
            dnsName: Swift.String? = nil,
            ec2InstanceIds: [Swift.String]? = nil,
            elasticLoadBalancerName: Swift.String? = nil,
            layerId: Swift.String? = nil,
            region: Swift.String? = nil,
            stackId: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.dnsName = dnsName
            self.ec2InstanceIds = ec2InstanceIds
            self.elasticLoadBalancerName = elasticLoadBalancerName
            self.layerId = layerId
            self.region = region
            self.stackId = stackId
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension OpsWorksClientTypes.EnvironmentVariable: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case secure = "Secure"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let secure = secure {
            try encodeContainer.encode(secure, forKey: .secure)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let secureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .secure)
        secure = secureDecoded
    }
}

extension OpsWorksClientTypes.EnvironmentVariable: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentVariable(key: \(Swift.String(describing: key)), secure: \(Swift.String(describing: secure)), value: \(Swift.String(describing: value)))"}
}

extension OpsWorksClientTypes {
    /// Represents an app's environment variable.
    public struct EnvironmentVariable: Swift.Equatable {
        /// (Required) The environment variable's name, which can consist of up to 64 characters and must be specified. The name can contain upper- and lowercase letters, numbers, and underscores (_), but it must start with a letter or underscore.
        /// This member is required.
        public var key: Swift.String?
        /// (Optional) Whether the variable's value will be returned by the DescribeApps action.
        ///       To conceal an environment variable's value, set Secure to true.
        ///         DescribeApps then returns *****FILTERED***** instead of the actual
        ///       value. The default value for Secure is false.
        public var secure: Swift.Bool?
        /// (Optional) The environment variable's value, which can be left empty. If you specify a value, it can contain up to 256 characters, which must all be printable.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            secure: Swift.Bool? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.secure = secure
            self.value = value
        }
    }

}

public struct GetHostnameSuggestionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetHostnameSuggestionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetHostnameSuggestionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetHostnameSuggestionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetHostnameSuggestionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetHostnameSuggestionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetHostnameSuggestionOutputError>
}

extension GetHostnameSuggestionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetHostnameSuggestionInput(layerId: \(Swift.String(describing: layerId)))"}
}

extension GetHostnameSuggestionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerId = "LayerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
    }
}

public struct GetHostnameSuggestionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetHostnameSuggestionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetHostnameSuggestionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetHostnameSuggestionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetHostnameSuggestionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetHostnameSuggestionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetHostnameSuggestionOutputError>
}

public struct GetHostnameSuggestionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetHostnameSuggestionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetHostnameSuggestionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetHostnameSuggestionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetHostnameSuggestionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetHostnameSuggestionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetHostnameSuggestionOutputError>
}

public struct GetHostnameSuggestionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetHostnameSuggestionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetHostnameSuggestionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetHostnameSuggestionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetHostnameSuggestionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetHostnameSuggestionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetHostnameSuggestionOutputError>
}

public struct GetHostnameSuggestionInput: Swift.Equatable {
    /// The layer ID.
    /// This member is required.
    public var layerId: Swift.String?

    public init (
        layerId: Swift.String? = nil
    )
    {
        self.layerId = layerId
    }
}

struct GetHostnameSuggestionInputBody: Swift.Equatable {
    public let layerId: Swift.String?
}

extension GetHostnameSuggestionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerId = "LayerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
    }
}

extension GetHostnameSuggestionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetHostnameSuggestionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetHostnameSuggestionOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetHostnameSuggestionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetHostnameSuggestionOutputResponse(hostname: \(Swift.String(describing: hostname)), layerId: \(Swift.String(describing: layerId)))"}
}

extension GetHostnameSuggestionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetHostnameSuggestionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hostname = output.hostname
            self.layerId = output.layerId
        } else {
            self.hostname = nil
            self.layerId = nil
        }
    }
}

/// Contains the response to a GetHostnameSuggestion request.
public struct GetHostnameSuggestionOutputResponse: Swift.Equatable {
    /// The generated host name.
    public var hostname: Swift.String?
    /// The layer ID.
    public var layerId: Swift.String?

    public init (
        hostname: Swift.String? = nil,
        layerId: Swift.String? = nil
    )
    {
        self.hostname = hostname
        self.layerId = layerId
    }
}

struct GetHostnameSuggestionOutputResponseBody: Swift.Equatable {
    public let layerId: Swift.String?
    public let hostname: Swift.String?
}

extension GetHostnameSuggestionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname = "Hostname"
        case layerId = "LayerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
    }
}

public struct GrantAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GrantAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GrantAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GrantAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GrantAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GrantAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GrantAccessOutputError>
}

extension GrantAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GrantAccessInput(instanceId: \(Swift.String(describing: instanceId)), validForInMinutes: \(Swift.String(describing: validForInMinutes)))"}
}

extension GrantAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case validForInMinutes = "ValidForInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let validForInMinutes = validForInMinutes {
            try encodeContainer.encode(validForInMinutes, forKey: .validForInMinutes)
        }
    }
}

public struct GrantAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GrantAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GrantAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GrantAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GrantAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GrantAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GrantAccessOutputError>
}

public struct GrantAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GrantAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GrantAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GrantAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GrantAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GrantAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GrantAccessOutputError>
}

public struct GrantAccessInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GrantAccessInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GrantAccessInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GrantAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GrantAccessInput
    public typealias MOutput = ClientRuntime.OperationOutput<GrantAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GrantAccessOutputError>
}

public struct GrantAccessInput: Swift.Equatable {
    /// The instance's AWS OpsWorks Stacks ID.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The length of time (in minutes) that the grant is valid. When the grant expires at the end of this period, the user will no longer be able to use the credentials to log in. If the user is logged in at the time, he or she automatically will be logged out.
    public var validForInMinutes: Swift.Int?

    public init (
        instanceId: Swift.String? = nil,
        validForInMinutes: Swift.Int? = nil
    )
    {
        self.instanceId = instanceId
        self.validForInMinutes = validForInMinutes
    }
}

struct GrantAccessInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let validForInMinutes: Swift.Int?
}

extension GrantAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case validForInMinutes = "ValidForInMinutes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let validForInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validForInMinutes)
        validForInMinutes = validForInMinutesDecoded
    }
}

extension GrantAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GrantAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GrantAccessOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GrantAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GrantAccessOutputResponse(temporaryCredential: \(Swift.String(describing: temporaryCredential)))"}
}

extension GrantAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GrantAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.temporaryCredential = output.temporaryCredential
        } else {
            self.temporaryCredential = nil
        }
    }
}

/// Contains the response to a GrantAccess request.
public struct GrantAccessOutputResponse: Swift.Equatable {
    /// A TemporaryCredential object that contains the data needed to log in to the
    ///       instance by RDP clients, such as the Microsoft Remote Desktop Connection.
    public var temporaryCredential: OpsWorksClientTypes.TemporaryCredential?

    public init (
        temporaryCredential: OpsWorksClientTypes.TemporaryCredential? = nil
    )
    {
        self.temporaryCredential = temporaryCredential
    }
}

struct GrantAccessOutputResponseBody: Swift.Equatable {
    public let temporaryCredential: OpsWorksClientTypes.TemporaryCredential?
}

extension GrantAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case temporaryCredential = "TemporaryCredential"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let temporaryCredentialDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.TemporaryCredential.self, forKey: .temporaryCredential)
        temporaryCredential = temporaryCredentialDecoded
    }
}

extension OpsWorksClientTypes.Instance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case amiId = "AmiId"
        case architecture = "Architecture"
        case arn = "Arn"
        case autoScalingType = "AutoScalingType"
        case availabilityZone = "AvailabilityZone"
        case blockDeviceMappings = "BlockDeviceMappings"
        case createdAt = "CreatedAt"
        case ebsOptimized = "EbsOptimized"
        case ec2InstanceId = "Ec2InstanceId"
        case ecsClusterArn = "EcsClusterArn"
        case ecsContainerInstanceArn = "EcsContainerInstanceArn"
        case elasticIp = "ElasticIp"
        case hostname = "Hostname"
        case infrastructureClass = "InfrastructureClass"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case instanceId = "InstanceId"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceType = "InstanceType"
        case lastServiceErrorId = "LastServiceErrorId"
        case layerIds = "LayerIds"
        case os = "Os"
        case platform = "Platform"
        case privateDns = "PrivateDns"
        case privateIp = "PrivateIp"
        case publicDns = "PublicDns"
        case publicIp = "PublicIp"
        case registeredBy = "RegisteredBy"
        case reportedAgentVersion = "ReportedAgentVersion"
        case reportedOs = "ReportedOs"
        case rootDeviceType = "RootDeviceType"
        case rootDeviceVolumeId = "RootDeviceVolumeId"
        case securityGroupIds = "SecurityGroupIds"
        case sshHostDsaKeyFingerprint = "SshHostDsaKeyFingerprint"
        case sshHostRsaKeyFingerprint = "SshHostRsaKeyFingerprint"
        case sshKeyName = "SshKeyName"
        case stackId = "StackId"
        case status = "Status"
        case subnetId = "SubnetId"
        case tenancy = "Tenancy"
        case virtualizationType = "VirtualizationType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let amiId = amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let architecture = architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let autoScalingType = autoScalingType {
            try encodeContainer.encode(autoScalingType.rawValue, forKey: .autoScalingType)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for blockdevicemappings0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(blockdevicemappings0)
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let ebsOptimized = ebsOptimized {
            try encodeContainer.encode(ebsOptimized, forKey: .ebsOptimized)
        }
        if let ec2InstanceId = ec2InstanceId {
            try encodeContainer.encode(ec2InstanceId, forKey: .ec2InstanceId)
        }
        if let ecsClusterArn = ecsClusterArn {
            try encodeContainer.encode(ecsClusterArn, forKey: .ecsClusterArn)
        }
        if let ecsContainerInstanceArn = ecsContainerInstanceArn {
            try encodeContainer.encode(ecsContainerInstanceArn, forKey: .ecsContainerInstanceArn)
        }
        if let elasticIp = elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let infrastructureClass = infrastructureClass {
            try encodeContainer.encode(infrastructureClass, forKey: .infrastructureClass)
        }
        if let installUpdatesOnBoot = installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceProfileArn = instanceProfileArn {
            try encodeContainer.encode(instanceProfileArn, forKey: .instanceProfileArn)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let lastServiceErrorId = lastServiceErrorId {
            try encodeContainer.encode(lastServiceErrorId, forKey: .lastServiceErrorId)
        }
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
        if let os = os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let privateDns = privateDns {
            try encodeContainer.encode(privateDns, forKey: .privateDns)
        }
        if let privateIp = privateIp {
            try encodeContainer.encode(privateIp, forKey: .privateIp)
        }
        if let publicDns = publicDns {
            try encodeContainer.encode(publicDns, forKey: .publicDns)
        }
        if let publicIp = publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let registeredBy = registeredBy {
            try encodeContainer.encode(registeredBy, forKey: .registeredBy)
        }
        if let reportedAgentVersion = reportedAgentVersion {
            try encodeContainer.encode(reportedAgentVersion, forKey: .reportedAgentVersion)
        }
        if let reportedOs = reportedOs {
            try encodeContainer.encode(reportedOs, forKey: .reportedOs)
        }
        if let rootDeviceType = rootDeviceType {
            try encodeContainer.encode(rootDeviceType.rawValue, forKey: .rootDeviceType)
        }
        if let rootDeviceVolumeId = rootDeviceVolumeId {
            try encodeContainer.encode(rootDeviceVolumeId, forKey: .rootDeviceVolumeId)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for strings0 in securityGroupIds {
                try securityGroupIdsContainer.encode(strings0)
            }
        }
        if let sshHostDsaKeyFingerprint = sshHostDsaKeyFingerprint {
            try encodeContainer.encode(sshHostDsaKeyFingerprint, forKey: .sshHostDsaKeyFingerprint)
        }
        if let sshHostRsaKeyFingerprint = sshHostRsaKeyFingerprint {
            try encodeContainer.encode(sshHostRsaKeyFingerprint, forKey: .sshHostRsaKeyFingerprint)
        }
        if let sshKeyName = sshKeyName {
            try encodeContainer.encode(sshKeyName, forKey: .sshKeyName)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tenancy = tenancy {
            try encodeContainer.encode(tenancy, forKey: .tenancy)
        }
        if let virtualizationType = virtualizationType {
            try encodeContainer.encode(virtualizationType.rawValue, forKey: .virtualizationType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let autoScalingTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AutoScalingType.self, forKey: .autoScalingType)
        autoScalingType = autoScalingTypeDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.BlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[OpsWorksClientTypes.BlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [OpsWorksClientTypes.BlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let ec2InstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceId)
        ec2InstanceId = ec2InstanceIdDecoded
        let ecsClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecsClusterArn)
        ecsClusterArn = ecsClusterArnDecoded
        let ecsContainerInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecsContainerInstanceArn)
        ecsContainerInstanceArn = ecsContainerInstanceArnDecoded
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let infrastructureClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureClass)
        infrastructureClass = infrastructureClassDecoded
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileArn)
        instanceProfileArn = instanceProfileArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let lastServiceErrorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastServiceErrorId)
        lastServiceErrorId = lastServiceErrorIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
        let osDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .os)
        os = osDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let privateDnsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDns)
        privateDns = privateDnsDecoded
        let privateIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIp)
        privateIp = privateIpDecoded
        let publicDnsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicDns)
        publicDns = publicDnsDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
        let registeredByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredBy)
        registeredBy = registeredByDecoded
        let reportedAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportedAgentVersion)
        reportedAgentVersion = reportedAgentVersionDecoded
        let reportedOsDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.ReportedOs.self, forKey: .reportedOs)
        reportedOs = reportedOsDecoded
        let rootDeviceTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.RootDeviceType.self, forKey: .rootDeviceType)
        rootDeviceType = rootDeviceTypeDecoded
        let rootDeviceVolumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootDeviceVolumeId)
        rootDeviceVolumeId = rootDeviceVolumeIdDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let sshHostDsaKeyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshHostDsaKeyFingerprint)
        sshHostDsaKeyFingerprint = sshHostDsaKeyFingerprintDecoded
        let sshHostRsaKeyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshHostRsaKeyFingerprint)
        sshHostRsaKeyFingerprint = sshHostRsaKeyFingerprintDecoded
        let sshKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshKeyName)
        sshKeyName = sshKeyNameDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let virtualizationTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.VirtualizationType.self, forKey: .virtualizationType)
        virtualizationType = virtualizationTypeDecoded
    }
}

extension OpsWorksClientTypes.Instance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Instance(agentVersion: \(Swift.String(describing: agentVersion)), amiId: \(Swift.String(describing: amiId)), architecture: \(Swift.String(describing: architecture)), arn: \(Swift.String(describing: arn)), autoScalingType: \(Swift.String(describing: autoScalingType)), availabilityZone: \(Swift.String(describing: availabilityZone)), blockDeviceMappings: \(Swift.String(describing: blockDeviceMappings)), createdAt: \(Swift.String(describing: createdAt)), ebsOptimized: \(Swift.String(describing: ebsOptimized)), ec2InstanceId: \(Swift.String(describing: ec2InstanceId)), ecsClusterArn: \(Swift.String(describing: ecsClusterArn)), ecsContainerInstanceArn: \(Swift.String(describing: ecsContainerInstanceArn)), elasticIp: \(Swift.String(describing: elasticIp)), hostname: \(Swift.String(describing: hostname)), infrastructureClass: \(Swift.String(describing: infrastructureClass)), installUpdatesOnBoot: \(Swift.String(describing: installUpdatesOnBoot)), instanceId: \(Swift.String(describing: instanceId)), instanceProfileArn: \(Swift.String(describing: instanceProfileArn)), instanceType: \(Swift.String(describing: instanceType)), lastServiceErrorId: \(Swift.String(describing: lastServiceErrorId)), layerIds: \(Swift.String(describing: layerIds)), os: \(Swift.String(describing: os)), platform: \(Swift.String(describing: platform)), privateDns: \(Swift.String(describing: privateDns)), privateIp: \(Swift.String(describing: privateIp)), publicDns: \(Swift.String(describing: publicDns)), publicIp: \(Swift.String(describing: publicIp)), registeredBy: \(Swift.String(describing: registeredBy)), reportedAgentVersion: \(Swift.String(describing: reportedAgentVersion)), reportedOs: \(Swift.String(describing: reportedOs)), rootDeviceType: \(Swift.String(describing: rootDeviceType)), rootDeviceVolumeId: \(Swift.String(describing: rootDeviceVolumeId)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), sshHostDsaKeyFingerprint: \(Swift.String(describing: sshHostDsaKeyFingerprint)), sshHostRsaKeyFingerprint: \(Swift.String(describing: sshHostRsaKeyFingerprint)), sshKeyName: \(Swift.String(describing: sshKeyName)), stackId: \(Swift.String(describing: stackId)), status: \(Swift.String(describing: status)), subnetId: \(Swift.String(describing: subnetId)), tenancy: \(Swift.String(describing: tenancy)), virtualizationType: \(Swift.String(describing: virtualizationType)))"}
}

extension OpsWorksClientTypes {
    /// Describes an instance.
    public struct Instance: Swift.Equatable {
        /// The agent version. This parameter is set to INHERIT if
        ///       the instance inherits the default stack setting or to a
        ///       a version number for a fixed agent version.
        public var agentVersion: Swift.String?
        /// A custom AMI ID to be used to create the instance. For more
        ///       information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html">Instances
        ///
        public var amiId: Swift.String?
        /// The instance architecture: "i386" or "x86_64".
        public var architecture: OpsWorksClientTypes.Architecture?
        /// The instance's Amazon Resource Number (ARN).
        public var arn: Swift.String?
        /// For load-based or time-based instances, the type.
        public var autoScalingType: OpsWorksClientTypes.AutoScalingType?
        /// The instance Availability Zone. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints.
        public var availabilityZone: Swift.String?
        /// An array of BlockDeviceMapping objects that specify the instance's block device
        ///       mappings.
        public var blockDeviceMappings: [OpsWorksClientTypes.BlockDeviceMapping]?
        /// The time that the instance was created.
        public var createdAt: Swift.String?
        /// Whether this is an Amazon EBS-optimized instance.
        public var ebsOptimized: Swift.Bool?
        /// The ID of the associated Amazon EC2 instance.
        public var ec2InstanceId: Swift.String?
        /// For container instances, the Amazon ECS cluster's ARN.
        public var ecsClusterArn: Swift.String?
        /// For container instances, the instance's ARN.
        public var ecsContainerInstanceArn: Swift.String?
        /// The instance <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html">Elastic IP address .
        public var elasticIp: Swift.String?
        /// The instance host name.
        public var hostname: Swift.String?
        /// For registered instances, the infrastructure class: ec2 or
        ///         on-premises.
        public var infrastructureClass: Swift.String?
        /// Whether to install operating system and package updates when the instance boots. The default
        ///       value is true. If this value is set to false, you must then update
        ///       your instances manually by using CreateDeployment to run the
        ///         update_dependencies stack command or
        ///       by manually running yum (Amazon
        ///       Linux) or apt-get (Ubuntu) on the instances.
        ///
        ///             We strongly recommend using the default value of true, to ensure that your
        ///         instances have the latest security updates.
        ///
        public var installUpdatesOnBoot: Swift.Bool?
        /// The instance ID.
        public var instanceId: Swift.String?
        /// The ARN of the instance's IAM profile. For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
        ///       Identifiers.
        public var instanceProfileArn: Swift.String?
        /// The instance type, such as t2.micro.
        public var instanceType: Swift.String?
        /// The ID of the last service error. For more information, call
        ///       DescribeServiceErrors.
        public var lastServiceErrorId: Swift.String?
        /// An array containing the instance layer IDs.
        public var layerIds: [Swift.String]?
        /// The instance's operating system.
        public var os: Swift.String?
        /// The instance's platform.
        public var platform: Swift.String?
        /// The instance's private DNS name.
        public var privateDns: Swift.String?
        /// The instance's private IP address.
        public var privateIp: Swift.String?
        /// The instance public DNS name.
        public var publicDns: Swift.String?
        /// The instance public IP address.
        public var publicIp: Swift.String?
        /// For registered instances, who performed the registration.
        public var registeredBy: Swift.String?
        /// The instance's reported AWS OpsWorks Stacks agent version.
        public var reportedAgentVersion: Swift.String?
        /// For registered instances, the reported operating system.
        public var reportedOs: OpsWorksClientTypes.ReportedOs?
        /// The instance's root device type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device">Storage for the Root Device.
        public var rootDeviceType: OpsWorksClientTypes.RootDeviceType?
        /// The root device volume ID.
        public var rootDeviceVolumeId: Swift.String?
        /// An array containing the instance security group IDs.
        public var securityGroupIds: [Swift.String]?
        /// The SSH key's Deep Security Agent (DSA) fingerprint.
        public var sshHostDsaKeyFingerprint: Swift.String?
        /// The SSH key's RSA fingerprint.
        public var sshHostRsaKeyFingerprint: Swift.String?
        /// The instance's Amazon EC2 key-pair name.
        public var sshKeyName: Swift.String?
        /// The stack ID.
        public var stackId: Swift.String?
        /// The instance status:
        ///
        ///
        ///
        ///                   booting
        ///
        ///
        ///
        ///
        ///                   connection_lost
        ///
        ///
        ///
        ///
        ///                   online
        ///
        ///
        ///
        ///
        ///                   pending
        ///
        ///
        ///
        ///
        ///                   rebooting
        ///
        ///
        ///
        ///
        ///                   requested
        ///
        ///
        ///
        ///
        ///                   running_setup
        ///
        ///
        ///
        ///
        ///                   setup_failed
        ///
        ///
        ///
        ///
        ///                   shutting_down
        ///
        ///
        ///
        ///
        ///                   start_failed
        ///
        ///
        ///
        ///
        ///                   stop_failed
        ///
        ///
        ///
        ///
        ///                   stopped
        ///
        ///
        ///
        ///
        ///                   stopping
        ///
        ///
        ///
        ///
        ///                   terminated
        ///
        ///
        ///
        ///
        ///                   terminating
        ///
        ///
        ///
        public var status: Swift.String?
        /// The instance's subnet ID; applicable only if the stack is running in a VPC.
        public var subnetId: Swift.String?
        /// The instance's tenancy option, such as dedicated or host.
        public var tenancy: Swift.String?
        /// The instance's virtualization type: paravirtual or hvm.
        public var virtualizationType: OpsWorksClientTypes.VirtualizationType?

        public init (
            agentVersion: Swift.String? = nil,
            amiId: Swift.String? = nil,
            architecture: OpsWorksClientTypes.Architecture? = nil,
            arn: Swift.String? = nil,
            autoScalingType: OpsWorksClientTypes.AutoScalingType? = nil,
            availabilityZone: Swift.String? = nil,
            blockDeviceMappings: [OpsWorksClientTypes.BlockDeviceMapping]? = nil,
            createdAt: Swift.String? = nil,
            ebsOptimized: Swift.Bool? = nil,
            ec2InstanceId: Swift.String? = nil,
            ecsClusterArn: Swift.String? = nil,
            ecsContainerInstanceArn: Swift.String? = nil,
            elasticIp: Swift.String? = nil,
            hostname: Swift.String? = nil,
            infrastructureClass: Swift.String? = nil,
            installUpdatesOnBoot: Swift.Bool? = nil,
            instanceId: Swift.String? = nil,
            instanceProfileArn: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            lastServiceErrorId: Swift.String? = nil,
            layerIds: [Swift.String]? = nil,
            os: Swift.String? = nil,
            platform: Swift.String? = nil,
            privateDns: Swift.String? = nil,
            privateIp: Swift.String? = nil,
            publicDns: Swift.String? = nil,
            publicIp: Swift.String? = nil,
            registeredBy: Swift.String? = nil,
            reportedAgentVersion: Swift.String? = nil,
            reportedOs: OpsWorksClientTypes.ReportedOs? = nil,
            rootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
            rootDeviceVolumeId: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            sshHostDsaKeyFingerprint: Swift.String? = nil,
            sshHostRsaKeyFingerprint: Swift.String? = nil,
            sshKeyName: Swift.String? = nil,
            stackId: Swift.String? = nil,
            status: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            tenancy: Swift.String? = nil,
            virtualizationType: OpsWorksClientTypes.VirtualizationType? = nil
        )
        {
            self.agentVersion = agentVersion
            self.amiId = amiId
            self.architecture = architecture
            self.arn = arn
            self.autoScalingType = autoScalingType
            self.availabilityZone = availabilityZone
            self.blockDeviceMappings = blockDeviceMappings
            self.createdAt = createdAt
            self.ebsOptimized = ebsOptimized
            self.ec2InstanceId = ec2InstanceId
            self.ecsClusterArn = ecsClusterArn
            self.ecsContainerInstanceArn = ecsContainerInstanceArn
            self.elasticIp = elasticIp
            self.hostname = hostname
            self.infrastructureClass = infrastructureClass
            self.installUpdatesOnBoot = installUpdatesOnBoot
            self.instanceId = instanceId
            self.instanceProfileArn = instanceProfileArn
            self.instanceType = instanceType
            self.lastServiceErrorId = lastServiceErrorId
            self.layerIds = layerIds
            self.os = os
            self.platform = platform
            self.privateDns = privateDns
            self.privateIp = privateIp
            self.publicDns = publicDns
            self.publicIp = publicIp
            self.registeredBy = registeredBy
            self.reportedAgentVersion = reportedAgentVersion
            self.reportedOs = reportedOs
            self.rootDeviceType = rootDeviceType
            self.rootDeviceVolumeId = rootDeviceVolumeId
            self.securityGroupIds = securityGroupIds
            self.sshHostDsaKeyFingerprint = sshHostDsaKeyFingerprint
            self.sshHostRsaKeyFingerprint = sshHostRsaKeyFingerprint
            self.sshKeyName = sshKeyName
            self.stackId = stackId
            self.status = status
            self.subnetId = subnetId
            self.tenancy = tenancy
            self.virtualizationType = virtualizationType
        }
    }

}

extension OpsWorksClientTypes.InstanceIdentity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document = "Document"
        case signature = "Signature"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let signature = signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signature)
        signature = signatureDecoded
    }
}

extension OpsWorksClientTypes.InstanceIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceIdentity(document: \(Swift.String(describing: document)), signature: \(Swift.String(describing: signature)))"}
}

extension OpsWorksClientTypes {
    /// Contains a description of an Amazon EC2 instance from the Amazon EC2 metadata service. For more
    ///       information, see <a href="https://docs.aws.amazon.com/sdkfornet/latest/apidocs/Index.html">Instance Metadata and User Data.
    public struct InstanceIdentity: Swift.Equatable {
        /// A JSON document that contains the metadata.
        public var document: Swift.String?
        /// A signature that can be used to verify the document's accuracy and authenticity.
        public var signature: Swift.String?

        public init (
            document: Swift.String? = nil,
            signature: Swift.String? = nil
        )
        {
            self.document = document
            self.signature = signature
        }
    }

}

extension OpsWorksClientTypes.InstancesCount: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assigning = "Assigning"
        case booting = "Booting"
        case connectionLost = "ConnectionLost"
        case deregistering = "Deregistering"
        case online = "Online"
        case pending = "Pending"
        case rebooting = "Rebooting"
        case registered = "Registered"
        case registering = "Registering"
        case requested = "Requested"
        case runningSetup = "RunningSetup"
        case setupFailed = "SetupFailed"
        case shuttingDown = "ShuttingDown"
        case startFailed = "StartFailed"
        case stopFailed = "StopFailed"
        case stopped = "Stopped"
        case stopping = "Stopping"
        case terminated = "Terminated"
        case terminating = "Terminating"
        case unassigning = "Unassigning"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assigning = assigning {
            try encodeContainer.encode(assigning, forKey: .assigning)
        }
        if let booting = booting {
            try encodeContainer.encode(booting, forKey: .booting)
        }
        if let connectionLost = connectionLost {
            try encodeContainer.encode(connectionLost, forKey: .connectionLost)
        }
        if let deregistering = deregistering {
            try encodeContainer.encode(deregistering, forKey: .deregistering)
        }
        if let online = online {
            try encodeContainer.encode(online, forKey: .online)
        }
        if let pending = pending {
            try encodeContainer.encode(pending, forKey: .pending)
        }
        if let rebooting = rebooting {
            try encodeContainer.encode(rebooting, forKey: .rebooting)
        }
        if let registered = registered {
            try encodeContainer.encode(registered, forKey: .registered)
        }
        if let registering = registering {
            try encodeContainer.encode(registering, forKey: .registering)
        }
        if let requested = requested {
            try encodeContainer.encode(requested, forKey: .requested)
        }
        if let runningSetup = runningSetup {
            try encodeContainer.encode(runningSetup, forKey: .runningSetup)
        }
        if let setupFailed = setupFailed {
            try encodeContainer.encode(setupFailed, forKey: .setupFailed)
        }
        if let shuttingDown = shuttingDown {
            try encodeContainer.encode(shuttingDown, forKey: .shuttingDown)
        }
        if let startFailed = startFailed {
            try encodeContainer.encode(startFailed, forKey: .startFailed)
        }
        if let stopFailed = stopFailed {
            try encodeContainer.encode(stopFailed, forKey: .stopFailed)
        }
        if let stopped = stopped {
            try encodeContainer.encode(stopped, forKey: .stopped)
        }
        if let stopping = stopping {
            try encodeContainer.encode(stopping, forKey: .stopping)
        }
        if let terminated = terminated {
            try encodeContainer.encode(terminated, forKey: .terminated)
        }
        if let terminating = terminating {
            try encodeContainer.encode(terminating, forKey: .terminating)
        }
        if let unassigning = unassigning {
            try encodeContainer.encode(unassigning, forKey: .unassigning)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assigningDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assigning)
        assigning = assigningDecoded
        let bootingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .booting)
        booting = bootingDecoded
        let connectionLostDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionLost)
        connectionLost = connectionLostDecoded
        let deregisteringDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deregistering)
        deregistering = deregisteringDecoded
        let onlineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .online)
        online = onlineDecoded
        let pendingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pending)
        pending = pendingDecoded
        let rebootingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rebooting)
        rebooting = rebootingDecoded
        let registeredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .registered)
        registered = registeredDecoded
        let registeringDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .registering)
        registering = registeringDecoded
        let requestedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requested)
        requested = requestedDecoded
        let runningSetupDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .runningSetup)
        runningSetup = runningSetupDecoded
        let setupFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .setupFailed)
        setupFailed = setupFailedDecoded
        let shuttingDownDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shuttingDown)
        shuttingDown = shuttingDownDecoded
        let startFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startFailed)
        startFailed = startFailedDecoded
        let stopFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stopFailed)
        stopFailed = stopFailedDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stopped)
        stopped = stoppedDecoded
        let stoppingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stopping)
        stopping = stoppingDecoded
        let terminatedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .terminated)
        terminated = terminatedDecoded
        let terminatingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .terminating)
        terminating = terminatingDecoded
        let unassigningDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unassigning)
        unassigning = unassigningDecoded
    }
}

extension OpsWorksClientTypes.InstancesCount: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstancesCount(assigning: \(Swift.String(describing: assigning)), booting: \(Swift.String(describing: booting)), connectionLost: \(Swift.String(describing: connectionLost)), deregistering: \(Swift.String(describing: deregistering)), online: \(Swift.String(describing: online)), pending: \(Swift.String(describing: pending)), rebooting: \(Swift.String(describing: rebooting)), registered: \(Swift.String(describing: registered)), registering: \(Swift.String(describing: registering)), requested: \(Swift.String(describing: requested)), runningSetup: \(Swift.String(describing: runningSetup)), setupFailed: \(Swift.String(describing: setupFailed)), shuttingDown: \(Swift.String(describing: shuttingDown)), startFailed: \(Swift.String(describing: startFailed)), stopFailed: \(Swift.String(describing: stopFailed)), stopped: \(Swift.String(describing: stopped)), stopping: \(Swift.String(describing: stopping)), terminated: \(Swift.String(describing: terminated)), terminating: \(Swift.String(describing: terminating)), unassigning: \(Swift.String(describing: unassigning)))"}
}

extension OpsWorksClientTypes {
    /// Describes how many instances a stack has for each status.
    public struct InstancesCount: Swift.Equatable {
        /// The number of instances in the Assigning state.
        public var assigning: Swift.Int?
        /// The number of instances with booting status.
        public var booting: Swift.Int?
        /// The number of instances with connection_lost status.
        public var connectionLost: Swift.Int?
        /// The number of instances in the Deregistering state.
        public var deregistering: Swift.Int?
        /// The number of instances with online status.
        public var online: Swift.Int?
        /// The number of instances with pending status.
        public var pending: Swift.Int?
        /// The number of instances with rebooting status.
        public var rebooting: Swift.Int?
        /// The number of instances in the Registered state.
        public var registered: Swift.Int?
        /// The number of instances in the Registering state.
        public var registering: Swift.Int?
        /// The number of instances with requested status.
        public var requested: Swift.Int?
        /// The number of instances with running_setup status.
        public var runningSetup: Swift.Int?
        /// The number of instances with setup_failed status.
        public var setupFailed: Swift.Int?
        /// The number of instances with shutting_down status.
        public var shuttingDown: Swift.Int?
        /// The number of instances with start_failed status.
        public var startFailed: Swift.Int?
        /// The number of instances with stop_failed status.
        public var stopFailed: Swift.Int?
        /// The number of instances with stopped status.
        public var stopped: Swift.Int?
        /// The number of instances with stopping status.
        public var stopping: Swift.Int?
        /// The number of instances with terminated status.
        public var terminated: Swift.Int?
        /// The number of instances with terminating status.
        public var terminating: Swift.Int?
        /// The number of instances in the Unassigning state.
        public var unassigning: Swift.Int?

        public init (
            assigning: Swift.Int? = nil,
            booting: Swift.Int? = nil,
            connectionLost: Swift.Int? = nil,
            deregistering: Swift.Int? = nil,
            online: Swift.Int? = nil,
            pending: Swift.Int? = nil,
            rebooting: Swift.Int? = nil,
            registered: Swift.Int? = nil,
            registering: Swift.Int? = nil,
            requested: Swift.Int? = nil,
            runningSetup: Swift.Int? = nil,
            setupFailed: Swift.Int? = nil,
            shuttingDown: Swift.Int? = nil,
            startFailed: Swift.Int? = nil,
            stopFailed: Swift.Int? = nil,
            stopped: Swift.Int? = nil,
            stopping: Swift.Int? = nil,
            terminated: Swift.Int? = nil,
            terminating: Swift.Int? = nil,
            unassigning: Swift.Int? = nil
        )
        {
            self.assigning = assigning
            self.booting = booting
            self.connectionLost = connectionLost
            self.deregistering = deregistering
            self.online = online
            self.pending = pending
            self.rebooting = rebooting
            self.registered = registered
            self.registering = registering
            self.requested = requested
            self.runningSetup = runningSetup
            self.setupFailed = setupFailed
            self.shuttingDown = shuttingDown
            self.startFailed = startFailed
            self.stopFailed = stopFailed
            self.stopped = stopped
            self.stopping = stopping
            self.terminated = terminated
            self.terminating = terminating
            self.unassigning = unassigning
        }
    }

}

extension OpsWorksClientTypes.Layer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case attributes = "Attributes"
        case autoAssignElasticIps = "AutoAssignElasticIps"
        case autoAssignPublicIps = "AutoAssignPublicIps"
        case cloudWatchLogsConfiguration = "CloudWatchLogsConfiguration"
        case createdAt = "CreatedAt"
        case customInstanceProfileArn = "CustomInstanceProfileArn"
        case customJson = "CustomJson"
        case customRecipes = "CustomRecipes"
        case customSecurityGroupIds = "CustomSecurityGroupIds"
        case defaultRecipes = "DefaultRecipes"
        case defaultSecurityGroupNames = "DefaultSecurityGroupNames"
        case enableAutoHealing = "EnableAutoHealing"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case layerId = "LayerId"
        case lifecycleEventConfiguration = "LifecycleEventConfiguration"
        case name = "Name"
        case packages = "Packages"
        case shortname = "Shortname"
        case stackId = "StackId"
        case type = "Type"
        case useEbsOptimizedInstances = "UseEbsOptimizedInstances"
        case volumeConfigurations = "VolumeConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, layerattributes0) in attributes {
                try attributesContainer.encode(layerattributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let autoAssignElasticIps = autoAssignElasticIps {
            try encodeContainer.encode(autoAssignElasticIps, forKey: .autoAssignElasticIps)
        }
        if let autoAssignPublicIps = autoAssignPublicIps {
            try encodeContainer.encode(autoAssignPublicIps, forKey: .autoAssignPublicIps)
        }
        if let cloudWatchLogsConfiguration = cloudWatchLogsConfiguration {
            try encodeContainer.encode(cloudWatchLogsConfiguration, forKey: .cloudWatchLogsConfiguration)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let customInstanceProfileArn = customInstanceProfileArn {
            try encodeContainer.encode(customInstanceProfileArn, forKey: .customInstanceProfileArn)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let customRecipes = customRecipes {
            try encodeContainer.encode(customRecipes, forKey: .customRecipes)
        }
        if let customSecurityGroupIds = customSecurityGroupIds {
            var customSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customSecurityGroupIds)
            for strings0 in customSecurityGroupIds {
                try customSecurityGroupIdsContainer.encode(strings0)
            }
        }
        if let defaultRecipes = defaultRecipes {
            try encodeContainer.encode(defaultRecipes, forKey: .defaultRecipes)
        }
        if let defaultSecurityGroupNames = defaultSecurityGroupNames {
            var defaultSecurityGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultSecurityGroupNames)
            for strings0 in defaultSecurityGroupNames {
                try defaultSecurityGroupNamesContainer.encode(strings0)
            }
        }
        if let enableAutoHealing = enableAutoHealing {
            try encodeContainer.encode(enableAutoHealing, forKey: .enableAutoHealing)
        }
        if let installUpdatesOnBoot = installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let lifecycleEventConfiguration = lifecycleEventConfiguration {
            try encodeContainer.encode(lifecycleEventConfiguration, forKey: .lifecycleEventConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packages = packages {
            var packagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .packages)
            for strings0 in packages {
                try packagesContainer.encode(strings0)
            }
        }
        if let shortname = shortname {
            try encodeContainer.encode(shortname, forKey: .shortname)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let useEbsOptimizedInstances = useEbsOptimizedInstances {
            try encodeContainer.encode(useEbsOptimizedInstances, forKey: .useEbsOptimizedInstances)
        }
        if let volumeConfigurations = volumeConfigurations {
            var volumeConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeConfigurations)
            for volumeconfigurations0 in volumeConfigurations {
                try volumeConfigurationsContainer.encode(volumeconfigurations0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.LayerType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let shortnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortname)
        shortname = shortnameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let cloudWatchLogsConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.CloudWatchLogsConfiguration.self, forKey: .cloudWatchLogsConfiguration)
        cloudWatchLogsConfiguration = cloudWatchLogsConfigurationDecoded
        let customInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customInstanceProfileArn)
        customInstanceProfileArn = customInstanceProfileArnDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let customSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .customSecurityGroupIds)
        var customSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let customSecurityGroupIdsContainer = customSecurityGroupIdsContainer {
            customSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in customSecurityGroupIdsContainer {
                if let string0 = string0 {
                    customSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        customSecurityGroupIds = customSecurityGroupIdsDecoded0
        let defaultSecurityGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .defaultSecurityGroupNames)
        var defaultSecurityGroupNamesDecoded0:[Swift.String]? = nil
        if let defaultSecurityGroupNamesContainer = defaultSecurityGroupNamesContainer {
            defaultSecurityGroupNamesDecoded0 = [Swift.String]()
            for string0 in defaultSecurityGroupNamesContainer {
                if let string0 = string0 {
                    defaultSecurityGroupNamesDecoded0?.append(string0)
                }
            }
        }
        defaultSecurityGroupNames = defaultSecurityGroupNamesDecoded0
        let packagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .packages)
        var packagesDecoded0:[Swift.String]? = nil
        if let packagesContainer = packagesContainer {
            packagesDecoded0 = [Swift.String]()
            for string0 in packagesContainer {
                if let string0 = string0 {
                    packagesDecoded0?.append(string0)
                }
            }
        }
        packages = packagesDecoded0
        let volumeConfigurationsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.VolumeConfiguration?].self, forKey: .volumeConfigurations)
        var volumeConfigurationsDecoded0:[OpsWorksClientTypes.VolumeConfiguration]? = nil
        if let volumeConfigurationsContainer = volumeConfigurationsContainer {
            volumeConfigurationsDecoded0 = [OpsWorksClientTypes.VolumeConfiguration]()
            for structure0 in volumeConfigurationsContainer {
                if let structure0 = structure0 {
                    volumeConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        volumeConfigurations = volumeConfigurationsDecoded0
        let enableAutoHealingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoHealing)
        enableAutoHealing = enableAutoHealingDecoded
        let autoAssignElasticIpsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssignElasticIps)
        autoAssignElasticIps = autoAssignElasticIpsDecoded
        let autoAssignPublicIpsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssignPublicIps)
        autoAssignPublicIps = autoAssignPublicIpsDecoded
        let defaultRecipesDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Recipes.self, forKey: .defaultRecipes)
        defaultRecipes = defaultRecipesDecoded
        let customRecipesDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Recipes.self, forKey: .customRecipes)
        customRecipes = customRecipesDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let useEbsOptimizedInstancesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useEbsOptimizedInstances)
        useEbsOptimizedInstances = useEbsOptimizedInstancesDecoded
        let lifecycleEventConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.LifecycleEventConfiguration.self, forKey: .lifecycleEventConfiguration)
        lifecycleEventConfiguration = lifecycleEventConfigurationDecoded
    }
}

extension OpsWorksClientTypes.Layer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Layer(arn: \(Swift.String(describing: arn)), attributes: \(Swift.String(describing: attributes)), autoAssignElasticIps: \(Swift.String(describing: autoAssignElasticIps)), autoAssignPublicIps: \(Swift.String(describing: autoAssignPublicIps)), cloudWatchLogsConfiguration: \(Swift.String(describing: cloudWatchLogsConfiguration)), createdAt: \(Swift.String(describing: createdAt)), customInstanceProfileArn: \(Swift.String(describing: customInstanceProfileArn)), customJson: \(Swift.String(describing: customJson)), customRecipes: \(Swift.String(describing: customRecipes)), customSecurityGroupIds: \(Swift.String(describing: customSecurityGroupIds)), defaultRecipes: \(Swift.String(describing: defaultRecipes)), defaultSecurityGroupNames: \(Swift.String(describing: defaultSecurityGroupNames)), enableAutoHealing: \(Swift.String(describing: enableAutoHealing)), installUpdatesOnBoot: \(Swift.String(describing: installUpdatesOnBoot)), layerId: \(Swift.String(describing: layerId)), lifecycleEventConfiguration: \(Swift.String(describing: lifecycleEventConfiguration)), name: \(Swift.String(describing: name)), packages: \(Swift.String(describing: packages)), shortname: \(Swift.String(describing: shortname)), stackId: \(Swift.String(describing: stackId)), type: \(Swift.String(describing: type)), useEbsOptimizedInstances: \(Swift.String(describing: useEbsOptimizedInstances)), volumeConfigurations: \(Swift.String(describing: volumeConfigurations)))"}
}

extension OpsWorksClientTypes {
    /// Describes a layer.
    public struct Layer: Swift.Equatable {
        /// The Amazon Resource Number (ARN) of a layer.
        public var arn: Swift.String?
        /// The layer attributes.
        ///          For the HaproxyStatsPassword, MysqlRootPassword, and
        ///         GangliaPassword attributes, AWS OpsWorks Stacks returns *****FILTERED*****
        ///       instead of the actual value
        ///          For an ECS Cluster layer, AWS OpsWorks Stacks the EcsClusterArn attribute is set to the cluster's ARN.
        public var attributes: [Swift.String:Swift.String]?
        /// Whether to automatically assign an <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html">Elastic IP
        ///         address to the layer's instances. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html">How to Edit
        ///         a Layer.
        public var autoAssignElasticIps: Swift.Bool?
        /// For stacks that are running in a VPC, whether to automatically assign a public IP address to
        ///       the layer's instances. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html">How to Edit
        ///         a Layer.
        public var autoAssignPublicIps: Swift.Bool?
        /// The Amazon CloudWatch Logs configuration settings for the layer.
        public var cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration?
        /// Date when the layer was created.
        public var createdAt: Swift.String?
        /// The ARN of the default IAM profile to be used for the layer's EC2 instances. For more
        ///       information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
        ///       Identifiers.
        public var customInstanceProfileArn: Swift.String?
        /// A JSON formatted string containing the layer's custom stack configuration and deployment attributes.
        public var customJson: Swift.String?
        /// A LayerCustomRecipes object that specifies the layer's custom recipes.
        public var customRecipes: OpsWorksClientTypes.Recipes?
        /// An array containing the layer's custom security group IDs.
        public var customSecurityGroupIds: [Swift.String]?
        /// AWS OpsWorks Stacks supports five lifecycle events: setup, configuration,
        ///             deploy, undeploy, and shutdown.
        ///             For each layer, AWS OpsWorks Stacks runs a set of standard recipes for each event. You can also provide
        ///             custom recipes for any or all layers and events. AWS OpsWorks Stacks runs custom event recipes after the standard
        ///             recipes. LayerCustomRecipes specifies the custom recipes for a particular layer to be run in response to each of
        ///             the five events.
        ///         To specify a recipe, use the cookbook's directory name in the repository followed by two colons and the recipe
        ///             name, which is the recipe's file name without the .rb extension. For example: phpapp2::dbsetup specifies the
        ///             dbsetup.rb recipe in the repository's phpapp2 folder.
        public var defaultRecipes: OpsWorksClientTypes.Recipes?
        /// An array containing the layer's security group names.
        public var defaultSecurityGroupNames: [Swift.String]?
        /// Whether auto healing is disabled for the layer.
        public var enableAutoHealing: Swift.Bool?
        /// Whether to install operating system and package updates when the instance boots. The default
        ///       value is true. If this value is set to false, you must then update
        ///       your instances manually by using CreateDeployment to run the
        ///         update_dependencies stack command or manually running yum (Amazon
        ///       Linux) or apt-get (Ubuntu) on the instances.
        ///
        ///             We strongly recommend using the default value of true, to ensure that your
        ///         instances have the latest security updates.
        ///
        public var installUpdatesOnBoot: Swift.Bool?
        /// The layer ID.
        public var layerId: Swift.String?
        /// A LifeCycleEventConfiguration object that specifies the Shutdown event
        ///       configuration.
        public var lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration?
        /// The layer name.
        public var name: Swift.String?
        /// An array of Package objects that describe the layer's packages.
        public var packages: [Swift.String]?
        /// The layer short name.
        public var shortname: Swift.String?
        /// The layer stack ID.
        public var stackId: Swift.String?
        /// The layer type.
        public var type: OpsWorksClientTypes.LayerType?
        /// Whether the layer uses Amazon EBS-optimized instances.
        public var useEbsOptimizedInstances: Swift.Bool?
        /// A VolumeConfigurations object that describes the layer's Amazon EBS volumes.
        public var volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]?

        public init (
            arn: Swift.String? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            autoAssignElasticIps: Swift.Bool? = nil,
            autoAssignPublicIps: Swift.Bool? = nil,
            cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration? = nil,
            createdAt: Swift.String? = nil,
            customInstanceProfileArn: Swift.String? = nil,
            customJson: Swift.String? = nil,
            customRecipes: OpsWorksClientTypes.Recipes? = nil,
            customSecurityGroupIds: [Swift.String]? = nil,
            defaultRecipes: OpsWorksClientTypes.Recipes? = nil,
            defaultSecurityGroupNames: [Swift.String]? = nil,
            enableAutoHealing: Swift.Bool? = nil,
            installUpdatesOnBoot: Swift.Bool? = nil,
            layerId: Swift.String? = nil,
            lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration? = nil,
            name: Swift.String? = nil,
            packages: [Swift.String]? = nil,
            shortname: Swift.String? = nil,
            stackId: Swift.String? = nil,
            type: OpsWorksClientTypes.LayerType? = nil,
            useEbsOptimizedInstances: Swift.Bool? = nil,
            volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]? = nil
        )
        {
            self.arn = arn
            self.attributes = attributes
            self.autoAssignElasticIps = autoAssignElasticIps
            self.autoAssignPublicIps = autoAssignPublicIps
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.createdAt = createdAt
            self.customInstanceProfileArn = customInstanceProfileArn
            self.customJson = customJson
            self.customRecipes = customRecipes
            self.customSecurityGroupIds = customSecurityGroupIds
            self.defaultRecipes = defaultRecipes
            self.defaultSecurityGroupNames = defaultSecurityGroupNames
            self.enableAutoHealing = enableAutoHealing
            self.installUpdatesOnBoot = installUpdatesOnBoot
            self.layerId = layerId
            self.lifecycleEventConfiguration = lifecycleEventConfiguration
            self.name = name
            self.packages = packages
            self.shortname = shortname
            self.stackId = stackId
            self.type = type
            self.useEbsOptimizedInstances = useEbsOptimizedInstances
            self.volumeConfigurations = volumeConfigurations
        }
    }

}

extension OpsWorksClientTypes {
    public enum LayerAttributesKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bundlerversion
        case ecsclusterarn
        case enablehaproxystats
        case gangliapassword
        case gangliaurl
        case gangliauser
        case haproxyhealthcheckmethod
        case haproxyhealthcheckurl
        case haproxystatspassword
        case haproxystatsurl
        case haproxystatsuser
        case javaappserver
        case javaappserverversion
        case jvm
        case jvmoptions
        case jvmversion
        case managebundler
        case memcachedmemory
        case mysqlrootpassword
        case mysqlrootpasswordubiquitous
        case nodejsversion
        case passengerversion
        case railsstack
        case rubyversion
        case rubygemsversion
        case sdkUnknown(Swift.String)

        public static var allCases: [LayerAttributesKeys] {
            return [
                .bundlerversion,
                .ecsclusterarn,
                .enablehaproxystats,
                .gangliapassword,
                .gangliaurl,
                .gangliauser,
                .haproxyhealthcheckmethod,
                .haproxyhealthcheckurl,
                .haproxystatspassword,
                .haproxystatsurl,
                .haproxystatsuser,
                .javaappserver,
                .javaappserverversion,
                .jvm,
                .jvmoptions,
                .jvmversion,
                .managebundler,
                .memcachedmemory,
                .mysqlrootpassword,
                .mysqlrootpasswordubiquitous,
                .nodejsversion,
                .passengerversion,
                .railsstack,
                .rubyversion,
                .rubygemsversion,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bundlerversion: return "BundlerVersion"
            case .ecsclusterarn: return "EcsClusterArn"
            case .enablehaproxystats: return "EnableHaproxyStats"
            case .gangliapassword: return "GangliaPassword"
            case .gangliaurl: return "GangliaUrl"
            case .gangliauser: return "GangliaUser"
            case .haproxyhealthcheckmethod: return "HaproxyHealthCheckMethod"
            case .haproxyhealthcheckurl: return "HaproxyHealthCheckUrl"
            case .haproxystatspassword: return "HaproxyStatsPassword"
            case .haproxystatsurl: return "HaproxyStatsUrl"
            case .haproxystatsuser: return "HaproxyStatsUser"
            case .javaappserver: return "JavaAppServer"
            case .javaappserverversion: return "JavaAppServerVersion"
            case .jvm: return "Jvm"
            case .jvmoptions: return "JvmOptions"
            case .jvmversion: return "JvmVersion"
            case .managebundler: return "ManageBundler"
            case .memcachedmemory: return "MemcachedMemory"
            case .mysqlrootpassword: return "MysqlRootPassword"
            case .mysqlrootpasswordubiquitous: return "MysqlRootPasswordUbiquitous"
            case .nodejsversion: return "NodejsVersion"
            case .passengerversion: return "PassengerVersion"
            case .railsstack: return "RailsStack"
            case .rubyversion: return "RubyVersion"
            case .rubygemsversion: return "RubygemsVersion"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LayerAttributesKeys(rawValue: rawValue) ?? LayerAttributesKeys.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes {
    public enum LayerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsFlowRuby
        case custom
        case dbMaster
        case ecsCluster
        case javaApp
        case lb
        case memcached
        case monitoringMaster
        case nodejsApp
        case phpApp
        case railsApp
        case web
        case sdkUnknown(Swift.String)

        public static var allCases: [LayerType] {
            return [
                .awsFlowRuby,
                .custom,
                .dbMaster,
                .ecsCluster,
                .javaApp,
                .lb,
                .memcached,
                .monitoringMaster,
                .nodejsApp,
                .phpApp,
                .railsApp,
                .web,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsFlowRuby: return "aws-flow-ruby"
            case .custom: return "custom"
            case .dbMaster: return "db-master"
            case .ecsCluster: return "ecs-cluster"
            case .javaApp: return "java-app"
            case .lb: return "lb"
            case .memcached: return "memcached"
            case .monitoringMaster: return "monitoring-master"
            case .nodejsApp: return "nodejs-app"
            case .phpApp: return "php-app"
            case .railsApp: return "rails-app"
            case .web: return "web"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LayerType(rawValue: rawValue) ?? LayerType.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.LifecycleEventConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shutdown = "Shutdown"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shutdown = shutdown {
            try encodeContainer.encode(shutdown, forKey: .shutdown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shutdownDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.ShutdownEventConfiguration.self, forKey: .shutdown)
        shutdown = shutdownDecoded
    }
}

extension OpsWorksClientTypes.LifecycleEventConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LifecycleEventConfiguration(shutdown: \(Swift.String(describing: shutdown)))"}
}

extension OpsWorksClientTypes {
    /// Specifies the lifecycle event configuration
    public struct LifecycleEventConfiguration: Swift.Equatable {
        /// A ShutdownEventConfiguration object that specifies the Shutdown event
        ///       configuration.
        public var shutdown: OpsWorksClientTypes.ShutdownEventConfiguration?

        public init (
            shutdown: OpsWorksClientTypes.ShutdownEventConfiguration? = nil
        )
        {
            self.shutdown = shutdown
        }
    }

}

public struct ListTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

extension ListTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInput: Swift.Equatable {
    /// Do not use. A validation exception occurs if you add a MaxResults parameter to a ListTagsRequest call.
    ///
    public var maxResults: Swift.Int
    /// Do not use. A validation exception occurs if you add a NextToken parameter to a ListTagsRequest call.
    ///
    public var nextToken: Swift.String?
    /// The stack or layer's Amazon Resource Number (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

/// Contains the response to a ListTags request.
public struct ListTagsOutputResponse: Swift.Equatable {
    /// If a paginated request does not return all of the remaining results, this parameter is set to a token that
    ///             you can assign to the request object's NextToken parameter to get the next set of results.
    ///             If the previous paginated request returned all of the remaining results,
    ///             this parameter is set to null.
    ///
    public var nextToken: Swift.String?
    /// A set of key-value pairs that contain tag keys and tag values that are attached to a stack or layer.
    public var tags: [Swift.String:Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
    public let nextToken: Swift.String?
}

extension ListTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension OpsWorksClientTypes.LoadBasedAutoScalingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downScaling = "DownScaling"
        case enable = "Enable"
        case layerId = "LayerId"
        case upScaling = "UpScaling"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let downScaling = downScaling {
            try encodeContainer.encode(downScaling, forKey: .downScaling)
        }
        if let enable = enable {
            try encodeContainer.encode(enable, forKey: .enable)
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let upScaling = upScaling {
            try encodeContainer.encode(upScaling, forKey: .upScaling)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let enableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enable)
        enable = enableDecoded
        let upScalingDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AutoScalingThresholds.self, forKey: .upScaling)
        upScaling = upScalingDecoded
        let downScalingDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AutoScalingThresholds.self, forKey: .downScaling)
        downScaling = downScalingDecoded
    }
}

extension OpsWorksClientTypes.LoadBasedAutoScalingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoadBasedAutoScalingConfiguration(downScaling: \(Swift.String(describing: downScaling)), enable: \(Swift.String(describing: enable)), layerId: \(Swift.String(describing: layerId)), upScaling: \(Swift.String(describing: upScaling)))"}
}

extension OpsWorksClientTypes {
    /// Describes a layer's load-based auto scaling configuration.
    public struct LoadBasedAutoScalingConfiguration: Swift.Equatable {
        /// An AutoScalingThresholds object that describes the downscaling configuration,
        ///       which defines how and when AWS OpsWorks Stacks reduces the number of instances.
        public var downScaling: OpsWorksClientTypes.AutoScalingThresholds?
        /// Whether load-based auto scaling is enabled for the layer.
        public var enable: Swift.Bool?
        /// The layer ID.
        public var layerId: Swift.String?
        /// An AutoScalingThresholds object that describes the upscaling configuration,
        ///       which defines how and when AWS OpsWorks Stacks increases the number of instances.
        public var upScaling: OpsWorksClientTypes.AutoScalingThresholds?

        public init (
            downScaling: OpsWorksClientTypes.AutoScalingThresholds? = nil,
            enable: Swift.Bool? = nil,
            layerId: Swift.String? = nil,
            upScaling: OpsWorksClientTypes.AutoScalingThresholds? = nil
        )
        {
            self.downScaling = downScaling
            self.enable = enable
            self.layerId = layerId
            self.upScaling = upScaling
        }
    }

}

extension OpsWorksClientTypes.OperatingSystem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationManagers = "ConfigurationManagers"
        case id = "Id"
        case name = "Name"
        case reportedName = "ReportedName"
        case reportedVersion = "ReportedVersion"
        case supported = "Supported"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationManagers = configurationManagers {
            var configurationManagersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationManagers)
            for operatingsystemconfigurationmanagers0 in configurationManagers {
                try configurationManagersContainer.encode(operatingsystemconfigurationmanagers0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reportedName = reportedName {
            try encodeContainer.encode(reportedName, forKey: .reportedName)
        }
        if let reportedVersion = reportedVersion {
            try encodeContainer.encode(reportedVersion, forKey: .reportedVersion)
        }
        if let supported = supported {
            try encodeContainer.encode(supported, forKey: .supported)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let configurationManagersContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.OperatingSystemConfigurationManager?].self, forKey: .configurationManagers)
        var configurationManagersDecoded0:[OpsWorksClientTypes.OperatingSystemConfigurationManager]? = nil
        if let configurationManagersContainer = configurationManagersContainer {
            configurationManagersDecoded0 = [OpsWorksClientTypes.OperatingSystemConfigurationManager]()
            for structure0 in configurationManagersContainer {
                if let structure0 = structure0 {
                    configurationManagersDecoded0?.append(structure0)
                }
            }
        }
        configurationManagers = configurationManagersDecoded0
        let reportedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportedName)
        reportedName = reportedNameDecoded
        let reportedVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportedVersion)
        reportedVersion = reportedVersionDecoded
        let supportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supported)
        supported = supportedDecoded
    }
}

extension OpsWorksClientTypes.OperatingSystem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperatingSystem(configurationManagers: \(Swift.String(describing: configurationManagers)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), reportedName: \(Swift.String(describing: reportedName)), reportedVersion: \(Swift.String(describing: reportedVersion)), supported: \(Swift.String(describing: supported)), type: \(Swift.String(describing: type)))"}
}

extension OpsWorksClientTypes {
    /// Describes supported operating systems in AWS OpsWorks Stacks.
    public struct OperatingSystem: Swift.Equatable {
        /// Supported configuration manager name and versions for an AWS OpsWorks Stacks operating system.
        public var configurationManagers: [OpsWorksClientTypes.OperatingSystemConfigurationManager]?
        /// The ID of a supported operating system, such as Amazon Linux 2018.03.
        public var id: Swift.String?
        /// The name of the operating system, such as Amazon Linux 2018.03.
        public var name: Swift.String?
        /// A short name for the operating system manufacturer.
        public var reportedName: Swift.String?
        /// The version of the operating system, including the release and edition, if applicable.
        public var reportedVersion: Swift.String?
        /// Indicates that an operating system is not supported for new instances.
        public var supported: Swift.Bool?
        /// The type of a supported operating system, either Linux or Windows.
        public var type: Swift.String?

        public init (
            configurationManagers: [OpsWorksClientTypes.OperatingSystemConfigurationManager]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            reportedName: Swift.String? = nil,
            reportedVersion: Swift.String? = nil,
            supported: Swift.Bool? = nil,
            type: Swift.String? = nil
        )
        {
            self.configurationManagers = configurationManagers
            self.id = id
            self.name = name
            self.reportedName = reportedName
            self.reportedVersion = reportedVersion
            self.supported = supported
            self.type = type
        }
    }

}

extension OpsWorksClientTypes.OperatingSystemConfigurationManager: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension OpsWorksClientTypes.OperatingSystemConfigurationManager: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperatingSystemConfigurationManager(name: \(Swift.String(describing: name)), version: \(Swift.String(describing: version)))"}
}

extension OpsWorksClientTypes {
    /// A block that contains information about the configuration manager (Chef) and the versions of the configuration manager that are supported for an operating system.
    public struct OperatingSystemConfigurationManager: Swift.Equatable {
        /// The name of the configuration manager, which is Chef.
        public var name: Swift.String?
        /// The versions of the configuration manager that are supported by an operating system.
        public var version: Swift.String?

        public init (
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension OpsWorksClientTypes.Permission: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSsh = "AllowSsh"
        case allowSudo = "AllowSudo"
        case iamUserArn = "IamUserArn"
        case level = "Level"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSsh = allowSsh {
            try encodeContainer.encode(allowSsh, forKey: .allowSsh)
        }
        if let allowSudo = allowSudo {
            try encodeContainer.encode(allowSudo, forKey: .allowSudo)
        }
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let level = level {
            try encodeContainer.encode(level, forKey: .level)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let allowSshDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSsh)
        allowSsh = allowSshDecoded
        let allowSudoDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSudo)
        allowSudo = allowSudoDecoded
        let levelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .level)
        level = levelDecoded
    }
}

extension OpsWorksClientTypes.Permission: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Permission(allowSsh: \(Swift.String(describing: allowSsh)), allowSudo: \(Swift.String(describing: allowSudo)), iamUserArn: \(Swift.String(describing: iamUserArn)), level: \(Swift.String(describing: level)), stackId: \(Swift.String(describing: stackId)))"}
}

extension OpsWorksClientTypes {
    /// Describes stack or user permissions.
    public struct Permission: Swift.Equatable {
        /// Whether the user can use SSH.
        public var allowSsh: Swift.Bool?
        /// Whether the user can use sudo.
        public var allowSudo: Swift.Bool?
        /// The Amazon Resource Name (ARN) for an AWS Identity and Access Management (IAM) role. For more
        ///       information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
        ///       Identifiers.
        public var iamUserArn: Swift.String?
        /// The user's permission level, which must be the following:
        ///
        ///
        ///
        ///                   deny
        ///
        ///
        ///
        ///
        ///                   show
        ///
        ///
        ///
        ///
        ///                   deploy
        ///
        ///
        ///
        ///
        ///                   manage
        ///
        ///
        ///
        ///
        ///                   iam_only
        ///
        ///
        ///
        ///          For more information on the permissions associated with these levels, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/opsworks-security-users.html">Managing User Permissions
        ///
        public var level: Swift.String?
        /// A stack ID.
        public var stackId: Swift.String?

        public init (
            allowSsh: Swift.Bool? = nil,
            allowSudo: Swift.Bool? = nil,
            iamUserArn: Swift.String? = nil,
            level: Swift.String? = nil,
            stackId: Swift.String? = nil
        )
        {
            self.allowSsh = allowSsh
            self.allowSudo = allowSudo
            self.iamUserArn = iamUserArn
            self.level = level
            self.stackId = stackId
        }
    }

}

extension OpsWorksClientTypes.RaidArray: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case createdAt = "CreatedAt"
        case device = "Device"
        case instanceId = "InstanceId"
        case iops = "Iops"
        case mountPoint = "MountPoint"
        case name = "Name"
        case numberOfDisks = "NumberOfDisks"
        case raidArrayId = "RaidArrayId"
        case raidLevel = "RaidLevel"
        case size = "Size"
        case stackId = "StackId"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let device = device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let iops = iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let mountPoint = mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberOfDisks = numberOfDisks {
            try encodeContainer.encode(numberOfDisks, forKey: .numberOfDisks)
        }
        if let raidArrayId = raidArrayId {
            try encodeContainer.encode(raidArrayId, forKey: .raidArrayId)
        }
        if let raidLevel = raidLevel {
            try encodeContainer.encode(raidLevel, forKey: .raidLevel)
        }
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let raidArrayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .raidArrayId)
        raidArrayId = raidArrayIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let raidLevelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .raidLevel)
        raidLevel = raidLevelDecoded
        let numberOfDisksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDisks)
        numberOfDisks = numberOfDisksDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .device)
        device = deviceDecoded
        let mountPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
    }
}

extension OpsWorksClientTypes.RaidArray: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RaidArray(availabilityZone: \(Swift.String(describing: availabilityZone)), createdAt: \(Swift.String(describing: createdAt)), device: \(Swift.String(describing: device)), instanceId: \(Swift.String(describing: instanceId)), iops: \(Swift.String(describing: iops)), mountPoint: \(Swift.String(describing: mountPoint)), name: \(Swift.String(describing: name)), numberOfDisks: \(Swift.String(describing: numberOfDisks)), raidArrayId: \(Swift.String(describing: raidArrayId)), raidLevel: \(Swift.String(describing: raidLevel)), size: \(Swift.String(describing: size)), stackId: \(Swift.String(describing: stackId)), volumeType: \(Swift.String(describing: volumeType)))"}
}

extension OpsWorksClientTypes {
    /// Describes an instance's RAID array.
    public struct RaidArray: Swift.Equatable {
        /// The array's Availability Zone. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints.
        public var availabilityZone: Swift.String?
        /// When the RAID array was created.
        public var createdAt: Swift.String?
        /// The array's Linux device. For example /dev/mdadm0.
        public var device: Swift.String?
        /// The instance ID.
        public var instanceId: Swift.String?
        /// For PIOPS volumes, the IOPS per disk.
        public var iops: Swift.Int?
        /// The array's mount point.
        public var mountPoint: Swift.String?
        /// The array name.
        public var name: Swift.String?
        /// The number of disks in the array.
        public var numberOfDisks: Swift.Int?
        /// The array ID.
        public var raidArrayId: Swift.String?
        /// The <a href="http://en.wikipedia.org/wiki/Standard_RAID_levels">RAID level.
        public var raidLevel: Swift.Int?
        /// The array's size.
        public var size: Swift.Int?
        /// The stack ID.
        public var stackId: Swift.String?
        /// The volume type, standard or PIOPS.
        public var volumeType: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            device: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            iops: Swift.Int? = nil,
            mountPoint: Swift.String? = nil,
            name: Swift.String? = nil,
            numberOfDisks: Swift.Int? = nil,
            raidArrayId: Swift.String? = nil,
            raidLevel: Swift.Int? = nil,
            size: Swift.Int? = nil,
            stackId: Swift.String? = nil,
            volumeType: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.createdAt = createdAt
            self.device = device
            self.instanceId = instanceId
            self.iops = iops
            self.mountPoint = mountPoint
            self.name = name
            self.numberOfDisks = numberOfDisks
            self.raidArrayId = raidArrayId
            self.raidLevel = raidLevel
            self.size = size
            self.stackId = stackId
            self.volumeType = volumeType
        }
    }

}

extension OpsWorksClientTypes.RdsDbInstance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case dbInstanceIdentifier = "DbInstanceIdentifier"
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case engine = "Engine"
        case missingOnRds = "MissingOnRds"
        case rdsDbInstanceArn = "RdsDbInstanceArn"
        case region = "Region"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let dbInstanceIdentifier = dbInstanceIdentifier {
            try encodeContainer.encode(dbInstanceIdentifier, forKey: .dbInstanceIdentifier)
        }
        if let dbPassword = dbPassword {
            try encodeContainer.encode(dbPassword, forKey: .dbPassword)
        }
        if let dbUser = dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if let engine = engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let missingOnRds = missingOnRds {
            try encodeContainer.encode(missingOnRds, forKey: .missingOnRds)
        }
        if let rdsDbInstanceArn = rdsDbInstanceArn {
            try encodeContainer.encode(rdsDbInstanceArn, forKey: .rdsDbInstanceArn)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rdsDbInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rdsDbInstanceArn)
        rdsDbInstanceArn = rdsDbInstanceArnDecoded
        let dbInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbInstanceIdentifier)
        dbInstanceIdentifier = dbInstanceIdentifierDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let dbPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbPassword)
        dbPassword = dbPasswordDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let missingOnRdsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .missingOnRds)
        missingOnRds = missingOnRdsDecoded
    }
}

extension OpsWorksClientTypes.RdsDbInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RdsDbInstance(address: \(Swift.String(describing: address)), dbInstanceIdentifier: \(Swift.String(describing: dbInstanceIdentifier)), dbPassword: \(Swift.String(describing: dbPassword)), dbUser: \(Swift.String(describing: dbUser)), engine: \(Swift.String(describing: engine)), missingOnRds: \(Swift.String(describing: missingOnRds)), rdsDbInstanceArn: \(Swift.String(describing: rdsDbInstanceArn)), region: \(Swift.String(describing: region)), stackId: \(Swift.String(describing: stackId)))"}
}

extension OpsWorksClientTypes {
    /// Describes an Amazon RDS instance.
    public struct RdsDbInstance: Swift.Equatable {
        /// The instance's address.
        public var address: Swift.String?
        /// The DB instance identifier.
        public var dbInstanceIdentifier: Swift.String?
        /// AWS OpsWorks Stacks returns *****FILTERED***** instead of the actual value.
        public var dbPassword: Swift.String?
        /// The master user name.
        public var dbUser: Swift.String?
        /// The instance's database engine.
        public var engine: Swift.String?
        /// Set to true if AWS OpsWorks Stacks is unable to discover the Amazon RDS instance. AWS OpsWorks Stacks attempts
        ///       to discover the instance only once. If this value is set to true, you must
        ///       deregister the instance, and then register it again.
        public var missingOnRds: Swift.Bool?
        /// The instance's ARN.
        public var rdsDbInstanceArn: Swift.String?
        /// The instance's AWS region.
        public var region: Swift.String?
        /// The ID of the stack with which the instance is registered.
        public var stackId: Swift.String?

        public init (
            address: Swift.String? = nil,
            dbInstanceIdentifier: Swift.String? = nil,
            dbPassword: Swift.String? = nil,
            dbUser: Swift.String? = nil,
            engine: Swift.String? = nil,
            missingOnRds: Swift.Bool? = nil,
            rdsDbInstanceArn: Swift.String? = nil,
            region: Swift.String? = nil,
            stackId: Swift.String? = nil
        )
        {
            self.address = address
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbPassword = dbPassword
            self.dbUser = dbUser
            self.engine = engine
            self.missingOnRds = missingOnRds
            self.rdsDbInstanceArn = rdsDbInstanceArn
            self.region = region
            self.stackId = stackId
        }
    }

}

public struct RebootInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootInstanceOutputError>
}

extension RebootInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootInstanceInput(instanceId: \(Swift.String(describing: instanceId)))"}
}

extension RebootInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct RebootInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootInstanceOutputError>
}

public struct RebootInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootInstanceOutputError>
}

public struct RebootInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RebootInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RebootInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<RebootInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootInstanceOutputError>
}

public struct RebootInstanceInput: Swift.Equatable {
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct RebootInstanceInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
}

extension RebootInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension RebootInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootInstanceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootInstanceOutputResponse()"}
}

extension RebootInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RebootInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct RebootInstanceOutputResponseBody: Swift.Equatable {
}

extension RebootInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension OpsWorksClientTypes.Recipes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configure = "Configure"
        case deploy = "Deploy"
        case setup = "Setup"
        case shutdown = "Shutdown"
        case undeploy = "Undeploy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configure = configure {
            var configureContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configure)
            for strings0 in configure {
                try configureContainer.encode(strings0)
            }
        }
        if let deploy = deploy {
            var deployContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deploy)
            for strings0 in deploy {
                try deployContainer.encode(strings0)
            }
        }
        if let setup = setup {
            var setupContainer = encodeContainer.nestedUnkeyedContainer(forKey: .setup)
            for strings0 in setup {
                try setupContainer.encode(strings0)
            }
        }
        if let shutdown = shutdown {
            var shutdownContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shutdown)
            for strings0 in shutdown {
                try shutdownContainer.encode(strings0)
            }
        }
        if let undeploy = undeploy {
            var undeployContainer = encodeContainer.nestedUnkeyedContainer(forKey: .undeploy)
            for strings0 in undeploy {
                try undeployContainer.encode(strings0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let setupContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .setup)
        var setupDecoded0:[Swift.String]? = nil
        if let setupContainer = setupContainer {
            setupDecoded0 = [Swift.String]()
            for string0 in setupContainer {
                if let string0 = string0 {
                    setupDecoded0?.append(string0)
                }
            }
        }
        setup = setupDecoded0
        let configureContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configure)
        var configureDecoded0:[Swift.String]? = nil
        if let configureContainer = configureContainer {
            configureDecoded0 = [Swift.String]()
            for string0 in configureContainer {
                if let string0 = string0 {
                    configureDecoded0?.append(string0)
                }
            }
        }
        configure = configureDecoded0
        let deployContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deploy)
        var deployDecoded0:[Swift.String]? = nil
        if let deployContainer = deployContainer {
            deployDecoded0 = [Swift.String]()
            for string0 in deployContainer {
                if let string0 = string0 {
                    deployDecoded0?.append(string0)
                }
            }
        }
        deploy = deployDecoded0
        let undeployContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .undeploy)
        var undeployDecoded0:[Swift.String]? = nil
        if let undeployContainer = undeployContainer {
            undeployDecoded0 = [Swift.String]()
            for string0 in undeployContainer {
                if let string0 = string0 {
                    undeployDecoded0?.append(string0)
                }
            }
        }
        undeploy = undeployDecoded0
        let shutdownContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .shutdown)
        var shutdownDecoded0:[Swift.String]? = nil
        if let shutdownContainer = shutdownContainer {
            shutdownDecoded0 = [Swift.String]()
            for string0 in shutdownContainer {
                if let string0 = string0 {
                    shutdownDecoded0?.append(string0)
                }
            }
        }
        shutdown = shutdownDecoded0
    }
}

extension OpsWorksClientTypes.Recipes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Recipes(configure: \(Swift.String(describing: configure)), deploy: \(Swift.String(describing: deploy)), setup: \(Swift.String(describing: setup)), shutdown: \(Swift.String(describing: shutdown)), undeploy: \(Swift.String(describing: undeploy)))"}
}

extension OpsWorksClientTypes {
    /// AWS OpsWorks Stacks supports five
    ///       lifecycle events:
    ///         setup, configuration, deploy, undeploy, and shutdown. For
    ///       each layer, AWS OpsWorks Stacks runs a set of standard recipes for each event. In addition, you can provide
    ///       custom recipes for any or all layers and events. AWS OpsWorks Stacks runs custom event recipes after the
    ///       standard recipes. LayerCustomRecipes specifies the custom recipes for a
    ///       particular layer to be run in response to each of the five events.
    ///
    ///          To specify a recipe, use the cookbook's directory name in the repository followed by two colons and the recipe name, which is the recipe's file name without the .rb extension. For example: phpapp2::dbsetup specifies the dbsetup.rb recipe in the repository's phpapp2 folder.
    public struct Recipes: Swift.Equatable {
        /// An array of custom recipe names to be run following a configure event.
        public var configure: [Swift.String]?
        /// An array of custom recipe names to be run following a deploy event.
        public var deploy: [Swift.String]?
        /// An array of custom recipe names to be run following a setup event.
        public var setup: [Swift.String]?
        /// An array of custom recipe names to be run following a shutdown event.
        public var shutdown: [Swift.String]?
        /// An array of custom recipe names to be run following a undeploy event.
        public var undeploy: [Swift.String]?

        public init (
            configure: [Swift.String]? = nil,
            deploy: [Swift.String]? = nil,
            setup: [Swift.String]? = nil,
            shutdown: [Swift.String]? = nil,
            undeploy: [Swift.String]? = nil
        )
        {
            self.configure = configure
            self.deploy = deploy
            self.setup = setup
            self.shutdown = shutdown
            self.undeploy = undeploy
        }
    }

}

public struct RegisterEcsClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterEcsClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterEcsClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterEcsClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterEcsClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterEcsClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterEcsClusterOutputError>
}

extension RegisterEcsClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterEcsClusterInput(ecsClusterArn: \(Swift.String(describing: ecsClusterArn)), stackId: \(Swift.String(describing: stackId)))"}
}

extension RegisterEcsClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArn = "EcsClusterArn"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecsClusterArn = ecsClusterArn {
            try encodeContainer.encode(ecsClusterArn, forKey: .ecsClusterArn)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct RegisterEcsClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterEcsClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterEcsClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterEcsClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterEcsClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterEcsClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterEcsClusterOutputError>
}

public struct RegisterEcsClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterEcsClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterEcsClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterEcsClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterEcsClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterEcsClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterEcsClusterOutputError>
}

public struct RegisterEcsClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterEcsClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RegisterEcsClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterEcsClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterEcsClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterEcsClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterEcsClusterOutputError>
}

public struct RegisterEcsClusterInput: Swift.Equatable {
    /// The cluster's ARN.
    /// This member is required.
    public var ecsClusterArn: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init (
        ecsClusterArn: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.ecsClusterArn = ecsClusterArn
        self.stackId = stackId
    }
}

struct RegisterEcsClusterInputBody: Swift.Equatable {
    public let ecsClusterArn: Swift.String?
    public let stackId: Swift.String?
}

extension RegisterEcsClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArn = "EcsClusterArn"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecsClusterArn)
        ecsClusterArn = ecsClusterArnDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension RegisterEcsClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterEcsClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterEcsClusterOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterEcsClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterEcsClusterOutputResponse(ecsClusterArn: \(Swift.String(describing: ecsClusterArn)))"}
}

extension RegisterEcsClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterEcsClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ecsClusterArn = output.ecsClusterArn
        } else {
            self.ecsClusterArn = nil
        }
    }
}

/// Contains the response to a RegisterEcsCluster request.
public struct RegisterEcsClusterOutputResponse: Swift.Equatable {
    /// The cluster's ARN.
    public var ecsClusterArn: Swift.String?

    public init (
        ecsClusterArn: Swift.String? = nil
    )
    {
        self.ecsClusterArn = ecsClusterArn
    }
}

struct RegisterEcsClusterOutputResponseBody: Swift.Equatable {
    public let ecsClusterArn: Swift.String?
}

extension RegisterEcsClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArn = "EcsClusterArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecsClusterArn)
        ecsClusterArn = ecsClusterArnDecoded
    }
}

public struct RegisterElasticIpInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterElasticIpInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterElasticIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterElasticIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterElasticIpOutputError>
}

extension RegisterElasticIpInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterElasticIpInput(elasticIp: \(Swift.String(describing: elasticIp)), stackId: \(Swift.String(describing: stackId)))"}
}

extension RegisterElasticIpInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct RegisterElasticIpInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterElasticIpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterElasticIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterElasticIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterElasticIpOutputError>
}

public struct RegisterElasticIpInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterElasticIpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterElasticIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterElasticIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterElasticIpOutputError>
}

public struct RegisterElasticIpInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterElasticIpInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RegisterElasticIpInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterElasticIpInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterElasticIpOutputError>
}

public struct RegisterElasticIpInput: Swift.Equatable {
    /// The Elastic IP address.
    /// This member is required.
    public var elasticIp: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init (
        elasticIp: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
        self.stackId = stackId
    }
}

struct RegisterElasticIpInputBody: Swift.Equatable {
    public let elasticIp: Swift.String?
    public let stackId: Swift.String?
}

extension RegisterElasticIpInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension RegisterElasticIpOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterElasticIpOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterElasticIpOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterElasticIpOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterElasticIpOutputResponse(elasticIp: \(Swift.String(describing: elasticIp)))"}
}

extension RegisterElasticIpOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterElasticIpOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.elasticIp = output.elasticIp
        } else {
            self.elasticIp = nil
        }
    }
}

/// Contains the response to a RegisterElasticIp request.
public struct RegisterElasticIpOutputResponse: Swift.Equatable {
    /// The Elastic IP address.
    public var elasticIp: Swift.String?

    public init (
        elasticIp: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
    }
}

struct RegisterElasticIpOutputResponseBody: Swift.Equatable {
    public let elasticIp: Swift.String?
}

extension RegisterElasticIpOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
    }
}

public struct RegisterInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterInstanceOutputError>
}

extension RegisterInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterInstanceInput(hostname: \(Swift.String(describing: hostname)), instanceIdentity: \(Swift.String(describing: instanceIdentity)), privateIp: \(Swift.String(describing: privateIp)), publicIp: \(Swift.String(describing: publicIp)), rsaPublicKey: \(Swift.String(describing: rsaPublicKey)), rsaPublicKeyFingerprint: \(Swift.String(describing: rsaPublicKeyFingerprint)), stackId: \(Swift.String(describing: stackId)))"}
}

extension RegisterInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname = "Hostname"
        case instanceIdentity = "InstanceIdentity"
        case privateIp = "PrivateIp"
        case publicIp = "PublicIp"
        case rsaPublicKey = "RsaPublicKey"
        case rsaPublicKeyFingerprint = "RsaPublicKeyFingerprint"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let instanceIdentity = instanceIdentity {
            try encodeContainer.encode(instanceIdentity, forKey: .instanceIdentity)
        }
        if let privateIp = privateIp {
            try encodeContainer.encode(privateIp, forKey: .privateIp)
        }
        if let publicIp = publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let rsaPublicKey = rsaPublicKey {
            try encodeContainer.encode(rsaPublicKey, forKey: .rsaPublicKey)
        }
        if let rsaPublicKeyFingerprint = rsaPublicKeyFingerprint {
            try encodeContainer.encode(rsaPublicKeyFingerprint, forKey: .rsaPublicKeyFingerprint)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct RegisterInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterInstanceOutputError>
}

public struct RegisterInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterInstanceOutputError>
}

public struct RegisterInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RegisterInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterInstanceOutputError>
}

public struct RegisterInstanceInput: Swift.Equatable {
    /// The instance's hostname.
    public var hostname: Swift.String?
    /// An InstanceIdentity object that contains the instance's identity.
    public var instanceIdentity: OpsWorksClientTypes.InstanceIdentity?
    /// The instance's private IP address.
    public var privateIp: Swift.String?
    /// The instance's public IP address.
    public var publicIp: Swift.String?
    /// The instances public RSA key. This key is used to encrypt communication between the instance and the service.
    public var rsaPublicKey: Swift.String?
    /// The instances public RSA key fingerprint.
    public var rsaPublicKeyFingerprint: Swift.String?
    /// The ID of the stack that the instance is to be registered with.
    /// This member is required.
    public var stackId: Swift.String?

    public init (
        hostname: Swift.String? = nil,
        instanceIdentity: OpsWorksClientTypes.InstanceIdentity? = nil,
        privateIp: Swift.String? = nil,
        publicIp: Swift.String? = nil,
        rsaPublicKey: Swift.String? = nil,
        rsaPublicKeyFingerprint: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.hostname = hostname
        self.instanceIdentity = instanceIdentity
        self.privateIp = privateIp
        self.publicIp = publicIp
        self.rsaPublicKey = rsaPublicKey
        self.rsaPublicKeyFingerprint = rsaPublicKeyFingerprint
        self.stackId = stackId
    }
}

struct RegisterInstanceInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let hostname: Swift.String?
    public let publicIp: Swift.String?
    public let privateIp: Swift.String?
    public let rsaPublicKey: Swift.String?
    public let rsaPublicKeyFingerprint: Swift.String?
    public let instanceIdentity: OpsWorksClientTypes.InstanceIdentity?
}

extension RegisterInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname = "Hostname"
        case instanceIdentity = "InstanceIdentity"
        case privateIp = "PrivateIp"
        case publicIp = "PublicIp"
        case rsaPublicKey = "RsaPublicKey"
        case rsaPublicKeyFingerprint = "RsaPublicKeyFingerprint"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
        let privateIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIp)
        privateIp = privateIpDecoded
        let rsaPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rsaPublicKey)
        rsaPublicKey = rsaPublicKeyDecoded
        let rsaPublicKeyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rsaPublicKeyFingerprint)
        rsaPublicKeyFingerprint = rsaPublicKeyFingerprintDecoded
        let instanceIdentityDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.InstanceIdentity.self, forKey: .instanceIdentity)
        instanceIdentity = instanceIdentityDecoded
    }
}

extension RegisterInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterInstanceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterInstanceOutputResponse(instanceId: \(Swift.String(describing: instanceId)))"}
}

extension RegisterInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceId = output.instanceId
        } else {
            self.instanceId = nil
        }
    }
}

/// Contains the response to a RegisterInstanceResult request.
public struct RegisterInstanceOutputResponse: Swift.Equatable {
    /// The registered instance's AWS OpsWorks Stacks ID.
    public var instanceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct RegisterInstanceOutputResponseBody: Swift.Equatable {
    public let instanceId: Swift.String?
}

extension RegisterInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

public struct RegisterRdsDbInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterRdsDbInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterRdsDbInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterRdsDbInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterRdsDbInstanceOutputError>
}

extension RegisterRdsDbInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterRdsDbInstanceInput(dbPassword: \(Swift.String(describing: dbPassword)), dbUser: \(Swift.String(describing: dbUser)), rdsDbInstanceArn: \(Swift.String(describing: rdsDbInstanceArn)), stackId: \(Swift.String(describing: stackId)))"}
}

extension RegisterRdsDbInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case rdsDbInstanceArn = "RdsDbInstanceArn"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbPassword = dbPassword {
            try encodeContainer.encode(dbPassword, forKey: .dbPassword)
        }
        if let dbUser = dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if let rdsDbInstanceArn = rdsDbInstanceArn {
            try encodeContainer.encode(rdsDbInstanceArn, forKey: .rdsDbInstanceArn)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct RegisterRdsDbInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterRdsDbInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterRdsDbInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterRdsDbInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterRdsDbInstanceOutputError>
}

public struct RegisterRdsDbInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterRdsDbInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterRdsDbInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterRdsDbInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterRdsDbInstanceOutputError>
}

public struct RegisterRdsDbInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterRdsDbInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RegisterRdsDbInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterRdsDbInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterRdsDbInstanceOutputError>
}

public struct RegisterRdsDbInstanceInput: Swift.Equatable {
    /// The database password.
    /// This member is required.
    public var dbPassword: Swift.String?
    /// The database's master user name.
    /// This member is required.
    public var dbUser: Swift.String?
    /// The Amazon RDS instance's ARN.
    /// This member is required.
    public var rdsDbInstanceArn: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init (
        dbPassword: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        rdsDbInstanceArn: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.dbPassword = dbPassword
        self.dbUser = dbUser
        self.rdsDbInstanceArn = rdsDbInstanceArn
        self.stackId = stackId
    }
}

struct RegisterRdsDbInstanceInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let rdsDbInstanceArn: Swift.String?
    public let dbUser: Swift.String?
    public let dbPassword: Swift.String?
}

extension RegisterRdsDbInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case rdsDbInstanceArn = "RdsDbInstanceArn"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let rdsDbInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rdsDbInstanceArn)
        rdsDbInstanceArn = rdsDbInstanceArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let dbPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbPassword)
        dbPassword = dbPasswordDecoded
    }
}

extension RegisterRdsDbInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterRdsDbInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterRdsDbInstanceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterRdsDbInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterRdsDbInstanceOutputResponse()"}
}

extension RegisterRdsDbInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RegisterRdsDbInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct RegisterRdsDbInstanceOutputResponseBody: Swift.Equatable {
}

extension RegisterRdsDbInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct RegisterVolumeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterVolumeOutputError>
}

extension RegisterVolumeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterVolumeInput(ec2VolumeId: \(Swift.String(describing: ec2VolumeId)), stackId: \(Swift.String(describing: stackId)))"}
}

extension RegisterVolumeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2VolumeId = "Ec2VolumeId"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2VolumeId = ec2VolumeId {
            try encodeContainer.encode(ec2VolumeId, forKey: .ec2VolumeId)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct RegisterVolumeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterVolumeOutputError>
}

public struct RegisterVolumeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterVolumeOutputError>
}

public struct RegisterVolumeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterVolumeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RegisterVolumeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterVolumeInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterVolumeOutputError>
}

public struct RegisterVolumeInput: Swift.Equatable {
    /// The Amazon EBS volume ID.
    public var ec2VolumeId: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init (
        ec2VolumeId: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.ec2VolumeId = ec2VolumeId
        self.stackId = stackId
    }
}

struct RegisterVolumeInputBody: Swift.Equatable {
    public let ec2VolumeId: Swift.String?
    public let stackId: Swift.String?
}

extension RegisterVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2VolumeId = "Ec2VolumeId"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2VolumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2VolumeId)
        ec2VolumeId = ec2VolumeIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension RegisterVolumeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterVolumeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterVolumeOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterVolumeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterVolumeOutputResponse(volumeId: \(Swift.String(describing: volumeId)))"}
}

extension RegisterVolumeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterVolumeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.volumeId = output.volumeId
        } else {
            self.volumeId = nil
        }
    }
}

/// Contains the response to a RegisterVolume request.
public struct RegisterVolumeOutputResponse: Swift.Equatable {
    /// The volume ID.
    public var volumeId: Swift.String?

    public init (
        volumeId: Swift.String? = nil
    )
    {
        self.volumeId = volumeId
    }
}

struct RegisterVolumeOutputResponseBody: Swift.Equatable {
    public let volumeId: Swift.String?
}

extension RegisterVolumeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeId = "VolumeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
    }
}

extension OpsWorksClientTypes.ReportedOs: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case family = "Family"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let family = family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension OpsWorksClientTypes.ReportedOs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReportedOs(family: \(Swift.String(describing: family)), name: \(Swift.String(describing: name)), version: \(Swift.String(describing: version)))"}
}

extension OpsWorksClientTypes {
    /// A registered instance's reported operating system.
    public struct ReportedOs: Swift.Equatable {
        /// The operating system family.
        public var family: Swift.String?
        /// The operating system name.
        public var name: Swift.String?
        /// The operating system version.
        public var version: Swift.String?

        public init (
            family: Swift.String? = nil,
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.family = family
            self.name = name
            self.version = version
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsWorksClientTypes {
    public enum RootDeviceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ebs
        case instanceStore
        case sdkUnknown(Swift.String)

        public static var allCases: [RootDeviceType] {
            return [
                .ebs,
                .instanceStore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ebs: return "ebs"
            case .instanceStore: return "instance-store"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RootDeviceType(rawValue: rawValue) ?? RootDeviceType.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.SelfUserProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArn = "IamUserArn"
        case name = "Name"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let sshUsername = sshUsername {
            try encodeContainer.encode(sshUsername, forKey: .sshUsername)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sshUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshUsername)
        sshUsername = sshUsernameDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension OpsWorksClientTypes.SelfUserProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SelfUserProfile(iamUserArn: \(Swift.String(describing: iamUserArn)), name: \(Swift.String(describing: name)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), sshUsername: \(Swift.String(describing: sshUsername)))"}
}

extension OpsWorksClientTypes {
    /// Describes a user's SSH information.
    public struct SelfUserProfile: Swift.Equatable {
        /// The user's IAM ARN.
        public var iamUserArn: Swift.String?
        /// The user's name.
        public var name: Swift.String?
        /// The user's SSH public key.
        public var sshPublicKey: Swift.String?
        /// The user's SSH user name.
        public var sshUsername: Swift.String?

        public init (
            iamUserArn: Swift.String? = nil,
            name: Swift.String? = nil,
            sshPublicKey: Swift.String? = nil,
            sshUsername: Swift.String? = nil
        )
        {
            self.iamUserArn = iamUserArn
            self.name = name
            self.sshPublicKey = sshPublicKey
            self.sshUsername = sshUsername
        }
    }

}

extension OpsWorksClientTypes.ServiceError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case instanceId = "InstanceId"
        case message = "Message"
        case serviceErrorId = "ServiceErrorId"
        case stackId = "StackId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let serviceErrorId = serviceErrorId {
            try encodeContainer.encode(serviceErrorId, forKey: .serviceErrorId)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceErrorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceErrorId)
        serviceErrorId = serviceErrorIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension OpsWorksClientTypes.ServiceError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceError(createdAt: \(Swift.String(describing: createdAt)), instanceId: \(Swift.String(describing: instanceId)), message: \(Swift.String(describing: message)), serviceErrorId: \(Swift.String(describing: serviceErrorId)), stackId: \(Swift.String(describing: stackId)), type: \(Swift.String(describing: type)))"}
}

extension OpsWorksClientTypes {
    /// Describes an AWS OpsWorks Stacks service error.
    public struct ServiceError: Swift.Equatable {
        /// When the error occurred.
        public var createdAt: Swift.String?
        /// The instance ID.
        public var instanceId: Swift.String?
        /// A message that describes the error.
        public var message: Swift.String?
        /// The error ID.
        public var serviceErrorId: Swift.String?
        /// The stack ID.
        public var stackId: Swift.String?
        /// The error type.
        public var type: Swift.String?

        public init (
            createdAt: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            message: Swift.String? = nil,
            serviceErrorId: Swift.String? = nil,
            stackId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.instanceId = instanceId
            self.message = message
            self.serviceErrorId = serviceErrorId
            self.stackId = stackId
            self.type = type
        }
    }

}

public struct SetLoadBasedAutoScalingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetLoadBasedAutoScalingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetLoadBasedAutoScalingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetLoadBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetLoadBasedAutoScalingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetLoadBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetLoadBasedAutoScalingOutputError>
}

extension SetLoadBasedAutoScalingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetLoadBasedAutoScalingInput(downScaling: \(Swift.String(describing: downScaling)), enable: \(Swift.String(describing: enable)), layerId: \(Swift.String(describing: layerId)), upScaling: \(Swift.String(describing: upScaling)))"}
}

extension SetLoadBasedAutoScalingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downScaling = "DownScaling"
        case enable = "Enable"
        case layerId = "LayerId"
        case upScaling = "UpScaling"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let downScaling = downScaling {
            try encodeContainer.encode(downScaling, forKey: .downScaling)
        }
        if let enable = enable {
            try encodeContainer.encode(enable, forKey: .enable)
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let upScaling = upScaling {
            try encodeContainer.encode(upScaling, forKey: .upScaling)
        }
    }
}

public struct SetLoadBasedAutoScalingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetLoadBasedAutoScalingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetLoadBasedAutoScalingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetLoadBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetLoadBasedAutoScalingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetLoadBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetLoadBasedAutoScalingOutputError>
}

public struct SetLoadBasedAutoScalingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetLoadBasedAutoScalingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetLoadBasedAutoScalingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetLoadBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetLoadBasedAutoScalingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetLoadBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetLoadBasedAutoScalingOutputError>
}

public struct SetLoadBasedAutoScalingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetLoadBasedAutoScalingInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SetLoadBasedAutoScalingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetLoadBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SetLoadBasedAutoScalingInput
    public typealias MOutput = ClientRuntime.OperationOutput<SetLoadBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetLoadBasedAutoScalingOutputError>
}

public struct SetLoadBasedAutoScalingInput: Swift.Equatable {
    /// An AutoScalingThresholds object with the downscaling threshold configuration. If
    ///       the load falls below these thresholds for a specified amount of time, AWS OpsWorks Stacks stops a specified
    ///       number of instances.
    public var downScaling: OpsWorksClientTypes.AutoScalingThresholds?
    /// Enables load-based auto scaling for the layer.
    public var enable: Swift.Bool?
    /// The layer ID.
    /// This member is required.
    public var layerId: Swift.String?
    /// An AutoScalingThresholds object with the upscaling threshold configuration. If
    ///       the load exceeds these thresholds for a specified amount of time, AWS OpsWorks Stacks starts a specified
    ///       number of instances.
    public var upScaling: OpsWorksClientTypes.AutoScalingThresholds?

    public init (
        downScaling: OpsWorksClientTypes.AutoScalingThresholds? = nil,
        enable: Swift.Bool? = nil,
        layerId: Swift.String? = nil,
        upScaling: OpsWorksClientTypes.AutoScalingThresholds? = nil
    )
    {
        self.downScaling = downScaling
        self.enable = enable
        self.layerId = layerId
        self.upScaling = upScaling
    }
}

struct SetLoadBasedAutoScalingInputBody: Swift.Equatable {
    public let layerId: Swift.String?
    public let enable: Swift.Bool?
    public let upScaling: OpsWorksClientTypes.AutoScalingThresholds?
    public let downScaling: OpsWorksClientTypes.AutoScalingThresholds?
}

extension SetLoadBasedAutoScalingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downScaling = "DownScaling"
        case enable = "Enable"
        case layerId = "LayerId"
        case upScaling = "UpScaling"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let enableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enable)
        enable = enableDecoded
        let upScalingDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AutoScalingThresholds.self, forKey: .upScaling)
        upScaling = upScalingDecoded
        let downScalingDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AutoScalingThresholds.self, forKey: .downScaling)
        downScaling = downScalingDecoded
    }
}

extension SetLoadBasedAutoScalingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetLoadBasedAutoScalingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetLoadBasedAutoScalingOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetLoadBasedAutoScalingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetLoadBasedAutoScalingOutputResponse()"}
}

extension SetLoadBasedAutoScalingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetLoadBasedAutoScalingOutputResponse: Swift.Equatable {

    public init() {}
}

struct SetLoadBasedAutoScalingOutputResponseBody: Swift.Equatable {
}

extension SetLoadBasedAutoScalingOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct SetPermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetPermissionOutputError>
}

extension SetPermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetPermissionInput(allowSsh: \(Swift.String(describing: allowSsh)), allowSudo: \(Swift.String(describing: allowSudo)), iamUserArn: \(Swift.String(describing: iamUserArn)), level: \(Swift.String(describing: level)), stackId: \(Swift.String(describing: stackId)))"}
}

extension SetPermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSsh = "AllowSsh"
        case allowSudo = "AllowSudo"
        case iamUserArn = "IamUserArn"
        case level = "Level"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSsh = allowSsh {
            try encodeContainer.encode(allowSsh, forKey: .allowSsh)
        }
        if let allowSudo = allowSudo {
            try encodeContainer.encode(allowSudo, forKey: .allowSudo)
        }
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let level = level {
            try encodeContainer.encode(level, forKey: .level)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct SetPermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetPermissionOutputError>
}

public struct SetPermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetPermissionOutputError>
}

public struct SetPermissionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetPermissionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SetPermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SetPermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<SetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetPermissionOutputError>
}

public struct SetPermissionInput: Swift.Equatable {
    /// The user is allowed to use SSH to communicate with the instance.
    public var allowSsh: Swift.Bool?
    /// The user is allowed to use sudo to elevate privileges.
    public var allowSudo: Swift.Bool?
    /// The user's IAM ARN. This can also be a federated user's ARN.
    /// This member is required.
    public var iamUserArn: Swift.String?
    /// The user's permission level, which must be set to one of the following strings. You cannot set your own permissions level.
    ///
    ///
    ///
    ///                   deny
    ///
    ///
    ///
    ///
    ///                   show
    ///
    ///
    ///
    ///
    ///                   deploy
    ///
    ///
    ///
    ///
    ///                   manage
    ///
    ///
    ///
    ///
    ///                   iam_only
    ///
    ///
    ///
    ///          For more information about the permissions associated with these levels, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/opsworks-security-users.html">Managing User Permissions.
    public var level: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init (
        allowSsh: Swift.Bool? = nil,
        allowSudo: Swift.Bool? = nil,
        iamUserArn: Swift.String? = nil,
        level: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.allowSsh = allowSsh
        self.allowSudo = allowSudo
        self.iamUserArn = iamUserArn
        self.level = level
        self.stackId = stackId
    }
}

struct SetPermissionInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let iamUserArn: Swift.String?
    public let allowSsh: Swift.Bool?
    public let allowSudo: Swift.Bool?
    public let level: Swift.String?
}

extension SetPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSsh = "AllowSsh"
        case allowSudo = "AllowSudo"
        case iamUserArn = "IamUserArn"
        case level = "Level"
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let allowSshDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSsh)
        allowSsh = allowSshDecoded
        let allowSudoDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSudo)
        allowSudo = allowSudoDecoded
        let levelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .level)
        level = levelDecoded
    }
}

extension SetPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetPermissionOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetPermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetPermissionOutputResponse()"}
}

extension SetPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetPermissionOutputResponse: Swift.Equatable {

    public init() {}
}

struct SetPermissionOutputResponseBody: Swift.Equatable {
}

extension SetPermissionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct SetTimeBasedAutoScalingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetTimeBasedAutoScalingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetTimeBasedAutoScalingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetTimeBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetTimeBasedAutoScalingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetTimeBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetTimeBasedAutoScalingOutputError>
}

extension SetTimeBasedAutoScalingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetTimeBasedAutoScalingInput(autoScalingSchedule: \(Swift.String(describing: autoScalingSchedule)), instanceId: \(Swift.String(describing: instanceId)))"}
}

extension SetTimeBasedAutoScalingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingSchedule = "AutoScalingSchedule"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingSchedule = autoScalingSchedule {
            try encodeContainer.encode(autoScalingSchedule, forKey: .autoScalingSchedule)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct SetTimeBasedAutoScalingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetTimeBasedAutoScalingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetTimeBasedAutoScalingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetTimeBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetTimeBasedAutoScalingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetTimeBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetTimeBasedAutoScalingOutputError>
}

public struct SetTimeBasedAutoScalingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetTimeBasedAutoScalingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetTimeBasedAutoScalingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetTimeBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetTimeBasedAutoScalingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetTimeBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetTimeBasedAutoScalingOutputError>
}

public struct SetTimeBasedAutoScalingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetTimeBasedAutoScalingInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SetTimeBasedAutoScalingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetTimeBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SetTimeBasedAutoScalingInput
    public typealias MOutput = ClientRuntime.OperationOutput<SetTimeBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetTimeBasedAutoScalingOutputError>
}

public struct SetTimeBasedAutoScalingInput: Swift.Equatable {
    /// An AutoScalingSchedule with the instance schedule.
    public var autoScalingSchedule: OpsWorksClientTypes.WeeklyAutoScalingSchedule?
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        autoScalingSchedule: OpsWorksClientTypes.WeeklyAutoScalingSchedule? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.autoScalingSchedule = autoScalingSchedule
        self.instanceId = instanceId
    }
}

struct SetTimeBasedAutoScalingInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let autoScalingSchedule: OpsWorksClientTypes.WeeklyAutoScalingSchedule?
}

extension SetTimeBasedAutoScalingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingSchedule = "AutoScalingSchedule"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let autoScalingScheduleDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.WeeklyAutoScalingSchedule.self, forKey: .autoScalingSchedule)
        autoScalingSchedule = autoScalingScheduleDecoded
    }
}

extension SetTimeBasedAutoScalingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetTimeBasedAutoScalingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetTimeBasedAutoScalingOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetTimeBasedAutoScalingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetTimeBasedAutoScalingOutputResponse()"}
}

extension SetTimeBasedAutoScalingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetTimeBasedAutoScalingOutputResponse: Swift.Equatable {

    public init() {}
}

struct SetTimeBasedAutoScalingOutputResponseBody: Swift.Equatable {
}

extension SetTimeBasedAutoScalingOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension OpsWorksClientTypes.ShutdownEventConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delayUntilElbConnectionsDrained = "DelayUntilElbConnectionsDrained"
        case executionTimeout = "ExecutionTimeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delayUntilElbConnectionsDrained = delayUntilElbConnectionsDrained {
            try encodeContainer.encode(delayUntilElbConnectionsDrained, forKey: .delayUntilElbConnectionsDrained)
        }
        if let executionTimeout = executionTimeout {
            try encodeContainer.encode(executionTimeout, forKey: .executionTimeout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionTimeout)
        executionTimeout = executionTimeoutDecoded
        let delayUntilElbConnectionsDrainedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .delayUntilElbConnectionsDrained)
        delayUntilElbConnectionsDrained = delayUntilElbConnectionsDrainedDecoded
    }
}

extension OpsWorksClientTypes.ShutdownEventConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ShutdownEventConfiguration(delayUntilElbConnectionsDrained: \(Swift.String(describing: delayUntilElbConnectionsDrained)), executionTimeout: \(Swift.String(describing: executionTimeout)))"}
}

extension OpsWorksClientTypes {
    /// The Shutdown event configuration.
    public struct ShutdownEventConfiguration: Swift.Equatable {
        /// Whether to enable Elastic Load Balancing connection draining. For more information, see <a href="https://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/TerminologyandKeyConcepts.html#conn-drain">Connection Draining
        ///
        public var delayUntilElbConnectionsDrained: Swift.Bool?
        /// The time, in seconds, that AWS OpsWorks Stacks will wait after triggering a Shutdown event before shutting down an instance.
        public var executionTimeout: Swift.Int?

        public init (
            delayUntilElbConnectionsDrained: Swift.Bool? = nil,
            executionTimeout: Swift.Int? = nil
        )
        {
            self.delayUntilElbConnectionsDrained = delayUntilElbConnectionsDrained
            self.executionTimeout = executionTimeout
        }
    }

}

extension OpsWorksClientTypes.Source: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case revision = "Revision"
        case sshKey = "SshKey"
        case type = "Type"
        case url = "Url"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let sshKey = sshKey {
            try encodeContainer.encode(sshKey, forKey: .sshKey)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.SourceType.self, forKey: .type)
        type = typeDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let sshKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshKey)
        sshKey = sshKeyDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension OpsWorksClientTypes.Source: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Source(password: \(Swift.String(describing: password)), revision: \(Swift.String(describing: revision)), sshKey: \(Swift.String(describing: sshKey)), type: \(Swift.String(describing: type)), url: \(Swift.String(describing: url)), username: \(Swift.String(describing: username)))"}
}

extension OpsWorksClientTypes {
    /// Contains the information required to retrieve an app or cookbook from a repository. For more
    ///       information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html">Creating Apps or <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html">Custom Recipes and
    ///         Cookbooks.
    public struct Source: Swift.Equatable {
        /// When included in a request, the parameter depends on the repository type.
        ///
        ///
        ///                For Amazon S3 bundles, set Password to the appropriate IAM secret access
        ///         key.
        ///
        ///
        ///                For HTTP bundles and Subversion repositories, set Password to the
        ///         password.
        ///
        ///
        ///          For more information on how to safely handle IAM credentials, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html">https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html.
        ///          In responses, AWS OpsWorks Stacks returns *****FILTERED***** instead of the actual value.
        public var password: Swift.String?
        /// The application's version. AWS OpsWorks Stacks enables you to easily deploy new versions of an application. One of the simplest approaches is to have branches or revisions in your repository that represent different versions that can potentially be deployed.
        public var revision: Swift.String?
        /// In requests, the repository's SSH key.
        ///          In responses, AWS OpsWorks Stacks returns *****FILTERED***** instead of the actual value.
        public var sshKey: Swift.String?
        /// The repository type.
        public var type: OpsWorksClientTypes.SourceType?
        /// The source URL. The following is an example of an Amazon S3 source URL:  https://s3.amazonaws.com/opsworks-demo-bucket/opsworks_cookbook_demo.tar.gz.
        public var url: Swift.String?
        /// This parameter depends on the repository type.
        ///
        ///
        ///                For Amazon S3 bundles, set Username to the appropriate IAM access key
        ///         ID.
        ///
        ///
        ///                For HTTP bundles, Git repositories, and Subversion repositories, set Username
        ///         to the user name.
        ///
        ///
        public var username: Swift.String?

        public init (
            password: Swift.String? = nil,
            revision: Swift.String? = nil,
            sshKey: Swift.String? = nil,
            type: OpsWorksClientTypes.SourceType? = nil,
            url: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.revision = revision
            self.sshKey = sshKey
            self.type = type
            self.url = url
            self.username = username
        }
    }

}

extension OpsWorksClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archive
        case git
        case s3
        case svn
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .archive,
                .git,
                .s3,
                .svn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archive: return "archive"
            case .git: return "git"
            case .s3: return "s3"
            case .svn: return "svn"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.SslConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case chain = "Chain"
        case privateKey = "PrivateKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let chain = chain {
            try encodeContainer.encode(chain, forKey: .chain)
        }
        if let privateKey = privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
        let chainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chain)
        chain = chainDecoded
    }
}

extension OpsWorksClientTypes.SslConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SslConfiguration(certificate: \(Swift.String(describing: certificate)), chain: \(Swift.String(describing: chain)), privateKey: \(Swift.String(describing: privateKey)))"}
}

extension OpsWorksClientTypes {
    /// Describes an app's SSL configuration.
    public struct SslConfiguration: Swift.Equatable {
        /// The contents of the certificate's domain.crt file.
        /// This member is required.
        public var certificate: Swift.String?
        /// Optional. Can be used to specify an intermediate certificate authority key or client authentication.
        public var chain: Swift.String?
        /// The private key; the contents of the certificate's domain.kex file.
        /// This member is required.
        public var privateKey: Swift.String?

        public init (
            certificate: Swift.String? = nil,
            chain: Swift.String? = nil,
            privateKey: Swift.String? = nil
        )
        {
            self.certificate = certificate
            self.chain = chain
            self.privateKey = privateKey
        }
    }

}

extension OpsWorksClientTypes.Stack: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case arn = "Arn"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case configurationManager = "ConfigurationManager"
        case createdAt = "CreatedAt"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case region = "Region"
        case serviceRoleArn = "ServiceRoleArn"
        case stackId = "StackId"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, stackattributes0) in attributes {
                try attributesContainer.encode(stackattributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let chefConfiguration = chefConfiguration {
            try encodeContainer.encode(chefConfiguration, forKey: .chefConfiguration)
        }
        if let configurationManager = configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let customCookbooksSource = customCookbooksSource {
            try encodeContainer.encode(customCookbooksSource, forKey: .customCookbooksSource)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let defaultAvailabilityZone = defaultAvailabilityZone {
            try encodeContainer.encode(defaultAvailabilityZone, forKey: .defaultAvailabilityZone)
        }
        if let defaultInstanceProfileArn = defaultInstanceProfileArn {
            try encodeContainer.encode(defaultInstanceProfileArn, forKey: .defaultInstanceProfileArn)
        }
        if let defaultOs = defaultOs {
            try encodeContainer.encode(defaultOs, forKey: .defaultOs)
        }
        if let defaultRootDeviceType = defaultRootDeviceType {
            try encodeContainer.encode(defaultRootDeviceType.rawValue, forKey: .defaultRootDeviceType)
        }
        if let defaultSshKeyName = defaultSshKeyName {
            try encodeContainer.encode(defaultSshKeyName, forKey: .defaultSshKeyName)
        }
        if let defaultSubnetId = defaultSubnetId {
            try encodeContainer.encode(defaultSubnetId, forKey: .defaultSubnetId)
        }
        if let hostnameTheme = hostnameTheme {
            try encodeContainer.encode(hostnameTheme, forKey: .hostnameTheme)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let useCustomCookbooks = useCustomCookbooks {
            try encodeContainer.encode(useCustomCookbooks, forKey: .useCustomCookbooks)
        }
        if let useOpsworksSecurityGroups = useOpsworksSecurityGroups {
            try encodeContainer.encode(useOpsworksSecurityGroups, forKey: .useOpsworksSecurityGroups)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let defaultInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultInstanceProfileArn)
        defaultInstanceProfileArn = defaultInstanceProfileArnDecoded
        let defaultOsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOs)
        defaultOs = defaultOsDecoded
        let hostnameThemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostnameTheme)
        hostnameTheme = hostnameThemeDecoded
        let defaultAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultAvailabilityZone)
        defaultAvailabilityZone = defaultAvailabilityZoneDecoded
        let defaultSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSubnetId)
        defaultSubnetId = defaultSubnetIdDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
        let chefConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.ChefConfiguration.self, forKey: .chefConfiguration)
        chefConfiguration = chefConfigurationDecoded
        let useCustomCookbooksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useCustomCookbooks)
        useCustomCookbooks = useCustomCookbooksDecoded
        let useOpsworksSecurityGroupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useOpsworksSecurityGroups)
        useOpsworksSecurityGroups = useOpsworksSecurityGroupsDecoded
        let customCookbooksSourceDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Source.self, forKey: .customCookbooksSource)
        customCookbooksSource = customCookbooksSourceDecoded
        let defaultSshKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSshKeyName)
        defaultSshKeyName = defaultSshKeyNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let defaultRootDeviceTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.RootDeviceType.self, forKey: .defaultRootDeviceType)
        defaultRootDeviceType = defaultRootDeviceTypeDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension OpsWorksClientTypes.Stack: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Stack(agentVersion: \(Swift.String(describing: agentVersion)), arn: \(Swift.String(describing: arn)), attributes: \(Swift.String(describing: attributes)), chefConfiguration: \(Swift.String(describing: chefConfiguration)), configurationManager: \(Swift.String(describing: configurationManager)), createdAt: \(Swift.String(describing: createdAt)), customCookbooksSource: \(Swift.String(describing: customCookbooksSource)), customJson: \(Swift.String(describing: customJson)), defaultAvailabilityZone: \(Swift.String(describing: defaultAvailabilityZone)), defaultInstanceProfileArn: \(Swift.String(describing: defaultInstanceProfileArn)), defaultOs: \(Swift.String(describing: defaultOs)), defaultRootDeviceType: \(Swift.String(describing: defaultRootDeviceType)), defaultSshKeyName: \(Swift.String(describing: defaultSshKeyName)), defaultSubnetId: \(Swift.String(describing: defaultSubnetId)), hostnameTheme: \(Swift.String(describing: hostnameTheme)), name: \(Swift.String(describing: name)), region: \(Swift.String(describing: region)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), stackId: \(Swift.String(describing: stackId)), useCustomCookbooks: \(Swift.String(describing: useCustomCookbooks)), useOpsworksSecurityGroups: \(Swift.String(describing: useOpsworksSecurityGroups)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension OpsWorksClientTypes {
    /// Describes a stack.
    public struct Stack: Swift.Equatable {
        /// The agent version. This parameter is set to LATEST for auto-update.
        ///       or a version number for a fixed agent version.
        public var agentVersion: Swift.String?
        /// The stack's ARN.
        public var arn: Swift.String?
        /// The stack's attributes.
        public var attributes: [Swift.String:Swift.String]?
        /// A ChefConfiguration object that specifies whether to enable Berkshelf and the
        ///       Berkshelf version. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html">Create a New Stack.
        public var chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
        /// The configuration manager.
        public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
        /// The date when the stack was created.
        public var createdAt: Swift.String?
        /// Contains the information required to retrieve an app or cookbook from a repository. For more information,
        ///             see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html">Adding Apps or
        ///             <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html">Cookbooks and Recipes.
        public var customCookbooksSource: OpsWorksClientTypes.Source?
        /// A JSON object that contains user-defined attributes to be added to the stack configuration and deployment attributes. You can use custom JSON to override the corresponding default stack configuration attribute values or to pass data to recipes. The string should be in the following format:
        ///
        ///             "{\"key1\": \"value1\", \"key2\": \"value2\",...}"
        ///
        ///          For more information on custom JSON, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html">Use Custom JSON to
        ///         Modify the Stack Configuration Attributes.
        public var customJson: Swift.String?
        /// The stack's default Availability Zone. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints.
        public var defaultAvailabilityZone: Swift.String?
        /// The ARN of an IAM profile that is the default profile for all of the stack's EC2 instances.
        ///       For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
        ///       Identifiers.
        public var defaultInstanceProfileArn: Swift.String?
        /// The stack's default operating system.
        public var defaultOs: Swift.String?
        /// The default root device type. This value is used by default for all instances in the stack,
        ///       but you can override it when you create an instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device">Storage for the Root Device.
        public var defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
        /// A default Amazon EC2 key pair for the stack's instances. You can override this value when you create or update an instance.
        public var defaultSshKeyName: Swift.String?
        /// The default subnet ID; applicable only if the stack is running in a VPC.
        public var defaultSubnetId: Swift.String?
        /// The stack host name theme, with spaces replaced by underscores.
        public var hostnameTheme: Swift.String?
        /// The stack name.
        public var name: Swift.String?
        /// The stack AWS region, such as "ap-northeast-2". For more information about AWS regions, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints.
        public var region: Swift.String?
        /// The stack AWS Identity and Access Management (IAM) role.
        public var serviceRoleArn: Swift.String?
        /// The stack ID.
        public var stackId: Swift.String?
        /// Whether the stack uses custom cookbooks.
        public var useCustomCookbooks: Swift.Bool?
        /// Whether the stack automatically associates the AWS OpsWorks Stacks built-in security groups with the stack's layers.
        public var useOpsworksSecurityGroups: Swift.Bool?
        /// The VPC ID; applicable only if the stack is running in a VPC.
        public var vpcId: Swift.String?

        public init (
            agentVersion: Swift.String? = nil,
            arn: Swift.String? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            chefConfiguration: OpsWorksClientTypes.ChefConfiguration? = nil,
            configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
            createdAt: Swift.String? = nil,
            customCookbooksSource: OpsWorksClientTypes.Source? = nil,
            customJson: Swift.String? = nil,
            defaultAvailabilityZone: Swift.String? = nil,
            defaultInstanceProfileArn: Swift.String? = nil,
            defaultOs: Swift.String? = nil,
            defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
            defaultSshKeyName: Swift.String? = nil,
            defaultSubnetId: Swift.String? = nil,
            hostnameTheme: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil,
            serviceRoleArn: Swift.String? = nil,
            stackId: Swift.String? = nil,
            useCustomCookbooks: Swift.Bool? = nil,
            useOpsworksSecurityGroups: Swift.Bool? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.agentVersion = agentVersion
            self.arn = arn
            self.attributes = attributes
            self.chefConfiguration = chefConfiguration
            self.configurationManager = configurationManager
            self.createdAt = createdAt
            self.customCookbooksSource = customCookbooksSource
            self.customJson = customJson
            self.defaultAvailabilityZone = defaultAvailabilityZone
            self.defaultInstanceProfileArn = defaultInstanceProfileArn
            self.defaultOs = defaultOs
            self.defaultRootDeviceType = defaultRootDeviceType
            self.defaultSshKeyName = defaultSshKeyName
            self.defaultSubnetId = defaultSubnetId
            self.hostnameTheme = hostnameTheme
            self.name = name
            self.region = region
            self.serviceRoleArn = serviceRoleArn
            self.stackId = stackId
            self.useCustomCookbooks = useCustomCookbooks
            self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
            self.vpcId = vpcId
        }
    }

}

extension OpsWorksClientTypes {
    public enum StackAttributesKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case color
        case sdkUnknown(Swift.String)

        public static var allCases: [StackAttributesKeys] {
            return [
                .color,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .color: return "Color"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StackAttributesKeys(rawValue: rawValue) ?? StackAttributesKeys.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.StackConfigurationManager: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension OpsWorksClientTypes.StackConfigurationManager: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StackConfigurationManager(name: \(Swift.String(describing: name)), version: \(Swift.String(describing: version)))"}
}

extension OpsWorksClientTypes {
    /// Describes the configuration manager.
    public struct StackConfigurationManager: Swift.Equatable {
        /// The name. This parameter must be set to "Chef".
        public var name: Swift.String?
        /// The Chef version. This parameter must be set to 12, 11.10, or 11.4 for Linux stacks, and to 12.2 for Windows stacks. The default value for Linux stacks is 11.4.
        public var version: Swift.String?

        public init (
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension OpsWorksClientTypes.StackSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsCount = "AppsCount"
        case arn = "Arn"
        case instancesCount = "InstancesCount"
        case layersCount = "LayersCount"
        case name = "Name"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appsCount = appsCount {
            try encodeContainer.encode(appsCount, forKey: .appsCount)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let instancesCount = instancesCount {
            try encodeContainer.encode(instancesCount, forKey: .instancesCount)
        }
        if let layersCount = layersCount {
            try encodeContainer.encode(layersCount, forKey: .layersCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let layersCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .layersCount)
        layersCount = layersCountDecoded
        let appsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .appsCount)
        appsCount = appsCountDecoded
        let instancesCountDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.InstancesCount.self, forKey: .instancesCount)
        instancesCount = instancesCountDecoded
    }
}

extension OpsWorksClientTypes.StackSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StackSummary(appsCount: \(Swift.String(describing: appsCount)), arn: \(Swift.String(describing: arn)), instancesCount: \(Swift.String(describing: instancesCount)), layersCount: \(Swift.String(describing: layersCount)), name: \(Swift.String(describing: name)), stackId: \(Swift.String(describing: stackId)))"}
}

extension OpsWorksClientTypes {
    /// Summarizes the number of layers, instances, and apps in a stack.
    public struct StackSummary: Swift.Equatable {
        /// The number of apps.
        public var appsCount: Swift.Int?
        /// The stack's ARN.
        public var arn: Swift.String?
        /// An InstancesCount object with the number of instances in each status.
        public var instancesCount: OpsWorksClientTypes.InstancesCount?
        /// The number of layers.
        public var layersCount: Swift.Int?
        /// The stack name.
        public var name: Swift.String?
        /// The stack ID.
        public var stackId: Swift.String?

        public init (
            appsCount: Swift.Int? = nil,
            arn: Swift.String? = nil,
            instancesCount: OpsWorksClientTypes.InstancesCount? = nil,
            layersCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            stackId: Swift.String? = nil
        )
        {
            self.appsCount = appsCount
            self.arn = arn
            self.instancesCount = instancesCount
            self.layersCount = layersCount
            self.name = name
            self.stackId = stackId
        }
    }

}

public struct StartInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartInstanceOutputError>
}

extension StartInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartInstanceInput(instanceId: \(Swift.String(describing: instanceId)))"}
}

extension StartInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct StartInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartInstanceOutputError>
}

public struct StartInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartInstanceOutputError>
}

public struct StartInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartInstanceOutputError>
}

public struct StartInstanceInput: Swift.Equatable {
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct StartInstanceInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
}

extension StartInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension StartInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartInstanceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartInstanceOutputResponse()"}
}

extension StartInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct StartInstanceOutputResponseBody: Swift.Equatable {
}

extension StartInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct StartStackInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartStackOutputError>
}

extension StartStackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartStackInput(stackId: \(Swift.String(describing: stackId)))"}
}

extension StartStackInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct StartStackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartStackOutputError>
}

public struct StartStackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartStackOutputError>
}

public struct StartStackInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStackInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartStackOutputError>
}

public struct StartStackInput: Swift.Equatable {
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init (
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct StartStackInputBody: Swift.Equatable {
    public let stackId: Swift.String?
}

extension StartStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension StartStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartStackOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartStackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartStackOutputResponse()"}
}

extension StartStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartStackOutputResponse: Swift.Equatable {

    public init() {}
}

struct StartStackOutputResponseBody: Swift.Equatable {
}

extension StartStackOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct StopInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopInstanceOutputError>
}

extension StopInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopInstanceInput(force: \(Swift.String(describing: force)), instanceId: \(Swift.String(describing: instanceId)))"}
}

extension StopInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force = "Force"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let force = force {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct StopInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopInstanceOutputError>
}

public struct StopInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopInstanceOutputError>
}

public struct StopInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StopInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopInstanceOutputError>
}

public struct StopInstanceInput: Swift.Equatable {
    /// Specifies whether to force an instance to stop. If the instance's root device type is ebs, or EBS-backed,
    ///             adding the Force parameter to the StopInstances API call disassociates the AWS OpsWorks Stacks instance from EC2, and forces deletion of only the OpsWorks Stacks instance.
    ///             You must also delete the formerly-associated instance in EC2 after troubleshooting and replacing the AWS OpsWorks Stacks instance with a new one.
    public var force: Swift.Bool?
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        force: Swift.Bool? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.force = force
        self.instanceId = instanceId
    }
}

struct StopInstanceInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let force: Swift.Bool?
}

extension StopInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force = "Force"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let forceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension StopInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopInstanceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopInstanceOutputResponse()"}
}

extension StopInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopInstanceOutputResponseBody: Swift.Equatable {
}

extension StopInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct StopStackInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopStackOutputError>
}

extension StopStackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopStackInput(stackId: \(Swift.String(describing: stackId)))"}
}

extension StopStackInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct StopStackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopStackOutputError>
}

public struct StopStackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopStackOutputError>
}

public struct StopStackInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopStackInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StopStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopStackOutputError>
}

public struct StopStackInput: Swift.Equatable {
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init (
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct StopStackInputBody: Swift.Equatable {
    public let stackId: Swift.String?
}

extension StopStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension StopStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopStackOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopStackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopStackOutputResponse()"}
}

extension StopStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopStackOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopStackOutputResponseBody: Swift.Equatable {
}

extension StopStackOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The stack or layer's Amazon Resource Number (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map that contains tag keys and tag values that are attached to a stack or layer.
    ///
    ///
    ///                The key cannot be empty.
    ///
    ///
    ///                The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
    ///
    ///
    ///
    ///                The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
    ///
    ///
    ///
    ///                Leading and trailing white spaces are trimmed from both the key and value.
    ///
    ///
    ///                A maximum of 40 tags is allowed for any resource.
    ///
    ///
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension OpsWorksClientTypes.TemporaryCredential: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case password = "Password"
        case username = "Username"
        case validForInMinutes = "ValidForInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
        if let validForInMinutes = validForInMinutes {
            try encodeContainer.encode(validForInMinutes, forKey: .validForInMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let validForInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validForInMinutes)
        validForInMinutes = validForInMinutesDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension OpsWorksClientTypes.TemporaryCredential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TemporaryCredential(instanceId: \(Swift.String(describing: instanceId)), password: \(Swift.String(describing: password)), username: \(Swift.String(describing: username)), validForInMinutes: \(Swift.String(describing: validForInMinutes)))"}
}

extension OpsWorksClientTypes {
    /// Contains the data needed by RDP clients such as the Microsoft Remote Desktop Connection to log in to the instance.
    public struct TemporaryCredential: Swift.Equatable {
        /// The instance's AWS OpsWorks Stacks ID.
        public var instanceId: Swift.String?
        /// The password.
        public var password: Swift.String?
        /// The user name.
        public var username: Swift.String?
        /// The length of time (in minutes) that the grant is valid. When the grant expires, at the end of this period, the user will no longer be able to use the credentials to log in. If they are logged in at the time, they will be automatically logged out.
        public var validForInMinutes: Swift.Int?

        public init (
            instanceId: Swift.String? = nil,
            password: Swift.String? = nil,
            username: Swift.String? = nil,
            validForInMinutes: Swift.Int? = nil
        )
        {
            self.instanceId = instanceId
            self.password = password
            self.username = username
            self.validForInMinutes = validForInMinutes
        }
    }

}

extension OpsWorksClientTypes.TimeBasedAutoScalingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingSchedule = "AutoScalingSchedule"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingSchedule = autoScalingSchedule {
            try encodeContainer.encode(autoScalingSchedule, forKey: .autoScalingSchedule)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let autoScalingScheduleDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.WeeklyAutoScalingSchedule.self, forKey: .autoScalingSchedule)
        autoScalingSchedule = autoScalingScheduleDecoded
    }
}

extension OpsWorksClientTypes.TimeBasedAutoScalingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TimeBasedAutoScalingConfiguration(autoScalingSchedule: \(Swift.String(describing: autoScalingSchedule)), instanceId: \(Swift.String(describing: instanceId)))"}
}

extension OpsWorksClientTypes {
    /// Describes an instance's time-based auto scaling configuration.
    public struct TimeBasedAutoScalingConfiguration: Swift.Equatable {
        /// A WeeklyAutoScalingSchedule object with the instance schedule.
        public var autoScalingSchedule: OpsWorksClientTypes.WeeklyAutoScalingSchedule?
        /// The instance ID.
        public var instanceId: Swift.String?

        public init (
            autoScalingSchedule: OpsWorksClientTypes.WeeklyAutoScalingSchedule? = nil,
            instanceId: Swift.String? = nil
        )
        {
            self.autoScalingSchedule = autoScalingSchedule
            self.instanceId = instanceId
        }
    }

}

public struct UnassignInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnassignInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnassignInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnassignInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnassignInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnassignInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnassignInstanceOutputError>
}

extension UnassignInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnassignInstanceInput(instanceId: \(Swift.String(describing: instanceId)))"}
}

extension UnassignInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct UnassignInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnassignInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnassignInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnassignInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnassignInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnassignInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnassignInstanceOutputError>
}

public struct UnassignInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnassignInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnassignInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnassignInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnassignInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnassignInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnassignInstanceOutputError>
}

public struct UnassignInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnassignInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UnassignInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnassignInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UnassignInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UnassignInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnassignInstanceOutputError>
}

public struct UnassignInstanceInput: Swift.Equatable {
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init (
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct UnassignInstanceInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
}

extension UnassignInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension UnassignInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnassignInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnassignInstanceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnassignInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnassignInstanceOutputResponse()"}
}

extension UnassignInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UnassignInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UnassignInstanceOutputResponseBody: Swift.Equatable {
}

extension UnassignInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UnassignVolumeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnassignVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnassignVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnassignVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnassignVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnassignVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnassignVolumeOutputError>
}

extension UnassignVolumeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnassignVolumeInput(volumeId: \(Swift.String(describing: volumeId)))"}
}

extension UnassignVolumeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeId = "VolumeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
    }
}

public struct UnassignVolumeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnassignVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnassignVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnassignVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnassignVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnassignVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnassignVolumeOutputError>
}

public struct UnassignVolumeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnassignVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnassignVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnassignVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnassignVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnassignVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnassignVolumeOutputError>
}

public struct UnassignVolumeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnassignVolumeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UnassignVolumeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnassignVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UnassignVolumeInput
    public typealias MOutput = ClientRuntime.OperationOutput<UnassignVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnassignVolumeOutputError>
}

public struct UnassignVolumeInput: Swift.Equatable {
    /// The volume ID.
    /// This member is required.
    public var volumeId: Swift.String?

    public init (
        volumeId: Swift.String? = nil
    )
    {
        self.volumeId = volumeId
    }
}

struct UnassignVolumeInputBody: Swift.Equatable {
    public let volumeId: Swift.String?
}

extension UnassignVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeId = "VolumeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
    }
}

extension UnassignVolumeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnassignVolumeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnassignVolumeOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnassignVolumeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnassignVolumeOutputResponse()"}
}

extension UnassignVolumeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UnassignVolumeOutputResponse: Swift.Equatable {

    public init() {}
}

struct UnassignVolumeOutputResponseBody: Swift.Equatable {
}

extension UnassignVolumeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The stack or layer's Amazon Resource Number (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys of tags to be removed from a stack or layer.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateAppInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppOutputError>
}

extension UpdateAppInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInput(appId: \(Swift.String(describing: appId)), appSource: \(Swift.String(describing: appSource)), attributes: \(Swift.String(describing: attributes)), dataSources: \(Swift.String(describing: dataSources)), description: \(Swift.String(describing: description)), domains: \(Swift.String(describing: domains)), enableSsl: \(Swift.String(describing: enableSsl)), environment: \(Swift.String(describing: environment)), name: \(Swift.String(describing: name)), sslConfiguration: \(Swift.String(describing: sslConfiguration)), type: \(Swift.String(describing: type)))"}
}

extension UpdateAppInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case appSource = "AppSource"
        case attributes = "Attributes"
        case dataSources = "DataSources"
        case description = "Description"
        case domains = "Domains"
        case enableSsl = "EnableSsl"
        case environment = "Environment"
        case name = "Name"
        case sslConfiguration = "SslConfiguration"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let appSource = appSource {
            try encodeContainer.encode(appSource, forKey: .appSource)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, appattributes0) in attributes {
                try attributesContainer.encode(appattributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasources0 in dataSources {
                try dataSourcesContainer.encode(datasources0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for strings0 in domains {
                try domainsContainer.encode(strings0)
            }
        }
        if let enableSsl = enableSsl {
            try encodeContainer.encode(enableSsl, forKey: .enableSsl)
        }
        if let environment = environment {
            var environmentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environment)
            for environmentvariables0 in environment {
                try environmentContainer.encode(environmentvariables0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sslConfiguration = sslConfiguration {
            try encodeContainer.encode(sslConfiguration, forKey: .sslConfiguration)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct UpdateAppInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppOutputError>
}

public struct UpdateAppInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppOutputError>
}

public struct UpdateAppInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateAppInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAppInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppOutputError>
}

public struct UpdateAppInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// A Source object that specifies the app repository.
    public var appSource: OpsWorksClientTypes.Source?
    /// One or more user-defined key/value pairs to be added to the stack attributes.
    public var attributes: [Swift.String:Swift.String]?
    /// The app's data sources.
    public var dataSources: [OpsWorksClientTypes.DataSource]?
    /// A description of the app.
    public var description: Swift.String?
    /// The app's virtual host settings, with multiple domains separated by commas. For example:
    ///         'www.example.com, example.com'
    ///
    public var domains: [Swift.String]?
    /// Whether SSL is enabled for the app.
    public var enableSsl: Swift.Bool?
    /// An array of EnvironmentVariable objects that specify environment variables to be
    ///       associated with the app. After you deploy the app, these variables are defined on the
    ///       associated app server instances.For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html#workingapps-creating-environment"> Environment Variables.
    ///          There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variables' names, values, and protected flag values - cannot exceed 20 KB. This limit should accommodate most if not all use cases. Exceeding it will cause an exception with the message, "Environment: is too large (maximum is 20 KB)."
    ///
    ///             If you have specified one or more environment variables, you cannot modify the stack's Chef version.
    ///
    public var environment: [OpsWorksClientTypes.EnvironmentVariable]?
    /// The app name.
    public var name: Swift.String?
    /// An SslConfiguration object with the SSL configuration.
    public var sslConfiguration: OpsWorksClientTypes.SslConfiguration?
    /// The app type.
    public var type: OpsWorksClientTypes.AppType?

    public init (
        appId: Swift.String? = nil,
        appSource: OpsWorksClientTypes.Source? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        dataSources: [OpsWorksClientTypes.DataSource]? = nil,
        description: Swift.String? = nil,
        domains: [Swift.String]? = nil,
        enableSsl: Swift.Bool? = nil,
        environment: [OpsWorksClientTypes.EnvironmentVariable]? = nil,
        name: Swift.String? = nil,
        sslConfiguration: OpsWorksClientTypes.SslConfiguration? = nil,
        type: OpsWorksClientTypes.AppType? = nil
    )
    {
        self.appId = appId
        self.appSource = appSource
        self.attributes = attributes
        self.dataSources = dataSources
        self.description = description
        self.domains = domains
        self.enableSsl = enableSsl
        self.environment = environment
        self.name = name
        self.sslConfiguration = sslConfiguration
        self.type = type
    }
}

struct UpdateAppInputBody: Swift.Equatable {
    public let appId: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let dataSources: [OpsWorksClientTypes.DataSource]?
    public let type: OpsWorksClientTypes.AppType?
    public let appSource: OpsWorksClientTypes.Source?
    public let domains: [Swift.String]?
    public let enableSsl: Swift.Bool?
    public let sslConfiguration: OpsWorksClientTypes.SslConfiguration?
    public let attributes: [Swift.String:Swift.String]?
    public let environment: [OpsWorksClientTypes.EnvironmentVariable]?
}

extension UpdateAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case appSource = "AppSource"
        case attributes = "Attributes"
        case dataSources = "DataSources"
        case description = "Description"
        case domains = "Domains"
        case enableSsl = "EnableSsl"
        case environment = "Environment"
        case name = "Name"
        case sslConfiguration = "SslConfiguration"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourcesContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[OpsWorksClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [OpsWorksClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AppType.self, forKey: .type)
        type = typeDecoded
        let appSourceDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Source.self, forKey: .appSource)
        appSource = appSourceDecoded
        let domainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domains)
        var domainsDecoded0:[Swift.String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [Swift.String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
        let enableSslDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSsl)
        enableSsl = enableSslDecoded
        let sslConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.SslConfiguration.self, forKey: .sslConfiguration)
        sslConfiguration = sslConfigurationDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let environmentContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.EnvironmentVariable?].self, forKey: .environment)
        var environmentDecoded0:[OpsWorksClientTypes.EnvironmentVariable]? = nil
        if let environmentContainer = environmentContainer {
            environmentDecoded0 = [OpsWorksClientTypes.EnvironmentVariable]()
            for structure0 in environmentContainer {
                if let structure0 = structure0 {
                    environmentDecoded0?.append(structure0)
                }
            }
        }
        environment = environmentDecoded0
    }
}

extension UpdateAppOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAppOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAppOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAppOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppOutputResponse()"}
}

extension UpdateAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAppOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateAppOutputResponseBody: Swift.Equatable {
}

extension UpdateAppOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateElasticIpInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateElasticIpInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateElasticIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateElasticIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateElasticIpOutputError>
}

extension UpdateElasticIpInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateElasticIpInput(elasticIp: \(Swift.String(describing: elasticIp)), name: \(Swift.String(describing: name)))"}
}

extension UpdateElasticIpInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateElasticIpInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateElasticIpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateElasticIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateElasticIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateElasticIpOutputError>
}

public struct UpdateElasticIpInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateElasticIpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateElasticIpInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateElasticIpInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateElasticIpOutputError>
}

public struct UpdateElasticIpInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateElasticIpInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateElasticIpInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateElasticIpInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateElasticIpOutputError>
}

public struct UpdateElasticIpInput: Swift.Equatable {
    /// The IP address for which you want to update the name.
    /// This member is required.
    public var elasticIp: Swift.String?
    /// The new name.
    public var name: Swift.String?

    public init (
        elasticIp: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
        self.name = name
    }
}

struct UpdateElasticIpInputBody: Swift.Equatable {
    public let elasticIp: Swift.String?
    public let name: Swift.String?
}

extension UpdateElasticIpInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateElasticIpOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateElasticIpOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateElasticIpOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateElasticIpOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateElasticIpOutputResponse()"}
}

extension UpdateElasticIpOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateElasticIpOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateElasticIpOutputResponseBody: Swift.Equatable {
}

extension UpdateElasticIpOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInstanceOutputError>
}

extension UpdateInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateInstanceInput(agentVersion: \(Swift.String(describing: agentVersion)), amiId: \(Swift.String(describing: amiId)), architecture: \(Swift.String(describing: architecture)), autoScalingType: \(Swift.String(describing: autoScalingType)), ebsOptimized: \(Swift.String(describing: ebsOptimized)), hostname: \(Swift.String(describing: hostname)), installUpdatesOnBoot: \(Swift.String(describing: installUpdatesOnBoot)), instanceId: \(Swift.String(describing: instanceId)), instanceType: \(Swift.String(describing: instanceType)), layerIds: \(Swift.String(describing: layerIds)), os: \(Swift.String(describing: os)), sshKeyName: \(Swift.String(describing: sshKeyName)))"}
}

extension UpdateInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case amiId = "AmiId"
        case architecture = "Architecture"
        case autoScalingType = "AutoScalingType"
        case ebsOptimized = "EbsOptimized"
        case hostname = "Hostname"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case instanceId = "InstanceId"
        case instanceType = "InstanceType"
        case layerIds = "LayerIds"
        case os = "Os"
        case sshKeyName = "SshKeyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let amiId = amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let architecture = architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let autoScalingType = autoScalingType {
            try encodeContainer.encode(autoScalingType.rawValue, forKey: .autoScalingType)
        }
        if let ebsOptimized = ebsOptimized {
            try encodeContainer.encode(ebsOptimized, forKey: .ebsOptimized)
        }
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let installUpdatesOnBoot = installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
        if let os = os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if let sshKeyName = sshKeyName {
            try encodeContainer.encode(sshKeyName, forKey: .sshKeyName)
        }
    }
}

public struct UpdateInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInstanceOutputError>
}

public struct UpdateInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInstanceOutputError>
}

public struct UpdateInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInstanceOutputError>
}

public struct UpdateInstanceInput: Swift.Equatable {
    /// The default AWS OpsWorks Stacks agent version. You have the following options:
    ///
    ///
    ///
    ///                   INHERIT - Use the stack's default agent version setting.
    ///
    ///
    ///
    ///                   version_number - Use the specified agent version.
    ///         This value overrides the stack's default setting.
    ///         To update the agent version, you must edit the instance configuration and specify a
    ///         new version.
    ///         AWS OpsWorks Stacks then automatically installs that version on the instance.
    ///
    ///
    ///          The default setting is INHERIT. To specify an agent version,
    ///       you must use the complete version number, not the abbreviated number shown on the console.
    ///       For a list of available agent version numbers, call DescribeAgentVersions.
    ///          AgentVersion cannot be set to Chef 12.2.
    public var agentVersion: Swift.String?
    /// The ID of the AMI that was used to create the instance. The value of this parameter must be the same AMI ID that the instance is already using.
    ///           You cannot apply a new AMI to an instance by running UpdateInstance. UpdateInstance does not work on instances that are using custom AMIs.
    ///
    public var amiId: Swift.String?
    /// The instance architecture. Instance types do not necessarily support both architectures. For
    ///       a list of the architectures that are supported by the different instance types, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance
    ///         Families and Types.
    public var architecture: OpsWorksClientTypes.Architecture?
    /// For load-based or time-based instances, the type. Windows stacks can use only time-based instances.
    public var autoScalingType: OpsWorksClientTypes.AutoScalingType?
    /// This property cannot be updated.
    public var ebsOptimized: Swift.Bool?
    /// The instance host name.
    public var hostname: Swift.String?
    /// Whether to install operating system and package updates when the instance boots. The default
    ///       value is true. To control when updates are installed, set this value to
    ///         false. You must then update your instances manually by using
    ///         CreateDeployment to run the update_dependencies stack command or
    ///       by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the
    ///       instances.
    ///
    ///             We strongly recommend using the default value of true, to ensure that your
    ///         instances have the latest security updates.
    ///
    public var installUpdatesOnBoot: Swift.Bool?
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The instance type, such as t2.micro. For a list of supported instance types,
    ///       open the stack in the console, choose Instances, and choose + Instance.
    ///       The Size list contains the currently supported types. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance
    ///         Families and Types. The parameter values that you use to specify the various types are
    ///       in the API Name column of the Available Instance Types table.
    public var instanceType: Swift.String?
    /// The instance's layer IDs.
    public var layerIds: [Swift.String]?
    /// The instance's operating system, which must be set to one of the following. You cannot update an instance that is using a custom AMI.
    ///
    ///
    ///                A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2018.03, Amazon Linux 2017.09, Amazon Linux 2017.03, Amazon Linux 2016.09, Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux
    ///         2015.03.
    ///
    ///
    ///                A supported Ubuntu operating system, such as Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.
    ///
    ///
    ///
    ///                   CentOS Linux 7
    ///
    ///
    ///
    ///
    ///                   Red Hat Enterprise Linux 7
    ///
    ///
    ///
    ///                A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express,
    ///               Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.
    ///
    ///
    ///          For more information about supported operating systems,
    ///       see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html">AWS OpsWorks Stacks Operating Systems.
    ///          The default option is the current Amazon Linux version. If you set this parameter to
    ///         Custom, you must use the AmiId parameter to
    ///       specify the custom AMI that you want to use. For more information about supported operating
    ///       systems, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html">Operating Systems. For more information about how to use custom AMIs with OpsWorks, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html">Using
    ///         Custom AMIs.
    ///
    ///             You can specify a different Linux operating system for the updated stack, but you cannot change from Linux to Windows or Windows to Linux.
    ///
    public var os: Swift.String?
    /// The instance's Amazon EC2 key name.
    public var sshKeyName: Swift.String?

    public init (
        agentVersion: Swift.String? = nil,
        amiId: Swift.String? = nil,
        architecture: OpsWorksClientTypes.Architecture? = nil,
        autoScalingType: OpsWorksClientTypes.AutoScalingType? = nil,
        ebsOptimized: Swift.Bool? = nil,
        hostname: Swift.String? = nil,
        installUpdatesOnBoot: Swift.Bool? = nil,
        instanceId: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        layerIds: [Swift.String]? = nil,
        os: Swift.String? = nil,
        sshKeyName: Swift.String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.amiId = amiId
        self.architecture = architecture
        self.autoScalingType = autoScalingType
        self.ebsOptimized = ebsOptimized
        self.hostname = hostname
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.instanceId = instanceId
        self.instanceType = instanceType
        self.layerIds = layerIds
        self.os = os
        self.sshKeyName = sshKeyName
    }
}

struct UpdateInstanceInputBody: Swift.Equatable {
    public let instanceId: Swift.String?
    public let layerIds: [Swift.String]?
    public let instanceType: Swift.String?
    public let autoScalingType: OpsWorksClientTypes.AutoScalingType?
    public let hostname: Swift.String?
    public let os: Swift.String?
    public let amiId: Swift.String?
    public let sshKeyName: Swift.String?
    public let architecture: OpsWorksClientTypes.Architecture?
    public let installUpdatesOnBoot: Swift.Bool?
    public let ebsOptimized: Swift.Bool?
    public let agentVersion: Swift.String?
}

extension UpdateInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case amiId = "AmiId"
        case architecture = "Architecture"
        case autoScalingType = "AutoScalingType"
        case ebsOptimized = "EbsOptimized"
        case hostname = "Hostname"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case instanceId = "InstanceId"
        case instanceType = "InstanceType"
        case layerIds = "LayerIds"
        case os = "Os"
        case sshKeyName = "SshKeyName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let autoScalingTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AutoScalingType.self, forKey: .autoScalingType)
        autoScalingType = autoScalingTypeDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let osDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .os)
        os = osDecoded
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let sshKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshKeyName)
        sshKeyName = sshKeyNameDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension UpdateInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInstanceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateInstanceOutputResponse()"}
}

extension UpdateInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateInstanceOutputResponseBody: Swift.Equatable {
}

extension UpdateInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateLayerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLayerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLayerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLayerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLayerOutputError>
}

extension UpdateLayerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLayerInput(attributes: \(Swift.String(describing: attributes)), autoAssignElasticIps: \(Swift.String(describing: autoAssignElasticIps)), autoAssignPublicIps: \(Swift.String(describing: autoAssignPublicIps)), cloudWatchLogsConfiguration: \(Swift.String(describing: cloudWatchLogsConfiguration)), customInstanceProfileArn: \(Swift.String(describing: customInstanceProfileArn)), customJson: \(Swift.String(describing: customJson)), customRecipes: \(Swift.String(describing: customRecipes)), customSecurityGroupIds: \(Swift.String(describing: customSecurityGroupIds)), enableAutoHealing: \(Swift.String(describing: enableAutoHealing)), installUpdatesOnBoot: \(Swift.String(describing: installUpdatesOnBoot)), layerId: \(Swift.String(describing: layerId)), lifecycleEventConfiguration: \(Swift.String(describing: lifecycleEventConfiguration)), name: \(Swift.String(describing: name)), packages: \(Swift.String(describing: packages)), shortname: \(Swift.String(describing: shortname)), useEbsOptimizedInstances: \(Swift.String(describing: useEbsOptimizedInstances)), volumeConfigurations: \(Swift.String(describing: volumeConfigurations)))"}
}

extension UpdateLayerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case autoAssignElasticIps = "AutoAssignElasticIps"
        case autoAssignPublicIps = "AutoAssignPublicIps"
        case cloudWatchLogsConfiguration = "CloudWatchLogsConfiguration"
        case customInstanceProfileArn = "CustomInstanceProfileArn"
        case customJson = "CustomJson"
        case customRecipes = "CustomRecipes"
        case customSecurityGroupIds = "CustomSecurityGroupIds"
        case enableAutoHealing = "EnableAutoHealing"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case layerId = "LayerId"
        case lifecycleEventConfiguration = "LifecycleEventConfiguration"
        case name = "Name"
        case packages = "Packages"
        case shortname = "Shortname"
        case useEbsOptimizedInstances = "UseEbsOptimizedInstances"
        case volumeConfigurations = "VolumeConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, layerattributes0) in attributes {
                try attributesContainer.encode(layerattributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let autoAssignElasticIps = autoAssignElasticIps {
            try encodeContainer.encode(autoAssignElasticIps, forKey: .autoAssignElasticIps)
        }
        if let autoAssignPublicIps = autoAssignPublicIps {
            try encodeContainer.encode(autoAssignPublicIps, forKey: .autoAssignPublicIps)
        }
        if let cloudWatchLogsConfiguration = cloudWatchLogsConfiguration {
            try encodeContainer.encode(cloudWatchLogsConfiguration, forKey: .cloudWatchLogsConfiguration)
        }
        if let customInstanceProfileArn = customInstanceProfileArn {
            try encodeContainer.encode(customInstanceProfileArn, forKey: .customInstanceProfileArn)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let customRecipes = customRecipes {
            try encodeContainer.encode(customRecipes, forKey: .customRecipes)
        }
        if let customSecurityGroupIds = customSecurityGroupIds {
            var customSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customSecurityGroupIds)
            for strings0 in customSecurityGroupIds {
                try customSecurityGroupIdsContainer.encode(strings0)
            }
        }
        if let enableAutoHealing = enableAutoHealing {
            try encodeContainer.encode(enableAutoHealing, forKey: .enableAutoHealing)
        }
        if let installUpdatesOnBoot = installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let lifecycleEventConfiguration = lifecycleEventConfiguration {
            try encodeContainer.encode(lifecycleEventConfiguration, forKey: .lifecycleEventConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packages = packages {
            var packagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .packages)
            for strings0 in packages {
                try packagesContainer.encode(strings0)
            }
        }
        if let shortname = shortname {
            try encodeContainer.encode(shortname, forKey: .shortname)
        }
        if let useEbsOptimizedInstances = useEbsOptimizedInstances {
            try encodeContainer.encode(useEbsOptimizedInstances, forKey: .useEbsOptimizedInstances)
        }
        if let volumeConfigurations = volumeConfigurations {
            var volumeConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeConfigurations)
            for volumeconfigurations0 in volumeConfigurations {
                try volumeConfigurationsContainer.encode(volumeconfigurations0)
            }
        }
    }
}

public struct UpdateLayerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLayerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLayerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLayerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLayerOutputError>
}

public struct UpdateLayerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLayerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLayerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLayerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLayerOutputError>
}

public struct UpdateLayerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLayerInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateLayerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLayerInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLayerOutputError>
}

public struct UpdateLayerInput: Swift.Equatable {
    /// One or more user-defined key/value pairs to be added to the stack attributes.
    public var attributes: [Swift.String:Swift.String]?
    /// Whether to automatically assign an <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html">Elastic IP
    ///         address to the layer's instances. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html">How to Edit
    ///         a Layer.
    public var autoAssignElasticIps: Swift.Bool?
    /// For stacks that are running in a VPC, whether to automatically assign a public IP address to
    ///       the layer's instances. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html">How to Edit
    ///         a Layer.
    public var autoAssignPublicIps: Swift.Bool?
    /// Specifies CloudWatch Logs configuration options for the layer. For more information, see CloudWatchLogsLogStream.
    public var cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration?
    /// The ARN of an IAM profile to be used for all of the layer's EC2 instances. For more
    ///       information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers.
    public var customInstanceProfileArn: Swift.String?
    /// A JSON-formatted string containing custom stack configuration and deployment attributes
    ///       to be installed on the layer's instances. For more information, see
    ///       <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook-json-override.html">
    ///         Using Custom JSON.
    ///
    public var customJson: Swift.String?
    /// A LayerCustomRecipes object that specifies the layer's custom recipes.
    public var customRecipes: OpsWorksClientTypes.Recipes?
    /// An array containing the layer's custom security group IDs.
    public var customSecurityGroupIds: [Swift.String]?
    /// Whether to disable auto healing for the layer.
    public var enableAutoHealing: Swift.Bool?
    /// Whether to install operating system and package updates when the instance boots. The default
    ///       value is true. To control when updates are installed, set this value to
    ///         false. You must then update your instances manually by using
    ///         CreateDeployment to run the update_dependencies stack command or
    ///       manually running yum (Amazon Linux) or apt-get (Ubuntu) on the
    ///       instances.
    ///
    ///             We strongly recommend using the default value of true, to ensure that your
    ///         instances have the latest security updates.
    ///
    public var installUpdatesOnBoot: Swift.Bool?
    /// The layer ID.
    /// This member is required.
    public var layerId: Swift.String?
    ///
    public var lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration?
    /// The layer name, which is used by the console.
    public var name: Swift.String?
    /// An array of Package objects that describe the layer's packages.
    public var packages: [Swift.String]?
    /// For custom layers only, use this parameter to specify the layer's short name, which is used internally by AWS OpsWorks Stacks and by Chef. The short name is also used as the name for the directory where your app files are installed. It can have a maximum of 200 characters and must be in the following format: /\A[a-z0-9\-\_\.]+\Z/.
    ///          The built-in layers' short names are defined by AWS OpsWorks Stacks. For more information, see the <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/layers.html">Layer Reference
    ///
    public var shortname: Swift.String?
    /// Whether to use Amazon EBS-optimized instances.
    public var useEbsOptimizedInstances: Swift.Bool?
    /// A VolumeConfigurations object that describes the layer's Amazon EBS volumes.
    public var volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        autoAssignElasticIps: Swift.Bool? = nil,
        autoAssignPublicIps: Swift.Bool? = nil,
        cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration? = nil,
        customInstanceProfileArn: Swift.String? = nil,
        customJson: Swift.String? = nil,
        customRecipes: OpsWorksClientTypes.Recipes? = nil,
        customSecurityGroupIds: [Swift.String]? = nil,
        enableAutoHealing: Swift.Bool? = nil,
        installUpdatesOnBoot: Swift.Bool? = nil,
        layerId: Swift.String? = nil,
        lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration? = nil,
        name: Swift.String? = nil,
        packages: [Swift.String]? = nil,
        shortname: Swift.String? = nil,
        useEbsOptimizedInstances: Swift.Bool? = nil,
        volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]? = nil
    )
    {
        self.attributes = attributes
        self.autoAssignElasticIps = autoAssignElasticIps
        self.autoAssignPublicIps = autoAssignPublicIps
        self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
        self.customInstanceProfileArn = customInstanceProfileArn
        self.customJson = customJson
        self.customRecipes = customRecipes
        self.customSecurityGroupIds = customSecurityGroupIds
        self.enableAutoHealing = enableAutoHealing
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.layerId = layerId
        self.lifecycleEventConfiguration = lifecycleEventConfiguration
        self.name = name
        self.packages = packages
        self.shortname = shortname
        self.useEbsOptimizedInstances = useEbsOptimizedInstances
        self.volumeConfigurations = volumeConfigurations
    }
}

struct UpdateLayerInputBody: Swift.Equatable {
    public let layerId: Swift.String?
    public let name: Swift.String?
    public let shortname: Swift.String?
    public let attributes: [Swift.String:Swift.String]?
    public let cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration?
    public let customInstanceProfileArn: Swift.String?
    public let customJson: Swift.String?
    public let customSecurityGroupIds: [Swift.String]?
    public let packages: [Swift.String]?
    public let volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]?
    public let enableAutoHealing: Swift.Bool?
    public let autoAssignElasticIps: Swift.Bool?
    public let autoAssignPublicIps: Swift.Bool?
    public let customRecipes: OpsWorksClientTypes.Recipes?
    public let installUpdatesOnBoot: Swift.Bool?
    public let useEbsOptimizedInstances: Swift.Bool?
    public let lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration?
}

extension UpdateLayerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case autoAssignElasticIps = "AutoAssignElasticIps"
        case autoAssignPublicIps = "AutoAssignPublicIps"
        case cloudWatchLogsConfiguration = "CloudWatchLogsConfiguration"
        case customInstanceProfileArn = "CustomInstanceProfileArn"
        case customJson = "CustomJson"
        case customRecipes = "CustomRecipes"
        case customSecurityGroupIds = "CustomSecurityGroupIds"
        case enableAutoHealing = "EnableAutoHealing"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case layerId = "LayerId"
        case lifecycleEventConfiguration = "LifecycleEventConfiguration"
        case name = "Name"
        case packages = "Packages"
        case shortname = "Shortname"
        case useEbsOptimizedInstances = "UseEbsOptimizedInstances"
        case volumeConfigurations = "VolumeConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let shortnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortname)
        shortname = shortnameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let cloudWatchLogsConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.CloudWatchLogsConfiguration.self, forKey: .cloudWatchLogsConfiguration)
        cloudWatchLogsConfiguration = cloudWatchLogsConfigurationDecoded
        let customInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customInstanceProfileArn)
        customInstanceProfileArn = customInstanceProfileArnDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let customSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .customSecurityGroupIds)
        var customSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let customSecurityGroupIdsContainer = customSecurityGroupIdsContainer {
            customSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in customSecurityGroupIdsContainer {
                if let string0 = string0 {
                    customSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        customSecurityGroupIds = customSecurityGroupIdsDecoded0
        let packagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .packages)
        var packagesDecoded0:[Swift.String]? = nil
        if let packagesContainer = packagesContainer {
            packagesDecoded0 = [Swift.String]()
            for string0 in packagesContainer {
                if let string0 = string0 {
                    packagesDecoded0?.append(string0)
                }
            }
        }
        packages = packagesDecoded0
        let volumeConfigurationsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.VolumeConfiguration?].self, forKey: .volumeConfigurations)
        var volumeConfigurationsDecoded0:[OpsWorksClientTypes.VolumeConfiguration]? = nil
        if let volumeConfigurationsContainer = volumeConfigurationsContainer {
            volumeConfigurationsDecoded0 = [OpsWorksClientTypes.VolumeConfiguration]()
            for structure0 in volumeConfigurationsContainer {
                if let structure0 = structure0 {
                    volumeConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        volumeConfigurations = volumeConfigurationsDecoded0
        let enableAutoHealingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoHealing)
        enableAutoHealing = enableAutoHealingDecoded
        let autoAssignElasticIpsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssignElasticIps)
        autoAssignElasticIps = autoAssignElasticIpsDecoded
        let autoAssignPublicIpsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssignPublicIps)
        autoAssignPublicIps = autoAssignPublicIpsDecoded
        let customRecipesDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Recipes.self, forKey: .customRecipes)
        customRecipes = customRecipesDecoded
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let useEbsOptimizedInstancesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useEbsOptimizedInstances)
        useEbsOptimizedInstances = useEbsOptimizedInstancesDecoded
        let lifecycleEventConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.LifecycleEventConfiguration.self, forKey: .lifecycleEventConfiguration)
        lifecycleEventConfiguration = lifecycleEventConfigurationDecoded
    }
}

extension UpdateLayerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLayerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLayerOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLayerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLayerOutputResponse()"}
}

extension UpdateLayerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLayerOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateLayerOutputResponseBody: Swift.Equatable {
}

extension UpdateLayerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateMyUserProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMyUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMyUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMyUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMyUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMyUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMyUserProfileOutputError>
}

extension UpdateMyUserProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMyUserProfileInput(sshPublicKey: \(Swift.String(describing: sshPublicKey)))"}
}

extension UpdateMyUserProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKey = "SshPublicKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
    }
}

public struct UpdateMyUserProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMyUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMyUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMyUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMyUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMyUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMyUserProfileOutputError>
}

public struct UpdateMyUserProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMyUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMyUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMyUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMyUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMyUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMyUserProfileOutputError>
}

public struct UpdateMyUserProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMyUserProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateMyUserProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMyUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMyUserProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMyUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMyUserProfileOutputError>
}

public struct UpdateMyUserProfileInput: Swift.Equatable {
    /// The user's SSH public key.
    public var sshPublicKey: Swift.String?

    public init (
        sshPublicKey: Swift.String? = nil
    )
    {
        self.sshPublicKey = sshPublicKey
    }
}

struct UpdateMyUserProfileInputBody: Swift.Equatable {
    public let sshPublicKey: Swift.String?
}

extension UpdateMyUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKey = "SshPublicKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension UpdateMyUserProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMyUserProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMyUserProfileOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMyUserProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMyUserProfileOutputResponse()"}
}

extension UpdateMyUserProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateMyUserProfileOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateMyUserProfileOutputResponseBody: Swift.Equatable {
}

extension UpdateMyUserProfileOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateRdsDbInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRdsDbInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRdsDbInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRdsDbInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRdsDbInstanceOutputError>
}

extension UpdateRdsDbInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRdsDbInstanceInput(dbPassword: \(Swift.String(describing: dbPassword)), dbUser: \(Swift.String(describing: dbUser)), rdsDbInstanceArn: \(Swift.String(describing: rdsDbInstanceArn)))"}
}

extension UpdateRdsDbInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case rdsDbInstanceArn = "RdsDbInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbPassword = dbPassword {
            try encodeContainer.encode(dbPassword, forKey: .dbPassword)
        }
        if let dbUser = dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if let rdsDbInstanceArn = rdsDbInstanceArn {
            try encodeContainer.encode(rdsDbInstanceArn, forKey: .rdsDbInstanceArn)
        }
    }
}

public struct UpdateRdsDbInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRdsDbInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRdsDbInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRdsDbInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRdsDbInstanceOutputError>
}

public struct UpdateRdsDbInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRdsDbInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRdsDbInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRdsDbInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRdsDbInstanceOutputError>
}

public struct UpdateRdsDbInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRdsDbInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateRdsDbInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRdsDbInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRdsDbInstanceOutputError>
}

public struct UpdateRdsDbInstanceInput: Swift.Equatable {
    /// The database password.
    public var dbPassword: Swift.String?
    /// The master user name.
    public var dbUser: Swift.String?
    /// The Amazon RDS instance's ARN.
    /// This member is required.
    public var rdsDbInstanceArn: Swift.String?

    public init (
        dbPassword: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        rdsDbInstanceArn: Swift.String? = nil
    )
    {
        self.dbPassword = dbPassword
        self.dbUser = dbUser
        self.rdsDbInstanceArn = rdsDbInstanceArn
    }
}

struct UpdateRdsDbInstanceInputBody: Swift.Equatable {
    public let rdsDbInstanceArn: Swift.String?
    public let dbUser: Swift.String?
    public let dbPassword: Swift.String?
}

extension UpdateRdsDbInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case rdsDbInstanceArn = "RdsDbInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rdsDbInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rdsDbInstanceArn)
        rdsDbInstanceArn = rdsDbInstanceArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let dbPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbPassword)
        dbPassword = dbPasswordDecoded
    }
}

extension UpdateRdsDbInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRdsDbInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRdsDbInstanceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRdsDbInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRdsDbInstanceOutputResponse()"}
}

extension UpdateRdsDbInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRdsDbInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateRdsDbInstanceOutputResponseBody: Swift.Equatable {
}

extension UpdateRdsDbInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateStackInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStackOutputError>
}

extension UpdateStackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStackInput(agentVersion: \(Swift.String(describing: agentVersion)), attributes: \(Swift.String(describing: attributes)), chefConfiguration: \(Swift.String(describing: chefConfiguration)), configurationManager: \(Swift.String(describing: configurationManager)), customCookbooksSource: \(Swift.String(describing: customCookbooksSource)), customJson: \(Swift.String(describing: customJson)), defaultAvailabilityZone: \(Swift.String(describing: defaultAvailabilityZone)), defaultInstanceProfileArn: \(Swift.String(describing: defaultInstanceProfileArn)), defaultOs: \(Swift.String(describing: defaultOs)), defaultRootDeviceType: \(Swift.String(describing: defaultRootDeviceType)), defaultSshKeyName: \(Swift.String(describing: defaultSshKeyName)), defaultSubnetId: \(Swift.String(describing: defaultSubnetId)), hostnameTheme: \(Swift.String(describing: hostnameTheme)), name: \(Swift.String(describing: name)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), stackId: \(Swift.String(describing: stackId)), useCustomCookbooks: \(Swift.String(describing: useCustomCookbooks)), useOpsworksSecurityGroups: \(Swift.String(describing: useOpsworksSecurityGroups)))"}
}

extension UpdateStackInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case serviceRoleArn = "ServiceRoleArn"
        case stackId = "StackId"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, stackattributes0) in attributes {
                try attributesContainer.encode(stackattributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let chefConfiguration = chefConfiguration {
            try encodeContainer.encode(chefConfiguration, forKey: .chefConfiguration)
        }
        if let configurationManager = configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let customCookbooksSource = customCookbooksSource {
            try encodeContainer.encode(customCookbooksSource, forKey: .customCookbooksSource)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let defaultAvailabilityZone = defaultAvailabilityZone {
            try encodeContainer.encode(defaultAvailabilityZone, forKey: .defaultAvailabilityZone)
        }
        if let defaultInstanceProfileArn = defaultInstanceProfileArn {
            try encodeContainer.encode(defaultInstanceProfileArn, forKey: .defaultInstanceProfileArn)
        }
        if let defaultOs = defaultOs {
            try encodeContainer.encode(defaultOs, forKey: .defaultOs)
        }
        if let defaultRootDeviceType = defaultRootDeviceType {
            try encodeContainer.encode(defaultRootDeviceType.rawValue, forKey: .defaultRootDeviceType)
        }
        if let defaultSshKeyName = defaultSshKeyName {
            try encodeContainer.encode(defaultSshKeyName, forKey: .defaultSshKeyName)
        }
        if let defaultSubnetId = defaultSubnetId {
            try encodeContainer.encode(defaultSubnetId, forKey: .defaultSubnetId)
        }
        if let hostnameTheme = hostnameTheme {
            try encodeContainer.encode(hostnameTheme, forKey: .hostnameTheme)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let useCustomCookbooks = useCustomCookbooks {
            try encodeContainer.encode(useCustomCookbooks, forKey: .useCustomCookbooks)
        }
        if let useOpsworksSecurityGroups = useOpsworksSecurityGroups {
            try encodeContainer.encode(useOpsworksSecurityGroups, forKey: .useOpsworksSecurityGroups)
        }
    }
}

public struct UpdateStackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStackOutputError>
}

public struct UpdateStackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStackOutputError>
}

public struct UpdateStackInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStackInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStackOutputError>
}

public struct UpdateStackInput: Swift.Equatable {
    /// The default AWS OpsWorks Stacks agent version. You have the following options:
    ///
    ///
    ///                Auto-update - Set this parameter to LATEST. AWS OpsWorks Stacks
    ///         automatically installs new agent versions on the stack's instances as soon as
    ///         they are available.
    ///
    ///
    ///                Fixed version - Set this parameter to your preferred agent version. To update the agent version, you must edit the stack configuration and specify a new version. AWS OpsWorks Stacks then automatically installs that version on the stack's instances.
    ///
    ///
    ///          The default setting is LATEST. To specify an agent version,
    ///       you must use the complete version number, not the abbreviated number shown on the console.
    ///       For a list of available agent version numbers, call DescribeAgentVersions.
    ///           AgentVersion cannot be set to Chef 12.2.
    ///
    ///             You can also specify an agent version when you create or update an instance, which overrides the stack's default setting.
    ///
    public var agentVersion: Swift.String?
    /// One or more user-defined key-value pairs to be added to the stack attributes.
    public var attributes: [Swift.String:Swift.String]?
    /// A ChefConfiguration object that specifies whether to enable Berkshelf and the
    ///       Berkshelf version on Chef 11.10 stacks. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html">Create a New Stack.
    public var chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
    /// The configuration manager. When you update a stack, we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 12.
    public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    /// Contains the information required to retrieve an app or cookbook from a repository. For more information,
    ///             see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html">Adding Apps or <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html">Cookbooks and Recipes.
    public var customCookbooksSource: OpsWorksClientTypes.Source?
    /// A string that contains user-defined, custom JSON. It can be used to override the corresponding default stack configuration JSON values or to pass data to recipes. The string should be in the following format:
    ///
    ///             "{\"key1\": \"value1\", \"key2\": \"value2\",...}"
    ///
    ///          For more information about custom JSON, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html">Use Custom JSON to
    ///         Modify the Stack Configuration Attributes.
    public var customJson: Swift.String?
    /// The stack's default Availability Zone, which must be in the
    ///       stack's region. For more
    ///       information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and
    ///         Endpoints. If you also specify a value for DefaultSubnetId, the subnet must
    ///       be in the same zone. For more information, see CreateStack.
    public var defaultAvailabilityZone: Swift.String?
    /// The ARN of an IAM profile that is the default profile for all of the stack's EC2 instances.
    ///       For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers.
    public var defaultInstanceProfileArn: Swift.String?
    /// The stack's operating system, which must be set to one of the following:
    ///
    ///
    ///                A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2018.03, Amazon Linux 2017.09, Amazon Linux 2017.03, Amazon Linux 2016.09,
    ///               Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.
    ///
    ///
    ///                A supported Ubuntu operating system, such as Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.
    ///
    ///
    ///
    ///                   CentOS Linux 7
    ///
    ///
    ///
    ///
    ///                   Red Hat Enterprise Linux 7
    ///
    ///
    ///
    ///                A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express,
    ///               Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.
    ///
    ///
    ///                A custom AMI: Custom. You specify the custom AMI you want to use when
    ///         you create instances. For more information about how to use custom AMIs with OpsWorks, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html">Using
    ///           Custom AMIs.
    ///
    ///
    ///          The default option is the stack's current operating system.
    ///       For more information about supported operating systems,
    ///       see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html">AWS OpsWorks Stacks Operating Systems.
    public var defaultOs: Swift.String?
    /// The default root device type. This value is used by default for all instances in the stack,
    ///       but you can override it when you create an instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device">Storage for the Root Device.
    public var defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
    /// A default Amazon EC2 key-pair name. The default value is
    ///       none. If you specify a key-pair name,
    ///       AWS OpsWorks Stacks installs the public key on the instance and you can use the private key with an SSH
    ///       client to log in to the instance. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-ssh.html"> Using SSH to
    ///         Communicate with an Instance and <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/security-ssh-access.html"> Managing SSH
    ///         Access. You can override this setting by specifying a different key pair, or no key
    ///       pair, when you <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-add.html">
    ///         create an instance.
    public var defaultSshKeyName: Swift.String?
    /// The stack's default VPC subnet ID. This parameter is required if you specify a value for the
    ///         VpcId parameter. All instances are launched into this subnet unless you specify
    ///       otherwise when you create the instance. If you also specify a value for
    ///         DefaultAvailabilityZone, the subnet must be in that zone. For information on
    ///       default values and when this parameter is required, see the VpcId parameter
    ///       description.
    public var defaultSubnetId: Swift.String?
    /// The stack's new host name theme, with spaces replaced by underscores.
    ///       The theme is used to generate host names for the stack's instances.
    ///       By default, HostnameTheme is set to Layer_Dependent, which creates host names by appending integers to the
    ///       layer's short name. The other themes are:
    ///
    ///
    ///
    ///                   Baked_Goods
    ///
    ///
    ///
    ///
    ///                   Clouds
    ///
    ///
    ///
    ///
    ///                   Europe_Cities
    ///
    ///
    ///
    ///
    ///                   Fruits
    ///
    ///
    ///
    ///
    ///                   Greek_Deities_and_Titans
    ///
    ///
    ///
    ///
    ///                   Legendary_creatures_from_Japan
    ///
    ///
    ///
    ///
    ///                   Planets_and_Moons
    ///
    ///
    ///
    ///
    ///                   Roman_Deities
    ///
    ///
    ///
    ///
    ///                   Scottish_Islands
    ///
    ///
    ///
    ///
    ///                   US_Cities
    ///
    ///
    ///
    ///
    ///                   Wild_Cats
    ///
    ///
    ///
    ///          To obtain a generated host name, call GetHostNameSuggestion, which returns a
    ///       host name based on the current theme.
    public var hostnameTheme: Swift.String?
    /// The stack's new name.
    public var name: Swift.String?
    /// Do not use this parameter. You cannot update a stack's service role.
    public var serviceRoleArn: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?
    /// Whether the stack uses custom cookbooks.
    public var useCustomCookbooks: Swift.Bool?
    /// Whether to associate the AWS OpsWorks Stacks built-in security groups with the stack's layers.
    ///          AWS OpsWorks Stacks provides a standard set of built-in security groups, one for each layer, which are
    ///       associated with layers by default. UseOpsworksSecurityGroups allows you to
    ///       provide your own custom security groups
    ///       instead of using the built-in groups. UseOpsworksSecurityGroups has
    ///       the following settings:
    ///
    ///
    ///                True - AWS OpsWorks Stacks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it, but you cannot delete the built-in security group.
    ///
    ///
    ///                False - AWS OpsWorks Stacks does not associate built-in security groups with layers. You must create appropriate EC2 security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on. Custom security groups are required only for those layers that need custom settings.
    ///
    ///
    ///          For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html">Create a New
    ///         Stack.
    public var useOpsworksSecurityGroups: Swift.Bool?

    public init (
        agentVersion: Swift.String? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        chefConfiguration: OpsWorksClientTypes.ChefConfiguration? = nil,
        configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
        customCookbooksSource: OpsWorksClientTypes.Source? = nil,
        customJson: Swift.String? = nil,
        defaultAvailabilityZone: Swift.String? = nil,
        defaultInstanceProfileArn: Swift.String? = nil,
        defaultOs: Swift.String? = nil,
        defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
        defaultSshKeyName: Swift.String? = nil,
        defaultSubnetId: Swift.String? = nil,
        hostnameTheme: Swift.String? = nil,
        name: Swift.String? = nil,
        serviceRoleArn: Swift.String? = nil,
        stackId: Swift.String? = nil,
        useCustomCookbooks: Swift.Bool? = nil,
        useOpsworksSecurityGroups: Swift.Bool? = nil
    )
    {
        self.agentVersion = agentVersion
        self.attributes = attributes
        self.chefConfiguration = chefConfiguration
        self.configurationManager = configurationManager
        self.customCookbooksSource = customCookbooksSource
        self.customJson = customJson
        self.defaultAvailabilityZone = defaultAvailabilityZone
        self.defaultInstanceProfileArn = defaultInstanceProfileArn
        self.defaultOs = defaultOs
        self.defaultRootDeviceType = defaultRootDeviceType
        self.defaultSshKeyName = defaultSshKeyName
        self.defaultSubnetId = defaultSubnetId
        self.hostnameTheme = hostnameTheme
        self.name = name
        self.serviceRoleArn = serviceRoleArn
        self.stackId = stackId
        self.useCustomCookbooks = useCustomCookbooks
        self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
    }
}

struct UpdateStackInputBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let name: Swift.String?
    public let attributes: [Swift.String:Swift.String]?
    public let serviceRoleArn: Swift.String?
    public let defaultInstanceProfileArn: Swift.String?
    public let defaultOs: Swift.String?
    public let hostnameTheme: Swift.String?
    public let defaultAvailabilityZone: Swift.String?
    public let defaultSubnetId: Swift.String?
    public let customJson: Swift.String?
    public let configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    public let chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
    public let useCustomCookbooks: Swift.Bool?
    public let customCookbooksSource: OpsWorksClientTypes.Source?
    public let defaultSshKeyName: Swift.String?
    public let defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
    public let useOpsworksSecurityGroups: Swift.Bool?
    public let agentVersion: Swift.String?
}

extension UpdateStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case serviceRoleArn = "ServiceRoleArn"
        case stackId = "StackId"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let defaultInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultInstanceProfileArn)
        defaultInstanceProfileArn = defaultInstanceProfileArnDecoded
        let defaultOsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOs)
        defaultOs = defaultOsDecoded
        let hostnameThemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostnameTheme)
        hostnameTheme = hostnameThemeDecoded
        let defaultAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultAvailabilityZone)
        defaultAvailabilityZone = defaultAvailabilityZoneDecoded
        let defaultSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSubnetId)
        defaultSubnetId = defaultSubnetIdDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
        let chefConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.ChefConfiguration.self, forKey: .chefConfiguration)
        chefConfiguration = chefConfigurationDecoded
        let useCustomCookbooksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useCustomCookbooks)
        useCustomCookbooks = useCustomCookbooksDecoded
        let customCookbooksSourceDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Source.self, forKey: .customCookbooksSource)
        customCookbooksSource = customCookbooksSourceDecoded
        let defaultSshKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSshKeyName)
        defaultSshKeyName = defaultSshKeyNameDecoded
        let defaultRootDeviceTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.RootDeviceType.self, forKey: .defaultRootDeviceType)
        defaultRootDeviceType = defaultRootDeviceTypeDecoded
        let useOpsworksSecurityGroupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useOpsworksSecurityGroups)
        useOpsworksSecurityGroups = useOpsworksSecurityGroupsDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension UpdateStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStackOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStackOutputResponse()"}
}

extension UpdateStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateStackOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateStackOutputResponseBody: Swift.Equatable {
}

extension UpdateStackOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateUserProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserProfileOutputError>
}

extension UpdateUserProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserProfileInput(allowSelfManagement: \(Swift.String(describing: allowSelfManagement)), iamUserArn: \(Swift.String(describing: iamUserArn)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), sshUsername: \(Swift.String(describing: sshUsername)))"}
}

extension UpdateUserProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSelfManagement = "AllowSelfManagement"
        case iamUserArn = "IamUserArn"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSelfManagement = allowSelfManagement {
            try encodeContainer.encode(allowSelfManagement, forKey: .allowSelfManagement)
        }
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let sshUsername = sshUsername {
            try encodeContainer.encode(sshUsername, forKey: .sshUsername)
        }
    }
}

public struct UpdateUserProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserProfileOutputError>
}

public struct UpdateUserProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserProfileOutputError>
}

public struct UpdateUserProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateUserProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateUserProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserProfileOutputError>
}

public struct UpdateUserProfileInput: Swift.Equatable {
    /// Whether users can specify their own SSH public key through the My Settings page. For more
    ///       information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/security-settingsshkey.html">Managing User
    ///         Permissions.
    public var allowSelfManagement: Swift.Bool?
    /// The user IAM ARN. This can also be a federated user's ARN.
    /// This member is required.
    public var iamUserArn: Swift.String?
    /// The user's new SSH public key.
    public var sshPublicKey: Swift.String?
    /// The user's SSH user name. The allowable characters are [a-z], [A-Z], [0-9], '-', and '_'. If
    ///       the specified name includes other punctuation marks, AWS OpsWorks Stacks removes them. For example,
    ///         my.name will be changed to myname. If you do not specify an SSH
    ///       user name, AWS OpsWorks Stacks generates one from the IAM user name.
    public var sshUsername: Swift.String?

    public init (
        allowSelfManagement: Swift.Bool? = nil,
        iamUserArn: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        sshUsername: Swift.String? = nil
    )
    {
        self.allowSelfManagement = allowSelfManagement
        self.iamUserArn = iamUserArn
        self.sshPublicKey = sshPublicKey
        self.sshUsername = sshUsername
    }
}

struct UpdateUserProfileInputBody: Swift.Equatable {
    public let iamUserArn: Swift.String?
    public let sshUsername: Swift.String?
    public let sshPublicKey: Swift.String?
    public let allowSelfManagement: Swift.Bool?
}

extension UpdateUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSelfManagement = "AllowSelfManagement"
        case iamUserArn = "IamUserArn"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let sshUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshUsername)
        sshUsername = sshUsernameDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let allowSelfManagementDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSelfManagement)
        allowSelfManagement = allowSelfManagementDecoded
    }
}

extension UpdateUserProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserProfileOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserProfileOutputResponse()"}
}

extension UpdateUserProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserProfileOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateUserProfileOutputResponseBody: Swift.Equatable {
}

extension UpdateUserProfileOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateVolumeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVolumeOutputError>
}

extension UpdateVolumeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVolumeInput(mountPoint: \(Swift.String(describing: mountPoint)), name: \(Swift.String(describing: name)), volumeId: \(Swift.String(describing: volumeId)))"}
}

extension UpdateVolumeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mountPoint = "MountPoint"
        case name = "Name"
        case volumeId = "VolumeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mountPoint = mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
    }
}

public struct UpdateVolumeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVolumeOutputError>
}

public struct UpdateVolumeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVolumeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVolumeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVolumeOutputError>
}

public struct UpdateVolumeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVolumeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateVolumeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateVolumeInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVolumeOutputError>
}

public struct UpdateVolumeInput: Swift.Equatable {
    /// The new mount point.
    public var mountPoint: Swift.String?
    /// The new name.
    public var name: Swift.String?
    /// The volume ID.
    /// This member is required.
    public var volumeId: Swift.String?

    public init (
        mountPoint: Swift.String? = nil,
        name: Swift.String? = nil,
        volumeId: Swift.String? = nil
    )
    {
        self.mountPoint = mountPoint
        self.name = name
        self.volumeId = volumeId
    }
}

struct UpdateVolumeInputBody: Swift.Equatable {
    public let volumeId: Swift.String?
    public let name: Swift.String?
    public let mountPoint: Swift.String?
}

extension UpdateVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mountPoint = "MountPoint"
        case name = "Name"
        case volumeId = "VolumeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let mountPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
    }
}

extension UpdateVolumeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVolumeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVolumeOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVolumeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVolumeOutputResponse()"}
}

extension UpdateVolumeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateVolumeOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateVolumeOutputResponseBody: Swift.Equatable {
}

extension UpdateVolumeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension OpsWorksClientTypes.UserProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSelfManagement = "AllowSelfManagement"
        case iamUserArn = "IamUserArn"
        case name = "Name"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSelfManagement = allowSelfManagement {
            try encodeContainer.encode(allowSelfManagement, forKey: .allowSelfManagement)
        }
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let sshUsername = sshUsername {
            try encodeContainer.encode(sshUsername, forKey: .sshUsername)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sshUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshUsername)
        sshUsername = sshUsernameDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let allowSelfManagementDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSelfManagement)
        allowSelfManagement = allowSelfManagementDecoded
    }
}

extension OpsWorksClientTypes.UserProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserProfile(allowSelfManagement: \(Swift.String(describing: allowSelfManagement)), iamUserArn: \(Swift.String(describing: iamUserArn)), name: \(Swift.String(describing: name)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), sshUsername: \(Swift.String(describing: sshUsername)))"}
}

extension OpsWorksClientTypes {
    /// Describes a user's SSH information.
    public struct UserProfile: Swift.Equatable {
        /// Whether users can specify their own SSH public key through the My Settings page. For more
        ///       information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/security-settingsshkey.html">Managing User
        ///         Permissions.
        public var allowSelfManagement: Swift.Bool?
        /// The user's IAM ARN.
        public var iamUserArn: Swift.String?
        /// The user's name.
        public var name: Swift.String?
        /// The user's SSH public key.
        public var sshPublicKey: Swift.String?
        /// The user's SSH user name.
        public var sshUsername: Swift.String?

        public init (
            allowSelfManagement: Swift.Bool? = nil,
            iamUserArn: Swift.String? = nil,
            name: Swift.String? = nil,
            sshPublicKey: Swift.String? = nil,
            sshUsername: Swift.String? = nil
        )
        {
            self.allowSelfManagement = allowSelfManagement
            self.iamUserArn = iamUserArn
            self.name = name
            self.sshPublicKey = sshPublicKey
            self.sshUsername = sshUsername
        }
    }

}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a request was not valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsWorksClientTypes {
    public enum VirtualizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hvm
        case paravirtual
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualizationType] {
            return [
                .hvm,
                .paravirtual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hvm: return "hvm"
            case .paravirtual: return "paravirtual"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VirtualizationType(rawValue: rawValue) ?? VirtualizationType.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.Volume: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case device = "Device"
        case ec2VolumeId = "Ec2VolumeId"
        case encrypted = "Encrypted"
        case instanceId = "InstanceId"
        case iops = "Iops"
        case mountPoint = "MountPoint"
        case name = "Name"
        case raidArrayId = "RaidArrayId"
        case region = "Region"
        case size = "Size"
        case status = "Status"
        case volumeId = "VolumeId"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let device = device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let ec2VolumeId = ec2VolumeId {
            try encodeContainer.encode(ec2VolumeId, forKey: .ec2VolumeId)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let iops = iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let mountPoint = mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let raidArrayId = raidArrayId {
            try encodeContainer.encode(raidArrayId, forKey: .raidArrayId)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let ec2VolumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2VolumeId)
        ec2VolumeId = ec2VolumeIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let raidArrayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .raidArrayId)
        raidArrayId = raidArrayIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .device)
        device = deviceDecoded
        let mountPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
    }
}

extension OpsWorksClientTypes.Volume: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Volume(availabilityZone: \(Swift.String(describing: availabilityZone)), device: \(Swift.String(describing: device)), ec2VolumeId: \(Swift.String(describing: ec2VolumeId)), encrypted: \(Swift.String(describing: encrypted)), instanceId: \(Swift.String(describing: instanceId)), iops: \(Swift.String(describing: iops)), mountPoint: \(Swift.String(describing: mountPoint)), name: \(Swift.String(describing: name)), raidArrayId: \(Swift.String(describing: raidArrayId)), region: \(Swift.String(describing: region)), size: \(Swift.String(describing: size)), status: \(Swift.String(describing: status)), volumeId: \(Swift.String(describing: volumeId)), volumeType: \(Swift.String(describing: volumeType)))"}
}

extension OpsWorksClientTypes {
    /// Describes an instance's Amazon EBS volume.
    public struct Volume: Swift.Equatable {
        /// The volume Availability Zone. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints.
        public var availabilityZone: Swift.String?
        /// The device name.
        public var device: Swift.String?
        /// The Amazon EC2 volume ID.
        public var ec2VolumeId: Swift.String?
        /// Specifies whether an Amazon EBS volume is encrypted. For more information,
        ///             see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption.
        public var encrypted: Swift.Bool?
        /// The instance ID.
        public var instanceId: Swift.String?
        /// For PIOPS volumes, the IOPS per disk.
        public var iops: Swift.Int?
        /// The volume mount point. For example, "/mnt/disk1".
        public var mountPoint: Swift.String?
        /// The volume name.
        public var name: Swift.String?
        /// The RAID array ID.
        public var raidArrayId: Swift.String?
        /// The AWS region. For more information about AWS regions, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints.
        public var region: Swift.String?
        /// The volume size.
        public var size: Swift.Int?
        /// The value returned by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeVolumes.html">DescribeVolumes.
        public var status: Swift.String?
        /// The volume ID.
        public var volumeId: Swift.String?
        /// The volume type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">
        ///           Amazon EBS Volume Types.
        ///
        ///
        ///
        ///                   standard - Magnetic. Magnetic volumes must have a minimum size of 1 GiB and a maximum size of 1024 GiB.
        ///
        ///
        ///
        ///                   io1 - Provisioned IOPS (SSD). PIOPS volumes must have a minimum size of 4 GiB and a maximum size of 16384 GiB.
        ///
        ///
        ///
        ///                   gp2 - General Purpose (SSD). General purpose volumes must have a minimum size of 1 GiB and a maximum size of 16384 GiB.
        ///
        ///
        ///
        ///                   st1 - Throughput Optimized hard disk drive (HDD). Throughput optimized HDD volumes must have a minimum size of 500 GiB and a maximum size of 16384 GiB.
        ///
        ///
        ///
        ///                   sc1 - Cold HDD. Cold HDD volumes must have a minimum size of 500 GiB and a maximum size of 16384 GiB.
        ///
        ///
        public var volumeType: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            device: Swift.String? = nil,
            ec2VolumeId: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            instanceId: Swift.String? = nil,
            iops: Swift.Int? = nil,
            mountPoint: Swift.String? = nil,
            name: Swift.String? = nil,
            raidArrayId: Swift.String? = nil,
            region: Swift.String? = nil,
            size: Swift.Int? = nil,
            status: Swift.String? = nil,
            volumeId: Swift.String? = nil,
            volumeType: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.device = device
            self.ec2VolumeId = ec2VolumeId
            self.encrypted = encrypted
            self.instanceId = instanceId
            self.iops = iops
            self.mountPoint = mountPoint
            self.name = name
            self.raidArrayId = raidArrayId
            self.region = region
            self.size = size
            self.status = status
            self.volumeId = volumeId
            self.volumeType = volumeType
        }
    }

}

extension OpsWorksClientTypes.VolumeConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encrypted = "Encrypted"
        case iops = "Iops"
        case mountPoint = "MountPoint"
        case numberOfDisks = "NumberOfDisks"
        case raidLevel = "RaidLevel"
        case size = "Size"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let iops = iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let mountPoint = mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
        if let numberOfDisks = numberOfDisks {
            try encodeContainer.encode(numberOfDisks, forKey: .numberOfDisks)
        }
        if let raidLevel = raidLevel {
            try encodeContainer.encode(raidLevel, forKey: .raidLevel)
        }
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mountPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
        let raidLevelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .raidLevel)
        raidLevel = raidLevelDecoded
        let numberOfDisksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDisks)
        numberOfDisks = numberOfDisksDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
    }
}

extension OpsWorksClientTypes.VolumeConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VolumeConfiguration(encrypted: \(Swift.String(describing: encrypted)), iops: \(Swift.String(describing: iops)), mountPoint: \(Swift.String(describing: mountPoint)), numberOfDisks: \(Swift.String(describing: numberOfDisks)), raidLevel: \(Swift.String(describing: raidLevel)), size: \(Swift.String(describing: size)), volumeType: \(Swift.String(describing: volumeType)))"}
}

extension OpsWorksClientTypes {
    /// Describes an Amazon EBS volume configuration.
    public struct VolumeConfiguration: Swift.Equatable {
        /// Specifies whether an Amazon EBS volume is encrypted. For more information,
        ///             see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption.
        public var encrypted: Swift.Bool?
        /// For PIOPS volumes, the IOPS per disk.
        public var iops: Swift.Int?
        /// The volume mount point. For example "/dev/sdh".
        /// This member is required.
        public var mountPoint: Swift.String?
        /// The number of disks in the volume.
        /// This member is required.
        public var numberOfDisks: Swift.Int?
        /// The volume <a href="http://en.wikipedia.org/wiki/Standard_RAID_levels">RAID level.
        public var raidLevel: Swift.Int?
        /// The volume size.
        /// This member is required.
        public var size: Swift.Int?
        /// The volume type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">
        ///           Amazon EBS Volume Types.
        ///
        ///
        ///
        ///                   standard - Magnetic. Magnetic volumes must have a minimum size of 1 GiB and a maximum size of 1024 GiB.
        ///
        ///
        ///
        ///                   io1 - Provisioned IOPS (SSD). PIOPS volumes must have a minimum size of 4 GiB and a maximum size of 16384 GiB.
        ///
        ///
        ///
        ///                   gp2 - General Purpose (SSD). General purpose volumes must have a minimum size of 1 GiB and a maximum size of 16384 GiB.
        ///
        ///
        ///
        ///                   st1 - Throughput Optimized hard disk drive (HDD). Throughput optimized HDD volumes must have a minimum size of 500 GiB and a maximum size of 16384 GiB.
        ///
        ///
        ///
        ///                   sc1 - Cold HDD. Cold HDD volumes must have a minimum size of 500 GiB and a maximum size of 16384 GiB.
        ///
        ///
        public var volumeType: Swift.String?

        public init (
            encrypted: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            mountPoint: Swift.String? = nil,
            numberOfDisks: Swift.Int? = nil,
            raidLevel: Swift.Int? = nil,
            size: Swift.Int? = nil,
            volumeType: Swift.String? = nil
        )
        {
            self.encrypted = encrypted
            self.iops = iops
            self.mountPoint = mountPoint
            self.numberOfDisks = numberOfDisks
            self.raidLevel = raidLevel
            self.size = size
            self.volumeType = volumeType
        }
    }

}

extension OpsWorksClientTypes {
    public enum VolumeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gp2
        case io1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [VolumeType] {
            return [
                .gp2,
                .io1,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "gp2"
            case .io1: return "io1"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VolumeType(rawValue: rawValue) ?? VolumeType.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.WeeklyAutoScalingSchedule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case friday = "Friday"
        case monday = "Monday"
        case saturday = "Saturday"
        case sunday = "Sunday"
        case thursday = "Thursday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let friday = friday {
            var fridayContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .friday)
            for (dictKey0, dailyautoscalingschedule0) in friday {
                try fridayContainer.encode(dailyautoscalingschedule0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let monday = monday {
            var mondayContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .monday)
            for (dictKey0, dailyautoscalingschedule0) in monday {
                try mondayContainer.encode(dailyautoscalingschedule0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let saturday = saturday {
            var saturdayContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .saturday)
            for (dictKey0, dailyautoscalingschedule0) in saturday {
                try saturdayContainer.encode(dailyautoscalingschedule0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sunday = sunday {
            var sundayContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sunday)
            for (dictKey0, dailyautoscalingschedule0) in sunday {
                try sundayContainer.encode(dailyautoscalingschedule0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let thursday = thursday {
            var thursdayContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .thursday)
            for (dictKey0, dailyautoscalingschedule0) in thursday {
                try thursdayContainer.encode(dailyautoscalingschedule0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tuesday = tuesday {
            var tuesdayContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tuesday)
            for (dictKey0, dailyautoscalingschedule0) in tuesday {
                try tuesdayContainer.encode(dailyautoscalingschedule0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let wednesday = wednesday {
            var wednesdayContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .wednesday)
            for (dictKey0, dailyautoscalingschedule0) in wednesday {
                try wednesdayContainer.encode(dailyautoscalingschedule0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mondayContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .monday)
        var mondayDecoded0: [Swift.String:Swift.String]? = nil
        if let mondayContainer = mondayContainer {
            mondayDecoded0 = [Swift.String:Swift.String]()
            for (key0, switch0) in mondayContainer {
                if let switch0 = switch0 {
                    mondayDecoded0?[key0] = switch0
                }
            }
        }
        monday = mondayDecoded0
        let tuesdayContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tuesday)
        var tuesdayDecoded0: [Swift.String:Swift.String]? = nil
        if let tuesdayContainer = tuesdayContainer {
            tuesdayDecoded0 = [Swift.String:Swift.String]()
            for (key0, switch0) in tuesdayContainer {
                if let switch0 = switch0 {
                    tuesdayDecoded0?[key0] = switch0
                }
            }
        }
        tuesday = tuesdayDecoded0
        let wednesdayContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .wednesday)
        var wednesdayDecoded0: [Swift.String:Swift.String]? = nil
        if let wednesdayContainer = wednesdayContainer {
            wednesdayDecoded0 = [Swift.String:Swift.String]()
            for (key0, switch0) in wednesdayContainer {
                if let switch0 = switch0 {
                    wednesdayDecoded0?[key0] = switch0
                }
            }
        }
        wednesday = wednesdayDecoded0
        let thursdayContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .thursday)
        var thursdayDecoded0: [Swift.String:Swift.String]? = nil
        if let thursdayContainer = thursdayContainer {
            thursdayDecoded0 = [Swift.String:Swift.String]()
            for (key0, switch0) in thursdayContainer {
                if let switch0 = switch0 {
                    thursdayDecoded0?[key0] = switch0
                }
            }
        }
        thursday = thursdayDecoded0
        let fridayContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .friday)
        var fridayDecoded0: [Swift.String:Swift.String]? = nil
        if let fridayContainer = fridayContainer {
            fridayDecoded0 = [Swift.String:Swift.String]()
            for (key0, switch0) in fridayContainer {
                if let switch0 = switch0 {
                    fridayDecoded0?[key0] = switch0
                }
            }
        }
        friday = fridayDecoded0
        let saturdayContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .saturday)
        var saturdayDecoded0: [Swift.String:Swift.String]? = nil
        if let saturdayContainer = saturdayContainer {
            saturdayDecoded0 = [Swift.String:Swift.String]()
            for (key0, switch0) in saturdayContainer {
                if let switch0 = switch0 {
                    saturdayDecoded0?[key0] = switch0
                }
            }
        }
        saturday = saturdayDecoded0
        let sundayContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sunday)
        var sundayDecoded0: [Swift.String:Swift.String]? = nil
        if let sundayContainer = sundayContainer {
            sundayDecoded0 = [Swift.String:Swift.String]()
            for (key0, switch0) in sundayContainer {
                if let switch0 = switch0 {
                    sundayDecoded0?[key0] = switch0
                }
            }
        }
        sunday = sundayDecoded0
    }
}

extension OpsWorksClientTypes.WeeklyAutoScalingSchedule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WeeklyAutoScalingSchedule(friday: \(Swift.String(describing: friday)), monday: \(Swift.String(describing: monday)), saturday: \(Swift.String(describing: saturday)), sunday: \(Swift.String(describing: sunday)), thursday: \(Swift.String(describing: thursday)), tuesday: \(Swift.String(describing: tuesday)), wednesday: \(Swift.String(describing: wednesday)))"}
}

extension OpsWorksClientTypes {
    /// Describes a time-based instance's auto scaling schedule. The schedule consists of a set of key-value pairs.
    ///
    ///
    ///                The key is the time period (a UTC hour) and must be an integer from 0 - 23.
    ///
    ///
    ///                The value indicates whether the instance should be online or offline for the specified period, and must be set to "on" or "off"
    ///
    ///
    ///          The default setting for all time periods is off, so you use the following parameters primarily to specify the online periods. You don't have to explicitly specify offline periods unless you want to change an online period to an offline period.
    ///          The following example specifies that the instance should be online for four hours, from UTC 1200 - 1600. It will be off for the remainder of the day.
    ///
    ///              { "12":"on", "13":"on", "14":"on", "15":"on" }
    ///
    public struct WeeklyAutoScalingSchedule: Swift.Equatable {
        /// The schedule for Friday.
        public var friday: [Swift.String:Swift.String]?
        /// The schedule for Monday.
        public var monday: [Swift.String:Swift.String]?
        /// The schedule for Saturday.
        public var saturday: [Swift.String:Swift.String]?
        /// The schedule for Sunday.
        public var sunday: [Swift.String:Swift.String]?
        /// The schedule for Thursday.
        public var thursday: [Swift.String:Swift.String]?
        /// The schedule for Tuesday.
        public var tuesday: [Swift.String:Swift.String]?
        /// The schedule for Wednesday.
        public var wednesday: [Swift.String:Swift.String]?

        public init (
            friday: [Swift.String:Swift.String]? = nil,
            monday: [Swift.String:Swift.String]? = nil,
            saturday: [Swift.String:Swift.String]? = nil,
            sunday: [Swift.String:Swift.String]? = nil,
            thursday: [Swift.String:Swift.String]? = nil,
            tuesday: [Swift.String:Swift.String]? = nil,
            wednesday: [Swift.String:Swift.String]? = nil
        )
        {
            self.friday = friday
            self.monday = monday
            self.saturday = saturday
            self.sunday = sunday
            self.thursday = thursday
            self.tuesday = tuesday
            self.wednesday = wednesday
        }
    }

}
