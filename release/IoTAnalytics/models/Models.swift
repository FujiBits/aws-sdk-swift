// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IoTAnalyticsClientTypes.AddAttributesActivity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case name
        case next
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributenamemapping0) in attributes {
                try attributesContainer.encode(attributenamemapping0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributename0) in attributesContainer {
                if let attributename0 = attributename0 {
                    attributesDecoded0?[key0] = attributename0
                }
            }
        }
        attributes = attributesDecoded0
        let nextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .next)
        next = nextDecoded
    }
}

extension IoTAnalyticsClientTypes.AddAttributesActivity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddAttributesActivity(attributes: \(Swift.String(describing: attributes)), name: \(Swift.String(describing: name)), next: \(Swift.String(describing: next)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>An activity that adds other attributes based on existing attributes in the message.</p>
    public struct AddAttributesActivity: Swift.Equatable {
        /// <p>A list of 1-50 <code>AttributeNameMapping</code> objects that map an existing attribute to
        ///       a new attribute.</p>
        ///          <note>
        ///             <p>The existing attributes remain in the message, so if you want to remove the originals,
        ///         use <code>RemoveAttributeActivity</code>.</p>
        ///          </note>
        public let attributes: [Swift.String:Swift.String]?
        /// <p>The name of the addAttributes activity.</p>
        public let name: Swift.String?
        /// <p>The next activity in the pipeline.</p>
        public let next: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            next: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.name = name
            self.next = next
        }
    }

}

extension IoTAnalyticsClientTypes.BatchPutMessageErrorEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case messageId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension IoTAnalyticsClientTypes.BatchPutMessageErrorEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutMessageErrorEntry(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), messageId: \(Swift.String(describing: messageId)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Contains informations about errors.</p>
    public struct BatchPutMessageErrorEntry: Swift.Equatable {
        /// <p>The code associated with the error.</p>
        public let errorCode: Swift.String?
        /// <p>The message associated with the error.</p>
        public let errorMessage: Swift.String?
        /// <p>The ID of the message that caused the error. See the value corresponding to the
        ///             <code>messageId</code> key in the message object.</p>
        public let messageId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            messageId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.messageId = messageId
        }
    }

}

public struct BatchPutMessageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutMessageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchPutMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchPutMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutMessageOutputError>
}

extension BatchPutMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutMessageInput(channelName: \(Swift.String(describing: channelName)), messages: \(Swift.String(describing: messages)))"}
}

extension BatchPutMessageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName
        case messages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let messages = messages {
            var messagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messages)
            for messages0 in messages {
                try messagesContainer.encode(messages0)
            }
        }
    }
}

public struct BatchPutMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchPutMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchPutMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutMessageOutputError>
}

public struct BatchPutMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchPutMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchPutMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutMessageOutputError>
}

public struct BatchPutMessageInput: Swift.Equatable {
    /// <p>The name of the channel where the messages are sent.</p>
    public let channelName: Swift.String?
    /// <p>The list of messages to be sent. Each message has the format: { "messageId": "string",
    ///          "payload": "string"}.</p>
    ///          <p>The field names of message payloads (data) that you send to AWS IoT Analytics:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Must contain only alphanumeric characters and undescores (_). No other special characters are
    ///                allowed.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must begin with an alphabetic character or single underscore (_).</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot contain hyphens (-).</p>
    ///             </li>
    ///             <li>
    ///                <p>In regular expression terms: "^[A-Za-z_]([A-Za-z0-9]*|[A-Za-z0-9][A-Za-z0-9_]*)$".
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot be more than 255 characters.</p>
    ///             </li>
    ///             <li>
    ///                <p>Are case insensitive. (Fields named foo and FOO in the same payload are considered
    ///                duplicates.)</p>
    ///             </li>
    ///          </ul>
    ///          <p>For example, {"temp_01": 29} or {"_temp_01": 29} are valid, but {"temp-01": 29},
    ///  {"01_temp": 29} or {"__temp_01": 29} are invalid in message payloads.  </p>
    public let messages: [IoTAnalyticsClientTypes.Message]?

    public init (
        channelName: Swift.String? = nil,
        messages: [IoTAnalyticsClientTypes.Message]? = nil
    )
    {
        self.channelName = channelName
        self.messages = messages
    }
}

struct BatchPutMessageInputBody: Swift.Equatable {
    public let channelName: Swift.String?
    public let messages: [IoTAnalyticsClientTypes.Message]?
}

extension BatchPutMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName
        case messages
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let messagesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[IoTAnalyticsClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [IoTAnalyticsClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
    }
}

extension BatchPutMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchPutMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchPutMessageOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchPutMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutMessageOutputResponse(batchPutMessageErrorEntries: \(Swift.String(describing: batchPutMessageErrorEntries)))"}
}

extension BatchPutMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchPutMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchPutMessageErrorEntries = output.batchPutMessageErrorEntries
        } else {
            self.batchPutMessageErrorEntries = nil
        }
    }
}

public struct BatchPutMessageOutputResponse: Swift.Equatable {
    /// <p>A list of any errors encountered when sending the messages to the channel.</p>
    public let batchPutMessageErrorEntries: [IoTAnalyticsClientTypes.BatchPutMessageErrorEntry]?

    public init (
        batchPutMessageErrorEntries: [IoTAnalyticsClientTypes.BatchPutMessageErrorEntry]? = nil
    )
    {
        self.batchPutMessageErrorEntries = batchPutMessageErrorEntries
    }
}

struct BatchPutMessageOutputResponseBody: Swift.Equatable {
    public let batchPutMessageErrorEntries: [IoTAnalyticsClientTypes.BatchPutMessageErrorEntry]?
}

extension BatchPutMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchPutMessageErrorEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchPutMessageErrorEntriesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.BatchPutMessageErrorEntry?].self, forKey: .batchPutMessageErrorEntries)
        var batchPutMessageErrorEntriesDecoded0:[IoTAnalyticsClientTypes.BatchPutMessageErrorEntry]? = nil
        if let batchPutMessageErrorEntriesContainer = batchPutMessageErrorEntriesContainer {
            batchPutMessageErrorEntriesDecoded0 = [IoTAnalyticsClientTypes.BatchPutMessageErrorEntry]()
            for structure0 in batchPutMessageErrorEntriesContainer {
                if let structure0 = structure0 {
                    batchPutMessageErrorEntriesDecoded0?.append(structure0)
                }
            }
        }
        batchPutMessageErrorEntries = batchPutMessageErrorEntriesDecoded0
    }
}

extension CancelPipelineReprocessingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelPipelineReprocessingInput(pipelineName: \(Swift.String(describing: pipelineName)), reprocessingId: \(Swift.String(describing: reprocessingId)))"}
}

extension CancelPipelineReprocessingInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct CancelPipelineReprocessingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelPipelineReprocessingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelPipelineReprocessingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelPipelineReprocessingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelPipelineReprocessingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelPipelineReprocessingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelPipelineReprocessingOutputError>
}

public struct CancelPipelineReprocessingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelPipelineReprocessingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelPipelineReprocessingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelPipelineReprocessingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelPipelineReprocessingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelPipelineReprocessingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelPipelineReprocessingOutputError>
}

public struct CancelPipelineReprocessingInput: Swift.Equatable {
    /// <p>The name of pipeline for which data reprocessing is canceled.</p>
    public let pipelineName: Swift.String?
    /// <p>The ID of the reprocessing task (returned by
    ///       <code>StartPipelineReprocessing</code>).</p>
    public let reprocessingId: Swift.String?

    public init (
        pipelineName: Swift.String? = nil,
        reprocessingId: Swift.String? = nil
    )
    {
        self.pipelineName = pipelineName
        self.reprocessingId = reprocessingId
    }
}

struct CancelPipelineReprocessingInputBody: Swift.Equatable {
}

extension CancelPipelineReprocessingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelPipelineReprocessingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelPipelineReprocessingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelPipelineReprocessingOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelPipelineReprocessingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelPipelineReprocessingOutputResponse()"}
}

extension CancelPipelineReprocessingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelPipelineReprocessingOutputResponse: Swift.Equatable {

    public init() {}
}

struct CancelPipelineReprocessingOutputResponseBody: Swift.Equatable {
}

extension CancelPipelineReprocessingOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IoTAnalyticsClientTypes.Channel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case lastMessageArrivalTime
        case lastUpdateTime
        case name
        case retentionPeriod
        case status
        case storage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastMessageArrivalTime = lastMessageArrivalTime {
            try encodeContainer.encode(lastMessageArrivalTime.timeIntervalSince1970, forKey: .lastMessageArrivalTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let storage = storage {
            try encodeContainer.encode(storage, forKey: .storage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let storageDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ChannelStorage.self, forKey: .storage)
        storage = storageDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ChannelStatus.self, forKey: .status)
        status = statusDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let lastMessageArrivalTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastMessageArrivalTime)
        lastMessageArrivalTime = lastMessageArrivalTimeDecoded
    }
}

extension IoTAnalyticsClientTypes.Channel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Channel(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), lastMessageArrivalTime: \(Swift.String(describing: lastMessageArrivalTime)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), name: \(Swift.String(describing: name)), retentionPeriod: \(Swift.String(describing: retentionPeriod)), status: \(Swift.String(describing: status)), storage: \(Swift.String(describing: storage)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>A collection of data from an MQTT topic. Channels archive the raw, unprocessed messages
    ///       before publishing the data to a pipeline.</p>
    public struct Channel: Swift.Equatable {
        /// <p>The ARN of the channel.</p>
        public let arn: Swift.String?
        /// <p>When the channel was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The last time when a new message arrived in the channel.</p>
        ///          <p>AWS IoT Analytics updates this value at most once per minute for one channel.
        ///   Hence, the <code>lastMessageArrivalTime</code> value is an approximation.</p>
        ///          <p>This feature only applies to messages that arrived in the data store after October 23, 2020. </p>
        public let lastMessageArrivalTime: ClientRuntime.Date?
        /// <p>When the channel was last updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The name of the channel.</p>
        public let name: Swift.String?
        /// <p>How long, in days, message data is kept for the channel.</p>
        public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
        /// <p>The status of the channel.</p>
        public let status: IoTAnalyticsClientTypes.ChannelStatus?
        /// <p>Where channel data is stored. You can choose one of <code>serviceManagedS3</code> or
        ///         <code>customerManagedS3</code> storage. If not specified, the default is
        ///         <code>serviceManagedS3</code>. You cannot change this storage option after the channel is
        ///       created.</p>
        public let storage: IoTAnalyticsClientTypes.ChannelStorage?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastMessageArrivalTime: ClientRuntime.Date? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod? = nil,
            status: IoTAnalyticsClientTypes.ChannelStatus? = nil,
            storage: IoTAnalyticsClientTypes.ChannelStorage? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.lastMessageArrivalTime = lastMessageArrivalTime
            self.lastUpdateTime = lastUpdateTime
            self.name = name
            self.retentionPeriod = retentionPeriod
            self.status = status
            self.storage = storage
        }
    }

}

extension IoTAnalyticsClientTypes.ChannelActivity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName
        case name
        case next
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let nextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .next)
        next = nextDecoded
    }
}

extension IoTAnalyticsClientTypes.ChannelActivity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelActivity(channelName: \(Swift.String(describing: channelName)), name: \(Swift.String(describing: name)), next: \(Swift.String(describing: next)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>The activity that determines the source of the messages to be processed.</p>
    public struct ChannelActivity: Swift.Equatable {
        /// <p>The name of the channel from which the messages are processed.</p>
        public let channelName: Swift.String?
        /// <p>The name of the channel activity.</p>
        public let name: Swift.String?
        /// <p>The next activity in the pipeline.</p>
        public let next: Swift.String?

        public init (
            channelName: Swift.String? = nil,
            name: Swift.String? = nil,
            next: Swift.String? = nil
        )
        {
            self.channelName = channelName
            self.name = name
            self.next = next
        }
    }

}

extension IoTAnalyticsClientTypes.ChannelMessages: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Paths
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Paths = s3Paths {
            var s3PathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Paths)
            for s3pathchannelmessages0 in s3Paths {
                try s3PathsContainer.encode(s3pathchannelmessages0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3PathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .s3Paths)
        var s3PathsDecoded0:[Swift.String]? = nil
        if let s3PathsContainer = s3PathsContainer {
            s3PathsDecoded0 = [Swift.String]()
            for string0 in s3PathsContainer {
                if let string0 = string0 {
                    s3PathsDecoded0?.append(string0)
                }
            }
        }
        s3Paths = s3PathsDecoded0
    }
}

extension IoTAnalyticsClientTypes.ChannelMessages: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMessages(s3Paths: \(Swift.String(describing: s3Paths)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Specifies one or more sets of channel messages.</p>
    public struct ChannelMessages: Swift.Equatable {
        /// <p>Specifies one or more keys that identify the Amazon Simple Storage Service (Amazon S3) objects that save your
        ///       channel messages.</p>
        public let s3Paths: [Swift.String]?

        public init (
            s3Paths: [Swift.String]? = nil
        )
        {
            self.s3Paths = s3Paths
        }
    }

}

extension IoTAnalyticsClientTypes.ChannelStatistics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case size
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.EstimatedResourceSize.self, forKey: .size)
        size = sizeDecoded
    }
}

extension IoTAnalyticsClientTypes.ChannelStatistics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelStatistics(size: \(Swift.String(describing: size)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Statistics information about the channel.</p>
    public struct ChannelStatistics: Swift.Equatable {
        /// <p>The estimated size of the channel.</p>
        public let size: IoTAnalyticsClientTypes.EstimatedResourceSize?

        public init (
            size: IoTAnalyticsClientTypes.EstimatedResourceSize? = nil
        )
        {
            self.size = size
        }
    }

}

extension IoTAnalyticsClientTypes {
    public enum ChannelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelStatus(rawValue: rawValue) ?? ChannelStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTAnalyticsClientTypes.ChannelStorage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedS3
        case serviceManagedS3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManagedS3 = customerManagedS3 {
            try encodeContainer.encode(customerManagedS3, forKey: .customerManagedS3)
        }
        if let serviceManagedS3 = serviceManagedS3 {
            try encodeContainer.encode(serviceManagedS3, forKey: .serviceManagedS3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceManagedS3Decoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ServiceManagedChannelS3Storage.self, forKey: .serviceManagedS3)
        serviceManagedS3 = serviceManagedS3Decoded
        let customerManagedS3Decoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.CustomerManagedChannelS3Storage.self, forKey: .customerManagedS3)
        customerManagedS3 = customerManagedS3Decoded
    }
}

extension IoTAnalyticsClientTypes.ChannelStorage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelStorage(customerManagedS3: \(Swift.String(describing: customerManagedS3)), serviceManagedS3: \(Swift.String(describing: serviceManagedS3)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Where channel data is stored. You may choose one of <code>serviceManagedS3</code> or
    ///         <code>customerManagedS3</code> storage. If not specified, the default is
    ///         <code>serviceManagedS3</code>. This cannot be changed after creation of the channel.</p>
    public struct ChannelStorage: Swift.Equatable {
        /// <p>Use this to store channel data in an S3 bucket that you manage. If customer managed
        ///       storage is selected, the <code>retentionPeriod</code> parameter is ignored. You cannot change
        ///       the choice of service-managed or customer-managed S3 storage after the channel is
        ///       created.</p>
        public let customerManagedS3: IoTAnalyticsClientTypes.CustomerManagedChannelS3Storage?
        /// <p>Use this to store channel data in an S3 bucket managed by AWS IoT Analytics. You cannot
        ///       change the choice of service-managed or customer-managed S3 storage after the channel is
        ///       created.</p>
        public let serviceManagedS3: IoTAnalyticsClientTypes.ServiceManagedChannelS3Storage?

        public init (
            customerManagedS3: IoTAnalyticsClientTypes.CustomerManagedChannelS3Storage? = nil,
            serviceManagedS3: IoTAnalyticsClientTypes.ServiceManagedChannelS3Storage? = nil
        )
        {
            self.customerManagedS3 = customerManagedS3
            self.serviceManagedS3 = serviceManagedS3
        }
    }

}

extension IoTAnalyticsClientTypes.ChannelStorageSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedS3
        case serviceManagedS3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManagedS3 = customerManagedS3 {
            try encodeContainer.encode(customerManagedS3, forKey: .customerManagedS3)
        }
        if let serviceManagedS3 = serviceManagedS3 {
            try encodeContainer.encode(serviceManagedS3, forKey: .serviceManagedS3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceManagedS3Decoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ServiceManagedChannelS3StorageSummary.self, forKey: .serviceManagedS3)
        serviceManagedS3 = serviceManagedS3Decoded
        let customerManagedS3Decoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.CustomerManagedChannelS3StorageSummary.self, forKey: .customerManagedS3)
        customerManagedS3 = customerManagedS3Decoded
    }
}

extension IoTAnalyticsClientTypes.ChannelStorageSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelStorageSummary(customerManagedS3: \(Swift.String(describing: customerManagedS3)), serviceManagedS3: \(Swift.String(describing: serviceManagedS3)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Where channel data is stored.</p>
    public struct ChannelStorageSummary: Swift.Equatable {
        /// <p>Used to store channel data in an S3 bucket that you manage.</p>
        public let customerManagedS3: IoTAnalyticsClientTypes.CustomerManagedChannelS3StorageSummary?
        /// <p>Used to store channel data in an S3 bucket managed by AWS IoT Analytics.</p>
        public let serviceManagedS3: IoTAnalyticsClientTypes.ServiceManagedChannelS3StorageSummary?

        public init (
            customerManagedS3: IoTAnalyticsClientTypes.CustomerManagedChannelS3StorageSummary? = nil,
            serviceManagedS3: IoTAnalyticsClientTypes.ServiceManagedChannelS3StorageSummary? = nil
        )
        {
            self.customerManagedS3 = customerManagedS3
            self.serviceManagedS3 = serviceManagedS3
        }
    }

}

extension IoTAnalyticsClientTypes.ChannelSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName
        case channelStorage
        case creationTime
        case lastMessageArrivalTime
        case lastUpdateTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelStorage = channelStorage {
            try encodeContainer.encode(channelStorage, forKey: .channelStorage)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastMessageArrivalTime = lastMessageArrivalTime {
            try encodeContainer.encode(lastMessageArrivalTime.timeIntervalSince1970, forKey: .lastMessageArrivalTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStorageDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ChannelStorageSummary.self, forKey: .channelStorage)
        channelStorage = channelStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ChannelStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let lastMessageArrivalTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastMessageArrivalTime)
        lastMessageArrivalTime = lastMessageArrivalTimeDecoded
    }
}

extension IoTAnalyticsClientTypes.ChannelSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelSummary(channelName: \(Swift.String(describing: channelName)), channelStorage: \(Swift.String(describing: channelStorage)), creationTime: \(Swift.String(describing: creationTime)), lastMessageArrivalTime: \(Swift.String(describing: lastMessageArrivalTime)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), status: \(Swift.String(describing: status)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>A summary of information about a channel.</p>
    public struct ChannelSummary: Swift.Equatable {
        /// <p>The name of the channel.</p>
        public let channelName: Swift.String?
        /// <p>Where channel data is stored.</p>
        public let channelStorage: IoTAnalyticsClientTypes.ChannelStorageSummary?
        /// <p>When the channel was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The last time when a new message arrived in the channel.</p>
        ///          <p>AWS IoT Analytics updates this value at most once per minute for one channel.
        ///   Hence, the <code>lastMessageArrivalTime</code> value is an approximation.</p>
        ///          <p>This feature only applies to messages that arrived in the data store after October 23, 2020. </p>
        public let lastMessageArrivalTime: ClientRuntime.Date?
        /// <p>The last time the channel was updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The status of the channel.</p>
        public let status: IoTAnalyticsClientTypes.ChannelStatus?

        public init (
            channelName: Swift.String? = nil,
            channelStorage: IoTAnalyticsClientTypes.ChannelStorageSummary? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastMessageArrivalTime: ClientRuntime.Date? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            status: IoTAnalyticsClientTypes.ChannelStatus? = nil
        )
        {
            self.channelName = channelName
            self.channelStorage = channelStorage
            self.creationTime = creationTime
            self.lastMessageArrivalTime = lastMessageArrivalTime
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }
    }

}

extension IoTAnalyticsClientTypes.Column: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTAnalyticsClientTypes.Column: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Column(name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Contains information about a column that stores your data.</p>
    public struct Column: Swift.Equatable {
        /// <p>The name of the column.</p>
        public let name: Swift.String?
        /// <p>The type of data. For more information about the supported data types, see <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-common.html">Common data types</a>
        ///       in the <i>AWS Glue Developer Guide</i>.</p>
        public let type: Swift.String?

        public init (
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension IoTAnalyticsClientTypes {
    public enum ComputeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acu1
        case acu2
        case sdkUnknown(Swift.String)

        public static var allCases: [ComputeType] {
            return [
                .acu1,
                .acu2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acu1: return "ACU_1"
            case .acu2: return "ACU_2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComputeType(rawValue: rawValue) ?? ComputeType.sdkUnknown(rawValue)
        }
    }
}

extension IoTAnalyticsClientTypes.ContainerDatasetAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionRoleArn
        case image
        case resourceConfiguration
        case variables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let image = image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if let resourceConfiguration = resourceConfiguration {
            try encodeContainer.encode(resourceConfiguration, forKey: .resourceConfiguration)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for variables0 in variables {
                try variablesContainer.encode(variables0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .image)
        image = imageDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let resourceConfigurationDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ResourceConfiguration.self, forKey: .resourceConfiguration)
        resourceConfiguration = resourceConfigurationDecoded
        let variablesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.Variable?].self, forKey: .variables)
        var variablesDecoded0:[IoTAnalyticsClientTypes.Variable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [IoTAnalyticsClientTypes.Variable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
    }
}

extension IoTAnalyticsClientTypes.ContainerDatasetAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContainerDatasetAction(executionRoleArn: \(Swift.String(describing: executionRoleArn)), image: \(Swift.String(describing: image)), resourceConfiguration: \(Swift.String(describing: resourceConfiguration)), variables: \(Swift.String(describing: variables)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Information required to run the <code>containerAction</code> to produce dataset
    ///       contents.</p>
    public struct ContainerDatasetAction: Swift.Equatable {
        /// <p>The ARN of the role that gives permission to the system to access required resources to
        ///       run the <code>containerAction</code>. This includes, at minimum, permission to retrieve the
        ///       dataset contents that are the input to the containerized application.</p>
        public let executionRoleArn: Swift.String?
        /// <p>The ARN of the Docker container stored in your account. The Docker container contains an
        ///       application and required support libraries and is used to generate dataset contents.</p>
        public let image: Swift.String?
        /// <p>Configuration of the resource that executes the <code>containerAction</code>.</p>
        public let resourceConfiguration: IoTAnalyticsClientTypes.ResourceConfiguration?
        /// <p>The values of variables used in the context of the execution of the containerized
        ///       application (basically, parameters passed to the application). Each variable must have a name
        ///       and a value given by one of <code>stringValue</code>, <code>datasetContentVersionValue</code>,
        ///       or <code>outputFileUriValue</code>.</p>
        public let variables: [IoTAnalyticsClientTypes.Variable]?

        public init (
            executionRoleArn: Swift.String? = nil,
            image: Swift.String? = nil,
            resourceConfiguration: IoTAnalyticsClientTypes.ResourceConfiguration? = nil,
            variables: [IoTAnalyticsClientTypes.Variable]? = nil
        )
        {
            self.executionRoleArn = executionRoleArn
            self.image = image
            self.resourceConfiguration = resourceConfiguration
            self.variables = variables
        }
    }

}

public struct CreateChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

extension CreateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelInput(channelName: \(Swift.String(describing: channelName)), channelStorage: \(Swift.String(describing: channelStorage)), retentionPeriod: \(Swift.String(describing: retentionPeriod)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName
        case channelStorage
        case retentionPeriod
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelStorage = channelStorage {
            try encodeContainer.encode(channelStorage, forKey: .channelStorage)
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInput: Swift.Equatable {
    /// <p>The name of the channel.</p>
    public let channelName: Swift.String?
    /// <p>Where channel data is stored. You can choose one of <code>serviceManagedS3</code> or
    ///         <code>customerManagedS3</code> storage. If not specified, the default is
    ///         <code>serviceManagedS3</code>. You cannot change this storage option after the channel is
    ///       created.</p>
    public let channelStorage: IoTAnalyticsClientTypes.ChannelStorage?
    /// <p>How long, in days, message data is kept for the channel. When
    ///         <code>customerManagedS3</code> storage is selected, this parameter is ignored.</p>
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
    /// <p>Metadata which can be used to manage the channel.</p>
    public let tags: [IoTAnalyticsClientTypes.Tag]?

    public init (
        channelName: Swift.String? = nil,
        channelStorage: IoTAnalyticsClientTypes.ChannelStorage? = nil,
        retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod? = nil,
        tags: [IoTAnalyticsClientTypes.Tag]? = nil
    )
    {
        self.channelName = channelName
        self.channelStorage = channelStorage
        self.retentionPeriod = retentionPeriod
        self.tags = tags
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    public let channelName: Swift.String?
    public let channelStorage: IoTAnalyticsClientTypes.ChannelStorage?
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
    public let tags: [IoTAnalyticsClientTypes.Tag]?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName
        case channelStorage
        case retentionPeriod
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStorageDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ChannelStorage.self, forKey: .channelStorage)
        channelStorage = channelStorageDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTAnalyticsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTAnalyticsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelOutputResponse(channelArn: \(Swift.String(describing: channelArn)), channelName: \(Swift.String(describing: channelName)), retentionPeriod: \(Swift.String(describing: retentionPeriod)))"}
}

extension CreateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelName = output.channelName
            self.retentionPeriod = output.retentionPeriod
        } else {
            self.channelArn = nil
            self.channelName = nil
            self.retentionPeriod = nil
        }
    }
}

public struct CreateChannelOutputResponse: Swift.Equatable {
    /// <p>The ARN of the channel.</p>
    public let channelArn: Swift.String?
    /// <p>The name of the channel.</p>
    public let channelName: Swift.String?
    /// <p>How long, in days, message data is kept for the channel.</p>
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?

    public init (
        channelArn: Swift.String? = nil,
        channelName: Swift.String? = nil,
        retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod? = nil
    )
    {
        self.channelArn = channelArn
        self.channelName = channelName
        self.retentionPeriod = retentionPeriod
    }
}

struct CreateChannelOutputResponseBody: Swift.Equatable {
    public let channelName: Swift.String?
    public let channelArn: Swift.String?
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
}

extension CreateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case channelName
        case retentionPeriod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
    }
}

public struct CreateDatasetContentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetContentOutputError>
}

extension CreateDatasetContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetContentInput(datasetName: \(Swift.String(describing: datasetName)), versionId: \(Swift.String(describing: versionId)))"}
}

extension CreateDatasetContentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }
}

public struct CreateDatasetContentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetContentOutputError>
}

public struct CreateDatasetContentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetContentOutputError>
}

public struct CreateDatasetContentInput: Swift.Equatable {
    /// <p>The name of the dataset.</p>
    public let datasetName: Swift.String?
    /// <p>The version ID of the dataset content. To specify <code>versionId</code> for a dataset
    ///       content, the dataset must use a <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">DeltaTimer</a> filter.</p>
    public let versionId: Swift.String?

    public init (
        datasetName: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
        self.versionId = versionId
    }
}

struct CreateDatasetContentInputBody: Swift.Equatable {
    public let versionId: Swift.String?
}

extension CreateDatasetContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension CreateDatasetContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetContentOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetContentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetContentOutputResponse(versionId: \(Swift.String(describing: versionId)))"}
}

extension CreateDatasetContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatasetContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.versionId = output.versionId
        } else {
            self.versionId = nil
        }
    }
}

public struct CreateDatasetContentOutputResponse: Swift.Equatable {
    /// <p>The version ID of the dataset contents that are being created.</p>
    public let versionId: Swift.String?

    public init (
        versionId: Swift.String? = nil
    )
    {
        self.versionId = versionId
    }
}

struct CreateDatasetContentOutputResponseBody: Swift.Equatable {
    public let versionId: Swift.String?
}

extension CreateDatasetContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

public struct CreateDatasetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

extension CreateDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetInput(actions: \(Swift.String(describing: actions)), contentDeliveryRules: \(Swift.String(describing: contentDeliveryRules)), datasetName: \(Swift.String(describing: datasetName)), lateDataRules: \(Swift.String(describing: lateDataRules)), retentionPeriod: \(Swift.String(describing: retentionPeriod)), tags: \(Swift.String(describing: tags)), triggers: \(Swift.String(describing: triggers)), versioningConfiguration: \(Swift.String(describing: versioningConfiguration)))"}
}

extension CreateDatasetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case contentDeliveryRules
        case datasetName
        case lateDataRules
        case retentionPeriod
        case tags
        case triggers
        case versioningConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for datasetactions0 in actions {
                try actionsContainer.encode(datasetactions0)
            }
        }
        if let contentDeliveryRules = contentDeliveryRules {
            var contentDeliveryRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contentDeliveryRules)
            for datasetcontentdeliveryrules0 in contentDeliveryRules {
                try contentDeliveryRulesContainer.encode(datasetcontentdeliveryrules0)
            }
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let lateDataRules = lateDataRules {
            var lateDataRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lateDataRules)
            for latedatarules0 in lateDataRules {
                try lateDataRulesContainer.encode(latedatarules0)
            }
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let triggers = triggers {
            var triggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .triggers)
            for datasettriggers0 in triggers {
                try triggersContainer.encode(datasettriggers0)
            }
        }
        if let versioningConfiguration = versioningConfiguration {
            try encodeContainer.encode(versioningConfiguration, forKey: .versioningConfiguration)
        }
    }
}

public struct CreateDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInput: Swift.Equatable {
    /// <p>A list of actions that create the data set contents.</p>
    public let actions: [IoTAnalyticsClientTypes.DatasetAction]?
    /// <p>When dataset contents are created, they are delivered to destinations specified
    ///       here.</p>
    public let contentDeliveryRules: [IoTAnalyticsClientTypes.DatasetContentDeliveryRule]?
    /// <p>The name of the data set.</p>
    public let datasetName: Swift.String?
    /// <p>A list of data rules that send notifications to Amazon CloudWatch, when data arrives late. To
    ///   specify <code>lateDataRules</code>, the dataset must use a <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">DeltaTimer</a>
    ///   filter.</p>
    public let lateDataRules: [IoTAnalyticsClientTypes.LateDataRule]?
    /// <p>Optional. How long, in days, versions of dataset contents are kept for the dataset. If not
    ///       specified or set to <code>null</code>, versions of dataset contents are retained for at most
    ///       90 days. The number of versions of dataset contents retained is determined by the
    ///         <code>versioningConfiguration</code> parameter. For more information, see <a href="https://docs.aws.amazon.com/iotanalytics/latest/userguide/getting-started.html#aws-iot-analytics-dataset-versions">Keeping Multiple Versions of AWS IoT Analytics Data Sets</a> in the <i>AWS IoT
    ///         Analytics User Guide</i>.</p>
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
    /// <p>Metadata which can be used to manage the data set.</p>
    public let tags: [IoTAnalyticsClientTypes.Tag]?
    /// <p>A list of triggers. A trigger causes data set contents to be populated at a specified time
    ///       interval or when another data set's contents are created. The list of triggers can be empty or
    ///       contain up to five <code>DataSetTrigger</code> objects.</p>
    public let triggers: [IoTAnalyticsClientTypes.DatasetTrigger]?
    /// <p>Optional. How many versions of dataset contents are kept. If not specified or set to null,
    ///       only the latest version plus the latest succeeded version (if they are different) are kept for
    ///       the time period specified by the <code>retentionPeriod</code> parameter. For more information,
    ///       see <a href="https://docs.aws.amazon.com/iotanalytics/latest/userguide/getting-started.html#aws-iot-analytics-dataset-versions">Keeping Multiple Versions of AWS IoT Analytics Data Sets</a> in the <i>AWS IoT
    ///         Analytics User Guide</i>.</p>
    public let versioningConfiguration: IoTAnalyticsClientTypes.VersioningConfiguration?

    public init (
        actions: [IoTAnalyticsClientTypes.DatasetAction]? = nil,
        contentDeliveryRules: [IoTAnalyticsClientTypes.DatasetContentDeliveryRule]? = nil,
        datasetName: Swift.String? = nil,
        lateDataRules: [IoTAnalyticsClientTypes.LateDataRule]? = nil,
        retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod? = nil,
        tags: [IoTAnalyticsClientTypes.Tag]? = nil,
        triggers: [IoTAnalyticsClientTypes.DatasetTrigger]? = nil,
        versioningConfiguration: IoTAnalyticsClientTypes.VersioningConfiguration? = nil
    )
    {
        self.actions = actions
        self.contentDeliveryRules = contentDeliveryRules
        self.datasetName = datasetName
        self.lateDataRules = lateDataRules
        self.retentionPeriod = retentionPeriod
        self.tags = tags
        self.triggers = triggers
        self.versioningConfiguration = versioningConfiguration
    }
}

struct CreateDatasetInputBody: Swift.Equatable {
    public let datasetName: Swift.String?
    public let actions: [IoTAnalyticsClientTypes.DatasetAction]?
    public let triggers: [IoTAnalyticsClientTypes.DatasetTrigger]?
    public let contentDeliveryRules: [IoTAnalyticsClientTypes.DatasetContentDeliveryRule]?
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
    public let versioningConfiguration: IoTAnalyticsClientTypes.VersioningConfiguration?
    public let tags: [IoTAnalyticsClientTypes.Tag]?
    public let lateDataRules: [IoTAnalyticsClientTypes.LateDataRule]?
}

extension CreateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case contentDeliveryRules
        case datasetName
        case lateDataRules
        case retentionPeriod
        case tags
        case triggers
        case versioningConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let actionsContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.DatasetAction?].self, forKey: .actions)
        var actionsDecoded0:[IoTAnalyticsClientTypes.DatasetAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [IoTAnalyticsClientTypes.DatasetAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let triggersContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.DatasetTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[IoTAnalyticsClientTypes.DatasetTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [IoTAnalyticsClientTypes.DatasetTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
        let contentDeliveryRulesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.DatasetContentDeliveryRule?].self, forKey: .contentDeliveryRules)
        var contentDeliveryRulesDecoded0:[IoTAnalyticsClientTypes.DatasetContentDeliveryRule]? = nil
        if let contentDeliveryRulesContainer = contentDeliveryRulesContainer {
            contentDeliveryRulesDecoded0 = [IoTAnalyticsClientTypes.DatasetContentDeliveryRule]()
            for structure0 in contentDeliveryRulesContainer {
                if let structure0 = structure0 {
                    contentDeliveryRulesDecoded0?.append(structure0)
                }
            }
        }
        contentDeliveryRules = contentDeliveryRulesDecoded0
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let versioningConfigurationDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.VersioningConfiguration.self, forKey: .versioningConfiguration)
        versioningConfiguration = versioningConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTAnalyticsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTAnalyticsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let lateDataRulesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.LateDataRule?].self, forKey: .lateDataRules)
        var lateDataRulesDecoded0:[IoTAnalyticsClientTypes.LateDataRule]? = nil
        if let lateDataRulesContainer = lateDataRulesContainer {
            lateDataRulesDecoded0 = [IoTAnalyticsClientTypes.LateDataRule]()
            for structure0 in lateDataRulesContainer {
                if let structure0 = structure0 {
                    lateDataRulesDecoded0?.append(structure0)
                }
            }
        }
        lateDataRules = lateDataRulesDecoded0
    }
}

extension CreateDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetOutputResponse(datasetArn: \(Swift.String(describing: datasetArn)), datasetName: \(Swift.String(describing: datasetName)), retentionPeriod: \(Swift.String(describing: retentionPeriod)))"}
}

extension CreateDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetArn = output.datasetArn
            self.datasetName = output.datasetName
            self.retentionPeriod = output.retentionPeriod
        } else {
            self.datasetArn = nil
            self.datasetName = nil
            self.retentionPeriod = nil
        }
    }
}

public struct CreateDatasetOutputResponse: Swift.Equatable {
    /// <p>The ARN of the dataset.</p>
    public let datasetArn: Swift.String?
    /// <p>The name of the dataset.</p>
    public let datasetName: Swift.String?
    /// <p>How long, in days, dataset contents are kept for the dataset.</p>
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?

    public init (
        datasetArn: Swift.String? = nil,
        datasetName: Swift.String? = nil,
        retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod? = nil
    )
    {
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.retentionPeriod = retentionPeriod
    }
}

struct CreateDatasetOutputResponseBody: Swift.Equatable {
    public let datasetName: Swift.String?
    public let datasetArn: Swift.String?
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
}

extension CreateDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case datasetName
        case retentionPeriod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
    }
}

public struct CreateDatastoreInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatastoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatastoreOutputError>
}

extension CreateDatastoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatastoreInput(datastoreName: \(Swift.String(describing: datastoreName)), datastoreStorage: \(Swift.String(describing: datastoreStorage)), fileFormatConfiguration: \(Swift.String(describing: fileFormatConfiguration)), retentionPeriod: \(Swift.String(describing: retentionPeriod)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDatastoreInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreName
        case datastoreStorage
        case fileFormatConfiguration
        case retentionPeriod
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreName = datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStorage = datastoreStorage {
            try encodeContainer.encode(datastoreStorage, forKey: .datastoreStorage)
        }
        if let fileFormatConfiguration = fileFormatConfiguration {
            try encodeContainer.encode(fileFormatConfiguration, forKey: .fileFormatConfiguration)
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDatastoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatastoreOutputError>
}

public struct CreateDatastoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatastoreOutputError>
}

public struct CreateDatastoreInput: Swift.Equatable {
    /// <p>The name of the data store.</p>
    public let datastoreName: Swift.String?
    /// <p>Where data store data is stored. You can choose one of <code>serviceManagedS3</code> or
    ///         <code>customerManagedS3</code> storage. If not specified, the default is
    ///         <code>serviceManagedS3</code>. You cannot change this storage option after the data store is
    ///       created.</p>
    public let datastoreStorage: IoTAnalyticsClientTypes.DatastoreStorage?
    /// <p>Contains the configuration information of file formats. AWS IoT Analytics data stores support JSON
    ///       and <a href="https://parquet.apache.org/">Parquet</a>.</p>
    ///          <p>The default file format is JSON. You can specify only one format.</p>
    ///          <p>You can't change the file format after you create the data store.</p>
    public let fileFormatConfiguration: IoTAnalyticsClientTypes.FileFormatConfiguration?
    /// <p>How long, in days, message data is kept for the data store. When
    ///         <code>customerManagedS3</code> storage is selected, this parameter is ignored.</p>
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
    /// <p>Metadata which can be used to manage the data store.</p>
    public let tags: [IoTAnalyticsClientTypes.Tag]?

    public init (
        datastoreName: Swift.String? = nil,
        datastoreStorage: IoTAnalyticsClientTypes.DatastoreStorage? = nil,
        fileFormatConfiguration: IoTAnalyticsClientTypes.FileFormatConfiguration? = nil,
        retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod? = nil,
        tags: [IoTAnalyticsClientTypes.Tag]? = nil
    )
    {
        self.datastoreName = datastoreName
        self.datastoreStorage = datastoreStorage
        self.fileFormatConfiguration = fileFormatConfiguration
        self.retentionPeriod = retentionPeriod
        self.tags = tags
    }
}

struct CreateDatastoreInputBody: Swift.Equatable {
    public let datastoreName: Swift.String?
    public let datastoreStorage: IoTAnalyticsClientTypes.DatastoreStorage?
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
    public let tags: [IoTAnalyticsClientTypes.Tag]?
    public let fileFormatConfiguration: IoTAnalyticsClientTypes.FileFormatConfiguration?
}

extension CreateDatastoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreName
        case datastoreStorage
        case fileFormatConfiguration
        case retentionPeriod
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStorageDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatastoreStorage.self, forKey: .datastoreStorage)
        datastoreStorage = datastoreStorageDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTAnalyticsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTAnalyticsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileFormatConfigurationDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.FileFormatConfiguration.self, forKey: .fileFormatConfiguration)
        fileFormatConfiguration = fileFormatConfigurationDecoded
    }
}

extension CreateDatastoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatastoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatastoreOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatastoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatastoreOutputResponse(datastoreArn: \(Swift.String(describing: datastoreArn)), datastoreName: \(Swift.String(describing: datastoreName)), retentionPeriod: \(Swift.String(describing: retentionPeriod)))"}
}

extension CreateDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreArn = output.datastoreArn
            self.datastoreName = output.datastoreName
            self.retentionPeriod = output.retentionPeriod
        } else {
            self.datastoreArn = nil
            self.datastoreName = nil
            self.retentionPeriod = nil
        }
    }
}

public struct CreateDatastoreOutputResponse: Swift.Equatable {
    /// <p>The ARN of the data store.</p>
    public let datastoreArn: Swift.String?
    /// <p>The name of the data store.</p>
    public let datastoreName: Swift.String?
    /// <p>How long, in days, message data is kept for the data store.</p>
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?

    public init (
        datastoreArn: Swift.String? = nil,
        datastoreName: Swift.String? = nil,
        retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod? = nil
    )
    {
        self.datastoreArn = datastoreArn
        self.datastoreName = datastoreName
        self.retentionPeriod = retentionPeriod
    }
}

struct CreateDatastoreOutputResponseBody: Swift.Equatable {
    public let datastoreName: Swift.String?
    public let datastoreArn: Swift.String?
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
}

extension CreateDatastoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreArn
        case datastoreName
        case retentionPeriod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
    }
}

public struct CreatePipelineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePipelineOutputError>
}

extension CreatePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePipelineInput(pipelineActivities: \(Swift.String(describing: pipelineActivities)), pipelineName: \(Swift.String(describing: pipelineName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreatePipelineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineActivities
        case pipelineName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineActivities = pipelineActivities {
            var pipelineActivitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pipelineActivities)
            for pipelineactivities0 in pipelineActivities {
                try pipelineActivitiesContainer.encode(pipelineactivities0)
            }
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreatePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePipelineOutputError>
}

public struct CreatePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePipelineOutputError>
}

public struct CreatePipelineInput: Swift.Equatable {
    /// <p>A list of <code>PipelineActivity</code> objects. Activities perform transformations on
    ///       your messages, such as removing, renaming or adding message attributes; filtering messages
    ///       based on attribute values; invoking your Lambda functions on messages for advanced processing;
    ///       or performing mathematical transformations to normalize device data.</p>
    ///          <p>The list can be 2-25 <code>PipelineActivity</code> objects and must contain both a
    ///         <code>channel</code> and a <code>datastore</code> activity. Each entry in the list must
    ///       contain only one activity. For example:</p>
    ///          <p>
    ///             <code>pipelineActivities = [ { "channel": { ... } }, { "lambda": { ... } }, ...
    ///       ]</code>
    ///          </p>
    public let pipelineActivities: [IoTAnalyticsClientTypes.PipelineActivity]?
    /// <p>The name of the pipeline.</p>
    public let pipelineName: Swift.String?
    /// <p>Metadata which can be used to manage the pipeline.</p>
    public let tags: [IoTAnalyticsClientTypes.Tag]?

    public init (
        pipelineActivities: [IoTAnalyticsClientTypes.PipelineActivity]? = nil,
        pipelineName: Swift.String? = nil,
        tags: [IoTAnalyticsClientTypes.Tag]? = nil
    )
    {
        self.pipelineActivities = pipelineActivities
        self.pipelineName = pipelineName
        self.tags = tags
    }
}

struct CreatePipelineInputBody: Swift.Equatable {
    public let pipelineName: Swift.String?
    public let pipelineActivities: [IoTAnalyticsClientTypes.PipelineActivity]?
    public let tags: [IoTAnalyticsClientTypes.Tag]?
}

extension CreatePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineActivities
        case pipelineName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let pipelineActivitiesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.PipelineActivity?].self, forKey: .pipelineActivities)
        var pipelineActivitiesDecoded0:[IoTAnalyticsClientTypes.PipelineActivity]? = nil
        if let pipelineActivitiesContainer = pipelineActivitiesContainer {
            pipelineActivitiesDecoded0 = [IoTAnalyticsClientTypes.PipelineActivity]()
            for structure0 in pipelineActivitiesContainer {
                if let structure0 = structure0 {
                    pipelineActivitiesDecoded0?.append(structure0)
                }
            }
        }
        pipelineActivities = pipelineActivitiesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTAnalyticsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTAnalyticsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePipelineOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePipelineOutputResponse(pipelineArn: \(Swift.String(describing: pipelineArn)), pipelineName: \(Swift.String(describing: pipelineName)))"}
}

extension CreatePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipelineArn = output.pipelineArn
            self.pipelineName = output.pipelineName
        } else {
            self.pipelineArn = nil
            self.pipelineName = nil
        }
    }
}

public struct CreatePipelineOutputResponse: Swift.Equatable {
    /// <p>The ARN of the pipeline.</p>
    public let pipelineArn: Swift.String?
    /// <p>The name of the pipeline.</p>
    public let pipelineName: Swift.String?

    public init (
        pipelineArn: Swift.String? = nil,
        pipelineName: Swift.String? = nil
    )
    {
        self.pipelineArn = pipelineArn
        self.pipelineName = pipelineName
    }
}

struct CreatePipelineOutputResponseBody: Swift.Equatable {
    public let pipelineName: Swift.String?
    public let pipelineArn: Swift.String?
}

extension CreatePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineArn
        case pipelineName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let pipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineArn)
        pipelineArn = pipelineArnDecoded
    }
}

extension IoTAnalyticsClientTypes.CustomerManagedChannelS3Storage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case keyPrefix
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPrefix = keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTAnalyticsClientTypes.CustomerManagedChannelS3Storage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomerManagedChannelS3Storage(bucket: \(Swift.String(describing: bucket)), keyPrefix: \(Swift.String(describing: keyPrefix)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Use this to store channel data in an S3 bucket that you manage. If customer managed
    ///       storage is selected, the <code>retentionPeriod</code> parameter is ignored. You cannot change
    ///       the choice of service-managed or customer-managed S3 storage after the channel is
    ///       created.</p>
    public struct CustomerManagedChannelS3Storage: Swift.Equatable {
        /// <p>The name of the S3 bucket in which channel data is stored.</p>
        public let bucket: Swift.String?
        /// <p>Optional. The prefix used to create the keys of the channel data objects. Each object in
        ///       an S3 bucket has a key that is its unique identifier in the bucket. Each object in a bucket
        ///       has exactly one key. The prefix must end with a forward slash (/).</p>
        public let keyPrefix: Swift.String?
        /// <p>The ARN of the role that grants AWS IoT Analytics permission to interact with your Amazon
        ///       S3 resources.</p>
        public let roleArn: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            keyPrefix: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.keyPrefix = keyPrefix
            self.roleArn = roleArn
        }
    }

}

extension IoTAnalyticsClientTypes.CustomerManagedChannelS3StorageSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case keyPrefix
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPrefix = keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTAnalyticsClientTypes.CustomerManagedChannelS3StorageSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomerManagedChannelS3StorageSummary(bucket: \(Swift.String(describing: bucket)), keyPrefix: \(Swift.String(describing: keyPrefix)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Used to store channel data in an S3 bucket that you manage.</p>
    public struct CustomerManagedChannelS3StorageSummary: Swift.Equatable {
        /// <p>The name of the S3 bucket in which channel data is stored.</p>
        public let bucket: Swift.String?
        /// <p>Optional. The prefix used to create the keys of the channel data objects. Each object in
        ///       an S3 bucket has a key that is its unique identifier within the bucket (each object in a
        ///       bucket has exactly one key). The prefix must end with a forward slash (/).</p>
        public let keyPrefix: Swift.String?
        /// <p>The ARN of the role that grants AWS IoT Analytics permission to interact with your Amazon
        ///       S3 resources.</p>
        public let roleArn: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            keyPrefix: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.keyPrefix = keyPrefix
            self.roleArn = roleArn
        }
    }

}

extension IoTAnalyticsClientTypes.CustomerManagedDatastoreS3Storage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case keyPrefix
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPrefix = keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTAnalyticsClientTypes.CustomerManagedDatastoreS3Storage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomerManagedDatastoreS3Storage(bucket: \(Swift.String(describing: bucket)), keyPrefix: \(Swift.String(describing: keyPrefix)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Use this to store data store data in an S3 bucket that you manage. When customer-managed
    ///       storage is selected, the <code>retentionPeriod</code> parameter is ignored. You cannot change
    ///       the choice of service-managed or customer-managed S3 storage after the data store is
    ///       created.</p>
    public struct CustomerManagedDatastoreS3Storage: Swift.Equatable {
        /// <p>The name of the S3 bucket in which data store data is stored.</p>
        public let bucket: Swift.String?
        /// <p>Optional. The prefix used to create the keys of the data store data objects. Each object
        ///       in an S3 bucket has a key that is its unique identifier in the bucket. Each object in a bucket
        ///       has exactly one key. The prefix must end with a forward slash (/).</p>
        public let keyPrefix: Swift.String?
        /// <p>The ARN of the role that grants AWS IoT Analytics permission to interact with your Amazon
        ///       S3 resources.</p>
        public let roleArn: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            keyPrefix: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.keyPrefix = keyPrefix
            self.roleArn = roleArn
        }
    }

}

extension IoTAnalyticsClientTypes.CustomerManagedDatastoreS3StorageSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case keyPrefix
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPrefix = keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTAnalyticsClientTypes.CustomerManagedDatastoreS3StorageSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomerManagedDatastoreS3StorageSummary(bucket: \(Swift.String(describing: bucket)), keyPrefix: \(Swift.String(describing: keyPrefix)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Used to store data store data in an S3 bucket that you manage.</p>
    public struct CustomerManagedDatastoreS3StorageSummary: Swift.Equatable {
        /// <p>The name of the S3 bucket in which data store data is stored.</p>
        public let bucket: Swift.String?
        /// <p>Optional. The prefix used to create the keys of the data store data objects. Each object
        ///       in an S3 bucket has a key that is its unique identifier in the bucket. Each object in a bucket
        ///       has exactly one key. The prefix must end with a forward slash (/).</p>
        public let keyPrefix: Swift.String?
        /// <p>The ARN of the role that grants AWS IoT Analytics permission to interact with your Amazon
        ///       S3 resources.</p>
        public let roleArn: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            keyPrefix: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.keyPrefix = keyPrefix
            self.roleArn = roleArn
        }
    }

}

extension IoTAnalyticsClientTypes.Dataset: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case arn
        case contentDeliveryRules
        case creationTime
        case lastUpdateTime
        case lateDataRules
        case name
        case retentionPeriod
        case status
        case triggers
        case versioningConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for datasetactions0 in actions {
                try actionsContainer.encode(datasetactions0)
            }
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let contentDeliveryRules = contentDeliveryRules {
            var contentDeliveryRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contentDeliveryRules)
            for datasetcontentdeliveryrules0 in contentDeliveryRules {
                try contentDeliveryRulesContainer.encode(datasetcontentdeliveryrules0)
            }
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let lateDataRules = lateDataRules {
            var lateDataRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lateDataRules)
            for latedatarules0 in lateDataRules {
                try lateDataRulesContainer.encode(latedatarules0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let triggers = triggers {
            var triggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .triggers)
            for datasettriggers0 in triggers {
                try triggersContainer.encode(datasettriggers0)
            }
        }
        if let versioningConfiguration = versioningConfiguration {
            try encodeContainer.encode(versioningConfiguration, forKey: .versioningConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let actionsContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.DatasetAction?].self, forKey: .actions)
        var actionsDecoded0:[IoTAnalyticsClientTypes.DatasetAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [IoTAnalyticsClientTypes.DatasetAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let triggersContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.DatasetTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[IoTAnalyticsClientTypes.DatasetTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [IoTAnalyticsClientTypes.DatasetTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
        let contentDeliveryRulesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.DatasetContentDeliveryRule?].self, forKey: .contentDeliveryRules)
        var contentDeliveryRulesDecoded0:[IoTAnalyticsClientTypes.DatasetContentDeliveryRule]? = nil
        if let contentDeliveryRulesContainer = contentDeliveryRulesContainer {
            contentDeliveryRulesDecoded0 = [IoTAnalyticsClientTypes.DatasetContentDeliveryRule]()
            for structure0 in contentDeliveryRulesContainer {
                if let structure0 = structure0 {
                    contentDeliveryRulesDecoded0?.append(structure0)
                }
            }
        }
        contentDeliveryRules = contentDeliveryRulesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatasetStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let versioningConfigurationDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.VersioningConfiguration.self, forKey: .versioningConfiguration)
        versioningConfiguration = versioningConfigurationDecoded
        let lateDataRulesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.LateDataRule?].self, forKey: .lateDataRules)
        var lateDataRulesDecoded0:[IoTAnalyticsClientTypes.LateDataRule]? = nil
        if let lateDataRulesContainer = lateDataRulesContainer {
            lateDataRulesDecoded0 = [IoTAnalyticsClientTypes.LateDataRule]()
            for structure0 in lateDataRulesContainer {
                if let structure0 = structure0 {
                    lateDataRulesDecoded0?.append(structure0)
                }
            }
        }
        lateDataRules = lateDataRulesDecoded0
    }
}

extension IoTAnalyticsClientTypes.Dataset: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Dataset(actions: \(Swift.String(describing: actions)), arn: \(Swift.String(describing: arn)), contentDeliveryRules: \(Swift.String(describing: contentDeliveryRules)), creationTime: \(Swift.String(describing: creationTime)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), lateDataRules: \(Swift.String(describing: lateDataRules)), name: \(Swift.String(describing: name)), retentionPeriod: \(Swift.String(describing: retentionPeriod)), status: \(Swift.String(describing: status)), triggers: \(Swift.String(describing: triggers)), versioningConfiguration: \(Swift.String(describing: versioningConfiguration)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Information about a data set.</p>
    public struct Dataset: Swift.Equatable {
        /// <p>The <code>DatasetAction</code> objects that automatically create the data set
        ///       contents.</p>
        public let actions: [IoTAnalyticsClientTypes.DatasetAction]?
        /// <p>The ARN of the data set.</p>
        public let arn: Swift.String?
        /// <p>When dataset contents are created they are delivered to destinations specified
        ///       here.</p>
        public let contentDeliveryRules: [IoTAnalyticsClientTypes.DatasetContentDeliveryRule]?
        /// <p>When the data set was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The last time the data set was updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>A list of data rules that send notifications to Amazon CloudWatch, when data arrives late. To
        ///   specify <code>lateDataRules</code>, the dataset must use a <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">DeltaTimer</a>
        ///   filter.</p>
        public let lateDataRules: [IoTAnalyticsClientTypes.LateDataRule]?
        /// <p>The name of the data set.</p>
        public let name: Swift.String?
        /// <p>Optional. How long, in days, message data is kept for the data set.</p>
        public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
        /// <p>The status of the data set.</p>
        public let status: IoTAnalyticsClientTypes.DatasetStatus?
        /// <p>The <code>DatasetTrigger</code> objects that specify when the data set is automatically
        ///       updated.</p>
        public let triggers: [IoTAnalyticsClientTypes.DatasetTrigger]?
        /// <p>Optional. How many versions of dataset contents are kept. If not specified or set to null,
        ///       only the latest version plus the latest succeeded version (if they are different) are kept for
        ///       the time period specified by the <code>retentionPeriod</code> parameter. For more information,
        ///       see <a href="https://docs.aws.amazon.com/iotanalytics/latest/userguide/getting-started.html#aws-iot-analytics-dataset-versions">Keeping Multiple Versions of AWS IoT Analytics Data Sets</a> in the <i>AWS IoT
        ///         Analytics User Guide</i>.</p>
        public let versioningConfiguration: IoTAnalyticsClientTypes.VersioningConfiguration?

        public init (
            actions: [IoTAnalyticsClientTypes.DatasetAction]? = nil,
            arn: Swift.String? = nil,
            contentDeliveryRules: [IoTAnalyticsClientTypes.DatasetContentDeliveryRule]? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            lateDataRules: [IoTAnalyticsClientTypes.LateDataRule]? = nil,
            name: Swift.String? = nil,
            retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod? = nil,
            status: IoTAnalyticsClientTypes.DatasetStatus? = nil,
            triggers: [IoTAnalyticsClientTypes.DatasetTrigger]? = nil,
            versioningConfiguration: IoTAnalyticsClientTypes.VersioningConfiguration? = nil
        )
        {
            self.actions = actions
            self.arn = arn
            self.contentDeliveryRules = contentDeliveryRules
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.lateDataRules = lateDataRules
            self.name = name
            self.retentionPeriod = retentionPeriod
            self.status = status
            self.triggers = triggers
            self.versioningConfiguration = versioningConfiguration
        }
    }

}

extension IoTAnalyticsClientTypes.DatasetAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionName
        case containerAction
        case queryAction
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let containerAction = containerAction {
            try encodeContainer.encode(containerAction, forKey: .containerAction)
        }
        if let queryAction = queryAction {
            try encodeContainer.encode(queryAction, forKey: .queryAction)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let queryActionDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.SqlQueryDatasetAction.self, forKey: .queryAction)
        queryAction = queryActionDecoded
        let containerActionDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ContainerDatasetAction.self, forKey: .containerAction)
        containerAction = containerActionDecoded
    }
}

extension IoTAnalyticsClientTypes.DatasetAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetAction(actionName: \(Swift.String(describing: actionName)), containerAction: \(Swift.String(describing: containerAction)), queryAction: \(Swift.String(describing: queryAction)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>A <code>DatasetAction</code> object that specifies how data set contents are automatically
    ///       created.</p>
    public struct DatasetAction: Swift.Equatable {
        /// <p>The name of the data set action by which data set contents are automatically
        ///       created.</p>
        public let actionName: Swift.String?
        /// <p>Information that allows the system to run a containerized application to create the
        ///       dataset contents. The application must be in a Docker container along with any required
        ///       support libraries.</p>
        public let containerAction: IoTAnalyticsClientTypes.ContainerDatasetAction?
        /// <p>An <code>SqlQueryDatasetAction</code> object that uses an SQL query to automatically
        ///       create data set contents.</p>
        public let queryAction: IoTAnalyticsClientTypes.SqlQueryDatasetAction?

        public init (
            actionName: Swift.String? = nil,
            containerAction: IoTAnalyticsClientTypes.ContainerDatasetAction? = nil,
            queryAction: IoTAnalyticsClientTypes.SqlQueryDatasetAction? = nil
        )
        {
            self.actionName = actionName
            self.containerAction = containerAction
            self.queryAction = queryAction
        }
    }

}

extension IoTAnalyticsClientTypes.DatasetActionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionName
        case actionType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let actionType = actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatasetActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
    }
}

extension IoTAnalyticsClientTypes.DatasetActionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetActionSummary(actionName: \(Swift.String(describing: actionName)), actionType: \(Swift.String(describing: actionType)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Information about the action that automatically creates the dataset's contents.</p>
    public struct DatasetActionSummary: Swift.Equatable {
        /// <p>The name of the action that automatically creates the dataset's contents.</p>
        public let actionName: Swift.String?
        /// <p>The type of action by which the dataset's contents are automatically created.</p>
        public let actionType: IoTAnalyticsClientTypes.DatasetActionType?

        public init (
            actionName: Swift.String? = nil,
            actionType: IoTAnalyticsClientTypes.DatasetActionType? = nil
        )
        {
            self.actionName = actionName
            self.actionType = actionType
        }
    }

}

extension IoTAnalyticsClientTypes {
    public enum DatasetActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case container
        case query
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetActionType] {
            return [
                .container,
                .query,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .container: return "CONTAINER"
            case .query: return "QUERY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetActionType(rawValue: rawValue) ?? DatasetActionType.sdkUnknown(rawValue)
        }
    }
}

extension IoTAnalyticsClientTypes.DatasetContentDeliveryDestination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotEventsDestinationConfiguration
        case s3DestinationConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iotEventsDestinationConfiguration = iotEventsDestinationConfiguration {
            try encodeContainer.encode(iotEventsDestinationConfiguration, forKey: .iotEventsDestinationConfiguration)
        }
        if let s3DestinationConfiguration = s3DestinationConfiguration {
            try encodeContainer.encode(s3DestinationConfiguration, forKey: .s3DestinationConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotEventsDestinationConfigurationDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.IotEventsDestinationConfiguration.self, forKey: .iotEventsDestinationConfiguration)
        iotEventsDestinationConfiguration = iotEventsDestinationConfigurationDecoded
        let s3DestinationConfigurationDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.S3DestinationConfiguration.self, forKey: .s3DestinationConfiguration)
        s3DestinationConfiguration = s3DestinationConfigurationDecoded
    }
}

extension IoTAnalyticsClientTypes.DatasetContentDeliveryDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetContentDeliveryDestination(iotEventsDestinationConfiguration: \(Swift.String(describing: iotEventsDestinationConfiguration)), s3DestinationConfiguration: \(Swift.String(describing: s3DestinationConfiguration)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>The destination to which dataset contents are delivered.</p>
    public struct DatasetContentDeliveryDestination: Swift.Equatable {
        /// <p>Configuration information for delivery of dataset contents to AWS IoT Events.</p>
        public let iotEventsDestinationConfiguration: IoTAnalyticsClientTypes.IotEventsDestinationConfiguration?
        /// <p>Configuration information for delivery of dataset contents to Amazon S3.</p>
        public let s3DestinationConfiguration: IoTAnalyticsClientTypes.S3DestinationConfiguration?

        public init (
            iotEventsDestinationConfiguration: IoTAnalyticsClientTypes.IotEventsDestinationConfiguration? = nil,
            s3DestinationConfiguration: IoTAnalyticsClientTypes.S3DestinationConfiguration? = nil
        )
        {
            self.iotEventsDestinationConfiguration = iotEventsDestinationConfiguration
            self.s3DestinationConfiguration = s3DestinationConfiguration
        }
    }

}

extension IoTAnalyticsClientTypes.DatasetContentDeliveryRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case entryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let entryName = entryName {
            try encodeContainer.encode(entryName, forKey: .entryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryName)
        entryName = entryNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatasetContentDeliveryDestination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension IoTAnalyticsClientTypes.DatasetContentDeliveryRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetContentDeliveryRule(destination: \(Swift.String(describing: destination)), entryName: \(Swift.String(describing: entryName)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>When dataset contents are created, they are delivered to destination specified
    ///       here.</p>
    public struct DatasetContentDeliveryRule: Swift.Equatable {
        /// <p>The destination to which dataset contents are delivered.</p>
        public let destination: IoTAnalyticsClientTypes.DatasetContentDeliveryDestination?
        /// <p>The name of the dataset content delivery rules entry.</p>
        public let entryName: Swift.String?

        public init (
            destination: IoTAnalyticsClientTypes.DatasetContentDeliveryDestination? = nil,
            entryName: Swift.String? = nil
        )
        {
            self.destination = destination
            self.entryName = entryName
        }
    }

}

extension IoTAnalyticsClientTypes {
    public enum DatasetContentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case failed
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetContentState] {
            return [
                .creating,
                .failed,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetContentState(rawValue: rawValue) ?? DatasetContentState.sdkUnknown(rawValue)
        }
    }
}

extension IoTAnalyticsClientTypes.DatasetContentStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatasetContentState.self, forKey: .state)
        state = stateDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension IoTAnalyticsClientTypes.DatasetContentStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetContentStatus(reason: \(Swift.String(describing: reason)), state: \(Swift.String(describing: state)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>The state of the data set contents and the reason they are in this state.</p>
    public struct DatasetContentStatus: Swift.Equatable {
        /// <p>The reason the data set contents are in this state.</p>
        public let reason: Swift.String?
        /// <p>The state of the data set contents. Can be one of READY, CREATING, SUCCEEDED, or
        ///       FAILED.</p>
        public let state: IoTAnalyticsClientTypes.DatasetContentState?

        public init (
            reason: Swift.String? = nil,
            state: IoTAnalyticsClientTypes.DatasetContentState? = nil
        )
        {
            self.reason = reason
            self.state = state
        }
    }

}

extension IoTAnalyticsClientTypes.DatasetContentSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case scheduleTime
        case status
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = completionTime {
            try encodeContainer.encode(completionTime.timeIntervalSince1970, forKey: .completionTime)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let scheduleTime = scheduleTime {
            try encodeContainer.encode(scheduleTime.timeIntervalSince1970, forKey: .scheduleTime)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatasetContentStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let scheduleTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .scheduleTime)
        scheduleTime = scheduleTimeDecoded
        let completionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completionTime)
        completionTime = completionTimeDecoded
    }
}

extension IoTAnalyticsClientTypes.DatasetContentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetContentSummary(completionTime: \(Swift.String(describing: completionTime)), creationTime: \(Swift.String(describing: creationTime)), scheduleTime: \(Swift.String(describing: scheduleTime)), status: \(Swift.String(describing: status)), version: \(Swift.String(describing: version)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Summary information about dataset contents.</p>
    public struct DatasetContentSummary: Swift.Equatable {
        /// <p>The time the dataset content status was updated to SUCCEEDED or FAILED.</p>
        public let completionTime: ClientRuntime.Date?
        /// <p>The actual time the creation of the dataset contents was started.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The time the creation of the dataset contents was scheduled to start.</p>
        public let scheduleTime: ClientRuntime.Date?
        /// <p>The status of the data set contents.</p>
        public let status: IoTAnalyticsClientTypes.DatasetContentStatus?
        /// <p>The version of the dataset contents.</p>
        public let version: Swift.String?

        public init (
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            scheduleTime: ClientRuntime.Date? = nil,
            status: IoTAnalyticsClientTypes.DatasetContentStatus? = nil,
            version: Swift.String? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.scheduleTime = scheduleTime
            self.status = status
            self.version = version
        }
    }

}

extension IoTAnalyticsClientTypes.DatasetContentVersionValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
    }
}

extension IoTAnalyticsClientTypes.DatasetContentVersionValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetContentVersionValue(datasetName: \(Swift.String(describing: datasetName)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>The dataset whose latest contents are used as input to the notebook or application.</p>
    public struct DatasetContentVersionValue: Swift.Equatable {
        /// <p>The name of the dataset whose latest contents are used as input to the notebook or
        ///       application.</p>
        public let datasetName: Swift.String?

        public init (
            datasetName: Swift.String? = nil
        )
        {
            self.datasetName = datasetName
        }
    }

}

extension IoTAnalyticsClientTypes.DatasetEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataURI
        case entryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataURI = dataURI {
            try encodeContainer.encode(dataURI, forKey: .dataURI)
        }
        if let entryName = entryName {
            try encodeContainer.encode(entryName, forKey: .entryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryName)
        entryName = entryNameDecoded
        let dataURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataURI)
        dataURI = dataURIDecoded
    }
}

extension IoTAnalyticsClientTypes.DatasetEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetEntry(dataURI: \(Swift.String(describing: dataURI)), entryName: \(Swift.String(describing: entryName)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>The reference to a data set entry.</p>
    public struct DatasetEntry: Swift.Equatable {
        /// <p>The presigned URI of the data set item.</p>
        public let dataURI: Swift.String?
        /// <p>The name of the data set item.</p>
        public let entryName: Swift.String?

        public init (
            dataURI: Swift.String? = nil,
            entryName: Swift.String? = nil
        )
        {
            self.dataURI = dataURI
            self.entryName = entryName
        }
    }

}

extension IoTAnalyticsClientTypes {
    public enum DatasetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetStatus(rawValue: rawValue) ?? DatasetStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTAnalyticsClientTypes.DatasetSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case creationTime
        case datasetName
        case lastUpdateTime
        case status
        case triggers
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for datasetactionsummaries0 in actions {
                try actionsContainer.encode(datasetactionsummaries0)
            }
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let triggers = triggers {
            var triggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .triggers)
            for datasettriggers0 in triggers {
                try triggersContainer.encode(datasettriggers0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatasetStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let triggersContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.DatasetTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[IoTAnalyticsClientTypes.DatasetTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [IoTAnalyticsClientTypes.DatasetTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.DatasetActionSummary?].self, forKey: .actions)
        var actionsDecoded0:[IoTAnalyticsClientTypes.DatasetActionSummary]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [IoTAnalyticsClientTypes.DatasetActionSummary]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension IoTAnalyticsClientTypes.DatasetSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetSummary(actions: \(Swift.String(describing: actions)), creationTime: \(Swift.String(describing: creationTime)), datasetName: \(Swift.String(describing: datasetName)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), status: \(Swift.String(describing: status)), triggers: \(Swift.String(describing: triggers)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>A summary of information about a data set.</p>
    public struct DatasetSummary: Swift.Equatable {
        /// <p>A list of <code>DataActionSummary</code> objects.</p>
        public let actions: [IoTAnalyticsClientTypes.DatasetActionSummary]?
        /// <p>The time the data set was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The name of the data set.</p>
        public let datasetName: Swift.String?
        /// <p>The last time the data set was updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The status of the data set.</p>
        public let status: IoTAnalyticsClientTypes.DatasetStatus?
        /// <p>A list of triggers. A trigger causes data set content to be populated at a specified time
        ///       interval or when another data set is populated. The list of triggers can be empty or contain
        ///       up to five <code>DataSetTrigger</code> objects</p>
        public let triggers: [IoTAnalyticsClientTypes.DatasetTrigger]?

        public init (
            actions: [IoTAnalyticsClientTypes.DatasetActionSummary]? = nil,
            creationTime: ClientRuntime.Date? = nil,
            datasetName: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            status: IoTAnalyticsClientTypes.DatasetStatus? = nil,
            triggers: [IoTAnalyticsClientTypes.DatasetTrigger]? = nil
        )
        {
            self.actions = actions
            self.creationTime = creationTime
            self.datasetName = datasetName
            self.lastUpdateTime = lastUpdateTime
            self.status = status
            self.triggers = triggers
        }
    }

}

extension IoTAnalyticsClientTypes.DatasetTrigger: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataset
        case schedule
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataset = dataset {
            try encodeContainer.encode(dataset, forKey: .dataset)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let datasetDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.TriggeringDataset.self, forKey: .dataset)
        dataset = datasetDecoded
    }
}

extension IoTAnalyticsClientTypes.DatasetTrigger: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetTrigger(dataset: \(Swift.String(describing: dataset)), schedule: \(Swift.String(describing: schedule)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>The <code>DatasetTrigger</code> that specifies when the data set is automatically
    ///       updated.</p>
    public struct DatasetTrigger: Swift.Equatable {
        /// <p>The data set whose content creation triggers the creation of this data set's
        ///       contents.</p>
        public let dataset: IoTAnalyticsClientTypes.TriggeringDataset?
        /// <p>The Schedule when the trigger is initiated.</p>
        public let schedule: IoTAnalyticsClientTypes.Schedule?

        public init (
            dataset: IoTAnalyticsClientTypes.TriggeringDataset? = nil,
            schedule: IoTAnalyticsClientTypes.Schedule? = nil
        )
        {
            self.dataset = dataset
            self.schedule = schedule
        }
    }

}

extension IoTAnalyticsClientTypes.Datastore: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case fileFormatConfiguration
        case lastMessageArrivalTime
        case lastUpdateTime
        case name
        case retentionPeriod
        case status
        case storage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let fileFormatConfiguration = fileFormatConfiguration {
            try encodeContainer.encode(fileFormatConfiguration, forKey: .fileFormatConfiguration)
        }
        if let lastMessageArrivalTime = lastMessageArrivalTime {
            try encodeContainer.encode(lastMessageArrivalTime.timeIntervalSince1970, forKey: .lastMessageArrivalTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let storage = storage {
            try encodeContainer.encode(storage, forKey: .storage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let storageDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatastoreStorage.self, forKey: .storage)
        storage = storageDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatastoreStatus.self, forKey: .status)
        status = statusDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let lastMessageArrivalTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastMessageArrivalTime)
        lastMessageArrivalTime = lastMessageArrivalTimeDecoded
        let fileFormatConfigurationDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.FileFormatConfiguration.self, forKey: .fileFormatConfiguration)
        fileFormatConfiguration = fileFormatConfigurationDecoded
    }
}

extension IoTAnalyticsClientTypes.Datastore: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Datastore(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), fileFormatConfiguration: \(Swift.String(describing: fileFormatConfiguration)), lastMessageArrivalTime: \(Swift.String(describing: lastMessageArrivalTime)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), name: \(Swift.String(describing: name)), retentionPeriod: \(Swift.String(describing: retentionPeriod)), status: \(Swift.String(describing: status)), storage: \(Swift.String(describing: storage)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Information about a data store.</p>
    public struct Datastore: Swift.Equatable {
        /// <p>The ARN of the data store.</p>
        public let arn: Swift.String?
        /// <p>When the data store was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>Contains the configuration information of file formats. AWS IoT Analytics data stores support JSON
        ///       and <a href="https://parquet.apache.org/">Parquet</a>.</p>
        ///          <p>The default file format is JSON. You can specify only one format.</p>
        ///          <p>You can't change the file format after you create the data store.</p>
        public let fileFormatConfiguration: IoTAnalyticsClientTypes.FileFormatConfiguration?
        /// <p>The last time when a new message arrived in the data store.</p>
        ///          <p>AWS IoT Analytics updates this value at most once per minute for one data store.
        ///   Hence, the <code>lastMessageArrivalTime</code> value is an approximation.</p>
        ///          <p>This feature only applies to messages that arrived in the data store after October 23, 2020. </p>
        public let lastMessageArrivalTime: ClientRuntime.Date?
        /// <p>The last time the data store was updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The name of the data store.</p>
        public let name: Swift.String?
        /// <p>How long, in days, message data is kept for the data store. When
        ///         <code>customerManagedS3</code> storage is selected, this parameter is ignored.</p>
        public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
        /// <p>The status of a data store:</p>
        ///          <dl>
        ///             <dt>CREATING</dt>
        ///             <dd>
        ///                <p>The data store is being created.</p>
        ///             </dd>
        ///             <dt>ACTIVE</dt>
        ///             <dd>
        ///                <p>The data store has been created and can be used.</p>
        ///             </dd>
        ///             <dt>DELETING</dt>
        ///             <dd>
        ///                <p>The data store is being deleted.</p>
        ///             </dd>
        ///          </dl>
        public let status: IoTAnalyticsClientTypes.DatastoreStatus?
        /// <p>Where data store data is stored. You can choose one of <code>serviceManagedS3</code> or
        ///         <code>customerManagedS3</code> storage. If not specified, the default is
        ///         <code>serviceManagedS3</code>. You cannot change this storage option after the data store is
        ///       created.</p>
        public let storage: IoTAnalyticsClientTypes.DatastoreStorage?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            fileFormatConfiguration: IoTAnalyticsClientTypes.FileFormatConfiguration? = nil,
            lastMessageArrivalTime: ClientRuntime.Date? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod? = nil,
            status: IoTAnalyticsClientTypes.DatastoreStatus? = nil,
            storage: IoTAnalyticsClientTypes.DatastoreStorage? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.fileFormatConfiguration = fileFormatConfiguration
            self.lastMessageArrivalTime = lastMessageArrivalTime
            self.lastUpdateTime = lastUpdateTime
            self.name = name
            self.retentionPeriod = retentionPeriod
            self.status = status
            self.storage = storage
        }
    }

}

extension IoTAnalyticsClientTypes.DatastoreActivity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreName
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreName = datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
    }
}

extension IoTAnalyticsClientTypes.DatastoreActivity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatastoreActivity(datastoreName: \(Swift.String(describing: datastoreName)), name: \(Swift.String(describing: name)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>The datastore activity that specifies where to store the processed data.</p>
    public struct DatastoreActivity: Swift.Equatable {
        /// <p>The name of the data store where processed messages are stored.</p>
        public let datastoreName: Swift.String?
        /// <p>The name of the datastore activity.</p>
        public let name: Swift.String?

        public init (
            datastoreName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.datastoreName = datastoreName
            self.name = name
        }
    }

}

extension IoTAnalyticsClientTypes.DatastoreStatistics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case size
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.EstimatedResourceSize.self, forKey: .size)
        size = sizeDecoded
    }
}

extension IoTAnalyticsClientTypes.DatastoreStatistics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatastoreStatistics(size: \(Swift.String(describing: size)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Statistical information about the data store.</p>
    public struct DatastoreStatistics: Swift.Equatable {
        /// <p>The estimated size of the data store.</p>
        public let size: IoTAnalyticsClientTypes.EstimatedResourceSize?

        public init (
            size: IoTAnalyticsClientTypes.EstimatedResourceSize? = nil
        )
        {
            self.size = size
        }
    }

}

extension IoTAnalyticsClientTypes {
    public enum DatastoreStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [DatastoreStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatastoreStatus(rawValue: rawValue) ?? DatastoreStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTAnalyticsClientTypes.DatastoreStorage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customermanageds3 = "customerManagedS3"
        case sdkUnknown
        case servicemanageds3 = "serviceManagedS3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .customermanageds3(customermanageds3):
                try container.encode(customermanageds3, forKey: .customermanageds3)
            case let .servicemanageds3(servicemanageds3):
                try container.encode(servicemanageds3, forKey: .servicemanageds3)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let servicemanageds3Decoded = try values.decodeIfPresent(IoTAnalyticsClientTypes.ServiceManagedDatastoreS3Storage.self, forKey: .servicemanageds3)
        if let servicemanageds3 = servicemanageds3Decoded {
            self = .servicemanageds3(servicemanageds3)
            return
        }
        let customermanageds3Decoded = try values.decodeIfPresent(IoTAnalyticsClientTypes.CustomerManagedDatastoreS3Storage.self, forKey: .customermanageds3)
        if let customermanageds3 = customermanageds3Decoded {
            self = .customermanageds3(customermanageds3)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTAnalyticsClientTypes {
    /// <p>Where data store data is stored. You can choose one of <code>serviceManagedS3</code> or
    ///         <code>customerManagedS3</code> storage. If not specified, the default is
    ///         <code>serviceManagedS3</code>. You cannot change this storage option after the data store is
    ///       created.</p>
    public enum DatastoreStorage: Swift.Equatable {
        /// <p>Use this to store data store data in an S3 bucket managed by AWS IoT Analytics. You cannot
        ///       change the choice of service-managed or customer-managed S3 storage after the data store is
        ///       created.</p>
        case servicemanageds3(IoTAnalyticsClientTypes.ServiceManagedDatastoreS3Storage)
        /// <p>Use this to store data store data in an S3 bucket that you manage. When customer managed
        ///       storage is selected, the <code>retentionPeriod</code> parameter is ignored. The choice of
        ///       service-managed or customer-managed S3 storage cannot be changed after creation of the data
        ///       store.</p>
        case customermanageds3(IoTAnalyticsClientTypes.CustomerManagedDatastoreS3Storage)
        case sdkUnknown(Swift.String)
    }

}

extension IoTAnalyticsClientTypes.DatastoreStorageSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedS3
        case serviceManagedS3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManagedS3 = customerManagedS3 {
            try encodeContainer.encode(customerManagedS3, forKey: .customerManagedS3)
        }
        if let serviceManagedS3 = serviceManagedS3 {
            try encodeContainer.encode(serviceManagedS3, forKey: .serviceManagedS3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceManagedS3Decoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ServiceManagedDatastoreS3StorageSummary.self, forKey: .serviceManagedS3)
        serviceManagedS3 = serviceManagedS3Decoded
        let customerManagedS3Decoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.CustomerManagedDatastoreS3StorageSummary.self, forKey: .customerManagedS3)
        customerManagedS3 = customerManagedS3Decoded
    }
}

extension IoTAnalyticsClientTypes.DatastoreStorageSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatastoreStorageSummary(customerManagedS3: \(Swift.String(describing: customerManagedS3)), serviceManagedS3: \(Swift.String(describing: serviceManagedS3)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Where data store data is stored.</p>
    public struct DatastoreStorageSummary: Swift.Equatable {
        /// <p>Used to store data store data in an S3 bucket that you manage.</p>
        public let customerManagedS3: IoTAnalyticsClientTypes.CustomerManagedDatastoreS3StorageSummary?
        /// <p>Used to store data store data in an S3 bucket managed by AWS IoT Analytics.</p>
        public let serviceManagedS3: IoTAnalyticsClientTypes.ServiceManagedDatastoreS3StorageSummary?

        public init (
            customerManagedS3: IoTAnalyticsClientTypes.CustomerManagedDatastoreS3StorageSummary? = nil,
            serviceManagedS3: IoTAnalyticsClientTypes.ServiceManagedDatastoreS3StorageSummary? = nil
        )
        {
            self.customerManagedS3 = customerManagedS3
            self.serviceManagedS3 = serviceManagedS3
        }
    }

}

extension IoTAnalyticsClientTypes.DatastoreSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case datastoreName
        case datastoreStorage
        case fileFormatType
        case lastMessageArrivalTime
        case lastUpdateTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datastoreName = datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStorage = datastoreStorage {
            try encodeContainer.encode(datastoreStorage, forKey: .datastoreStorage)
        }
        if let fileFormatType = fileFormatType {
            try encodeContainer.encode(fileFormatType.rawValue, forKey: .fileFormatType)
        }
        if let lastMessageArrivalTime = lastMessageArrivalTime {
            try encodeContainer.encode(lastMessageArrivalTime.timeIntervalSince1970, forKey: .lastMessageArrivalTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStorageDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatastoreStorageSummary.self, forKey: .datastoreStorage)
        datastoreStorage = datastoreStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatastoreStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let lastMessageArrivalTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastMessageArrivalTime)
        lastMessageArrivalTime = lastMessageArrivalTimeDecoded
        let fileFormatTypeDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.FileFormatType.self, forKey: .fileFormatType)
        fileFormatType = fileFormatTypeDecoded
    }
}

extension IoTAnalyticsClientTypes.DatastoreSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatastoreSummary(creationTime: \(Swift.String(describing: creationTime)), datastoreName: \(Swift.String(describing: datastoreName)), datastoreStorage: \(Swift.String(describing: datastoreStorage)), fileFormatType: \(Swift.String(describing: fileFormatType)), lastMessageArrivalTime: \(Swift.String(describing: lastMessageArrivalTime)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), status: \(Swift.String(describing: status)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>A summary of information about a data store.</p>
    public struct DatastoreSummary: Swift.Equatable {
        /// <p>When the data store was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The name of the data store.</p>
        public let datastoreName: Swift.String?
        /// <p>Where data store data is stored.</p>
        public let datastoreStorage: IoTAnalyticsClientTypes.DatastoreStorageSummary?
        /// <p>The file format of the data in the data store.</p>
        public let fileFormatType: IoTAnalyticsClientTypes.FileFormatType?
        /// <p>The last time when a new message arrived in the data store.</p>
        ///          <p>AWS IoT Analytics updates this value at most once per minute for one data store.
        ///   Hence, the <code>lastMessageArrivalTime</code> value is an approximation.</p>
        ///          <p>This feature only applies to messages that arrived in the data store after October 23, 2020. </p>
        public let lastMessageArrivalTime: ClientRuntime.Date?
        /// <p>The last time the data store was updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The status of the data store.</p>
        public let status: IoTAnalyticsClientTypes.DatastoreStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStorage: IoTAnalyticsClientTypes.DatastoreStorageSummary? = nil,
            fileFormatType: IoTAnalyticsClientTypes.FileFormatType? = nil,
            lastMessageArrivalTime: ClientRuntime.Date? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            status: IoTAnalyticsClientTypes.DatastoreStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.datastoreName = datastoreName
            self.datastoreStorage = datastoreStorage
            self.fileFormatType = fileFormatType
            self.lastMessageArrivalTime = lastMessageArrivalTime
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }
    }

}

extension DeleteChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelInput(channelName: \(Swift.String(describing: channelName)))"}
}

extension DeleteChannelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInput: Swift.Equatable {
    /// <p>The name of the channel to delete.</p>
    public let channelName: Swift.String?

    public init (
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct DeleteChannelInputBody: Swift.Equatable {
}

extension DeleteChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelOutputResponse()"}
}

extension DeleteChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteChannelOutputResponseBody: Swift.Equatable {
}

extension DeleteChannelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatasetContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetContentInput(datasetName: \(Swift.String(describing: datasetName)), versionId: \(Swift.String(describing: versionId)))"}
}

extension DeleteDatasetContentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDatasetContentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetContentOutputError>
}

public struct DeleteDatasetContentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetContentOutputError>
}

public struct DeleteDatasetContentInput: Swift.Equatable {
    /// <p>The name of the dataset whose content is deleted.</p>
    public let datasetName: Swift.String?
    /// <p>The version of the dataset whose content is deleted. You can also use the strings
    ///       "$LATEST" or "$LATEST_SUCCEEDED" to delete the latest or latest successfully completed data
    ///       set. If not specified, "$LATEST_SUCCEEDED" is the default.</p>
    public let versionId: Swift.String?

    public init (
        datasetName: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
        self.versionId = versionId
    }
}

struct DeleteDatasetContentInputBody: Swift.Equatable {
}

extension DeleteDatasetContentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatasetContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetContentOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetContentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetContentOutputResponse()"}
}

extension DeleteDatasetContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetContentOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDatasetContentOutputResponseBody: Swift.Equatable {
}

extension DeleteDatasetContentOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetInput(datasetName: \(Swift.String(describing: datasetName)))"}
}

extension DeleteDatasetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInput: Swift.Equatable {
    /// <p>The name of the data set to delete.</p>
    public let datasetName: Swift.String?

    public init (
        datasetName: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
}

extension DeleteDatasetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetOutputResponse()"}
}

extension DeleteDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDatasetOutputResponseBody: Swift.Equatable {
}

extension DeleteDatasetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatastoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatastoreInput(datastoreName: \(Swift.String(describing: datastoreName)))"}
}

extension DeleteDatastoreInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDatastoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatastoreOutputError>
}

public struct DeleteDatastoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatastoreOutputError>
}

public struct DeleteDatastoreInput: Swift.Equatable {
    /// <p>The name of the data store to delete.</p>
    public let datastoreName: Swift.String?

    public init (
        datastoreName: Swift.String? = nil
    )
    {
        self.datastoreName = datastoreName
    }
}

struct DeleteDatastoreInputBody: Swift.Equatable {
}

extension DeleteDatastoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatastoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatastoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatastoreOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatastoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatastoreOutputResponse()"}
}

extension DeleteDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatastoreOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDatastoreOutputResponseBody: Swift.Equatable {
}

extension DeleteDatastoreOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePipelineInput(pipelineName: \(Swift.String(describing: pipelineName)))"}
}

extension DeletePipelineInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeletePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePipelineOutputError>
}

public struct DeletePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePipelineOutputError>
}

public struct DeletePipelineInput: Swift.Equatable {
    /// <p>The name of the pipeline to delete.</p>
    public let pipelineName: Swift.String?

    public init (
        pipelineName: Swift.String? = nil
    )
    {
        self.pipelineName = pipelineName
    }
}

struct DeletePipelineInputBody: Swift.Equatable {
}

extension DeletePipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePipelineOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePipelineOutputResponse()"}
}

extension DeletePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePipelineOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePipelineOutputResponseBody: Swift.Equatable {
}

extension DeletePipelineOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IoTAnalyticsClientTypes.DeltaTime: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offsetSeconds
        case timeExpression
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offsetSeconds = offsetSeconds {
            try encodeContainer.encode(offsetSeconds, forKey: .offsetSeconds)
        }
        if let timeExpression = timeExpression {
            try encodeContainer.encode(timeExpression, forKey: .timeExpression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offsetSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offsetSeconds)
        offsetSeconds = offsetSecondsDecoded
        let timeExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeExpression)
        timeExpression = timeExpressionDecoded
    }
}

extension IoTAnalyticsClientTypes.DeltaTime: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeltaTime(offsetSeconds: \(Swift.String(describing: offsetSeconds)), timeExpression: \(Swift.String(describing: timeExpression)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Used to limit data to that which has arrived since the last execution of the
    ///       action.</p>
    public struct DeltaTime: Swift.Equatable {
        /// <p>The number of seconds of estimated in-flight lag time of message data. When you create
        ///       dataset contents using message data from a specified timeframe, some message data might still
        ///       be in flight when processing begins, and so do not arrive in time to be processed. Use this
        ///       field to make allowances for the in flight time of your message data, so that data not
        ///       processed from a previous timeframe is included with the next timeframe. Otherwise, missed
        ///       message data would be excluded from processing during the next timeframe too, because its
        ///       timestamp places it within the previous timeframe.</p>
        public let offsetSeconds: Swift.Int?
        /// <p>An expression by which the time of the message data might be determined. This can be the
        ///       name of a timestamp field or a SQL expression that is used to derive the time the message data
        ///       was generated.</p>
        public let timeExpression: Swift.String?

        public init (
            offsetSeconds: Swift.Int? = nil,
            timeExpression: Swift.String? = nil
        )
        {
            self.offsetSeconds = offsetSeconds
            self.timeExpression = timeExpression
        }
    }

}

extension IoTAnalyticsClientTypes.DeltaTimeSessionWindowConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeoutInMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeoutInMinutes = timeoutInMinutes {
            try encodeContainer.encode(timeoutInMinutes, forKey: .timeoutInMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMinutes)
        timeoutInMinutes = timeoutInMinutesDecoded
    }
}

extension IoTAnalyticsClientTypes.DeltaTimeSessionWindowConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeltaTimeSessionWindowConfiguration(timeoutInMinutes: \(Swift.String(describing: timeoutInMinutes)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>A structure that contains the configuration information of a delta time session
    ///       window.</p>
    ///          <p>
    ///             <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">
    ///                <code>DeltaTime</code>
    ///             </a> specifies a time interval. You can use
    ///         <code>DeltaTime</code> to create dataset contents with data that has arrived in the data
    ///       store since the last execution. For an example of <code>DeltaTime</code>, see <a href="https://docs.aws.amazon.com/iotanalytics/latest/userguide/automate-create-dataset.html#automate-example6"> Creating
    ///         a SQL dataset with a delta window (CLI)</a> in the
    ///         <i>AWS IoT Analytics User Guide</i>.</p>
    public struct DeltaTimeSessionWindowConfiguration: Swift.Equatable {
        /// <p>A time interval. You can use <code>timeoutInMinutes</code> so that AWS IoT Analytics can batch up late
        ///       data notifications that have been generated since the last execution. AWS IoT Analytics sends one batch of
        ///       notifications to Amazon CloudWatch Events at one time.</p>
        ///          <p>For more information about how to write a timestamp expression, see <a href="https://prestodb.io/docs/0.172/functions/datetime.html">Date and Time Functions and
        ///         Operators</a>, in the <i>Presto 0.172 Documentation</i>.</p>
        public let timeoutInMinutes: Swift.Int?

        public init (
            timeoutInMinutes: Swift.Int? = nil
        )
        {
            self.timeoutInMinutes = timeoutInMinutes
        }
    }

}

extension DescribeChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelInput(channelName: \(Swift.String(describing: channelName)), includeStatistics: \(Swift.String(describing: includeStatistics)))"}
}

extension DescribeChannelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.includeStatistics != false {
            let includeStatisticsQueryItem = ClientRuntime.URLQueryItem(name: "includeStatistics".urlPercentEncoding(), value: Swift.String(input.operationInput.includeStatistics).urlPercentEncoding())
            input.builder.withQueryItem(includeStatisticsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInput: Swift.Equatable {
    /// <p>The name of the channel whose information is retrieved.</p>
    public let channelName: Swift.String?
    /// <p>If true, additional statistical information about the channel is included in the response.
    ///       This feature cannot be used with a channel whose S3 storage is customer-managed.</p>
    public let includeStatistics: Swift.Bool

    public init (
        channelName: Swift.String? = nil,
        includeStatistics: Swift.Bool = false
    )
    {
        self.channelName = channelName
        self.includeStatistics = includeStatistics
    }
}

struct DescribeChannelInputBody: Swift.Equatable {
}

extension DescribeChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelOutputResponse(channel: \(Swift.String(describing: channel)), statistics: \(Swift.String(describing: statistics)))"}
}

extension DescribeChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
            self.statistics = output.statistics
        } else {
            self.channel = nil
            self.statistics = nil
        }
    }
}

public struct DescribeChannelOutputResponse: Swift.Equatable {
    /// <p>An object that contains information about the channel.</p>
    public let channel: IoTAnalyticsClientTypes.Channel?
    /// <p>Statistics about the channel. Included if the <code>includeStatistics</code> parameter is
    ///       set to <code>true</code> in the request.</p>
    public let statistics: IoTAnalyticsClientTypes.ChannelStatistics?

    public init (
        channel: IoTAnalyticsClientTypes.Channel? = nil,
        statistics: IoTAnalyticsClientTypes.ChannelStatistics? = nil
    )
    {
        self.channel = channel
        self.statistics = statistics
    }
}

struct DescribeChannelOutputResponseBody: Swift.Equatable {
    public let channel: IoTAnalyticsClientTypes.Channel?
    public let statistics: IoTAnalyticsClientTypes.ChannelStatistics?
}

extension DescribeChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
        case statistics
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ChannelStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
    }
}

extension DescribeDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetInput(datasetName: \(Swift.String(describing: datasetName)))"}
}

extension DescribeDatasetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInput: Swift.Equatable {
    /// <p>The name of the data set whose information is retrieved.</p>
    public let datasetName: Swift.String?

    public init (
        datasetName: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
    }
}

struct DescribeDatasetInputBody: Swift.Equatable {
}

extension DescribeDatasetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetOutputResponse(dataset: \(Swift.String(describing: dataset)))"}
}

extension DescribeDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataset = output.dataset
        } else {
            self.dataset = nil
        }
    }
}

public struct DescribeDatasetOutputResponse: Swift.Equatable {
    /// <p>An object that contains information about the data set.</p>
    public let dataset: IoTAnalyticsClientTypes.Dataset?

    public init (
        dataset: IoTAnalyticsClientTypes.Dataset? = nil
    )
    {
        self.dataset = dataset
    }
}

struct DescribeDatasetOutputResponseBody: Swift.Equatable {
    public let dataset: IoTAnalyticsClientTypes.Dataset?
}

extension DescribeDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataset
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.Dataset.self, forKey: .dataset)
        dataset = datasetDecoded
    }
}

extension DescribeDatastoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatastoreInput(datastoreName: \(Swift.String(describing: datastoreName)), includeStatistics: \(Swift.String(describing: includeStatistics)))"}
}

extension DescribeDatastoreInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeDatastoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatastoreOutputError>
}

public struct DescribeDatastoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.includeStatistics != false {
            let includeStatisticsQueryItem = ClientRuntime.URLQueryItem(name: "includeStatistics".urlPercentEncoding(), value: Swift.String(input.operationInput.includeStatistics).urlPercentEncoding())
            input.builder.withQueryItem(includeStatisticsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatastoreOutputError>
}

public struct DescribeDatastoreInput: Swift.Equatable {
    /// <p>The name of the data store</p>
    public let datastoreName: Swift.String?
    /// <p>If true, additional statistical information about the data store is included in the
    ///       response. This feature cannot be used with a data store whose S3 storage is
    ///       customer-managed.</p>
    public let includeStatistics: Swift.Bool

    public init (
        datastoreName: Swift.String? = nil,
        includeStatistics: Swift.Bool = false
    )
    {
        self.datastoreName = datastoreName
        self.includeStatistics = includeStatistics
    }
}

struct DescribeDatastoreInputBody: Swift.Equatable {
}

extension DescribeDatastoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDatastoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatastoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatastoreOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatastoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatastoreOutputResponse(datastore: \(Swift.String(describing: datastore)), statistics: \(Swift.String(describing: statistics)))"}
}

extension DescribeDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastore = output.datastore
            self.statistics = output.statistics
        } else {
            self.datastore = nil
            self.statistics = nil
        }
    }
}

public struct DescribeDatastoreOutputResponse: Swift.Equatable {
    /// <p>Information about the data store.</p>
    public let datastore: IoTAnalyticsClientTypes.Datastore?
    /// <p>Additional statistical information about the data store. Included if the
    ///         <code>includeStatistics</code> parameter is set to <code>true</code> in the request.</p>
    public let statistics: IoTAnalyticsClientTypes.DatastoreStatistics?

    public init (
        datastore: IoTAnalyticsClientTypes.Datastore? = nil,
        statistics: IoTAnalyticsClientTypes.DatastoreStatistics? = nil
    )
    {
        self.datastore = datastore
        self.statistics = statistics
    }
}

struct DescribeDatastoreOutputResponseBody: Swift.Equatable {
    public let datastore: IoTAnalyticsClientTypes.Datastore?
    public let statistics: IoTAnalyticsClientTypes.DatastoreStatistics?
}

extension DescribeDatastoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastore
        case statistics
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.Datastore.self, forKey: .datastore)
        datastore = datastoreDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatastoreStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
    }
}

extension DescribeLoggingOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLoggingOptionsInput()"}
}

extension DescribeLoggingOptionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeLoggingOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoggingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoggingOptionsOutputError>
}

public struct DescribeLoggingOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoggingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoggingOptionsOutputError>
}

public struct DescribeLoggingOptionsInput: Swift.Equatable {

    public init() {}
}

struct DescribeLoggingOptionsInputBody: Swift.Equatable {
}

extension DescribeLoggingOptionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeLoggingOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLoggingOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoggingOptionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoggingOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLoggingOptionsOutputResponse(loggingOptions: \(Swift.String(describing: loggingOptions)))"}
}

extension DescribeLoggingOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLoggingOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loggingOptions = output.loggingOptions
        } else {
            self.loggingOptions = nil
        }
    }
}

public struct DescribeLoggingOptionsOutputResponse: Swift.Equatable {
    /// <p>The current settings of the AWS IoT Analytics logging options.</p>
    public let loggingOptions: IoTAnalyticsClientTypes.LoggingOptions?

    public init (
        loggingOptions: IoTAnalyticsClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct DescribeLoggingOptionsOutputResponseBody: Swift.Equatable {
    public let loggingOptions: IoTAnalyticsClientTypes.LoggingOptions?
}

extension DescribeLoggingOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension DescribePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePipelineInput(pipelineName: \(Swift.String(describing: pipelineName)))"}
}

extension DescribePipelineInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePipelineOutputError>
}

public struct DescribePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePipelineOutputError>
}

public struct DescribePipelineInput: Swift.Equatable {
    /// <p>The name of the pipeline whose information is retrieved.</p>
    public let pipelineName: Swift.String?

    public init (
        pipelineName: Swift.String? = nil
    )
    {
        self.pipelineName = pipelineName
    }
}

struct DescribePipelineInputBody: Swift.Equatable {
}

extension DescribePipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePipelineOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePipelineOutputResponse(pipeline: \(Swift.String(describing: pipeline)))"}
}

extension DescribePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

public struct DescribePipelineOutputResponse: Swift.Equatable {
    /// <p>A <code>Pipeline</code> object that contains information about the pipeline.</p>
    public let pipeline: IoTAnalyticsClientTypes.Pipeline?

    public init (
        pipeline: IoTAnalyticsClientTypes.Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct DescribePipelineOutputResponseBody: Swift.Equatable {
    public let pipeline: IoTAnalyticsClientTypes.Pipeline?
}

extension DescribePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

extension IoTAnalyticsClientTypes.DeviceRegistryEnrichActivity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case name
        case next
        case roleArn
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attribute)
        attribute = attributeDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let nextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .next)
        next = nextDecoded
    }
}

extension IoTAnalyticsClientTypes.DeviceRegistryEnrichActivity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceRegistryEnrichActivity(attribute: \(Swift.String(describing: attribute)), name: \(Swift.String(describing: name)), next: \(Swift.String(describing: next)), roleArn: \(Swift.String(describing: roleArn)), thingName: \(Swift.String(describing: thingName)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>An activity that adds data from the AWS IoT device registry to your message.</p>
    public struct DeviceRegistryEnrichActivity: Swift.Equatable {
        /// <p>The name of the attribute that is added to the message.</p>
        public let attribute: Swift.String?
        /// <p>The name of the <code>deviceRegistryEnrich</code> activity.</p>
        public let name: Swift.String?
        /// <p>The next activity in the pipeline.</p>
        public let next: Swift.String?
        /// <p>The ARN of the role that allows access to the device's registry information.</p>
        public let roleArn: Swift.String?
        /// <p>The name of the IoT device whose registry information is added to the message.</p>
        public let thingName: Swift.String?

        public init (
            attribute: Swift.String? = nil,
            name: Swift.String? = nil,
            next: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.attribute = attribute
            self.name = name
            self.next = next
            self.roleArn = roleArn
            self.thingName = thingName
        }
    }

}

extension IoTAnalyticsClientTypes.DeviceShadowEnrichActivity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case name
        case next
        case roleArn
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attribute)
        attribute = attributeDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let nextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .next)
        next = nextDecoded
    }
}

extension IoTAnalyticsClientTypes.DeviceShadowEnrichActivity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceShadowEnrichActivity(attribute: \(Swift.String(describing: attribute)), name: \(Swift.String(describing: name)), next: \(Swift.String(describing: next)), roleArn: \(Swift.String(describing: roleArn)), thingName: \(Swift.String(describing: thingName)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>An activity that adds information from the AWS IoT Device Shadow service to a
    ///       message.</p>
    public struct DeviceShadowEnrichActivity: Swift.Equatable {
        /// <p>The name of the attribute that is added to the message.</p>
        public let attribute: Swift.String?
        /// <p>The name of the <code>deviceShadowEnrich</code> activity.</p>
        public let name: Swift.String?
        /// <p>The next activity in the pipeline.</p>
        public let next: Swift.String?
        /// <p>The ARN of the role that allows access to the device's shadow.</p>
        public let roleArn: Swift.String?
        /// <p>The name of the IoT device whose shadow information is added to the message.</p>
        public let thingName: Swift.String?

        public init (
            attribute: Swift.String? = nil,
            name: Swift.String? = nil,
            next: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.attribute = attribute
            self.name = name
            self.next = next
            self.roleArn = roleArn
            self.thingName = thingName
        }
    }

}

extension IoTAnalyticsClientTypes.EstimatedResourceSize: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedOn
        case estimatedSizeInBytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let estimatedOn = estimatedOn {
            try encodeContainer.encode(estimatedOn.timeIntervalSince1970, forKey: .estimatedOn)
        }
        if let estimatedSizeInBytes = estimatedSizeInBytes {
            try encodeContainer.encode(estimatedSizeInBytes, forKey: .estimatedSizeInBytes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedSizeInBytes)
        estimatedSizeInBytes = estimatedSizeInBytesDecoded
        let estimatedOnDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .estimatedOn)
        estimatedOn = estimatedOnDecoded
    }
}

extension IoTAnalyticsClientTypes.EstimatedResourceSize: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EstimatedResourceSize(estimatedOn: \(Swift.String(describing: estimatedOn)), estimatedSizeInBytes: \(Swift.String(describing: estimatedSizeInBytes)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>The estimated size of the resource.</p>
    public struct EstimatedResourceSize: Swift.Equatable {
        /// <p>The time when the estimate of the size of the resource was made.</p>
        public let estimatedOn: ClientRuntime.Date?
        /// <p>The estimated size of the resource, in bytes.</p>
        public let estimatedSizeInBytes: Swift.Double?

        public init (
            estimatedOn: ClientRuntime.Date? = nil,
            estimatedSizeInBytes: Swift.Double? = nil
        )
        {
            self.estimatedOn = estimatedOn
            self.estimatedSizeInBytes = estimatedSizeInBytes
        }
    }

}

extension IoTAnalyticsClientTypes.FileFormatConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jsonConfiguration
        case parquetConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jsonConfiguration = jsonConfiguration {
            try encodeContainer.encode(jsonConfiguration, forKey: .jsonConfiguration)
        }
        if let parquetConfiguration = parquetConfiguration {
            try encodeContainer.encode(parquetConfiguration, forKey: .parquetConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jsonConfigurationDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.JsonConfiguration.self, forKey: .jsonConfiguration)
        jsonConfiguration = jsonConfigurationDecoded
        let parquetConfigurationDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ParquetConfiguration.self, forKey: .parquetConfiguration)
        parquetConfiguration = parquetConfigurationDecoded
    }
}

extension IoTAnalyticsClientTypes.FileFormatConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FileFormatConfiguration(jsonConfiguration: \(Swift.String(describing: jsonConfiguration)), parquetConfiguration: \(Swift.String(describing: parquetConfiguration)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Contains the configuration information of file formats. AWS IoT Analytics data stores support JSON
    ///       and <a href="https://parquet.apache.org/">Parquet</a>.</p>
    ///          <p>The default file format is JSON. You can specify only one format.</p>
    ///          <p>You can't change the file format after you create the data store.</p>
    public struct FileFormatConfiguration: Swift.Equatable {
        /// <p>Contains the configuration information of the JSON format.</p>
        public let jsonConfiguration: IoTAnalyticsClientTypes.JsonConfiguration?
        /// <p>Contains the configuration information of the Parquet format.</p>
        public let parquetConfiguration: IoTAnalyticsClientTypes.ParquetConfiguration?

        public init (
            jsonConfiguration: IoTAnalyticsClientTypes.JsonConfiguration? = nil,
            parquetConfiguration: IoTAnalyticsClientTypes.ParquetConfiguration? = nil
        )
        {
            self.jsonConfiguration = jsonConfiguration
            self.parquetConfiguration = parquetConfiguration
        }
    }

}

extension IoTAnalyticsClientTypes {
    public enum FileFormatType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [FileFormatType] {
            return [
                .json,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileFormatType(rawValue: rawValue) ?? FileFormatType.sdkUnknown(rawValue)
        }
    }
}

extension IoTAnalyticsClientTypes.FilterActivity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case name
        case next
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filter)
        filter = filterDecoded
        let nextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .next)
        next = nextDecoded
    }
}

extension IoTAnalyticsClientTypes.FilterActivity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FilterActivity(filter: \(Swift.String(describing: filter)), name: \(Swift.String(describing: name)), next: \(Swift.String(describing: next)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>An activity that filters a message based on its attributes.</p>
    public struct FilterActivity: Swift.Equatable {
        /// <p>An expression that looks like a SQL WHERE clause that must return a Boolean value.
        ///       Messages that satisfy the condition are passed to the next activity. </p>
        public let filter: Swift.String?
        /// <p>The name of the filter activity.</p>
        public let name: Swift.String?
        /// <p>The next activity in the pipeline.</p>
        public let next: Swift.String?

        public init (
            filter: Swift.String? = nil,
            name: Swift.String? = nil,
            next: Swift.String? = nil
        )
        {
            self.filter = filter
            self.name = name
            self.next = next
        }
    }

}

extension GetDatasetContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDatasetContentInput(datasetName: \(Swift.String(describing: datasetName)), versionId: \(Swift.String(describing: versionId)))"}
}

extension GetDatasetContentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDatasetContentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDatasetContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDatasetContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDatasetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDatasetContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDatasetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDatasetContentOutputError>
}

public struct GetDatasetContentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDatasetContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDatasetContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDatasetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDatasetContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDatasetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDatasetContentOutputError>
}

public struct GetDatasetContentInput: Swift.Equatable {
    /// <p>The name of the data set whose contents are retrieved.</p>
    public let datasetName: Swift.String?
    /// <p>The version of the data set whose contents are retrieved. You can also use the strings
    ///       "$LATEST" or "$LATEST_SUCCEEDED" to retrieve the contents of the latest or latest successfully
    ///       completed data set. If not specified, "$LATEST_SUCCEEDED" is the default.</p>
    public let versionId: Swift.String?

    public init (
        datasetName: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
        self.versionId = versionId
    }
}

struct GetDatasetContentInputBody: Swift.Equatable {
}

extension GetDatasetContentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDatasetContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDatasetContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDatasetContentOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDatasetContentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDatasetContentOutputResponse(entries: \(Swift.String(describing: entries)), status: \(Swift.String(describing: status)), timestamp: \(Swift.String(describing: timestamp)))"}
}

extension GetDatasetContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDatasetContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.status = output.status
            self.timestamp = output.timestamp
        } else {
            self.entries = nil
            self.status = nil
            self.timestamp = nil
        }
    }
}

public struct GetDatasetContentOutputResponse: Swift.Equatable {
    /// <p>A list of <code>DatasetEntry</code> objects.</p>
    public let entries: [IoTAnalyticsClientTypes.DatasetEntry]?
    /// <p>The status of the data set content.</p>
    public let status: IoTAnalyticsClientTypes.DatasetContentStatus?
    /// <p>The time when the request was made.</p>
    public let timestamp: ClientRuntime.Date?

    public init (
        entries: [IoTAnalyticsClientTypes.DatasetEntry]? = nil,
        status: IoTAnalyticsClientTypes.DatasetContentStatus? = nil,
        timestamp: ClientRuntime.Date? = nil
    )
    {
        self.entries = entries
        self.status = status
        self.timestamp = timestamp
    }
}

struct GetDatasetContentOutputResponseBody: Swift.Equatable {
    public let entries: [IoTAnalyticsClientTypes.DatasetEntry]?
    public let timestamp: ClientRuntime.Date?
    public let status: IoTAnalyticsClientTypes.DatasetContentStatus?
}

extension GetDatasetContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
        case status
        case timestamp
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.DatasetEntry?].self, forKey: .entries)
        var entriesDecoded0:[IoTAnalyticsClientTypes.DatasetEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [IoTAnalyticsClientTypes.DatasetEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatasetContentStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTAnalyticsClientTypes.GlueConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension IoTAnalyticsClientTypes.GlueConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GlueConfiguration(databaseName: \(Swift.String(describing: databaseName)), tableName: \(Swift.String(describing: tableName)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Configuration information for coordination with AWS Glue, a fully managed extract,
    ///       transform and load (ETL) service.</p>
    public struct GlueConfiguration: Swift.Equatable {
        /// <p>The name of the database in your AWS Glue Data Catalog in which the table is located. An
        ///       AWS Glue Data Catalog database contains metadata tables.</p>
        public let databaseName: Swift.String?
        /// <p>The name of the table in your AWS Glue Data Catalog that is used to perform the ETL
        ///       operations. An AWS Glue Data Catalog table contains partitioned data and descriptions of data
        ///       sources and targets.</p>
        public let tableName: Swift.String?

        public init (
            databaseName: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.tableName = tableName
        }
    }

}

extension InternalFailureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalFailureException(message: \(Swift.String(describing: message)))"}
}

extension InternalFailureException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was an internal failure.</p>
public struct InternalFailureException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was not valid.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTAnalyticsClientTypes.IotEventsDestinationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputName
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputName = inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTAnalyticsClientTypes.IotEventsDestinationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IotEventsDestinationConfiguration(inputName: \(Swift.String(describing: inputName)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Configuration information for delivery of dataset contents to AWS IoT Events.</p>
    public struct IotEventsDestinationConfiguration: Swift.Equatable {
        /// <p>The name of the AWS IoT Events input to which dataset contents are delivered.</p>
        public let inputName: Swift.String?
        /// <p>The ARN of the role that grants AWS IoT Analytics permission to deliver dataset contents
        ///       to an AWS IoT Events input.</p>
        public let roleArn: Swift.String?

        public init (
            inputName: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.inputName = inputName
            self.roleArn = roleArn
        }
    }

}

extension IoTAnalyticsClientTypes.JsonConfiguration: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IoTAnalyticsClientTypes.JsonConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JsonConfiguration()"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Contains the configuration information of the JSON format.</p>
    public struct JsonConfiguration: Swift.Equatable {

        public init() {}
    }

}

extension IoTAnalyticsClientTypes.LambdaActivity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize
        case lambdaName
        case name
        case next
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSize = batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let lambdaName = lambdaName {
            try encodeContainer.encode(lambdaName, forKey: .lambdaName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lambdaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaName)
        lambdaName = lambdaNameDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let nextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .next)
        next = nextDecoded
    }
}

extension IoTAnalyticsClientTypes.LambdaActivity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaActivity(batchSize: \(Swift.String(describing: batchSize)), lambdaName: \(Swift.String(describing: lambdaName)), name: \(Swift.String(describing: name)), next: \(Swift.String(describing: next)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>An activity that runs a Lambda function to modify the message.</p>
    public struct LambdaActivity: Swift.Equatable {
        /// <p>The number of messages passed to the Lambda function for processing.</p>
        ///          <p>The Lambda function must be able to process all of these messages within five minutes,
        ///       which is the maximum timeout duration for Lambda functions.</p>
        public let batchSize: Swift.Int?
        /// <p>The name of the Lambda function that is run on the message.</p>
        public let lambdaName: Swift.String?
        /// <p>The name of the lambda activity.</p>
        public let name: Swift.String?
        /// <p>The next activity in the pipeline.</p>
        public let next: Swift.String?

        public init (
            batchSize: Swift.Int? = nil,
            lambdaName: Swift.String? = nil,
            name: Swift.String? = nil,
            next: Swift.String? = nil
        )
        {
            self.batchSize = batchSize
            self.lambdaName = lambdaName
            self.name = name
            self.next = next
        }
    }

}

extension IoTAnalyticsClientTypes.LateDataRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ruleConfiguration
        case ruleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleConfiguration = ruleConfiguration {
            try encodeContainer.encode(ruleConfiguration, forKey: .ruleConfiguration)
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let ruleConfigurationDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.LateDataRuleConfiguration.self, forKey: .ruleConfiguration)
        ruleConfiguration = ruleConfigurationDecoded
    }
}

extension IoTAnalyticsClientTypes.LateDataRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LateDataRule(ruleConfiguration: \(Swift.String(describing: ruleConfiguration)), ruleName: \(Swift.String(describing: ruleName)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>A structure that contains the name and configuration information of a late data
    ///       rule.</p>
    public struct LateDataRule: Swift.Equatable {
        /// <p>The information needed to configure the late data rule.</p>
        public let ruleConfiguration: IoTAnalyticsClientTypes.LateDataRuleConfiguration?
        /// <p>The name of the late data rule.</p>
        public let ruleName: Swift.String?

        public init (
            ruleConfiguration: IoTAnalyticsClientTypes.LateDataRuleConfiguration? = nil,
            ruleName: Swift.String? = nil
        )
        {
            self.ruleConfiguration = ruleConfiguration
            self.ruleName = ruleName
        }
    }

}

extension IoTAnalyticsClientTypes.LateDataRuleConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deltaTimeSessionWindowConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deltaTimeSessionWindowConfiguration = deltaTimeSessionWindowConfiguration {
            try encodeContainer.encode(deltaTimeSessionWindowConfiguration, forKey: .deltaTimeSessionWindowConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deltaTimeSessionWindowConfigurationDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DeltaTimeSessionWindowConfiguration.self, forKey: .deltaTimeSessionWindowConfiguration)
        deltaTimeSessionWindowConfiguration = deltaTimeSessionWindowConfigurationDecoded
    }
}

extension IoTAnalyticsClientTypes.LateDataRuleConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LateDataRuleConfiguration(deltaTimeSessionWindowConfiguration: \(Swift.String(describing: deltaTimeSessionWindowConfiguration)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>The information needed to configure a delta time session window.</p>
    public struct LateDataRuleConfiguration: Swift.Equatable {
        /// <p>The information needed to configure a delta time session window.</p>
        public let deltaTimeSessionWindowConfiguration: IoTAnalyticsClientTypes.DeltaTimeSessionWindowConfiguration?

        public init (
            deltaTimeSessionWindowConfiguration: IoTAnalyticsClientTypes.DeltaTimeSessionWindowConfiguration? = nil
        )
        {
            self.deltaTimeSessionWindowConfiguration = deltaTimeSessionWindowConfiguration
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The command caused an internal limit to be exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInput: Swift.Equatable {
    /// <p>The maximum number of results to return in this request.</p>
    ///          <p>The default value is 100.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Swift.Equatable {
}

extension ListChannelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsOutputResponse(channelSummaries: \(Swift.String(describing: channelSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelSummaries = output.channelSummaries
            self.nextToken = output.nextToken
        } else {
            self.channelSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Swift.Equatable {
    /// <p>A list of <code>ChannelSummary</code> objects.</p>
    public let channelSummaries: [IoTAnalyticsClientTypes.ChannelSummary]?
    /// <p>The token to retrieve the next set of results, or <code>null</code> if there are no more
    ///       results.</p>
    public let nextToken: Swift.String?

    public init (
        channelSummaries: [IoTAnalyticsClientTypes.ChannelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelSummaries = channelSummaries
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Swift.Equatable {
    public let channelSummaries: [IoTAnalyticsClientTypes.ChannelSummary]?
    public let nextToken: Swift.String?
}

extension ListChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelSummariesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.ChannelSummary?].self, forKey: .channelSummaries)
        var channelSummariesDecoded0:[IoTAnalyticsClientTypes.ChannelSummary]? = nil
        if let channelSummariesContainer = channelSummariesContainer {
            channelSummariesDecoded0 = [IoTAnalyticsClientTypes.ChannelSummary]()
            for structure0 in channelSummariesContainer {
                if let structure0 = structure0 {
                    channelSummariesDecoded0?.append(structure0)
                }
            }
        }
        channelSummaries = channelSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatasetContentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetContentsInput(datasetName: \(Swift.String(describing: datasetName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), scheduledBefore: \(Swift.String(describing: scheduledBefore)), scheduledOnOrAfter: \(Swift.String(describing: scheduledOnOrAfter)))"}
}

extension ListDatasetContentsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDatasetContentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetContentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetContentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetContentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetContentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetContentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetContentsOutputError>
}

public struct ListDatasetContentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetContentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetContentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetContentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let scheduledOnOrAfter = input.operationInput.scheduledOnOrAfter {
            let scheduledOnOrAfterQueryItem = ClientRuntime.URLQueryItem(name: "scheduledOnOrAfter".urlPercentEncoding(), value: Swift.String(scheduledOnOrAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(scheduledOnOrAfterQueryItem)
        }
        if let scheduledBefore = input.operationInput.scheduledBefore {
            let scheduledBeforeQueryItem = ClientRuntime.URLQueryItem(name: "scheduledBefore".urlPercentEncoding(), value: Swift.String(scheduledBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(scheduledBeforeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetContentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetContentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetContentsOutputError>
}

public struct ListDatasetContentsInput: Swift.Equatable {
    /// <p>The name of the data set whose contents information you want to list.</p>
    public let datasetName: Swift.String?
    /// <p>The maximum number of results to return in this request.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: Swift.String?
    /// <p>A filter to limit results to those data set contents whose creation is scheduled before
    ///       the given time. See the field <code>triggers.schedule</code> in the <code>CreateDataset</code>
    ///       request. (timestamp)</p>
    public let scheduledBefore: ClientRuntime.Date?
    /// <p>A filter to limit results to those data set contents whose creation is scheduled on or
    ///       after the given time. See the field <code>triggers.schedule</code> in the
    ///         <code>CreateDataset</code> request. (timestamp)</p>
    public let scheduledOnOrAfter: ClientRuntime.Date?

    public init (
        datasetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        scheduledBefore: ClientRuntime.Date? = nil,
        scheduledOnOrAfter: ClientRuntime.Date? = nil
    )
    {
        self.datasetName = datasetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scheduledBefore = scheduledBefore
        self.scheduledOnOrAfter = scheduledOnOrAfter
    }
}

struct ListDatasetContentsInputBody: Swift.Equatable {
}

extension ListDatasetContentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDatasetContentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetContentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetContentsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetContentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetContentsOutputResponse(datasetContentSummaries: \(Swift.String(describing: datasetContentSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetContentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatasetContentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetContentSummaries = output.datasetContentSummaries
            self.nextToken = output.nextToken
        } else {
            self.datasetContentSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetContentsOutputResponse: Swift.Equatable {
    /// <p>Summary information about data set contents that have been created.</p>
    public let datasetContentSummaries: [IoTAnalyticsClientTypes.DatasetContentSummary]?
    /// <p>The token to retrieve the next set of results, or <code>null</code> if there are no more
    ///       results.</p>
    public let nextToken: Swift.String?

    public init (
        datasetContentSummaries: [IoTAnalyticsClientTypes.DatasetContentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetContentSummaries = datasetContentSummaries
        self.nextToken = nextToken
    }
}

struct ListDatasetContentsOutputResponseBody: Swift.Equatable {
    public let datasetContentSummaries: [IoTAnalyticsClientTypes.DatasetContentSummary]?
    public let nextToken: Swift.String?
}

extension ListDatasetContentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetContentSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetContentSummariesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.DatasetContentSummary?].self, forKey: .datasetContentSummaries)
        var datasetContentSummariesDecoded0:[IoTAnalyticsClientTypes.DatasetContentSummary]? = nil
        if let datasetContentSummariesContainer = datasetContentSummariesContainer {
            datasetContentSummariesDecoded0 = [IoTAnalyticsClientTypes.DatasetContentSummary]()
            for structure0 in datasetContentSummariesContainer {
                if let structure0 = structure0 {
                    datasetContentSummariesDecoded0?.append(structure0)
                }
            }
        }
        datasetContentSummaries = datasetContentSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatasetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDatasetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInput: Swift.Equatable {
    /// <p>The maximum number of results to return in this request.</p>
    ///          <p>The default value is 100.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Swift.Equatable {
}

extension ListDatasetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDatasetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetsOutputResponse(datasetSummaries: \(Swift.String(describing: datasetSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatasetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetSummaries = output.datasetSummaries
            self.nextToken = output.nextToken
        } else {
            self.datasetSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetsOutputResponse: Swift.Equatable {
    /// <p>A list of <code>DatasetSummary</code> objects.</p>
    public let datasetSummaries: [IoTAnalyticsClientTypes.DatasetSummary]?
    /// <p>The token to retrieve the next set of results, or <code>null</code> if there are no more
    ///       results.</p>
    public let nextToken: Swift.String?

    public init (
        datasetSummaries: [IoTAnalyticsClientTypes.DatasetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetSummaries = datasetSummaries
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputResponseBody: Swift.Equatable {
    public let datasetSummaries: [IoTAnalyticsClientTypes.DatasetSummary]?
    public let nextToken: Swift.String?
}

extension ListDatasetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetSummariesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.DatasetSummary?].self, forKey: .datasetSummaries)
        var datasetSummariesDecoded0:[IoTAnalyticsClientTypes.DatasetSummary]? = nil
        if let datasetSummariesContainer = datasetSummariesContainer {
            datasetSummariesDecoded0 = [IoTAnalyticsClientTypes.DatasetSummary]()
            for structure0 in datasetSummariesContainer {
                if let structure0 = structure0 {
                    datasetSummariesDecoded0?.append(structure0)
                }
            }
        }
        datasetSummaries = datasetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatastoresInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatastoresInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatastoresInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDatastoresInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatastoresInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatastoresInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatastoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatastoresInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatastoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatastoresOutputError>
}

public struct ListDatastoresInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatastoresInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatastoresInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatastoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatastoresInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatastoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatastoresOutputError>
}

public struct ListDatastoresInput: Swift.Equatable {
    /// <p>The maximum number of results to return in this request.</p>
    ///          <p>The default value is 100.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatastoresInputBody: Swift.Equatable {
}

extension ListDatastoresInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDatastoresOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatastoresOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatastoresOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatastoresOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatastoresOutputResponse(datastoreSummaries: \(Swift.String(describing: datastoreSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatastoresOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatastoresOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreSummaries = output.datastoreSummaries
            self.nextToken = output.nextToken
        } else {
            self.datastoreSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatastoresOutputResponse: Swift.Equatable {
    /// <p>A list of <code>DatastoreSummary</code> objects.</p>
    public let datastoreSummaries: [IoTAnalyticsClientTypes.DatastoreSummary]?
    /// <p>The token to retrieve the next set of results, or <code>null</code> if there are no more
    ///       results.</p>
    public let nextToken: Swift.String?

    public init (
        datastoreSummaries: [IoTAnalyticsClientTypes.DatastoreSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datastoreSummaries = datastoreSummaries
        self.nextToken = nextToken
    }
}

struct ListDatastoresOutputResponseBody: Swift.Equatable {
    public let datastoreSummaries: [IoTAnalyticsClientTypes.DatastoreSummary]?
    public let nextToken: Swift.String?
}

extension ListDatastoresOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreSummariesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.DatastoreSummary?].self, forKey: .datastoreSummaries)
        var datastoreSummariesDecoded0:[IoTAnalyticsClientTypes.DatastoreSummary]? = nil
        if let datastoreSummariesContainer = datastoreSummariesContainer {
            datastoreSummariesDecoded0 = [IoTAnalyticsClientTypes.DatastoreSummary]()
            for structure0 in datastoreSummariesContainer {
                if let structure0 = structure0 {
                    datastoreSummariesDecoded0?.append(structure0)
                }
            }
        }
        datastoreSummaries = datastoreSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPipelinesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPipelinesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPipelinesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPipelinesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPipelinesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPipelinesOutputError>
}

public struct ListPipelinesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPipelinesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPipelinesOutputError>
}

public struct ListPipelinesInput: Swift.Equatable {
    /// <p>The maximum number of results to return in this request.</p>
    ///          <p>The default value is 100.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPipelinesInputBody: Swift.Equatable {
}

extension ListPipelinesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPipelinesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPipelinesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPipelinesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPipelinesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPipelinesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), pipelineSummaries: \(Swift.String(describing: pipelineSummaries)))"}
}

extension ListPipelinesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPipelinesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pipelineSummaries = output.pipelineSummaries
        } else {
            self.nextToken = nil
            self.pipelineSummaries = nil
        }
    }
}

public struct ListPipelinesOutputResponse: Swift.Equatable {
    /// <p>The token to retrieve the next set of results, or <code>null</code> if there are no more
    ///       results.</p>
    public let nextToken: Swift.String?
    /// <p>A list of <code>PipelineSummary</code> objects.</p>
    public let pipelineSummaries: [IoTAnalyticsClientTypes.PipelineSummary]?

    public init (
        nextToken: Swift.String? = nil,
        pipelineSummaries: [IoTAnalyticsClientTypes.PipelineSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.pipelineSummaries = pipelineSummaries
    }
}

struct ListPipelinesOutputResponseBody: Swift.Equatable {
    public let pipelineSummaries: [IoTAnalyticsClientTypes.PipelineSummary]?
    public let nextToken: Swift.String?
}

extension ListPipelinesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case pipelineSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineSummariesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.PipelineSummary?].self, forKey: .pipelineSummaries)
        var pipelineSummariesDecoded0:[IoTAnalyticsClientTypes.PipelineSummary]? = nil
        if let pipelineSummariesContainer = pipelineSummariesContainer {
            pipelineSummariesDecoded0 = [IoTAnalyticsClientTypes.PipelineSummary]()
            for structure0 in pipelineSummariesContainer {
                if let structure0 = structure0 {
                    pipelineSummariesDecoded0?.append(structure0)
                }
            }
        }
        pipelineSummaries = pipelineSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>The ARN of the resource whose tags you want to list.</p>
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>The tags (metadata) that you have assigned to the resource.</p>
    public let tags: [IoTAnalyticsClientTypes.Tag]?

    public init (
        tags: [IoTAnalyticsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [IoTAnalyticsClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTAnalyticsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTAnalyticsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IoTAnalyticsClientTypes {
    public enum LoggingLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingLevel] {
            return [
                .error,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggingLevel(rawValue: rawValue) ?? LoggingLevel.sdkUnknown(rawValue)
        }
    }
}

extension IoTAnalyticsClientTypes.LoggingOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case level
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let level = level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let levelDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.LoggingLevel.self, forKey: .level)
        level = levelDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension IoTAnalyticsClientTypes.LoggingOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoggingOptions(enabled: \(Swift.String(describing: enabled)), level: \(Swift.String(describing: level)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Information about logging options.</p>
    public struct LoggingOptions: Swift.Equatable {
        /// <p>If true, logging is enabled for AWS IoT Analytics.</p>
        public let enabled: Swift.Bool
        /// <p>The logging level. Currently, only ERROR is supported.</p>
        public let level: IoTAnalyticsClientTypes.LoggingLevel?
        /// <p>The ARN of the role that grants permission to AWS IoT Analytics to perform logging.</p>
        public let roleArn: Swift.String?

        public init (
            enabled: Swift.Bool = false,
            level: IoTAnalyticsClientTypes.LoggingLevel? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.level = level
            self.roleArn = roleArn
        }
    }

}

extension IoTAnalyticsClientTypes.MathActivity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case math
        case name
        case next
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let math = math {
            try encodeContainer.encode(math, forKey: .math)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attribute)
        attribute = attributeDecoded
        let mathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .math)
        math = mathDecoded
        let nextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .next)
        next = nextDecoded
    }
}

extension IoTAnalyticsClientTypes.MathActivity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MathActivity(attribute: \(Swift.String(describing: attribute)), math: \(Swift.String(describing: math)), name: \(Swift.String(describing: name)), next: \(Swift.String(describing: next)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>An activity that computes an arithmetic expression using the message's attributes.</p>
    public struct MathActivity: Swift.Equatable {
        /// <p>The name of the attribute that contains the result of the math operation.</p>
        public let attribute: Swift.String?
        /// <p>An expression that uses one or more existing attributes and must return an integer
        ///       value.</p>
        public let math: Swift.String?
        /// <p>The name of the math activity.</p>
        public let name: Swift.String?
        /// <p>The next activity in the pipeline.</p>
        public let next: Swift.String?

        public init (
            attribute: Swift.String? = nil,
            math: Swift.String? = nil,
            name: Swift.String? = nil,
            next: Swift.String? = nil
        )
        {
            self.attribute = attribute
            self.math = math
            self.name = name
            self.next = next
        }
    }

}

extension IoTAnalyticsClientTypes.Message: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId
        case payload
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let payload = payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IoTAnalyticsClientTypes.Message: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Message(messageId: \(Swift.String(describing: messageId)), payload: \(Swift.String(describing: payload)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Information about a message.</p>
    public struct Message: Swift.Equatable {
        /// <p>The ID you want to assign to the message. Each <code>messageId</code> must be unique
        ///          within each batch sent.</p>
        public let messageId: Swift.String?
        /// <p>The payload of the message. This can be a JSON string or a base64-encoded string
        ///          representing binary data, in which case you must decode it by means of a pipeline
        ///          activity.</p>
        public let payload: ClientRuntime.Data?

        public init (
            messageId: Swift.String? = nil,
            payload: ClientRuntime.Data? = nil
        )
        {
            self.messageId = messageId
            self.payload = payload
        }
    }

}

extension IoTAnalyticsClientTypes.OutputFileUriValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileName = fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileName)
        fileName = fileNameDecoded
    }
}

extension IoTAnalyticsClientTypes.OutputFileUriValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OutputFileUriValue(fileName: \(Swift.String(describing: fileName)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>The value of the variable as a structure that specifies an output file URI.</p>
    public struct OutputFileUriValue: Swift.Equatable {
        /// <p>The URI of the location where dataset contents are stored, usually the URI of a file in an
        ///       S3 bucket.</p>
        public let fileName: Swift.String?

        public init (
            fileName: Swift.String? = nil
        )
        {
            self.fileName = fileName
        }
    }

}

extension IoTAnalyticsClientTypes.ParquetConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaDefinition = schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.SchemaDefinition.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
    }
}

extension IoTAnalyticsClientTypes.ParquetConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParquetConfiguration(schemaDefinition: \(Swift.String(describing: schemaDefinition)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Contains the configuration information of the Parquet format.</p>
    public struct ParquetConfiguration: Swift.Equatable {
        /// <p>Information needed to define a schema.</p>
        public let schemaDefinition: IoTAnalyticsClientTypes.SchemaDefinition?

        public init (
            schemaDefinition: IoTAnalyticsClientTypes.SchemaDefinition? = nil
        )
        {
            self.schemaDefinition = schemaDefinition
        }
    }

}

extension IoTAnalyticsClientTypes.Pipeline: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activities
        case arn
        case creationTime
        case lastUpdateTime
        case name
        case reprocessingSummaries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activities = activities {
            var activitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .activities)
            for pipelineactivities0 in activities {
                try activitiesContainer.encode(pipelineactivities0)
            }
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reprocessingSummaries = reprocessingSummaries {
            var reprocessingSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reprocessingSummaries)
            for reprocessingsummaries0 in reprocessingSummaries {
                try reprocessingSummariesContainer.encode(reprocessingsummaries0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let activitiesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.PipelineActivity?].self, forKey: .activities)
        var activitiesDecoded0:[IoTAnalyticsClientTypes.PipelineActivity]? = nil
        if let activitiesContainer = activitiesContainer {
            activitiesDecoded0 = [IoTAnalyticsClientTypes.PipelineActivity]()
            for structure0 in activitiesContainer {
                if let structure0 = structure0 {
                    activitiesDecoded0?.append(structure0)
                }
            }
        }
        activities = activitiesDecoded0
        let reprocessingSummariesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.ReprocessingSummary?].self, forKey: .reprocessingSummaries)
        var reprocessingSummariesDecoded0:[IoTAnalyticsClientTypes.ReprocessingSummary]? = nil
        if let reprocessingSummariesContainer = reprocessingSummariesContainer {
            reprocessingSummariesDecoded0 = [IoTAnalyticsClientTypes.ReprocessingSummary]()
            for structure0 in reprocessingSummariesContainer {
                if let structure0 = structure0 {
                    reprocessingSummariesDecoded0?.append(structure0)
                }
            }
        }
        reprocessingSummaries = reprocessingSummariesDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension IoTAnalyticsClientTypes.Pipeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Pipeline(activities: \(Swift.String(describing: activities)), arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), name: \(Swift.String(describing: name)), reprocessingSummaries: \(Swift.String(describing: reprocessingSummaries)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Contains information about a pipeline.</p>
    public struct Pipeline: Swift.Equatable {
        /// <p>The activities that perform transformations on the messages.</p>
        public let activities: [IoTAnalyticsClientTypes.PipelineActivity]?
        /// <p>The ARN of the pipeline.</p>
        public let arn: Swift.String?
        /// <p>When the pipeline was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The last time the pipeline was updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The name of the pipeline.</p>
        public let name: Swift.String?
        /// <p>A summary of information about the pipeline reprocessing.</p>
        public let reprocessingSummaries: [IoTAnalyticsClientTypes.ReprocessingSummary]?

        public init (
            activities: [IoTAnalyticsClientTypes.PipelineActivity]? = nil,
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            reprocessingSummaries: [IoTAnalyticsClientTypes.ReprocessingSummary]? = nil
        )
        {
            self.activities = activities
            self.arn = arn
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.name = name
            self.reprocessingSummaries = reprocessingSummaries
        }
    }

}

extension IoTAnalyticsClientTypes.PipelineActivity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addAttributes
        case channel
        case datastore
        case deviceRegistryEnrich
        case deviceShadowEnrich
        case filter
        case lambda
        case math
        case removeAttributes
        case selectAttributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addAttributes = addAttributes {
            try encodeContainer.encode(addAttributes, forKey: .addAttributes)
        }
        if let channel = channel {
            try encodeContainer.encode(channel, forKey: .channel)
        }
        if let datastore = datastore {
            try encodeContainer.encode(datastore, forKey: .datastore)
        }
        if let deviceRegistryEnrich = deviceRegistryEnrich {
            try encodeContainer.encode(deviceRegistryEnrich, forKey: .deviceRegistryEnrich)
        }
        if let deviceShadowEnrich = deviceShadowEnrich {
            try encodeContainer.encode(deviceShadowEnrich, forKey: .deviceShadowEnrich)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let lambda = lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
        if let math = math {
            try encodeContainer.encode(math, forKey: .math)
        }
        if let removeAttributes = removeAttributes {
            try encodeContainer.encode(removeAttributes, forKey: .removeAttributes)
        }
        if let selectAttributes = selectAttributes {
            try encodeContainer.encode(selectAttributes, forKey: .selectAttributes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ChannelActivity.self, forKey: .channel)
        channel = channelDecoded
        let lambdaDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.LambdaActivity.self, forKey: .lambda)
        lambda = lambdaDecoded
        let datastoreDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatastoreActivity.self, forKey: .datastore)
        datastore = datastoreDecoded
        let addAttributesDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.AddAttributesActivity.self, forKey: .addAttributes)
        addAttributes = addAttributesDecoded
        let removeAttributesDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.RemoveAttributesActivity.self, forKey: .removeAttributes)
        removeAttributes = removeAttributesDecoded
        let selectAttributesDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.SelectAttributesActivity.self, forKey: .selectAttributes)
        selectAttributes = selectAttributesDecoded
        let filterDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.FilterActivity.self, forKey: .filter)
        filter = filterDecoded
        let mathDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.MathActivity.self, forKey: .math)
        math = mathDecoded
        let deviceRegistryEnrichDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DeviceRegistryEnrichActivity.self, forKey: .deviceRegistryEnrich)
        deviceRegistryEnrich = deviceRegistryEnrichDecoded
        let deviceShadowEnrichDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DeviceShadowEnrichActivity.self, forKey: .deviceShadowEnrich)
        deviceShadowEnrich = deviceShadowEnrichDecoded
    }
}

extension IoTAnalyticsClientTypes.PipelineActivity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PipelineActivity(addAttributes: \(Swift.String(describing: addAttributes)), channel: \(Swift.String(describing: channel)), datastore: \(Swift.String(describing: datastore)), deviceRegistryEnrich: \(Swift.String(describing: deviceRegistryEnrich)), deviceShadowEnrich: \(Swift.String(describing: deviceShadowEnrich)), filter: \(Swift.String(describing: filter)), lambda: \(Swift.String(describing: lambda)), math: \(Swift.String(describing: math)), removeAttributes: \(Swift.String(describing: removeAttributes)), selectAttributes: \(Swift.String(describing: selectAttributes)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>An activity that performs a transformation on a message.</p>
    public struct PipelineActivity: Swift.Equatable {
        /// <p>Adds other attributes based on existing attributes in the message.</p>
        public let addAttributes: IoTAnalyticsClientTypes.AddAttributesActivity?
        /// <p>Determines the source of the messages to be processed.</p>
        public let channel: IoTAnalyticsClientTypes.ChannelActivity?
        /// <p>Specifies where to store the processed message data.</p>
        public let datastore: IoTAnalyticsClientTypes.DatastoreActivity?
        /// <p>Adds data from the AWS IoT device registry to your message.</p>
        public let deviceRegistryEnrich: IoTAnalyticsClientTypes.DeviceRegistryEnrichActivity?
        /// <p>Adds information from the AWS IoT Device Shadow service to a message.</p>
        public let deviceShadowEnrich: IoTAnalyticsClientTypes.DeviceShadowEnrichActivity?
        /// <p>Filters a message based on its attributes.</p>
        public let filter: IoTAnalyticsClientTypes.FilterActivity?
        /// <p>Runs a Lambda function to modify the message.</p>
        public let lambda: IoTAnalyticsClientTypes.LambdaActivity?
        /// <p>Computes an arithmetic expression using the message's attributes and adds it to the
        ///       message.</p>
        public let math: IoTAnalyticsClientTypes.MathActivity?
        /// <p>Removes attributes from a message.</p>
        public let removeAttributes: IoTAnalyticsClientTypes.RemoveAttributesActivity?
        /// <p>Creates a new message using only the specified attributes from the original message.
        ///     </p>
        public let selectAttributes: IoTAnalyticsClientTypes.SelectAttributesActivity?

        public init (
            addAttributes: IoTAnalyticsClientTypes.AddAttributesActivity? = nil,
            channel: IoTAnalyticsClientTypes.ChannelActivity? = nil,
            datastore: IoTAnalyticsClientTypes.DatastoreActivity? = nil,
            deviceRegistryEnrich: IoTAnalyticsClientTypes.DeviceRegistryEnrichActivity? = nil,
            deviceShadowEnrich: IoTAnalyticsClientTypes.DeviceShadowEnrichActivity? = nil,
            filter: IoTAnalyticsClientTypes.FilterActivity? = nil,
            lambda: IoTAnalyticsClientTypes.LambdaActivity? = nil,
            math: IoTAnalyticsClientTypes.MathActivity? = nil,
            removeAttributes: IoTAnalyticsClientTypes.RemoveAttributesActivity? = nil,
            selectAttributes: IoTAnalyticsClientTypes.SelectAttributesActivity? = nil
        )
        {
            self.addAttributes = addAttributes
            self.channel = channel
            self.datastore = datastore
            self.deviceRegistryEnrich = deviceRegistryEnrich
            self.deviceShadowEnrich = deviceShadowEnrich
            self.filter = filter
            self.lambda = lambda
            self.math = math
            self.removeAttributes = removeAttributes
            self.selectAttributes = selectAttributes
        }
    }

}

extension IoTAnalyticsClientTypes.PipelineSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case lastUpdateTime
        case pipelineName
        case reprocessingSummaries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let reprocessingSummaries = reprocessingSummaries {
            var reprocessingSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reprocessingSummaries)
            for reprocessingsummaries0 in reprocessingSummaries {
                try reprocessingSummariesContainer.encode(reprocessingsummaries0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let reprocessingSummariesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.ReprocessingSummary?].self, forKey: .reprocessingSummaries)
        var reprocessingSummariesDecoded0:[IoTAnalyticsClientTypes.ReprocessingSummary]? = nil
        if let reprocessingSummariesContainer = reprocessingSummariesContainer {
            reprocessingSummariesDecoded0 = [IoTAnalyticsClientTypes.ReprocessingSummary]()
            for structure0 in reprocessingSummariesContainer {
                if let structure0 = structure0 {
                    reprocessingSummariesDecoded0?.append(structure0)
                }
            }
        }
        reprocessingSummaries = reprocessingSummariesDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension IoTAnalyticsClientTypes.PipelineSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PipelineSummary(creationTime: \(Swift.String(describing: creationTime)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), pipelineName: \(Swift.String(describing: pipelineName)), reprocessingSummaries: \(Swift.String(describing: reprocessingSummaries)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>A summary of information about a pipeline.</p>
    public struct PipelineSummary: Swift.Equatable {
        /// <p>When the pipeline was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>When the pipeline was last updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The name of the pipeline.</p>
        public let pipelineName: Swift.String?
        /// <p>A summary of information about the pipeline reprocessing.</p>
        public let reprocessingSummaries: [IoTAnalyticsClientTypes.ReprocessingSummary]?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            pipelineName: Swift.String? = nil,
            reprocessingSummaries: [IoTAnalyticsClientTypes.ReprocessingSummary]? = nil
        )
        {
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.pipelineName = pipelineName
            self.reprocessingSummaries = reprocessingSummaries
        }
    }

}

public struct PutLoggingOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLoggingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLoggingOptionsOutputError>
}

extension PutLoggingOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLoggingOptionsInput(loggingOptions: \(Swift.String(describing: loggingOptions)))"}
}

extension PutLoggingOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingOptions = loggingOptions {
            try encodeContainer.encode(loggingOptions, forKey: .loggingOptions)
        }
    }
}

public struct PutLoggingOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLoggingOptionsOutputError>
}

public struct PutLoggingOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLoggingOptionsOutputError>
}

public struct PutLoggingOptionsInput: Swift.Equatable {
    /// <p>The new values of the AWS IoT Analytics logging options.</p>
    public let loggingOptions: IoTAnalyticsClientTypes.LoggingOptions?

    public init (
        loggingOptions: IoTAnalyticsClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct PutLoggingOptionsInputBody: Swift.Equatable {
    public let loggingOptions: IoTAnalyticsClientTypes.LoggingOptions?
}

extension PutLoggingOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension PutLoggingOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLoggingOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLoggingOptionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLoggingOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLoggingOptionsOutputResponse()"}
}

extension PutLoggingOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutLoggingOptionsOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutLoggingOptionsOutputResponseBody: Swift.Equatable {
}

extension PutLoggingOptionsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IoTAnalyticsClientTypes.QueryFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deltaTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deltaTime = deltaTime {
            try encodeContainer.encode(deltaTime, forKey: .deltaTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deltaTimeDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DeltaTime.self, forKey: .deltaTime)
        deltaTime = deltaTimeDecoded
    }
}

extension IoTAnalyticsClientTypes.QueryFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryFilter(deltaTime: \(Swift.String(describing: deltaTime)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Information that is used to filter message data, to segregate it according to the
    ///       timeframe in which it arrives.</p>
    public struct QueryFilter: Swift.Equatable {
        /// <p>Used to limit data to that which has arrived since the last execution of the
        ///       action.</p>
        public let deltaTime: IoTAnalyticsClientTypes.DeltaTime?

        public init (
            deltaTime: IoTAnalyticsClientTypes.DeltaTime? = nil
        )
        {
            self.deltaTime = deltaTime
        }
    }

}

extension IoTAnalyticsClientTypes.RemoveAttributesActivity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case name
        case next
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributenames0 in attributes {
                try attributesContainer.encode(attributenames0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributes)
        var attributesDecoded0:[Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String]()
            for string0 in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?.append(string0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .next)
        next = nextDecoded
    }
}

extension IoTAnalyticsClientTypes.RemoveAttributesActivity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveAttributesActivity(attributes: \(Swift.String(describing: attributes)), name: \(Swift.String(describing: name)), next: \(Swift.String(describing: next)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>An activity that removes attributes from a message.</p>
    public struct RemoveAttributesActivity: Swift.Equatable {
        /// <p>A list of 1-50 attributes to remove from the message.</p>
        public let attributes: [Swift.String]?
        /// <p>The name of the <code>removeAttributes</code> activity.</p>
        public let name: Swift.String?
        /// <p>The next activity in the pipeline.</p>
        public let next: Swift.String?

        public init (
            attributes: [Swift.String]? = nil,
            name: Swift.String? = nil,
            next: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.name = name
            self.next = next
        }
    }

}

extension IoTAnalyticsClientTypes {
    public enum ReprocessingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ReprocessingStatus] {
            return [
                .cancelled,
                .failed,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReprocessingStatus(rawValue: rawValue) ?? ReprocessingStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTAnalyticsClientTypes.ReprocessingSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case id
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ReprocessingStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension IoTAnalyticsClientTypes.ReprocessingSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReprocessingSummary(creationTime: \(Swift.String(describing: creationTime)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Information about pipeline reprocessing.</p>
    public struct ReprocessingSummary: Swift.Equatable {
        /// <p>The time the pipeline reprocessing was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The <code>reprocessingId</code> returned by <code>StartPipelineReprocessing</code>.</p>
        public let id: Swift.String?
        /// <p>The status of the pipeline reprocessing.</p>
        public let status: IoTAnalyticsClientTypes.ReprocessingStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            status: IoTAnalyticsClientTypes.ReprocessingStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.id = id
            self.status = status
        }
    }

}

extension ResourceAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAlreadyExistsException(message: \(Swift.String(describing: message)), resourceArn: \(Swift.String(describing: resourceArn)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource with the same name already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// <p>The ARN of the resource.</p>
    public var resourceArn: Swift.String?
    /// <p>The ID of the resource.</p>
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceArn: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceArn
        case resourceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension IoTAnalyticsClientTypes.ResourceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeType
        case volumeSizeInGB
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeType = computeType {
            try encodeContainer.encode(computeType.rawValue, forKey: .computeType)
        }
        if volumeSizeInGB != 0 {
            try encodeContainer.encode(volumeSizeInGB, forKey: .volumeSizeInGB)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computeTypeDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let volumeSizeInGBDecoded = try containerValues.decode(Swift.Int.self, forKey: .volumeSizeInGB)
        volumeSizeInGB = volumeSizeInGBDecoded
    }
}

extension IoTAnalyticsClientTypes.ResourceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceConfiguration(computeType: \(Swift.String(describing: computeType)), volumeSizeInGB: \(Swift.String(describing: volumeSizeInGB)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>The configuration of the resource used to execute the <code>containerAction</code>.</p>
    public struct ResourceConfiguration: Swift.Equatable {
        /// <p>The type of the compute resource used to execute the <code>containerAction</code>.
        ///       Possible values are: <code>ACU_1</code> (vCPU=4, memory=16 GiB) or <code>ACU_2</code> (vCPU=8,
        ///       memory=32 GiB).</p>
        public let computeType: IoTAnalyticsClientTypes.ComputeType?
        /// <p>The size, in GB, of the persistent storage available to the resource instance used to
        ///       execute the <code>containerAction</code> (min: 1, max: 50).</p>
        public let volumeSizeInGB: Swift.Int

        public init (
            computeType: IoTAnalyticsClientTypes.ComputeType? = nil,
            volumeSizeInGB: Swift.Int = 0
        )
        {
            self.computeType = computeType
            self.volumeSizeInGB = volumeSizeInGB
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource with the specified name could not be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTAnalyticsClientTypes.RetentionPeriod: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfDays
        case unlimited
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberOfDays = numberOfDays {
            try encodeContainer.encode(numberOfDays, forKey: .numberOfDays)
        }
        if unlimited != false {
            try encodeContainer.encode(unlimited, forKey: .unlimited)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unlimitedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .unlimited)
        unlimited = unlimitedDecoded
        let numberOfDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDays)
        numberOfDays = numberOfDaysDecoded
    }
}

extension IoTAnalyticsClientTypes.RetentionPeriod: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetentionPeriod(numberOfDays: \(Swift.String(describing: numberOfDays)), unlimited: \(Swift.String(describing: unlimited)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>How long, in days, message data is kept.</p>
    public struct RetentionPeriod: Swift.Equatable {
        /// <p>The number of days that message data is kept. The <code>unlimited</code> parameter must be
        ///       false.</p>
        public let numberOfDays: Swift.Int?
        /// <p>If true, message data is kept indefinitely.</p>
        public let unlimited: Swift.Bool

        public init (
            numberOfDays: Swift.Int? = nil,
            unlimited: Swift.Bool = false
        )
        {
            self.numberOfDays = numberOfDays
            self.unlimited = unlimited
        }
    }

}

public struct RunPipelineActivityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RunPipelineActivityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RunPipelineActivityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RunPipelineActivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RunPipelineActivityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RunPipelineActivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RunPipelineActivityOutputError>
}

extension RunPipelineActivityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RunPipelineActivityInput(payloads: \(Swift.String(describing: payloads)), pipelineActivity: \(Swift.String(describing: pipelineActivity)))"}
}

extension RunPipelineActivityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloads
        case pipelineActivity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payloads = payloads {
            var payloadsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .payloads)
            for messagepayloads0 in payloads {
                try payloadsContainer.encode(messagepayloads0.base64EncodedString())
            }
        }
        if let pipelineActivity = pipelineActivity {
            try encodeContainer.encode(pipelineActivity, forKey: .pipelineActivity)
        }
    }
}

public struct RunPipelineActivityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RunPipelineActivityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RunPipelineActivityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RunPipelineActivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RunPipelineActivityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RunPipelineActivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RunPipelineActivityOutputError>
}

public struct RunPipelineActivityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RunPipelineActivityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RunPipelineActivityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RunPipelineActivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RunPipelineActivityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RunPipelineActivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RunPipelineActivityOutputError>
}

public struct RunPipelineActivityInput: Swift.Equatable {
    /// <p>The sample message payloads on which the pipeline activity is run.</p>
    public let payloads: [ClientRuntime.Data]?
    /// <p>The pipeline activity that is run. This must not be a channel activity or a datastore
    ///       activity because these activities are used in a pipeline only to load the original message and
    ///       to store the (possibly) transformed message. If a lambda activity is specified, only
    ///       short-running Lambda functions (those with a timeout of less than 30 seconds or less) can be
    ///       used.</p>
    public let pipelineActivity: IoTAnalyticsClientTypes.PipelineActivity?

    public init (
        payloads: [ClientRuntime.Data]? = nil,
        pipelineActivity: IoTAnalyticsClientTypes.PipelineActivity? = nil
    )
    {
        self.payloads = payloads
        self.pipelineActivity = pipelineActivity
    }
}

struct RunPipelineActivityInputBody: Swift.Equatable {
    public let pipelineActivity: IoTAnalyticsClientTypes.PipelineActivity?
    public let payloads: [ClientRuntime.Data]?
}

extension RunPipelineActivityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloads
        case pipelineActivity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineActivityDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.PipelineActivity.self, forKey: .pipelineActivity)
        pipelineActivity = pipelineActivityDecoded
        let payloadsContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .payloads)
        var payloadsDecoded0:[ClientRuntime.Data]? = nil
        if let payloadsContainer = payloadsContainer {
            payloadsDecoded0 = [ClientRuntime.Data]()
            for blob0 in payloadsContainer {
                if let blob0 = blob0 {
                    payloadsDecoded0?.append(blob0)
                }
            }
        }
        payloads = payloadsDecoded0
    }
}

extension RunPipelineActivityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RunPipelineActivityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RunPipelineActivityOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RunPipelineActivityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RunPipelineActivityOutputResponse(logResult: \(Swift.String(describing: logResult)), payloads: \(Swift.String(describing: payloads)))"}
}

extension RunPipelineActivityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RunPipelineActivityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logResult = output.logResult
            self.payloads = output.payloads
        } else {
            self.logResult = nil
            self.payloads = nil
        }
    }
}

public struct RunPipelineActivityOutputResponse: Swift.Equatable {
    /// <p>In case the pipeline activity fails, the log message that is generated.</p>
    public let logResult: Swift.String?
    /// <p>The enriched or transformed sample message payloads as base64-encoded strings. (The
    ///       results of running the pipeline activity on each input sample message payload, encoded in
    ///       base64.)</p>
    public let payloads: [ClientRuntime.Data]?

    public init (
        logResult: Swift.String? = nil,
        payloads: [ClientRuntime.Data]? = nil
    )
    {
        self.logResult = logResult
        self.payloads = payloads
    }
}

struct RunPipelineActivityOutputResponseBody: Swift.Equatable {
    public let payloads: [ClientRuntime.Data]?
    public let logResult: Swift.String?
}

extension RunPipelineActivityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logResult
        case payloads
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadsContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .payloads)
        var payloadsDecoded0:[ClientRuntime.Data]? = nil
        if let payloadsContainer = payloadsContainer {
            payloadsDecoded0 = [ClientRuntime.Data]()
            for blob0 in payloadsContainer {
                if let blob0 = blob0 {
                    payloadsDecoded0?.append(blob0)
                }
            }
        }
        payloads = payloadsDecoded0
        let logResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logResult)
        logResult = logResultDecoded
    }
}

extension IoTAnalyticsClientTypes.S3DestinationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case glueConfiguration
        case key
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let glueConfiguration = glueConfiguration {
            try encodeContainer.encode(glueConfiguration, forKey: .glueConfiguration)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let glueConfigurationDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.GlueConfiguration.self, forKey: .glueConfiguration)
        glueConfiguration = glueConfigurationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTAnalyticsClientTypes.S3DestinationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3DestinationConfiguration(bucket: \(Swift.String(describing: bucket)), glueConfiguration: \(Swift.String(describing: glueConfiguration)), key: \(Swift.String(describing: key)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Configuration information for delivery of dataset contents to Amazon Simple Storage
    ///       Service (Amazon S3).</p>
    public struct S3DestinationConfiguration: Swift.Equatable {
        /// <p>The name of the S3 bucket to which dataset contents are delivered.</p>
        public let bucket: Swift.String?
        /// <p>Configuration information for coordination with AWS Glue, a fully managed extract,
        ///       transform and load (ETL) service.</p>
        public let glueConfiguration: IoTAnalyticsClientTypes.GlueConfiguration?
        /// <p>The key of the dataset contents object in an S3 bucket. Each object has a key that is a
        ///       unique identifier. Each object has exactly one key.</p>
        ///          <p>You can create a unique key with the following options:</p>
        ///          <ul>
        ///             <li>
        ///                <p>Use <code>!{iotanalytics:scheduleTime}</code> to insert the time of a scheduled SQL
        ///           query run.</p>
        ///             </li>
        ///             <li>
        ///                <p>Use <code>!{iotanalytics:versionId}</code> to insert a unique hash that identifies a
        ///           dataset content.</p>
        ///             </li>
        ///             <li>
        ///                <p>Use <code>!{iotanalytics:creationTime}</code> to insert the creation time of a dataset
        ///           content.</p>
        ///             </li>
        ///          </ul>
        ///          <p>The following example creates a unique key for a CSV file:
        ///         <code>dataset/mydataset/!{iotanalytics:scheduleTime}/!{iotanalytics:versionId}.csv</code>
        ///          </p>
        ///          <note>
        ///             <p>If you don't use <code>!{iotanalytics:versionId}</code> to specify the key, you might
        ///         get duplicate keys. For example, you might have two dataset contents with the same
        ///           <code>scheduleTime</code> but different <code>versionId</code>s. This means that one
        ///         dataset content overwrites the other. </p>
        ///          </note>
        public let key: Swift.String?
        /// <p>The ARN of the role that grants AWS IoT Analytics permission to interact with your Amazon
        ///       S3 and AWS Glue resources.</p>
        public let roleArn: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            glueConfiguration: IoTAnalyticsClientTypes.GlueConfiguration? = nil,
            key: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.glueConfiguration = glueConfiguration
            self.key = key
            self.roleArn = roleArn
        }
    }

}

extension SampleChannelDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SampleChannelDataInput(channelName: \(Swift.String(describing: channelName)), endTime: \(Swift.String(describing: endTime)), maxMessages: \(Swift.String(describing: maxMessages)), startTime: \(Swift.String(describing: startTime)))"}
}

extension SampleChannelDataInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct SampleChannelDataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SampleChannelDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SampleChannelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SampleChannelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SampleChannelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SampleChannelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SampleChannelDataOutputError>
}

public struct SampleChannelDataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SampleChannelDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SampleChannelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SampleChannelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxMessages = input.operationInput.maxMessages {
            let maxMessagesQueryItem = ClientRuntime.URLQueryItem(name: "maxMessages".urlPercentEncoding(), value: Swift.String(maxMessages).urlPercentEncoding())
            input.builder.withQueryItem(maxMessagesQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SampleChannelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SampleChannelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SampleChannelDataOutputError>
}

public struct SampleChannelDataInput: Swift.Equatable {
    /// <p>The name of the channel whose message samples are retrieved.</p>
    public let channelName: Swift.String?
    /// <p>The end of the time window from which sample messages are retrieved.</p>
    public let endTime: ClientRuntime.Date?
    /// <p>The number of sample messages to be retrieved. The limit is 10. The default is also
    ///       10.</p>
    public let maxMessages: Swift.Int?
    /// <p>The start of the time window from which sample messages are retrieved.</p>
    public let startTime: ClientRuntime.Date?

    public init (
        channelName: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        maxMessages: Swift.Int? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.channelName = channelName
        self.endTime = endTime
        self.maxMessages = maxMessages
        self.startTime = startTime
    }
}

struct SampleChannelDataInputBody: Swift.Equatable {
}

extension SampleChannelDataInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SampleChannelDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SampleChannelDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SampleChannelDataOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SampleChannelDataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SampleChannelDataOutputResponse(payloads: \(Swift.String(describing: payloads)))"}
}

extension SampleChannelDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SampleChannelDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.payloads = output.payloads
        } else {
            self.payloads = nil
        }
    }
}

public struct SampleChannelDataOutputResponse: Swift.Equatable {
    /// <p>The list of message samples. Each sample message is returned as a base64-encoded
    ///       string.</p>
    public let payloads: [ClientRuntime.Data]?

    public init (
        payloads: [ClientRuntime.Data]? = nil
    )
    {
        self.payloads = payloads
    }
}

struct SampleChannelDataOutputResponseBody: Swift.Equatable {
    public let payloads: [ClientRuntime.Data]?
}

extension SampleChannelDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloads
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadsContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .payloads)
        var payloadsDecoded0:[ClientRuntime.Data]? = nil
        if let payloadsContainer = payloadsContainer {
            payloadsDecoded0 = [ClientRuntime.Data]()
            for blob0 in payloadsContainer {
                if let blob0 = blob0 {
                    payloadsDecoded0?.append(blob0)
                }
            }
        }
        payloads = payloadsDecoded0
    }
}

extension IoTAnalyticsClientTypes.Schedule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension IoTAnalyticsClientTypes.Schedule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Schedule(expression: \(Swift.String(describing: expression)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>The schedule for when to trigger an update.</p>
    public struct Schedule: Swift.Equatable {
        /// <p>The expression that defines when to trigger an update. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html">Schedule
        ///         Expressions for Rules</a> in the <i>Amazon CloudWatch Events User
        ///         Guide</i>.</p>
        public let expression: Swift.String?

        public init (
            expression: Swift.String? = nil
        )
        {
            self.expression = expression
        }
    }

}

extension IoTAnalyticsClientTypes.SchemaDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for columns0 in columns {
                try columnsContainer.encode(columns0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnsContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.Column?].self, forKey: .columns)
        var columnsDecoded0:[IoTAnalyticsClientTypes.Column]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [IoTAnalyticsClientTypes.Column]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
    }
}

extension IoTAnalyticsClientTypes.SchemaDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SchemaDefinition(columns: \(Swift.String(describing: columns)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Information needed to define a schema.</p>
    public struct SchemaDefinition: Swift.Equatable {
        /// <p>Specifies one or more columns that store your data.</p>
        ///          <p>Each schema can have up to 100 columns. Each column can have up to 100 nested types</p>
        public let columns: [IoTAnalyticsClientTypes.Column]?

        public init (
            columns: [IoTAnalyticsClientTypes.Column]? = nil
        )
        {
            self.columns = columns
        }
    }

}

extension IoTAnalyticsClientTypes.SelectAttributesActivity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case name
        case next
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributenames0 in attributes {
                try attributesContainer.encode(attributenames0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributes)
        var attributesDecoded0:[Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String]()
            for string0 in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?.append(string0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .next)
        next = nextDecoded
    }
}

extension IoTAnalyticsClientTypes.SelectAttributesActivity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SelectAttributesActivity(attributes: \(Swift.String(describing: attributes)), name: \(Swift.String(describing: name)), next: \(Swift.String(describing: next)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Creates a new message using only the specified attributes from the original
    ///       message.</p>
    public struct SelectAttributesActivity: Swift.Equatable {
        /// <p>A list of the attributes to select from the message.</p>
        public let attributes: [Swift.String]?
        /// <p>The name of the <code>selectAttributes</code> activity.</p>
        public let name: Swift.String?
        /// <p>The next activity in the pipeline.</p>
        public let next: Swift.String?

        public init (
            attributes: [Swift.String]? = nil,
            name: Swift.String? = nil,
            next: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.name = name
            self.next = next
        }
    }

}

extension IoTAnalyticsClientTypes.ServiceManagedChannelS3Storage: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IoTAnalyticsClientTypes.ServiceManagedChannelS3Storage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceManagedChannelS3Storage()"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Use this to store channel data in an S3 bucket managed by AWS IoT Analytics. You cannot
    ///       change the choice of service-managed or customer-managed S3 storage after the channel is
    ///       created.</p>
    public struct ServiceManagedChannelS3Storage: Swift.Equatable {

        public init() {}
    }

}

extension IoTAnalyticsClientTypes.ServiceManagedChannelS3StorageSummary: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IoTAnalyticsClientTypes.ServiceManagedChannelS3StorageSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceManagedChannelS3StorageSummary()"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Used to store channel data in an S3 bucket managed by AWS IoT Analytics.</p>
    public struct ServiceManagedChannelS3StorageSummary: Swift.Equatable {

        public init() {}
    }

}

extension IoTAnalyticsClientTypes.ServiceManagedDatastoreS3Storage: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IoTAnalyticsClientTypes.ServiceManagedDatastoreS3Storage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceManagedDatastoreS3Storage()"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Use this to store data store data in an S3 bucket managed by AWS IoT Analytics. You cannot
    ///       change the choice of service-managed or customer-managed S3 storage after the data store is
    ///       created.</p>
    public struct ServiceManagedDatastoreS3Storage: Swift.Equatable {

        public init() {}
    }

}

extension IoTAnalyticsClientTypes.ServiceManagedDatastoreS3StorageSummary: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IoTAnalyticsClientTypes.ServiceManagedDatastoreS3StorageSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceManagedDatastoreS3StorageSummary()"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Used to store data store data in an S3 bucket managed by AWS IoT Analytics.</p>
    public struct ServiceManagedDatastoreS3StorageSummary: Swift.Equatable {

        public init() {}
    }

}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is temporarily unavailable.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTAnalyticsClientTypes.SqlQueryDatasetAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case sqlQuery
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for queryfilters0 in filters {
                try filtersContainer.encode(queryfilters0)
            }
        }
        if let sqlQuery = sqlQuery {
            try encodeContainer.encode(sqlQuery, forKey: .sqlQuery)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlQueryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sqlQuery)
        sqlQuery = sqlQueryDecoded
        let filtersContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.QueryFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTAnalyticsClientTypes.QueryFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTAnalyticsClientTypes.QueryFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension IoTAnalyticsClientTypes.SqlQueryDatasetAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SqlQueryDatasetAction(filters: \(Swift.String(describing: filters)), sqlQuery: \(Swift.String(describing: sqlQuery)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>The SQL query to modify the message.</p>
    public struct SqlQueryDatasetAction: Swift.Equatable {
        /// <p>Prefilters applied to message data.</p>
        public let filters: [IoTAnalyticsClientTypes.QueryFilter]?
        /// <p>A SQL query string.</p>
        public let sqlQuery: Swift.String?

        public init (
            filters: [IoTAnalyticsClientTypes.QueryFilter]? = nil,
            sqlQuery: Swift.String? = nil
        )
        {
            self.filters = filters
            self.sqlQuery = sqlQuery
        }
    }

}

public struct StartPipelineReprocessingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartPipelineReprocessingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartPipelineReprocessingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartPipelineReprocessingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartPipelineReprocessingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartPipelineReprocessingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartPipelineReprocessingOutputError>
}

extension StartPipelineReprocessingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartPipelineReprocessingInput(channelMessages: \(Swift.String(describing: channelMessages)), endTime: \(Swift.String(describing: endTime)), pipelineName: \(Swift.String(describing: pipelineName)), startTime: \(Swift.String(describing: startTime)))"}
}

extension StartPipelineReprocessingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMessages
        case endTime
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelMessages = channelMessages {
            try encodeContainer.encode(channelMessages, forKey: .channelMessages)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct StartPipelineReprocessingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartPipelineReprocessingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartPipelineReprocessingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartPipelineReprocessingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartPipelineReprocessingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartPipelineReprocessingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartPipelineReprocessingOutputError>
}

public struct StartPipelineReprocessingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartPipelineReprocessingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartPipelineReprocessingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartPipelineReprocessingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartPipelineReprocessingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartPipelineReprocessingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartPipelineReprocessingOutputError>
}

public struct StartPipelineReprocessingInput: Swift.Equatable {
    /// <p>Specifies one or more sets of channel messages that you want to reprocess.</p>
    ///          <p>If you use the <code>channelMessages</code> object, you must not specify a value for
    ///         <code>startTime</code> and <code>endTime</code>.</p>
    public let channelMessages: IoTAnalyticsClientTypes.ChannelMessages?
    /// <p>The end time (exclusive) of raw message data that is reprocessed.</p>
    ///          <p>If you specify a value for the <code>endTime</code> parameter, you must not use the
    ///         <code>channelMessages</code> object.</p>
    public let endTime: ClientRuntime.Date?
    /// <p>The name of the pipeline on which to start reprocessing.</p>
    public let pipelineName: Swift.String?
    /// <p>The start time (inclusive) of raw message data that is reprocessed.</p>
    ///          <p>If you specify a value for the <code>startTime</code> parameter, you must not use the
    ///         <code>channelMessages</code> object.</p>
    public let startTime: ClientRuntime.Date?

    public init (
        channelMessages: IoTAnalyticsClientTypes.ChannelMessages? = nil,
        endTime: ClientRuntime.Date? = nil,
        pipelineName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.channelMessages = channelMessages
        self.endTime = endTime
        self.pipelineName = pipelineName
        self.startTime = startTime
    }
}

struct StartPipelineReprocessingInputBody: Swift.Equatable {
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
    public let channelMessages: IoTAnalyticsClientTypes.ChannelMessages?
}

extension StartPipelineReprocessingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMessages
        case endTime
        case startTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let channelMessagesDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ChannelMessages.self, forKey: .channelMessages)
        channelMessages = channelMessagesDecoded
    }
}

extension StartPipelineReprocessingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartPipelineReprocessingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartPipelineReprocessingOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartPipelineReprocessingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartPipelineReprocessingOutputResponse(reprocessingId: \(Swift.String(describing: reprocessingId)))"}
}

extension StartPipelineReprocessingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartPipelineReprocessingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reprocessingId = output.reprocessingId
        } else {
            self.reprocessingId = nil
        }
    }
}

public struct StartPipelineReprocessingOutputResponse: Swift.Equatable {
    /// <p>The ID of the pipeline reprocessing activity that was started.</p>
    public let reprocessingId: Swift.String?

    public init (
        reprocessingId: Swift.String? = nil
    )
    {
        self.reprocessingId = reprocessingId
    }
}

struct StartPipelineReprocessingOutputResponseBody: Swift.Equatable {
    public let reprocessingId: Swift.String?
}

extension StartPipelineReprocessingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reprocessingId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reprocessingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reprocessingId)
        reprocessingId = reprocessingIdDecoded
    }
}

extension IoTAnalyticsClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTAnalyticsClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>A set of key-value pairs that are used to manage the resource.</p>
    public struct Tag: Swift.Equatable {
        /// <p>The tag's key.</p>
        public let key: Swift.String?
        /// <p>The tag's value.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The ARN of the resource whose tags you want to modify.</p>
    public let resourceArn: Swift.String?
    /// <p>The new or modified tags for the resource.</p>
    public let tags: [IoTAnalyticsClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [IoTAnalyticsClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [IoTAnalyticsClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTAnalyticsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTAnalyticsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTAnalyticsClientTypes.TriggeringDataset: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IoTAnalyticsClientTypes.TriggeringDataset: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TriggeringDataset(name: \(Swift.String(describing: name)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Information about the dataset whose content generation triggers the new dataset content
    ///       generation.</p>
    public struct TriggeringDataset: Swift.Equatable {
        /// <p>The name of the dataset whose content generation triggers the new dataset content
        ///       generation.</p>
        public let name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The ARN of the resource whose tags you want to remove.</p>
    public let resourceArn: Swift.String?
    /// <p>The keys of those tags which you want to remove.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

extension UpdateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelInput(channelName: \(Swift.String(describing: channelName)), channelStorage: \(Swift.String(describing: channelStorage)), retentionPeriod: \(Swift.String(describing: retentionPeriod)))"}
}

extension UpdateChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelStorage
        case retentionPeriod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelStorage = channelStorage {
            try encodeContainer.encode(channelStorage, forKey: .channelStorage)
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
    }
}

public struct UpdateChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInput: Swift.Equatable {
    /// <p>The name of the channel to be updated.</p>
    public let channelName: Swift.String?
    /// <p>Where channel data is stored. You can choose one of <code>serviceManagedS3</code> or
    ///         <code>customerManagedS3</code> storage. If not specified, the default is
    ///         <code>serviceManagedS3</code>. You cannot change this storage option after the channel is
    ///       created.</p>
    public let channelStorage: IoTAnalyticsClientTypes.ChannelStorage?
    /// <p>How long, in days, message data is kept for the channel. The retention period cannot be
    ///       updated if the channel's S3 storage is customer-managed.</p>
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?

    public init (
        channelName: Swift.String? = nil,
        channelStorage: IoTAnalyticsClientTypes.ChannelStorage? = nil,
        retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod? = nil
    )
    {
        self.channelName = channelName
        self.channelStorage = channelStorage
        self.retentionPeriod = retentionPeriod
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    public let channelStorage: IoTAnalyticsClientTypes.ChannelStorage?
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelStorage
        case retentionPeriod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelStorageDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.ChannelStorage.self, forKey: .channelStorage)
        channelStorage = channelStorageDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
    }
}

extension UpdateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelOutputResponse()"}
}

extension UpdateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateChannelOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateChannelOutputResponseBody: Swift.Equatable {
}

extension UpdateChannelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDatasetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatasetOutputError>
}

extension UpdateDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDatasetInput(actions: \(Swift.String(describing: actions)), contentDeliveryRules: \(Swift.String(describing: contentDeliveryRules)), datasetName: \(Swift.String(describing: datasetName)), lateDataRules: \(Swift.String(describing: lateDataRules)), retentionPeriod: \(Swift.String(describing: retentionPeriod)), triggers: \(Swift.String(describing: triggers)), versioningConfiguration: \(Swift.String(describing: versioningConfiguration)))"}
}

extension UpdateDatasetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case contentDeliveryRules
        case lateDataRules
        case retentionPeriod
        case triggers
        case versioningConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for datasetactions0 in actions {
                try actionsContainer.encode(datasetactions0)
            }
        }
        if let contentDeliveryRules = contentDeliveryRules {
            var contentDeliveryRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contentDeliveryRules)
            for datasetcontentdeliveryrules0 in contentDeliveryRules {
                try contentDeliveryRulesContainer.encode(datasetcontentdeliveryrules0)
            }
        }
        if let lateDataRules = lateDataRules {
            var lateDataRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lateDataRules)
            for latedatarules0 in lateDataRules {
                try lateDataRulesContainer.encode(latedatarules0)
            }
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let triggers = triggers {
            var triggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .triggers)
            for datasettriggers0 in triggers {
                try triggersContainer.encode(datasettriggers0)
            }
        }
        if let versioningConfiguration = versioningConfiguration {
            try encodeContainer.encode(versioningConfiguration, forKey: .versioningConfiguration)
        }
    }
}

public struct UpdateDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatasetOutputError>
}

public struct UpdateDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatasetOutputError>
}

public struct UpdateDatasetInput: Swift.Equatable {
    /// <p>A list of <code>DatasetAction</code> objects.</p>
    public let actions: [IoTAnalyticsClientTypes.DatasetAction]?
    /// <p>When dataset contents are created, they are delivered to destinations specified
    ///       here.</p>
    public let contentDeliveryRules: [IoTAnalyticsClientTypes.DatasetContentDeliveryRule]?
    /// <p>The name of the data set to update.</p>
    public let datasetName: Swift.String?
    /// <p>A list of data rules that send notifications to Amazon CloudWatch, when data arrives late. To
    ///   specify <code>lateDataRules</code>, the dataset must use a <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">DeltaTimer</a>
    ///   filter.</p>
    public let lateDataRules: [IoTAnalyticsClientTypes.LateDataRule]?
    /// <p>How long, in days, dataset contents are kept for the dataset.</p>
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
    /// <p>A list of <code>DatasetTrigger</code> objects. The list can be empty or can contain up to
    ///       five <code>DatasetTrigger</code> objects.</p>
    public let triggers: [IoTAnalyticsClientTypes.DatasetTrigger]?
    /// <p>Optional. How many versions of dataset contents are kept. If not specified or set to null,
    ///       only the latest version plus the latest succeeded version (if they are different) are kept for
    ///       the time period specified by the <code>retentionPeriod</code> parameter. For more information,
    ///       see <a href="https://docs.aws.amazon.com/iotanalytics/latest/userguide/getting-started.html#aws-iot-analytics-dataset-versions">Keeping Multiple Versions of AWS IoT Analytics Data Sets</a> in the <i>AWS IoT
    ///         Analytics User Guide</i>.</p>
    public let versioningConfiguration: IoTAnalyticsClientTypes.VersioningConfiguration?

    public init (
        actions: [IoTAnalyticsClientTypes.DatasetAction]? = nil,
        contentDeliveryRules: [IoTAnalyticsClientTypes.DatasetContentDeliveryRule]? = nil,
        datasetName: Swift.String? = nil,
        lateDataRules: [IoTAnalyticsClientTypes.LateDataRule]? = nil,
        retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod? = nil,
        triggers: [IoTAnalyticsClientTypes.DatasetTrigger]? = nil,
        versioningConfiguration: IoTAnalyticsClientTypes.VersioningConfiguration? = nil
    )
    {
        self.actions = actions
        self.contentDeliveryRules = contentDeliveryRules
        self.datasetName = datasetName
        self.lateDataRules = lateDataRules
        self.retentionPeriod = retentionPeriod
        self.triggers = triggers
        self.versioningConfiguration = versioningConfiguration
    }
}

struct UpdateDatasetInputBody: Swift.Equatable {
    public let actions: [IoTAnalyticsClientTypes.DatasetAction]?
    public let triggers: [IoTAnalyticsClientTypes.DatasetTrigger]?
    public let contentDeliveryRules: [IoTAnalyticsClientTypes.DatasetContentDeliveryRule]?
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
    public let versioningConfiguration: IoTAnalyticsClientTypes.VersioningConfiguration?
    public let lateDataRules: [IoTAnalyticsClientTypes.LateDataRule]?
}

extension UpdateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case contentDeliveryRules
        case lateDataRules
        case retentionPeriod
        case triggers
        case versioningConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.DatasetAction?].self, forKey: .actions)
        var actionsDecoded0:[IoTAnalyticsClientTypes.DatasetAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [IoTAnalyticsClientTypes.DatasetAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let triggersContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.DatasetTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[IoTAnalyticsClientTypes.DatasetTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [IoTAnalyticsClientTypes.DatasetTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
        let contentDeliveryRulesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.DatasetContentDeliveryRule?].self, forKey: .contentDeliveryRules)
        var contentDeliveryRulesDecoded0:[IoTAnalyticsClientTypes.DatasetContentDeliveryRule]? = nil
        if let contentDeliveryRulesContainer = contentDeliveryRulesContainer {
            contentDeliveryRulesDecoded0 = [IoTAnalyticsClientTypes.DatasetContentDeliveryRule]()
            for structure0 in contentDeliveryRulesContainer {
                if let structure0 = structure0 {
                    contentDeliveryRulesDecoded0?.append(structure0)
                }
            }
        }
        contentDeliveryRules = contentDeliveryRulesDecoded0
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let versioningConfigurationDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.VersioningConfiguration.self, forKey: .versioningConfiguration)
        versioningConfiguration = versioningConfigurationDecoded
        let lateDataRulesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.LateDataRule?].self, forKey: .lateDataRules)
        var lateDataRulesDecoded0:[IoTAnalyticsClientTypes.LateDataRule]? = nil
        if let lateDataRulesContainer = lateDataRulesContainer {
            lateDataRulesDecoded0 = [IoTAnalyticsClientTypes.LateDataRule]()
            for structure0 in lateDataRulesContainer {
                if let structure0 = structure0 {
                    lateDataRulesDecoded0?.append(structure0)
                }
            }
        }
        lateDataRules = lateDataRulesDecoded0
    }
}

extension UpdateDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDatasetOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDatasetOutputResponse()"}
}

extension UpdateDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDatasetOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateDatasetOutputResponseBody: Swift.Equatable {
}

extension UpdateDatasetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDatastoreInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatastoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatastoreOutputError>
}

extension UpdateDatastoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDatastoreInput(datastoreName: \(Swift.String(describing: datastoreName)), datastoreStorage: \(Swift.String(describing: datastoreStorage)), fileFormatConfiguration: \(Swift.String(describing: fileFormatConfiguration)), retentionPeriod: \(Swift.String(describing: retentionPeriod)))"}
}

extension UpdateDatastoreInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreStorage
        case fileFormatConfiguration
        case retentionPeriod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreStorage = datastoreStorage {
            try encodeContainer.encode(datastoreStorage, forKey: .datastoreStorage)
        }
        if let fileFormatConfiguration = fileFormatConfiguration {
            try encodeContainer.encode(fileFormatConfiguration, forKey: .fileFormatConfiguration)
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
    }
}

public struct UpdateDatastoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatastoreOutputError>
}

public struct UpdateDatastoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatastoreOutputError>
}

public struct UpdateDatastoreInput: Swift.Equatable {
    /// <p>The name of the data store to be updated.</p>
    public let datastoreName: Swift.String?
    /// <p>Where data store data is stored. You can choose one of <code>serviceManagedS3</code> or
    ///         <code>customerManagedS3</code> storage. If not specified, the default
    ///         is<code>serviceManagedS3</code>. You cannot change this storage option after the data store
    ///       is created.</p>
    public let datastoreStorage: IoTAnalyticsClientTypes.DatastoreStorage?
    /// <p>Contains the configuration information of file formats. AWS IoT Analytics data stores support JSON
    ///       and <a href="https://parquet.apache.org/">Parquet</a>.</p>
    ///          <p>The default file format is JSON. You can specify only one format.</p>
    ///          <p>You can't change the file format after you create the data store.</p>
    public let fileFormatConfiguration: IoTAnalyticsClientTypes.FileFormatConfiguration?
    /// <p>How long, in days, message data is kept for the data store. The retention period cannot be
    ///       updated if the data store's S3 storage is customer-managed.</p>
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?

    public init (
        datastoreName: Swift.String? = nil,
        datastoreStorage: IoTAnalyticsClientTypes.DatastoreStorage? = nil,
        fileFormatConfiguration: IoTAnalyticsClientTypes.FileFormatConfiguration? = nil,
        retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod? = nil
    )
    {
        self.datastoreName = datastoreName
        self.datastoreStorage = datastoreStorage
        self.fileFormatConfiguration = fileFormatConfiguration
        self.retentionPeriod = retentionPeriod
    }
}

struct UpdateDatastoreInputBody: Swift.Equatable {
    public let retentionPeriod: IoTAnalyticsClientTypes.RetentionPeriod?
    public let datastoreStorage: IoTAnalyticsClientTypes.DatastoreStorage?
    public let fileFormatConfiguration: IoTAnalyticsClientTypes.FileFormatConfiguration?
}

extension UpdateDatastoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreStorage
        case fileFormatConfiguration
        case retentionPeriod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let datastoreStorageDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatastoreStorage.self, forKey: .datastoreStorage)
        datastoreStorage = datastoreStorageDecoded
        let fileFormatConfigurationDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.FileFormatConfiguration.self, forKey: .fileFormatConfiguration)
        fileFormatConfiguration = fileFormatConfigurationDecoded
    }
}

extension UpdateDatastoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatastoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDatastoreOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatastoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDatastoreOutputResponse()"}
}

extension UpdateDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDatastoreOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateDatastoreOutputResponseBody: Swift.Equatable {
}

extension UpdateDatastoreOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdatePipelineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePipelineOutputError>
}

extension UpdatePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePipelineInput(pipelineActivities: \(Swift.String(describing: pipelineActivities)), pipelineName: \(Swift.String(describing: pipelineName)))"}
}

extension UpdatePipelineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineActivities
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineActivities = pipelineActivities {
            var pipelineActivitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pipelineActivities)
            for pipelineactivities0 in pipelineActivities {
                try pipelineActivitiesContainer.encode(pipelineactivities0)
            }
        }
    }
}

public struct UpdatePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePipelineOutputError>
}

public struct UpdatePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePipelineOutputError>
}

public struct UpdatePipelineInput: Swift.Equatable {
    /// <p>A list of <code>PipelineActivity</code> objects. Activities perform transformations on
    ///       your messages, such as removing, renaming or adding message attributes; filtering messages
    ///       based on attribute values; invoking your Lambda functions on messages for advanced processing;
    ///       or performing mathematical transformations to normalize device data.</p>
    ///          <p>The list can be 2-25 <code>PipelineActivity</code> objects and must contain both a
    ///         <code>channel</code> and a <code>datastore</code> activity. Each entry in the list must
    ///       contain only one activity. For example:</p>
    ///          <p>
    ///             <code>pipelineActivities = [ { "channel": { ... } }, { "lambda": { ... } }, ...
    ///       ]</code>
    ///          </p>
    public let pipelineActivities: [IoTAnalyticsClientTypes.PipelineActivity]?
    /// <p>The name of the pipeline to update.</p>
    public let pipelineName: Swift.String?

    public init (
        pipelineActivities: [IoTAnalyticsClientTypes.PipelineActivity]? = nil,
        pipelineName: Swift.String? = nil
    )
    {
        self.pipelineActivities = pipelineActivities
        self.pipelineName = pipelineName
    }
}

struct UpdatePipelineInputBody: Swift.Equatable {
    public let pipelineActivities: [IoTAnalyticsClientTypes.PipelineActivity]?
}

extension UpdatePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineActivities
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineActivitiesContainer = try containerValues.decodeIfPresent([IoTAnalyticsClientTypes.PipelineActivity?].self, forKey: .pipelineActivities)
        var pipelineActivitiesDecoded0:[IoTAnalyticsClientTypes.PipelineActivity]? = nil
        if let pipelineActivitiesContainer = pipelineActivitiesContainer {
            pipelineActivitiesDecoded0 = [IoTAnalyticsClientTypes.PipelineActivity]()
            for structure0 in pipelineActivitiesContainer {
                if let structure0 = structure0 {
                    pipelineActivitiesDecoded0?.append(structure0)
                }
            }
        }
        pipelineActivities = pipelineActivitiesDecoded0
    }
}

extension UpdatePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePipelineOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePipelineOutputResponse()"}
}

extension UpdatePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePipelineOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdatePipelineOutputResponseBody: Swift.Equatable {
}

extension UpdatePipelineOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IoTAnalyticsClientTypes.Variable: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetContentVersionValue
        case doubleValue
        case name
        case outputFileUriValue
        case stringValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetContentVersionValue = datasetContentVersionValue {
            try encodeContainer.encode(datasetContentVersionValue, forKey: .datasetContentVersionValue)
        }
        if doubleValue != 0.0 {
            try encodeContainer.encode(doubleValue, forKey: .doubleValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputFileUriValue = outputFileUriValue {
            try encodeContainer.encode(outputFileUriValue, forKey: .outputFileUriValue)
        }
        if let stringValue = stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stringValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        let doubleValueDecoded = try containerValues.decode(Swift.Double.self, forKey: .doubleValue)
        doubleValue = doubleValueDecoded
        let datasetContentVersionValueDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.DatasetContentVersionValue.self, forKey: .datasetContentVersionValue)
        datasetContentVersionValue = datasetContentVersionValueDecoded
        let outputFileUriValueDecoded = try containerValues.decodeIfPresent(IoTAnalyticsClientTypes.OutputFileUriValue.self, forKey: .outputFileUriValue)
        outputFileUriValue = outputFileUriValueDecoded
    }
}

extension IoTAnalyticsClientTypes.Variable: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Variable(datasetContentVersionValue: \(Swift.String(describing: datasetContentVersionValue)), doubleValue: \(Swift.String(describing: doubleValue)), name: \(Swift.String(describing: name)), outputFileUriValue: \(Swift.String(describing: outputFileUriValue)), stringValue: \(Swift.String(describing: stringValue)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>An instance of a variable to be passed to the <code>containerAction</code> execution. Each
    ///       variable must have a name and a value given by one of <code>stringValue</code>,
    ///         <code>datasetContentVersionValue</code>, or <code>outputFileUriValue</code>.</p>
    public struct Variable: Swift.Equatable {
        /// <p>The value of the variable as a structure that specifies a dataset content version.</p>
        public let datasetContentVersionValue: IoTAnalyticsClientTypes.DatasetContentVersionValue?
        /// <p>The value of the variable as a double (numeric).</p>
        public let doubleValue: Swift.Double
        /// <p>The name of the variable.</p>
        public let name: Swift.String?
        /// <p>The value of the variable as a structure that specifies an output file URI.</p>
        public let outputFileUriValue: IoTAnalyticsClientTypes.OutputFileUriValue?
        /// <p>The value of the variable as a string.</p>
        public let stringValue: Swift.String?

        public init (
            datasetContentVersionValue: IoTAnalyticsClientTypes.DatasetContentVersionValue? = nil,
            doubleValue: Swift.Double = 0.0,
            name: Swift.String? = nil,
            outputFileUriValue: IoTAnalyticsClientTypes.OutputFileUriValue? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.datasetContentVersionValue = datasetContentVersionValue
            self.doubleValue = doubleValue
            self.name = name
            self.outputFileUriValue = outputFileUriValue
            self.stringValue = stringValue
        }
    }

}

extension IoTAnalyticsClientTypes.VersioningConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxVersions
        case unlimited
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxVersions = maxVersions {
            try encodeContainer.encode(maxVersions, forKey: .maxVersions)
        }
        if unlimited != false {
            try encodeContainer.encode(unlimited, forKey: .unlimited)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unlimitedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .unlimited)
        unlimited = unlimitedDecoded
        let maxVersionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxVersions)
        maxVersions = maxVersionsDecoded
    }
}

extension IoTAnalyticsClientTypes.VersioningConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VersioningConfiguration(maxVersions: \(Swift.String(describing: maxVersions)), unlimited: \(Swift.String(describing: unlimited)))"}
}

extension IoTAnalyticsClientTypes {
    /// <p>Information about the versioning of dataset contents.</p>
    public struct VersioningConfiguration: Swift.Equatable {
        /// <p>How many versions of dataset contents are kept. The <code>unlimited</code> parameter must
        ///       be <code>false</code>.</p>
        public let maxVersions: Swift.Int?
        /// <p>If true, unlimited versions of dataset contents are kept.</p>
        public let unlimited: Swift.Bool

        public init (
            maxVersions: Swift.Int? = nil,
            unlimited: Swift.Bool = false
        )
        {
            self.maxVersions = maxVersions
            self.unlimited = unlimited
        }
    }

}
