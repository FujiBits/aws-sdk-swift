// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension LambdaClientTypes.AccountLimit: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSizeUnzipped = "CodeSizeUnzipped"
        case codeSizeZipped = "CodeSizeZipped"
        case concurrentExecutions = "ConcurrentExecutions"
        case totalCodeSize = "TotalCodeSize"
        case unreservedConcurrentExecutions = "UnreservedConcurrentExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if codeSizeUnzipped != 0 {
            try encodeContainer.encode(codeSizeUnzipped, forKey: .codeSizeUnzipped)
        }
        if codeSizeZipped != 0 {
            try encodeContainer.encode(codeSizeZipped, forKey: .codeSizeZipped)
        }
        if concurrentExecutions != 0 {
            try encodeContainer.encode(concurrentExecutions, forKey: .concurrentExecutions)
        }
        if totalCodeSize != 0 {
            try encodeContainer.encode(totalCodeSize, forKey: .totalCodeSize)
        }
        if let unreservedConcurrentExecutions = unreservedConcurrentExecutions {
            try encodeContainer.encode(unreservedConcurrentExecutions, forKey: .unreservedConcurrentExecutions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCodeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalCodeSize)
        totalCodeSize = totalCodeSizeDecoded
        let codeSizeUnzippedDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSizeUnzipped)
        codeSizeUnzipped = codeSizeUnzippedDecoded
        let codeSizeZippedDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSizeZipped)
        codeSizeZipped = codeSizeZippedDecoded
        let concurrentExecutionsDecoded = try containerValues.decode(Swift.Int.self, forKey: .concurrentExecutions)
        concurrentExecutions = concurrentExecutionsDecoded
        let unreservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unreservedConcurrentExecutions)
        unreservedConcurrentExecutions = unreservedConcurrentExecutionsDecoded
    }
}

extension LambdaClientTypes.AccountLimit: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountLimit(codeSizeUnzipped: \(Swift.String(describing: codeSizeUnzipped)), codeSizeZipped: \(Swift.String(describing: codeSizeZipped)), concurrentExecutions: \(Swift.String(describing: concurrentExecutions)), totalCodeSize: \(Swift.String(describing: totalCodeSize)), unreservedConcurrentExecutions: \(Swift.String(describing: unreservedConcurrentExecutions)))"}
}

extension LambdaClientTypes {
    /// Limits that are related to concurrency and storage. All file and storage sizes are in bytes.
    public struct AccountLimit: Swift.Equatable {
        /// The maximum size of a function's deployment package and layers when they're extracted.
        public var codeSizeUnzipped: Swift.Int
        /// The maximum size of a deployment package when it's uploaded directly to Lambda. Use Amazon S3 for larger
        ///       files.
        public var codeSizeZipped: Swift.Int
        /// The maximum number of simultaneous function executions.
        public var concurrentExecutions: Swift.Int
        /// The amount of storage space that you can use for all deployment packages and layer archives.
        public var totalCodeSize: Swift.Int
        /// The maximum number of simultaneous function executions, minus the capacity that's reserved for individual
        ///       functions with PutFunctionConcurrency.
        public var unreservedConcurrentExecutions: Swift.Int?

        public init (
            codeSizeUnzipped: Swift.Int = 0,
            codeSizeZipped: Swift.Int = 0,
            concurrentExecutions: Swift.Int = 0,
            totalCodeSize: Swift.Int = 0,
            unreservedConcurrentExecutions: Swift.Int? = nil
        )
        {
            self.codeSizeUnzipped = codeSizeUnzipped
            self.codeSizeZipped = codeSizeZipped
            self.concurrentExecutions = concurrentExecutions
            self.totalCodeSize = totalCodeSize
            self.unreservedConcurrentExecutions = unreservedConcurrentExecutions
        }
    }

}

extension LambdaClientTypes.AccountUsage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCount = "FunctionCount"
        case totalCodeSize = "TotalCodeSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if functionCount != 0 {
            try encodeContainer.encode(functionCount, forKey: .functionCount)
        }
        if totalCodeSize != 0 {
            try encodeContainer.encode(totalCodeSize, forKey: .totalCodeSize)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCodeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalCodeSize)
        totalCodeSize = totalCodeSizeDecoded
        let functionCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .functionCount)
        functionCount = functionCountDecoded
    }
}

extension LambdaClientTypes.AccountUsage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountUsage(functionCount: \(Swift.String(describing: functionCount)), totalCodeSize: \(Swift.String(describing: totalCodeSize)))"}
}

extension LambdaClientTypes {
    /// The number of functions and amount of storage in use.
    public struct AccountUsage: Swift.Equatable {
        /// The number of Lambda functions.
        public var functionCount: Swift.Int
        /// The amount of storage space, in bytes, that's being used by deployment packages and layer archives.
        public var totalCodeSize: Swift.Int

        public init (
            functionCount: Swift.Int = 0,
            totalCodeSize: Swift.Int = 0
        )
        {
            self.functionCount = functionCount
            self.totalCodeSize = totalCodeSize
        }
    }

}

public struct AddLayerVersionPermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddLayerVersionPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddLayerVersionPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddLayerVersionPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddLayerVersionPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddLayerVersionPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddLayerVersionPermissionOutputError>
}

extension AddLayerVersionPermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddLayerVersionPermissionInput(action: \(Swift.String(describing: action)), layerName: \(Swift.String(describing: layerName)), organizationId: \(Swift.String(describing: organizationId)), principal: \(Swift.String(describing: principal)), revisionId: \(Swift.String(describing: revisionId)), statementId: \(Swift.String(describing: statementId)), versionNumber: \(Swift.String(describing: versionNumber)))"}
}

extension AddLayerVersionPermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case organizationId = "OrganizationId"
        case principal = "Principal"
        case statementId = "StatementId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

public struct AddLayerVersionPermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddLayerVersionPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddLayerVersionPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddLayerVersionPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddLayerVersionPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddLayerVersionPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddLayerVersionPermissionOutputError>
}

public struct AddLayerVersionPermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddLayerVersionPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddLayerVersionPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddLayerVersionPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let revisionId = input.operationInput.revisionId {
            let revisionIdQueryItem = ClientRuntime.URLQueryItem(name: "RevisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            input.builder.withQueryItem(revisionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddLayerVersionPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddLayerVersionPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddLayerVersionPermissionOutputError>
}

public struct AddLayerVersionPermissionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddLayerVersionPermissionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AddLayerVersionPermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddLayerVersionPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddLayerVersionPermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddLayerVersionPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddLayerVersionPermissionOutputError>
}

public struct AddLayerVersionPermissionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddLayerVersionPermissionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AddLayerVersionPermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddLayerVersionPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let layerName = input.layerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("layerName is nil and needs a value for the path of this operation"))))
        }
        let versionNumber = input.versionNumber
        var urlPath = "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)/policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddLayerVersionPermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddLayerVersionPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddLayerVersionPermissionOutputError>
}

public struct AddLayerVersionPermissionInput: Swift.Equatable {
    /// The API action that grants access to the layer. For example, lambda:GetLayerVersion.
    /// This member is required.
    public var action: Swift.String?
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// With the principal set to *, grant permission to all accounts in the specified
    ///       organization.
    public var organizationId: Swift.String?
    /// An account ID, or * to grant layer usage permission to all
    ///       accounts in an organization, or all Amazon Web Services accounts (if organizationId is not specified).
    ///       For the last case, make sure that you really do want all Amazon Web Services accounts to have usage permission to this layer.
    ///
    /// This member is required.
    public var principal: Swift.String?
    /// Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a
    ///       policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// An identifier that distinguishes the policy from others on the same layer version.
    /// This member is required.
    public var statementId: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int

    public init (
        action: Swift.String? = nil,
        layerName: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        principal: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.action = action
        self.layerName = layerName
        self.organizationId = organizationId
        self.principal = principal
        self.revisionId = revisionId
        self.statementId = statementId
        self.versionNumber = versionNumber
    }
}

struct AddLayerVersionPermissionInputBody: Swift.Equatable {
    public let statementId: Swift.String?
    public let action: Swift.String?
    public let principal: Swift.String?
    public let organizationId: Swift.String?
}

extension AddLayerVersionPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case organizationId = "OrganizationId"
        case principal = "Principal"
        case statementId = "StatementId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension AddLayerVersionPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddLayerVersionPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyLengthExceededException" : self = .policyLengthExceededException(try PolicyLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddLayerVersionPermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case policyLengthExceededException(PolicyLengthExceededException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddLayerVersionPermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddLayerVersionPermissionOutputResponse(revisionId: \(Swift.String(describing: revisionId)), statement: \(Swift.String(describing: statement)))"}
}

extension AddLayerVersionPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddLayerVersionPermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.revisionId = output.revisionId
            self.statement = output.statement
        } else {
            self.revisionId = nil
            self.statement = nil
        }
    }
}

public struct AddLayerVersionPermissionOutputResponse: Swift.Equatable {
    /// A unique identifier for the current revision of the policy.
    public var revisionId: Swift.String?
    /// The permission statement.
    public var statement: Swift.String?

    public init (
        revisionId: Swift.String? = nil,
        statement: Swift.String? = nil
    )
    {
        self.revisionId = revisionId
        self.statement = statement
    }
}

struct AddLayerVersionPermissionOutputResponseBody: Swift.Equatable {
    public let statement: Swift.String?
    public let revisionId: Swift.String?
}

extension AddLayerVersionPermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revisionId = "RevisionId"
        case statement = "Statement"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statement)
        statement = statementDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

public struct AddPermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddPermissionOutputError>
}

extension AddPermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddPermissionInput(action: \(Swift.String(describing: action)), eventSourceToken: \(Swift.String(describing: eventSourceToken)), functionName: \(Swift.String(describing: functionName)), principal: \(Swift.String(describing: principal)), qualifier: \(Swift.String(describing: qualifier)), revisionId: \(Swift.String(describing: revisionId)), sourceAccount: \(Swift.String(describing: sourceAccount)), sourceArn: \(Swift.String(describing: sourceArn)), statementId: \(Swift.String(describing: statementId)))"}
}

extension AddPermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case eventSourceToken = "EventSourceToken"
        case principal = "Principal"
        case revisionId = "RevisionId"
        case sourceAccount = "SourceAccount"
        case sourceArn = "SourceArn"
        case statementId = "StatementId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let eventSourceToken = eventSourceToken {
            try encodeContainer.encode(eventSourceToken, forKey: .eventSourceToken)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let sourceAccount = sourceAccount {
            try encodeContainer.encode(sourceAccount, forKey: .sourceAccount)
        }
        if let sourceArn = sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

public struct AddPermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddPermissionOutputError>
}

public struct AddPermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddPermissionOutputError>
}

public struct AddPermissionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddPermissionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AddPermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddPermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddPermissionOutputError>
}

public struct AddPermissionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddPermissionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AddPermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())/policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddPermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddPermissionOutputError>
}

public struct AddPermissionInput: Swift.Equatable {
    /// The action that the principal can use on the function. For example, lambda:InvokeFunction or
    ///         lambda:GetFunction.
    /// This member is required.
    public var action: Swift.String?
    /// For Alexa Smart Home functions, a token that must be supplied by the invoker.
    public var eventSourceToken: Swift.String?
    /// The name of the Lambda function, version, or alias.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The Amazon Web Services service or account that invokes the function. If you specify a service, use SourceArn or
    ///         SourceAccount to limit who can invoke the function through that service.
    /// This member is required.
    public var principal: Swift.String?
    /// Specify a version or alias to add permissions to a published version of the function.
    public var qualifier: Swift.String?
    /// Only update the policy if the revision ID matches the ID that's specified. Use this option to avoid modifying a
    ///       policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// For Amazon S3, the ID of the account that owns the resource. Use this together with SourceArn to
    ///       ensure that the resource is owned by the specified account. It is possible for an Amazon S3 bucket to be deleted
    ///       by its owner and recreated by another account.
    public var sourceAccount: Swift.String?
    /// For Amazon Web Services services, the ARN of the Amazon Web Services resource that invokes the function. For example, an Amazon S3 bucket or
    ///       Amazon SNS topic.
    ///          Note that Lambda configures the comparison using the StringLike operator.
    public var sourceArn: Swift.String?
    /// A statement identifier that differentiates the statement from others in the same policy.
    /// This member is required.
    public var statementId: Swift.String?

    public init (
        action: Swift.String? = nil,
        eventSourceToken: Swift.String? = nil,
        functionName: Swift.String? = nil,
        principal: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        sourceAccount: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.action = action
        self.eventSourceToken = eventSourceToken
        self.functionName = functionName
        self.principal = principal
        self.qualifier = qualifier
        self.revisionId = revisionId
        self.sourceAccount = sourceAccount
        self.sourceArn = sourceArn
        self.statementId = statementId
    }
}

struct AddPermissionInputBody: Swift.Equatable {
    public let statementId: Swift.String?
    public let action: Swift.String?
    public let principal: Swift.String?
    public let sourceArn: Swift.String?
    public let sourceAccount: Swift.String?
    public let eventSourceToken: Swift.String?
    public let revisionId: Swift.String?
}

extension AddPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case eventSourceToken = "EventSourceToken"
        case principal = "Principal"
        case revisionId = "RevisionId"
        case sourceAccount = "SourceAccount"
        case sourceArn = "SourceArn"
        case statementId = "StatementId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sourceAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceAccount)
        sourceAccount = sourceAccountDecoded
        let eventSourceTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceToken)
        eventSourceToken = eventSourceTokenDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension AddPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyLengthExceededException" : self = .policyLengthExceededException(try PolicyLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddPermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case policyLengthExceededException(PolicyLengthExceededException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddPermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddPermissionOutputResponse(statement: \(Swift.String(describing: statement)))"}
}

extension AddPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddPermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.statement = output.statement
        } else {
            self.statement = nil
        }
    }
}

public struct AddPermissionOutputResponse: Swift.Equatable {
    /// The permission statement that's added to the function policy.
    public var statement: Swift.String?

    public init (
        statement: Swift.String? = nil
    )
    {
        self.statement = statement
    }
}

struct AddPermissionOutputResponseBody: Swift.Equatable {
    public let statement: Swift.String?
}

extension AddPermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statement = "Statement"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statement)
        statement = statementDecoded
    }
}

extension LambdaClientTypes.AliasConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasArn = aliasArn {
            try encodeContainer.encode(aliasArn, forKey: .aliasArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let routingConfig = routingConfig {
            try encodeContainer.encode(routingConfig, forKey: .routingConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension LambdaClientTypes.AliasConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AliasConfiguration(aliasArn: \(Swift.String(describing: aliasArn)), description: \(Swift.String(describing: description)), functionVersion: \(Swift.String(describing: functionVersion)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), routingConfig: \(Swift.String(describing: routingConfig)))"}
}

extension LambdaClientTypes {
    /// Provides configuration information about a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias.
    public struct AliasConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the alias.
        public var aliasArn: Swift.String?
        /// A description of the alias.
        public var description: Swift.String?
        /// The function version that the alias invokes.
        public var functionVersion: Swift.String?
        /// The name of the alias.
        public var name: Swift.String?
        /// A unique identifier that changes when you update the alias.
        public var revisionId: Swift.String?
        /// The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">routing
        ///         configuration of the alias.
        public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

        public init (
            aliasArn: Swift.String? = nil,
            description: Swift.String? = nil,
            functionVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
        )
        {
            self.aliasArn = aliasArn
            self.description = description
            self.functionVersion = functionVersion
            self.name = name
            self.revisionId = revisionId
            self.routingConfig = routingConfig
        }
    }

}

extension LambdaClientTypes.AliasRoutingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalVersionWeights = "AdditionalVersionWeights"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalVersionWeights = additionalVersionWeights {
            var additionalVersionWeightsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalVersionWeights)
            for (dictKey0, additionalversionweights0) in additionalVersionWeights {
                try additionalVersionWeightsContainer.encode(additionalversionweights0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalVersionWeightsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Double?].self, forKey: .additionalVersionWeights)
        var additionalVersionWeightsDecoded0: [Swift.String:Swift.Double]? = nil
        if let additionalVersionWeightsContainer = additionalVersionWeightsContainer {
            additionalVersionWeightsDecoded0 = [Swift.String:Swift.Double]()
            for (key0, weight0) in additionalVersionWeightsContainer {
                if let weight0 = weight0 {
                    additionalVersionWeightsDecoded0?[key0] = weight0
                }
            }
        }
        additionalVersionWeights = additionalVersionWeightsDecoded0
    }
}

extension LambdaClientTypes.AliasRoutingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AliasRoutingConfiguration(additionalVersionWeights: \(Swift.String(describing: additionalVersionWeights)))"}
}

extension LambdaClientTypes {
    /// The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">traffic-shifting configuration of a Lambda function alias.
    public struct AliasRoutingConfiguration: Swift.Equatable {
        /// The second version, and the percentage of traffic that's routed to it.
        public var additionalVersionWeights: [Swift.String:Swift.Double]?

        public init (
            additionalVersionWeights: [Swift.String:Swift.Double]? = nil
        )
        {
            self.additionalVersionWeights = additionalVersionWeights
        }
    }

}

extension LambdaClientTypes.AllowedPublishers: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signingProfileVersionArns = "SigningProfileVersionArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingProfileVersionArns = signingProfileVersionArns {
            var signingProfileVersionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signingProfileVersionArns)
            for signingprofileversionarns0 in signingProfileVersionArns {
                try signingProfileVersionArnsContainer.encode(signingprofileversionarns0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingProfileVersionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .signingProfileVersionArns)
        var signingProfileVersionArnsDecoded0:[Swift.String]? = nil
        if let signingProfileVersionArnsContainer = signingProfileVersionArnsContainer {
            signingProfileVersionArnsDecoded0 = [Swift.String]()
            for string0 in signingProfileVersionArnsContainer {
                if let string0 = string0 {
                    signingProfileVersionArnsDecoded0?.append(string0)
                }
            }
        }
        signingProfileVersionArns = signingProfileVersionArnsDecoded0
    }
}

extension LambdaClientTypes.AllowedPublishers: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AllowedPublishers(signingProfileVersionArns: \(Swift.String(describing: signingProfileVersionArns)))"}
}

extension LambdaClientTypes {
    /// List of signing profiles that can sign a code package.
    public struct AllowedPublishers: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user
        ///       who can sign a code package.
        /// This member is required.
        public var signingProfileVersionArns: [Swift.String]?

        public init (
            signingProfileVersionArns: [Swift.String]? = nil
        )
        {
            self.signingProfileVersionArns = signingProfileVersionArns
        }
    }

}

extension LambdaClientTypes {
    public enum Architecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arm64
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [Architecture] {
            return [
                .arm64,
                .x8664,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "arm64"
            case .x8664: return "x86_64"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Architecture(rawValue: rawValue) ?? Architecture.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.CodeSigningConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case codeSigningConfigId = "CodeSigningConfigId"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
        case lastModified = "LastModified"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPublishers = allowedPublishers {
            try encodeContainer.encode(allowedPublishers, forKey: .allowedPublishers)
        }
        if let codeSigningConfigArn = codeSigningConfigArn {
            try encodeContainer.encode(codeSigningConfigArn, forKey: .codeSigningConfigArn)
        }
        if let codeSigningConfigId = codeSigningConfigId {
            try encodeContainer.encode(codeSigningConfigId, forKey: .codeSigningConfigId)
        }
        if let codeSigningPolicies = codeSigningPolicies {
            try encodeContainer.encode(codeSigningPolicies, forKey: .codeSigningPolicies)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigId)
        codeSigningConfigId = codeSigningConfigIdDecoded
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let allowedPublishersDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AllowedPublishers.self, forKey: .allowedPublishers)
        allowedPublishers = allowedPublishersDecoded
        let codeSigningPoliciesDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningPolicies.self, forKey: .codeSigningPolicies)
        codeSigningPolicies = codeSigningPoliciesDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension LambdaClientTypes.CodeSigningConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeSigningConfig(allowedPublishers: \(Swift.String(describing: allowedPublishers)), codeSigningConfigArn: \(Swift.String(describing: codeSigningConfigArn)), codeSigningConfigId: \(Swift.String(describing: codeSigningConfigId)), codeSigningPolicies: \(Swift.String(describing: codeSigningPolicies)), description: \(Swift.String(describing: description)), lastModified: \(Swift.String(describing: lastModified)))"}
}

extension LambdaClientTypes {
    /// Details about a <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html">Code signing configuration.
    public struct CodeSigningConfig: Swift.Equatable {
        /// List of allowed publishers.
        /// This member is required.
        public var allowedPublishers: LambdaClientTypes.AllowedPublishers?
        /// The Amazon Resource Name (ARN) of the Code signing configuration.
        /// This member is required.
        public var codeSigningConfigArn: Swift.String?
        /// Unique identifer for the Code signing configuration.
        /// This member is required.
        public var codeSigningConfigId: Swift.String?
        /// The code signing policy controls the validation failure action for signature mismatch or expiry.
        /// This member is required.
        public var codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
        /// Code signing configuration description.
        public var description: Swift.String?
        /// The date and time that the Code signing configuration was last modified, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        /// This member is required.
        public var lastModified: Swift.String?

        public init (
            allowedPublishers: LambdaClientTypes.AllowedPublishers? = nil,
            codeSigningConfigArn: Swift.String? = nil,
            codeSigningConfigId: Swift.String? = nil,
            codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies? = nil,
            description: Swift.String? = nil,
            lastModified: Swift.String? = nil
        )
        {
            self.allowedPublishers = allowedPublishers
            self.codeSigningConfigArn = codeSigningConfigArn
            self.codeSigningConfigId = codeSigningConfigId
            self.codeSigningPolicies = codeSigningPolicies
            self.description = description
            self.lastModified = lastModified
        }
    }

}

extension CodeSigningConfigNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeSigningConfigNotFoundException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension CodeSigningConfigNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CodeSigningConfigNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified code signing configuration does not exist.
public struct CodeSigningConfigNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct CodeSigningConfigNotFoundExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension CodeSigningConfigNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.CodeSigningPolicies: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case untrustedArtifactOnDeployment = "UntrustedArtifactOnDeployment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let untrustedArtifactOnDeployment = untrustedArtifactOnDeployment {
            try encodeContainer.encode(untrustedArtifactOnDeployment.rawValue, forKey: .untrustedArtifactOnDeployment)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let untrustedArtifactOnDeploymentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningPolicy.self, forKey: .untrustedArtifactOnDeployment)
        untrustedArtifactOnDeployment = untrustedArtifactOnDeploymentDecoded
    }
}

extension LambdaClientTypes.CodeSigningPolicies: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeSigningPolicies(untrustedArtifactOnDeployment: \(Swift.String(describing: untrustedArtifactOnDeployment)))"}
}

extension LambdaClientTypes {
    /// Code signing configuration <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html#config-codesigning-policies">policies specify the validation failure action for signature mismatch or
    ///        expiry.
    public struct CodeSigningPolicies: Swift.Equatable {
        /// Code signing configuration policy for deployment validation failure. If you set the policy to
        ///       Enforce, Lambda blocks the deployment request if signature validation checks fail. If you set the
        ///       policy to Warn, Lambda allows the deployment and creates a CloudWatch log.
        ///          Default value: Warn
        ///
        public var untrustedArtifactOnDeployment: LambdaClientTypes.CodeSigningPolicy?

        public init (
            untrustedArtifactOnDeployment: LambdaClientTypes.CodeSigningPolicy? = nil
        )
        {
            self.untrustedArtifactOnDeployment = untrustedArtifactOnDeployment
        }
    }

}

extension LambdaClientTypes {
    public enum CodeSigningPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enforce
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [CodeSigningPolicy] {
            return [
                .enforce,
                .warn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enforce: return "Enforce"
            case .warn: return "Warn"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CodeSigningPolicy(rawValue: rawValue) ?? CodeSigningPolicy.sdkUnknown(rawValue)
        }
    }
}

extension CodeStorageExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeStorageExceededException(type: \(Swift.String(describing: type)), message: \(Swift.String(describing: message)))"}
}

extension CodeStorageExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CodeStorageExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded your maximum total code size per account. <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">Learn more
///
public struct CodeStorageExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The exception type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct CodeStorageExceededExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension CodeStorageExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeVerificationFailedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeVerificationFailedException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension CodeVerificationFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CodeVerificationFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code signing policy
///       is set to ENFORCE. Lambda blocks the deployment.
public struct CodeVerificationFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct CodeVerificationFailedExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension CodeVerificationFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.Concurrency: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reservedConcurrentExecutions = reservedConcurrentExecutions {
            try encodeContainer.encode(reservedConcurrentExecutions, forKey: .reservedConcurrentExecutions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

extension LambdaClientTypes.Concurrency: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Concurrency(reservedConcurrentExecutions: \(Swift.String(describing: reservedConcurrentExecutions)))"}
}

extension LambdaClientTypes {
    public struct Concurrency: Swift.Equatable {
        /// The number of concurrent executions that are reserved for this function. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html">Managing Concurrency.
        public var reservedConcurrentExecutions: Swift.Int?

        public init (
            reservedConcurrentExecutions: Swift.Int? = nil
        )
        {
            self.reservedConcurrentExecutions = reservedConcurrentExecutions
        }
    }

}

public struct CreateAliasInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAliasOutputError>
}

extension CreateAliasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAliasInput(description: \(Swift.String(describing: description)), functionName: \(Swift.String(describing: functionName)), functionVersion: \(Swift.String(describing: functionVersion)), name: \(Swift.String(describing: name)), routingConfig: \(Swift.String(describing: routingConfig)))"}
}

extension CreateAliasInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case routingConfig = "RoutingConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let routingConfig = routingConfig {
            try encodeContainer.encode(routingConfig, forKey: .routingConfig)
        }
    }
}

public struct CreateAliasInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAliasOutputError>
}

public struct CreateAliasInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAliasOutputError>
}

public struct CreateAliasInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAliasInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateAliasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAliasInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAliasOutputError>
}

public struct CreateAliasInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAliasInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateAliasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAliasInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAliasOutputError>
}

public struct CreateAliasInput: Swift.Equatable {
    /// A description of the alias.
    public var description: Swift.String?
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - MyFunction.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The function version that the alias invokes.
    /// This member is required.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?
    /// The <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing">routing
    ///         configuration of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init (
        description: Swift.String? = nil,
        functionName: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.description = description
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.name = name
        self.routingConfig = routingConfig
    }
}

struct CreateAliasInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let functionVersion: Swift.String?
    public let description: Swift.String?
    public let routingConfig: LambdaClientTypes.AliasRoutingConfiguration?
}

extension CreateAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
    }
}

extension CreateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAliasOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAliasOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAliasOutputResponse(aliasArn: \(Swift.String(describing: aliasArn)), description: \(Swift.String(describing: description)), functionVersion: \(Swift.String(describing: functionVersion)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), routingConfig: \(Swift.String(describing: routingConfig)))"}
}

extension CreateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliasArn = output.aliasArn
            self.description = output.description
            self.functionVersion = output.functionVersion
            self.name = output.name
            self.revisionId = output.revisionId
            self.routingConfig = output.routingConfig
        } else {
            self.aliasArn = nil
            self.description = nil
            self.functionVersion = nil
            self.name = nil
            self.revisionId = nil
            self.routingConfig = nil
        }
    }
}

/// Provides configuration information about a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias.
public struct CreateAliasOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the alias.
    public var aliasArn: Swift.String?
    /// A description of the alias.
    public var description: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    public var name: Swift.String?
    /// A unique identifier that changes when you update the alias.
    public var revisionId: Swift.String?
    /// The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">routing
    ///         configuration of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init (
        aliasArn: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct CreateAliasOutputResponseBody: Swift.Equatable {
    public let aliasArn: Swift.String?
    public let name: Swift.String?
    public let functionVersion: Swift.String?
    public let description: Swift.String?
    public let routingConfig: LambdaClientTypes.AliasRoutingConfiguration?
    public let revisionId: Swift.String?
}

extension CreateAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

public struct CreateCodeSigningConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCodeSigningConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCodeSigningConfigOutputError>
}

extension CreateCodeSigningConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCodeSigningConfigInput(allowedPublishers: \(Swift.String(describing: allowedPublishers)), codeSigningPolicies: \(Swift.String(describing: codeSigningPolicies)), description: \(Swift.String(describing: description)))"}
}

extension CreateCodeSigningConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPublishers = allowedPublishers {
            try encodeContainer.encode(allowedPublishers, forKey: .allowedPublishers)
        }
        if let codeSigningPolicies = codeSigningPolicies {
            try encodeContainer.encode(codeSigningPolicies, forKey: .codeSigningPolicies)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct CreateCodeSigningConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCodeSigningConfigOutputError>
}

public struct CreateCodeSigningConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCodeSigningConfigOutputError>
}

public struct CreateCodeSigningConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCodeSigningConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCodeSigningConfigOutputError>
}

public struct CreateCodeSigningConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCodeSigningConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-04-22/code-signing-configs"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCodeSigningConfigOutputError>
}

public struct CreateCodeSigningConfigInput: Swift.Equatable {
    /// Signing profiles for this code signing configuration.
    /// This member is required.
    public var allowedPublishers: LambdaClientTypes.AllowedPublishers?
    /// The code signing policies define the actions to take if the validation checks fail.
    public var codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
    /// Descriptive name for this code signing configuration.
    public var description: Swift.String?

    public init (
        allowedPublishers: LambdaClientTypes.AllowedPublishers? = nil,
        codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies? = nil,
        description: Swift.String? = nil
    )
    {
        self.allowedPublishers = allowedPublishers
        self.codeSigningPolicies = codeSigningPolicies
        self.description = description
    }
}

struct CreateCodeSigningConfigInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let allowedPublishers: LambdaClientTypes.AllowedPublishers?
    public let codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
}

extension CreateCodeSigningConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let allowedPublishersDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AllowedPublishers.self, forKey: .allowedPublishers)
        allowedPublishers = allowedPublishersDecoded
        let codeSigningPoliciesDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningPolicies.self, forKey: .codeSigningPolicies)
        codeSigningPolicies = codeSigningPoliciesDecoded
    }
}

extension CreateCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCodeSigningConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCodeSigningConfigOutputResponse(codeSigningConfig: \(Swift.String(describing: codeSigningConfig)))"}
}

extension CreateCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfig = output.codeSigningConfig
        } else {
            self.codeSigningConfig = nil
        }
    }
}

public struct CreateCodeSigningConfigOutputResponse: Swift.Equatable {
    /// The code signing configuration.
    /// This member is required.
    public var codeSigningConfig: LambdaClientTypes.CodeSigningConfig?

    public init (
        codeSigningConfig: LambdaClientTypes.CodeSigningConfig? = nil
    )
    {
        self.codeSigningConfig = codeSigningConfig
    }
}

struct CreateCodeSigningConfigOutputResponseBody: Swift.Equatable {
    public let codeSigningConfig: LambdaClientTypes.CodeSigningConfig?
}

extension CreateCodeSigningConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfig = "CodeSigningConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningConfig.self, forKey: .codeSigningConfig)
        codeSigningConfig = codeSigningConfigDecoded
    }
}

public struct CreateEventSourceMappingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSourceMappingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventSourceMappingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventSourceMappingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSourceMappingOutputError>
}

extension CreateEventSourceMappingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventSourceMappingInput(batchSize: \(Swift.String(describing: batchSize)), bisectBatchOnFunctionError: \(Swift.String(describing: bisectBatchOnFunctionError)), destinationConfig: \(Swift.String(describing: destinationConfig)), enabled: \(Swift.String(describing: enabled)), eventSourceArn: \(Swift.String(describing: eventSourceArn)), functionName: \(Swift.String(describing: functionName)), functionResponseTypes: \(Swift.String(describing: functionResponseTypes)), maximumBatchingWindowInSeconds: \(Swift.String(describing: maximumBatchingWindowInSeconds)), maximumRecordAgeInSeconds: \(Swift.String(describing: maximumRecordAgeInSeconds)), maximumRetryAttempts: \(Swift.String(describing: maximumRetryAttempts)), parallelizationFactor: \(Swift.String(describing: parallelizationFactor)), queues: \(Swift.String(describing: queues)), selfManagedEventSource: \(Swift.String(describing: selfManagedEventSource)), sourceAccessConfigurations: \(Swift.String(describing: sourceAccessConfigurations)), startingPosition: \(Swift.String(describing: startingPosition)), startingPositionTimestamp: \(Swift.String(describing: startingPositionTimestamp)), topics: \(Swift.String(describing: topics)), tumblingWindowInSeconds: \(Swift.String(describing: tumblingWindowInSeconds)))"}
}

extension CreateEventSourceMappingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case enabled = "Enabled"
        case eventSourceArn = "EventSourceArn"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSize = batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let bisectBatchOnFunctionError = bisectBatchOnFunctionError {
            try encodeContainer.encode(bisectBatchOnFunctionError, forKey: .bisectBatchOnFunctionError)
        }
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let functionResponseTypes = functionResponseTypes {
            var functionResponseTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionResponseTypes)
            for functionresponsetypelist0 in functionResponseTypes {
                try functionResponseTypesContainer.encode(functionresponsetypelist0.rawValue)
            }
        }
        if let maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds {
            try encodeContainer.encode(maximumBatchingWindowInSeconds, forKey: .maximumBatchingWindowInSeconds)
        }
        if let maximumRecordAgeInSeconds = maximumRecordAgeInSeconds {
            try encodeContainer.encode(maximumRecordAgeInSeconds, forKey: .maximumRecordAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
        if let parallelizationFactor = parallelizationFactor {
            try encodeContainer.encode(parallelizationFactor, forKey: .parallelizationFactor)
        }
        if let queues = queues {
            var queuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queues)
            for queues0 in queues {
                try queuesContainer.encode(queues0)
            }
        }
        if let selfManagedEventSource = selfManagedEventSource {
            try encodeContainer.encode(selfManagedEventSource, forKey: .selfManagedEventSource)
        }
        if let sourceAccessConfigurations = sourceAccessConfigurations {
            var sourceAccessConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceAccessConfigurations)
            for sourceaccessconfigurations0 in sourceAccessConfigurations {
                try sourceAccessConfigurationsContainer.encode(sourceaccessconfigurations0)
            }
        }
        if let startingPosition = startingPosition {
            try encodeContainer.encode(startingPosition.rawValue, forKey: .startingPosition)
        }
        if let startingPositionTimestamp = startingPositionTimestamp {
            try encodeContainer.encode(startingPositionTimestamp.timeIntervalSince1970, forKey: .startingPositionTimestamp)
        }
        if let topics = topics {
            var topicsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topics)
            for topics0 in topics {
                try topicsContainer.encode(topics0)
            }
        }
        if let tumblingWindowInSeconds = tumblingWindowInSeconds {
            try encodeContainer.encode(tumblingWindowInSeconds, forKey: .tumblingWindowInSeconds)
        }
    }
}

public struct CreateEventSourceMappingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSourceMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventSourceMappingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventSourceMappingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSourceMappingOutputError>
}

public struct CreateEventSourceMappingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSourceMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventSourceMappingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventSourceMappingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSourceMappingOutputError>
}

public struct CreateEventSourceMappingInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSourceMappingInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateEventSourceMappingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEventSourceMappingInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSourceMappingOutputError>
}

public struct CreateEventSourceMappingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSourceMappingInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateEventSourceMappingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2015-03-31/event-source-mappings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEventSourceMappingInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSourceMappingOutputError>
}

public struct CreateEventSourceMappingInput: Swift.Equatable {
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation
    ///   (6 MB).
    ///
    ///
    ///
    ///                   Amazon Kinesis - Default 100. Max 10,000.
    ///
    ///
    ///
    ///                   Amazon DynamoDB Streams - Default 100. Max 1,000.
    ///
    ///
    ///
    ///                   Amazon Simple Queue Service - Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.
    ///
    ///
    ///
    ///                   Amazon Managed Streaming for Apache Kafka - Default 100. Max 10,000.
    ///
    ///
    ///
    ///                   Self-Managed Apache Kafka - Default 100. Max 10,000.
    ///
    ///
    public var batchSize: Swift.Int?
    /// (Streams only) If the function returns an error, split the batch in two and retry.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// When true, the event source mapping is active. When false, Lambda pauses polling and invocation.
    ///          Default: True
    public var enabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the event source.
    ///
    ///
    ///
    ///                   Amazon Kinesis - The ARN of the data stream or a stream consumer.
    ///
    ///
    ///
    ///                   Amazon DynamoDB Streams - The ARN of the stream.
    ///
    ///
    ///
    ///                   Amazon Simple Queue Service - The ARN of the queue.
    ///
    ///
    ///
    ///                   Amazon Managed Streaming for Apache Kafka - The ARN of the cluster.
    ///
    ///
    public var eventSourceArn: Swift.String?
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - MyFunction.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    ///
    ///
    ///                   Version or Alias ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// (Streams only) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// (Streams and Amazon SQS standard queues) The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function.
    ///          Default: 0
    ///          Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Streams only) Discard records older than the specified age. The default value is infinite (-1).
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Streams only) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records will be retried until the record expires.
    public var maximumRetryAttempts: Swift.Int?
    /// (Streams only) The number of batches to process from each shard concurrently.
    public var parallelizationFactor: Swift.Int?
    ///  (MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// The Self-Managed Apache Kafka cluster to send records.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// An array of authentication protocols or VPC components required to secure your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon
    ///       MSK Streams sources. AT_TIMESTAMP is only supported for Amazon Kinesis streams.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start
    ///       reading.
    public var startingPositionTimestamp: ClientRuntime.Date?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Streams only) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.
    public var tumblingWindowInSeconds: Swift.Int?

    public init (
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        enabled: Swift.Bool? = nil,
        eventSourceArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: ClientRuntime.Date? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.enabled = enabled
        self.eventSourceArn = eventSourceArn
        self.functionName = functionName
        self.functionResponseTypes = functionResponseTypes
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
    }
}

struct CreateEventSourceMappingInputBody: Swift.Equatable {
    public let eventSourceArn: Swift.String?
    public let functionName: Swift.String?
    public let enabled: Swift.Bool?
    public let batchSize: Swift.Int?
    public let maximumBatchingWindowInSeconds: Swift.Int?
    public let parallelizationFactor: Swift.Int?
    public let startingPosition: LambdaClientTypes.EventSourcePosition?
    public let startingPositionTimestamp: ClientRuntime.Date?
    public let destinationConfig: LambdaClientTypes.DestinationConfig?
    public let maximumRecordAgeInSeconds: Swift.Int?
    public let bisectBatchOnFunctionError: Swift.Bool?
    public let maximumRetryAttempts: Swift.Int?
    public let tumblingWindowInSeconds: Swift.Int?
    public let topics: [Swift.String]?
    public let queues: [Swift.String]?
    public let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    public let selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    public let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
}

extension CreateEventSourceMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case enabled = "Enabled"
        case eventSourceArn = "EventSourceArn"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension CreateEventSourceMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEventSourceMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventSourceMappingOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventSourceMappingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventSourceMappingOutputResponse(batchSize: \(Swift.String(describing: batchSize)), bisectBatchOnFunctionError: \(Swift.String(describing: bisectBatchOnFunctionError)), destinationConfig: \(Swift.String(describing: destinationConfig)), eventSourceArn: \(Swift.String(describing: eventSourceArn)), functionArn: \(Swift.String(describing: functionArn)), functionResponseTypes: \(Swift.String(describing: functionResponseTypes)), lastModified: \(Swift.String(describing: lastModified)), lastProcessingResult: \(Swift.String(describing: lastProcessingResult)), maximumBatchingWindowInSeconds: \(Swift.String(describing: maximumBatchingWindowInSeconds)), maximumRecordAgeInSeconds: \(Swift.String(describing: maximumRecordAgeInSeconds)), maximumRetryAttempts: \(Swift.String(describing: maximumRetryAttempts)), parallelizationFactor: \(Swift.String(describing: parallelizationFactor)), queues: \(Swift.String(describing: queues)), selfManagedEventSource: \(Swift.String(describing: selfManagedEventSource)), sourceAccessConfigurations: \(Swift.String(describing: sourceAccessConfigurations)), startingPosition: \(Swift.String(describing: startingPosition)), startingPositionTimestamp: \(Swift.String(describing: startingPositionTimestamp)), state: \(Swift.String(describing: state)), stateTransitionReason: \(Swift.String(describing: stateTransitionReason)), topics: \(Swift.String(describing: topics)), tumblingWindowInSeconds: \(Swift.String(describing: tumblingWindowInSeconds)), uUID: \(Swift.String(describing: uUID)))"}
}

extension CreateEventSourceMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEventSourceMappingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.eventSourceArn = output.eventSourceArn
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.selfManagedEventSource = output.selfManagedEventSource
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uUID = output.uUID
        } else {
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.eventSourceArn = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.selfManagedEventSource = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uUID = nil
        }
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see CreateEventSourceMapping.
public struct CreateEventSourceMappingOutputResponse: Swift.Equatable {
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).
    ///          Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100.
    ///          Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Streams only) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: ClientRuntime.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// (Streams and Amazon SQS standard queues) The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function.
    ///          Default: 0
    ///          Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Streams only) Discard records older than the specified age. The default value is -1,
    /// which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records.
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Streams only) Discard records after the specified number of retries. The default value is -1,
    /// which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    ///  (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK stream sources. AT_TIMESTAMP is supported only for Amazon Kinesis
    ///       streams.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start
    ///       reading.
    public var startingPositionTimestamp: ClientRuntime.Date?
    /// The state of the event source mapping. It can be one of the following: Creating,
    ///         Enabling, Enabled, Disabling, Disabled,
    ///         Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Streams only) The duration in seconds of a processing window. The range is 1–900 seconds.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uUID: Swift.String?

    public init (
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        lastModified: ClientRuntime.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: ClientRuntime.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uUID: Swift.String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.eventSourceArn = eventSourceArn
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

struct CreateEventSourceMappingOutputResponseBody: Swift.Equatable {
    public let uUID: Swift.String?
    public let startingPosition: LambdaClientTypes.EventSourcePosition?
    public let startingPositionTimestamp: ClientRuntime.Date?
    public let batchSize: Swift.Int?
    public let maximumBatchingWindowInSeconds: Swift.Int?
    public let parallelizationFactor: Swift.Int?
    public let eventSourceArn: Swift.String?
    public let functionArn: Swift.String?
    public let lastModified: ClientRuntime.Date?
    public let lastProcessingResult: Swift.String?
    public let state: Swift.String?
    public let stateTransitionReason: Swift.String?
    public let destinationConfig: LambdaClientTypes.DestinationConfig?
    public let topics: [Swift.String]?
    public let queues: [Swift.String]?
    public let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    public let selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    public let maximumRecordAgeInSeconds: Swift.Int?
    public let bisectBatchOnFunctionError: Swift.Bool?
    public let maximumRetryAttempts: Swift.Int?
    public let tumblingWindowInSeconds: Swift.Int?
    public let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
}

extension CreateEventSourceMappingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case eventSourceArn = "EventSourceArn"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uUID = "UUID"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uUIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uUID)
        uUID = uUIDDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

public struct CreateFunctionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

extension CreateFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFunctionInput(architectures: \(Swift.String(describing: architectures)), code: \(Swift.String(describing: code)), codeSigningConfigArn: \(Swift.String(describing: codeSigningConfigArn)), deadLetterConfig: \(Swift.String(describing: deadLetterConfig)), description: \(Swift.String(describing: description)), environment: \(Swift.String(describing: environment)), fileSystemConfigs: \(Swift.String(describing: fileSystemConfigs)), functionName: \(Swift.String(describing: functionName)), handler: \(Swift.String(describing: handler)), imageConfig: \(Swift.String(describing: imageConfig)), kMSKeyArn: \(Swift.String(describing: kMSKeyArn)), layers: \(Swift.String(describing: layers)), memorySize: \(Swift.String(describing: memorySize)), packageType: \(Swift.String(describing: packageType)), publish: \(Swift.String(describing: publish)), role: \(Swift.String(describing: role)), runtime: \(Swift.String(describing: runtime)), tags: \(Swift.String(describing: tags)), timeout: \(Swift.String(describing: timeout)), tracingConfig: \(Swift.String(describing: tracingConfig)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension CreateFunctionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case code = "Code"
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kMSKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case publish = "Publish"
        case role = "Role"
        case runtime = "Runtime"
        case tags = "Tags"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architectureslist0 in architectures {
                try architecturesContainer.encode(architectureslist0.rawValue)
            }
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let codeSigningConfigArn = codeSigningConfigArn {
            try encodeContainer.encode(codeSigningConfigArn, forKey: .codeSigningConfigArn)
        }
        if let deadLetterConfig = deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemConfigs = fileSystemConfigs {
            var fileSystemConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemConfigs)
            for filesystemconfiglist0 in fileSystemConfigs {
                try fileSystemConfigsContainer.encode(filesystemconfiglist0)
            }
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let handler = handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let imageConfig = imageConfig {
            try encodeContainer.encode(imageConfig, forKey: .imageConfig)
        }
        if let kMSKeyArn = kMSKeyArn {
            try encodeContainer.encode(kMSKeyArn, forKey: .kMSKeyArn)
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for layerlist0 in layers {
                try layersContainer.encode(layerlist0)
            }
        }
        if let memorySize = memorySize {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let packageType = packageType {
            try encodeContainer.encode(packageType.rawValue, forKey: .packageType)
        }
        if publish != false {
            try encodeContainer.encode(publish, forKey: .publish)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let runtime = runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tracingConfig = tracingConfig {
            try encodeContainer.encode(tracingConfig, forKey: .tracingConfig)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct CreateFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2015-03-31/functions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInput: Swift.Equatable {
    /// The instruction set architecture that the function supports. Enter a string array with one of the valid values.
    ///     The default value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The code for the function.
    /// This member is required.
    public var code: LambdaClientTypes.FunctionCode?
    /// To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration
    /// includes a set of signing profiles, which define the trusted publishers for this function.
    public var codeSigningConfigArn: Swift.String?
    /// A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events
    ///       when they fail processing. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">Dead Letter Queues.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// A description of the function.
    public var description: Swift.String?
    /// Environment variables that are accessible from function code during execution.
    public var environment: LambdaClientTypes.Environment?
    /// Connection settings for an Amazon EFS file system.
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the method within your code that Lambda calls to execute your function. The format includes the
    ///       file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information,
    ///       see <a href="https://docs.aws.amazon.com/lambda/latest/dg/programming-model-v2.html">Programming Model.
    public var handler: Swift.String?
    /// Container image <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-images.html#configuration-images-settings">configuration
    ///       values that override the values in the container image Dockerfile.
    public var imageConfig: LambdaClientTypes.ImageConfig?
    /// The ARN of the Amazon Web Services Key Management Service (KMS) key that's used to encrypt your function's environment
    ///       variables. If it's not provided, Lambda uses a default service key.
    public var kMSKeyArn: Swift.String?
    /// A list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">function layers
    ///       to add to the function's execution environment. Specify each layer by its ARN, including the version.
    public var layers: [Swift.String]?
    /// The amount of  <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-memory.html">memory available to the function at runtime.
    ///       Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for ZIP archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// Set to true to publish the first version of the function during creation.
    public var publish: Swift.Bool
    /// The Amazon Resource Name (ARN) of the function's execution role.
    /// This member is required.
    public var role: Swift.String?
    /// The identifier of the function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">runtime.
    public var runtime: LambdaClientTypes.Runtime?
    /// A list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/tagging.html">tags to apply to the
    ///       function.
    public var tags: [Swift.String:Swift.String]?
    /// The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The
    ///       maximum allowed value is 900 seconds. For additional information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html">Lambda execution environment.
    public var timeout: Swift.Int?
    /// Set Mode to Active to sample and trace a subset of incoming requests with
    /// <a href="https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html">X-Ray.
    public var tracingConfig: LambdaClientTypes.TracingConfig?
    /// For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC.
    ///       When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more
    ///       information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html">VPC Settings.
    public var vpcConfig: LambdaClientTypes.VpcConfig?

    public init (
        architectures: [LambdaClientTypes.Architecture]? = nil,
        code: LambdaClientTypes.FunctionCode? = nil,
        codeSigningConfigArn: Swift.String? = nil,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.Environment? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfig: LambdaClientTypes.ImageConfig? = nil,
        kMSKeyArn: Swift.String? = nil,
        layers: [Swift.String]? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        publish: Swift.Bool = false,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfig? = nil,
        vpcConfig: LambdaClientTypes.VpcConfig? = nil
    )
    {
        self.architectures = architectures
        self.code = code
        self.codeSigningConfigArn = codeSigningConfigArn
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionName = functionName
        self.handler = handler
        self.imageConfig = imageConfig
        self.kMSKeyArn = kMSKeyArn
        self.layers = layers
        self.memorySize = memorySize
        self.packageType = packageType
        self.publish = publish
        self.role = role
        self.runtime = runtime
        self.tags = tags
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.vpcConfig = vpcConfig
    }
}

struct CreateFunctionInputBody: Swift.Equatable {
    public let functionName: Swift.String?
    public let runtime: LambdaClientTypes.Runtime?
    public let role: Swift.String?
    public let handler: Swift.String?
    public let code: LambdaClientTypes.FunctionCode?
    public let description: Swift.String?
    public let timeout: Swift.Int?
    public let memorySize: Swift.Int?
    public let publish: Swift.Bool
    public let vpcConfig: LambdaClientTypes.VpcConfig?
    public let packageType: LambdaClientTypes.PackageType?
    public let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    public let environment: LambdaClientTypes.Environment?
    public let kMSKeyArn: Swift.String?
    public let tracingConfig: LambdaClientTypes.TracingConfig?
    public let tags: [Swift.String:Swift.String]?
    public let layers: [Swift.String]?
    public let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    public let imageConfig: LambdaClientTypes.ImageConfig?
    public let codeSigningConfigArn: Swift.String?
    public let architectures: [LambdaClientTypes.Architecture]?
}

extension CreateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case code = "Code"
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kMSKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case publish = "Publish"
        case role = "Role"
        case runtime = "Runtime"
        case tags = "Tags"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionCode.self, forKey: .code)
        code = codeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let publishDecoded = try containerValues.decode(Swift.Bool.self, forKey: .publish)
        publish = publishDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfig.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let layersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layers)
        var layersDecoded0:[Swift.String]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Swift.String]()
            for string0 in layersContainer {
                if let string0 = string0 {
                    layersDecoded0?.append(string0)
                }
            }
        }
        layers = layersDecoded0
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let imageConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfig.self, forKey: .imageConfig)
        imageConfig = imageConfigDecoded
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

extension CreateFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeSigningConfigNotFoundException" : self = .codeSigningConfigNotFoundException(try CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeStorageExceededException" : self = .codeStorageExceededException(try CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeVerificationFailedException" : self = .codeVerificationFailedException(try CodeVerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCodeSignatureException" : self = .invalidCodeSignatureException(try InvalidCodeSignatureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFunctionOutputError: Swift.Error, Swift.Equatable {
    case codeSigningConfigNotFoundException(CodeSigningConfigNotFoundException)
    case codeStorageExceededException(CodeStorageExceededException)
    case codeVerificationFailedException(CodeVerificationFailedException)
    case invalidCodeSignatureException(InvalidCodeSignatureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFunctionOutputResponse(architectures: \(Swift.String(describing: architectures)), codeSha256: \(Swift.String(describing: codeSha256)), codeSize: \(Swift.String(describing: codeSize)), deadLetterConfig: \(Swift.String(describing: deadLetterConfig)), description: \(Swift.String(describing: description)), environment: \(Swift.String(describing: environment)), fileSystemConfigs: \(Swift.String(describing: fileSystemConfigs)), functionArn: \(Swift.String(describing: functionArn)), functionName: \(Swift.String(describing: functionName)), handler: \(Swift.String(describing: handler)), imageConfigResponse: \(Swift.String(describing: imageConfigResponse)), kMSKeyArn: \(Swift.String(describing: kMSKeyArn)), lastModified: \(Swift.String(describing: lastModified)), lastUpdateStatus: \(Swift.String(describing: lastUpdateStatus)), lastUpdateStatusReason: \(Swift.String(describing: lastUpdateStatusReason)), lastUpdateStatusReasonCode: \(Swift.String(describing: lastUpdateStatusReasonCode)), layers: \(Swift.String(describing: layers)), masterArn: \(Swift.String(describing: masterArn)), memorySize: \(Swift.String(describing: memorySize)), packageType: \(Swift.String(describing: packageType)), revisionId: \(Swift.String(describing: revisionId)), role: \(Swift.String(describing: role)), runtime: \(Swift.String(describing: runtime)), signingJobArn: \(Swift.String(describing: signingJobArn)), signingProfileVersionArn: \(Swift.String(describing: signingProfileVersionArn)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)), stateReasonCode: \(Swift.String(describing: stateReasonCode)), timeout: \(Swift.String(describing: timeout)), tracingConfig: \(Swift.String(describing: tracingConfig)), version: \(Swift.String(describing: version)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension CreateFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFunctionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architectures = output.architectures
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kMSKeyArn = output.kMSKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.architectures = nil
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kMSKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// Details about a function's configuration.
public struct CreateFunctionOutputResponse: Swift.Equatable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the
    ///       valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">environment variables.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// Connection settings for an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html">Amazon EFS file system.
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin executing your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    ///       configured a customer managed CMK.
    public var kMSKeyArn: Swift.String?
    /// The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful
    ///       after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    ///       layers.
    public var layers: [LambdaClientTypes.Layer]?
    /// For Lambda@Edge functions, the ARN of the master function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The runtime environment for the Lambda function.
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by
    ///       invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or
    ///       modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init (
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kMSKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct CreateFunctionOutputResponseBody: Swift.Equatable {
    public let functionName: Swift.String?
    public let functionArn: Swift.String?
    public let runtime: LambdaClientTypes.Runtime?
    public let role: Swift.String?
    public let handler: Swift.String?
    public let codeSize: Swift.Int
    public let description: Swift.String?
    public let timeout: Swift.Int?
    public let memorySize: Swift.Int?
    public let lastModified: Swift.String?
    public let codeSha256: Swift.String?
    public let version: Swift.String?
    public let vpcConfig: LambdaClientTypes.VpcConfigResponse?
    public let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    public let environment: LambdaClientTypes.EnvironmentResponse?
    public let kMSKeyArn: Swift.String?
    public let tracingConfig: LambdaClientTypes.TracingConfigResponse?
    public let masterArn: Swift.String?
    public let revisionId: Swift.String?
    public let layers: [LambdaClientTypes.Layer]?
    public let state: LambdaClientTypes.State?
    public let stateReason: Swift.String?
    public let stateReasonCode: LambdaClientTypes.StateReasonCode?
    public let lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    public let lastUpdateStatusReason: Swift.String?
    public let lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    public let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    public let packageType: LambdaClientTypes.PackageType?
    public let imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    public let signingProfileVersionArn: Swift.String?
    public let signingJobArn: Swift.String?
    public let architectures: [LambdaClientTypes.Architecture]?
}

extension CreateFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

extension LambdaClientTypes.DeadLetterConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
    }
}

extension LambdaClientTypes.DeadLetterConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeadLetterConfig(targetArn: \(Swift.String(describing: targetArn)))"}
}

extension LambdaClientTypes {
    /// The <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">dead-letter queue for
    ///       failed asynchronous invocations.
    public struct DeadLetterConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        public var targetArn: Swift.String?

        public init (
            targetArn: Swift.String? = nil
        )
        {
            self.targetArn = targetArn
        }
    }

}

extension DeleteAliasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAliasInput(functionName: \(Swift.String(describing: functionName)), name: \(Swift.String(describing: name)))"}
}

extension DeleteAliasInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAliasInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAliasOutputError>
}

public struct DeleteAliasInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAliasOutputError>
}

public struct DeleteAliasInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAliasInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAliasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAliasInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAliasOutputError>
}

public struct DeleteAliasInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAliasInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAliasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases/\(name.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAliasInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAliasOutputError>
}

public struct DeleteAliasInput: Swift.Equatable {
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - MyFunction.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.name = name
    }
}

struct DeleteAliasInputBody: Swift.Equatable {
}

extension DeleteAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAliasOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAliasOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAliasOutputResponse()"}
}

extension DeleteAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAliasOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAliasOutputResponseBody: Swift.Equatable {
}

extension DeleteAliasOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCodeSigningConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCodeSigningConfigInput(codeSigningConfigArn: \(Swift.String(describing: codeSigningConfigArn)))"}
}

extension DeleteCodeSigningConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteCodeSigningConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCodeSigningConfigOutputError>
}

public struct DeleteCodeSigningConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCodeSigningConfigOutputError>
}

public struct DeleteCodeSigningConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCodeSigningConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCodeSigningConfigOutputError>
}

public struct DeleteCodeSigningConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCodeSigningConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let codeSigningConfigArn = input.codeSigningConfigArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("codeSigningConfigArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCodeSigningConfigOutputError>
}

public struct DeleteCodeSigningConfigInput: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?

    public init (
        codeSigningConfigArn: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
    }
}

struct DeleteCodeSigningConfigInputBody: Swift.Equatable {
}

extension DeleteCodeSigningConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCodeSigningConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCodeSigningConfigOutputResponse()"}
}

extension DeleteCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCodeSigningConfigOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteCodeSigningConfigOutputResponseBody: Swift.Equatable {
}

extension DeleteCodeSigningConfigOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEventSourceMappingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventSourceMappingInput(uUID: \(Swift.String(describing: uUID)))"}
}

extension DeleteEventSourceMappingInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteEventSourceMappingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSourceMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventSourceMappingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventSourceMappingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSourceMappingOutputError>
}

public struct DeleteEventSourceMappingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSourceMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventSourceMappingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventSourceMappingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSourceMappingOutputError>
}

public struct DeleteEventSourceMappingInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSourceMappingInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteEventSourceMappingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEventSourceMappingInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSourceMappingOutputError>
}

public struct DeleteEventSourceMappingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSourceMappingInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteEventSourceMappingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let uUID = input.uUID else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("uUID is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/event-source-mappings/\(uUID.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEventSourceMappingInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSourceMappingOutputError>
}

public struct DeleteEventSourceMappingInput: Swift.Equatable {
    /// The identifier of the event source mapping.
    /// This member is required.
    public var uUID: Swift.String?

    public init (
        uUID: Swift.String? = nil
    )
    {
        self.uUID = uUID
    }
}

struct DeleteEventSourceMappingInputBody: Swift.Equatable {
}

extension DeleteEventSourceMappingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEventSourceMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventSourceMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventSourceMappingOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventSourceMappingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventSourceMappingOutputResponse(batchSize: \(Swift.String(describing: batchSize)), bisectBatchOnFunctionError: \(Swift.String(describing: bisectBatchOnFunctionError)), destinationConfig: \(Swift.String(describing: destinationConfig)), eventSourceArn: \(Swift.String(describing: eventSourceArn)), functionArn: \(Swift.String(describing: functionArn)), functionResponseTypes: \(Swift.String(describing: functionResponseTypes)), lastModified: \(Swift.String(describing: lastModified)), lastProcessingResult: \(Swift.String(describing: lastProcessingResult)), maximumBatchingWindowInSeconds: \(Swift.String(describing: maximumBatchingWindowInSeconds)), maximumRecordAgeInSeconds: \(Swift.String(describing: maximumRecordAgeInSeconds)), maximumRetryAttempts: \(Swift.String(describing: maximumRetryAttempts)), parallelizationFactor: \(Swift.String(describing: parallelizationFactor)), queues: \(Swift.String(describing: queues)), selfManagedEventSource: \(Swift.String(describing: selfManagedEventSource)), sourceAccessConfigurations: \(Swift.String(describing: sourceAccessConfigurations)), startingPosition: \(Swift.String(describing: startingPosition)), startingPositionTimestamp: \(Swift.String(describing: startingPositionTimestamp)), state: \(Swift.String(describing: state)), stateTransitionReason: \(Swift.String(describing: stateTransitionReason)), topics: \(Swift.String(describing: topics)), tumblingWindowInSeconds: \(Swift.String(describing: tumblingWindowInSeconds)), uUID: \(Swift.String(describing: uUID)))"}
}

extension DeleteEventSourceMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteEventSourceMappingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.eventSourceArn = output.eventSourceArn
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.selfManagedEventSource = output.selfManagedEventSource
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uUID = output.uUID
        } else {
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.eventSourceArn = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.selfManagedEventSource = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uUID = nil
        }
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see CreateEventSourceMapping.
public struct DeleteEventSourceMappingOutputResponse: Swift.Equatable {
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).
    ///          Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100.
    ///          Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Streams only) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: ClientRuntime.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// (Streams and Amazon SQS standard queues) The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function.
    ///          Default: 0
    ///          Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Streams only) Discard records older than the specified age. The default value is -1,
    /// which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records.
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Streams only) Discard records after the specified number of retries. The default value is -1,
    /// which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    ///  (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK stream sources. AT_TIMESTAMP is supported only for Amazon Kinesis
    ///       streams.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start
    ///       reading.
    public var startingPositionTimestamp: ClientRuntime.Date?
    /// The state of the event source mapping. It can be one of the following: Creating,
    ///         Enabling, Enabled, Disabling, Disabled,
    ///         Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Streams only) The duration in seconds of a processing window. The range is 1–900 seconds.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uUID: Swift.String?

    public init (
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        lastModified: ClientRuntime.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: ClientRuntime.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uUID: Swift.String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.eventSourceArn = eventSourceArn
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

struct DeleteEventSourceMappingOutputResponseBody: Swift.Equatable {
    public let uUID: Swift.String?
    public let startingPosition: LambdaClientTypes.EventSourcePosition?
    public let startingPositionTimestamp: ClientRuntime.Date?
    public let batchSize: Swift.Int?
    public let maximumBatchingWindowInSeconds: Swift.Int?
    public let parallelizationFactor: Swift.Int?
    public let eventSourceArn: Swift.String?
    public let functionArn: Swift.String?
    public let lastModified: ClientRuntime.Date?
    public let lastProcessingResult: Swift.String?
    public let state: Swift.String?
    public let stateTransitionReason: Swift.String?
    public let destinationConfig: LambdaClientTypes.DestinationConfig?
    public let topics: [Swift.String]?
    public let queues: [Swift.String]?
    public let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    public let selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    public let maximumRecordAgeInSeconds: Swift.Int?
    public let bisectBatchOnFunctionError: Swift.Bool?
    public let maximumRetryAttempts: Swift.Int?
    public let tumblingWindowInSeconds: Swift.Int?
    public let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
}

extension DeleteEventSourceMappingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case eventSourceArn = "EventSourceArn"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uUID = "UUID"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uUIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uUID)
        uUID = uUIDDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension DeleteFunctionCodeSigningConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFunctionCodeSigningConfigInput(functionName: \(Swift.String(describing: functionName)))"}
}

extension DeleteFunctionCodeSigningConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteFunctionCodeSigningConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFunctionCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFunctionCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionCodeSigningConfigOutputError>
}

public struct DeleteFunctionCodeSigningConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFunctionCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFunctionCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionCodeSigningConfigOutputError>
}

public struct DeleteFunctionCodeSigningConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionCodeSigningConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteFunctionCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFunctionCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionCodeSigningConfigOutputError>
}

public struct DeleteFunctionCodeSigningConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionCodeSigningConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteFunctionCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-06-30/functions/\(functionName.urlPercentEncoding())/code-signing-config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFunctionCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionCodeSigningConfigOutputError>
}

public struct DeleteFunctionCodeSigningConfigInput: Swift.Equatable {
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - MyFunction.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init (
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct DeleteFunctionCodeSigningConfigInputBody: Swift.Equatable {
}

extension DeleteFunctionCodeSigningConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeSigningConfigNotFoundException" : self = .codeSigningConfigNotFoundException(try CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case codeSigningConfigNotFoundException(CodeSigningConfigNotFoundException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionCodeSigningConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFunctionCodeSigningConfigOutputResponse()"}
}

extension DeleteFunctionCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionCodeSigningConfigOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFunctionCodeSigningConfigOutputResponseBody: Swift.Equatable {
}

extension DeleteFunctionCodeSigningConfigOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionConcurrencyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFunctionConcurrencyInput(functionName: \(Swift.String(describing: functionName)))"}
}

extension DeleteFunctionConcurrencyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteFunctionConcurrencyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionConcurrencyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFunctionConcurrencyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFunctionConcurrencyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionConcurrencyOutputError>
}

public struct DeleteFunctionConcurrencyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionConcurrencyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFunctionConcurrencyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFunctionConcurrencyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionConcurrencyOutputError>
}

public struct DeleteFunctionConcurrencyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionConcurrencyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteFunctionConcurrencyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFunctionConcurrencyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionConcurrencyOutputError>
}

public struct DeleteFunctionConcurrencyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionConcurrencyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteFunctionConcurrencyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2017-10-31/functions/\(functionName.urlPercentEncoding())/concurrency"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFunctionConcurrencyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionConcurrencyOutputError>
}

public struct DeleteFunctionConcurrencyInput: Swift.Equatable {
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init (
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct DeleteFunctionConcurrencyInputBody: Swift.Equatable {
}

extension DeleteFunctionConcurrencyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionConcurrencyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionConcurrencyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionConcurrencyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionConcurrencyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFunctionConcurrencyOutputResponse()"}
}

extension DeleteFunctionConcurrencyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionConcurrencyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFunctionConcurrencyOutputResponseBody: Swift.Equatable {
}

extension DeleteFunctionConcurrencyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionEventInvokeConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFunctionEventInvokeConfigInput(functionName: \(Swift.String(describing: functionName)), qualifier: \(Swift.String(describing: qualifier)))"}
}

extension DeleteFunctionEventInvokeConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteFunctionEventInvokeConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionEventInvokeConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFunctionEventInvokeConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionEventInvokeConfigOutputError>
}

public struct DeleteFunctionEventInvokeConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionEventInvokeConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFunctionEventInvokeConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionEventInvokeConfigOutputError>
}

public struct DeleteFunctionEventInvokeConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionEventInvokeConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteFunctionEventInvokeConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFunctionEventInvokeConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionEventInvokeConfigOutputError>
}

public struct DeleteFunctionEventInvokeConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionEventInvokeConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteFunctionEventInvokeConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFunctionEventInvokeConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionEventInvokeConfigOutputError>
}

public struct DeleteFunctionEventInvokeConfigInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct DeleteFunctionEventInvokeConfigInputBody: Swift.Equatable {
}

extension DeleteFunctionEventInvokeConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionEventInvokeConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionEventInvokeConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionEventInvokeConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionEventInvokeConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFunctionEventInvokeConfigOutputResponse()"}
}

extension DeleteFunctionEventInvokeConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionEventInvokeConfigOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFunctionEventInvokeConfigOutputResponseBody: Swift.Equatable {
}

extension DeleteFunctionEventInvokeConfigOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFunctionInput(functionName: \(Swift.String(describing: functionName)), qualifier: \(Swift.String(describing: qualifier)))"}
}

extension DeleteFunctionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInput: Swift.Equatable {
    /// The name of the Lambda function or version.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function (name-only), my-function:1 (with version).
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version to delete. You can't delete a version that's referenced by an alias.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct DeleteFunctionInputBody: Swift.Equatable {
}

extension DeleteFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFunctionOutputResponse()"}
}

extension DeleteFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFunctionOutputResponseBody: Swift.Equatable {
}

extension DeleteFunctionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLayerVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLayerVersionInput(layerName: \(Swift.String(describing: layerName)), versionNumber: \(Swift.String(describing: versionNumber)))"}
}

extension DeleteLayerVersionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteLayerVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLayerVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLayerVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLayerVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLayerVersionOutputError>
}

public struct DeleteLayerVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLayerVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLayerVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLayerVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLayerVersionOutputError>
}

public struct DeleteLayerVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLayerVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteLayerVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLayerVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLayerVersionOutputError>
}

public struct DeleteLayerVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLayerVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteLayerVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let layerName = input.layerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("layerName is nil and needs a value for the path of this operation"))))
        }
        let versionNumber = input.versionNumber
        var urlPath = "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLayerVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLayerVersionOutputError>
}

public struct DeleteLayerVersionInput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int

    public init (
        layerName: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

struct DeleteLayerVersionInputBody: Swift.Equatable {
}

extension DeleteLayerVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLayerVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLayerVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLayerVersionOutputError: Swift.Error, Swift.Equatable {
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLayerVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLayerVersionOutputResponse()"}
}

extension DeleteLayerVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLayerVersionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteLayerVersionOutputResponseBody: Swift.Equatable {
}

extension DeleteLayerVersionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProvisionedConcurrencyConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProvisionedConcurrencyConfigInput(functionName: \(Swift.String(describing: functionName)), qualifier: \(Swift.String(describing: qualifier)))"}
}

extension DeleteProvisionedConcurrencyConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteProvisionedConcurrencyConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProvisionedConcurrencyConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProvisionedConcurrencyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProvisionedConcurrencyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProvisionedConcurrencyConfigOutputError>
}

public struct DeleteProvisionedConcurrencyConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProvisionedConcurrencyConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProvisionedConcurrencyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProvisionedConcurrencyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProvisionedConcurrencyConfigOutputError>
}

public struct DeleteProvisionedConcurrencyConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProvisionedConcurrencyConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteProvisionedConcurrencyConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProvisionedConcurrencyConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProvisionedConcurrencyConfigOutputError>
}

public struct DeleteProvisionedConcurrencyConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProvisionedConcurrencyConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteProvisionedConcurrencyConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProvisionedConcurrencyConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProvisionedConcurrencyConfigOutputError>
}

public struct DeleteProvisionedConcurrencyConfigInput: Swift.Equatable {
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The version number or alias name.
    /// This member is required.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct DeleteProvisionedConcurrencyConfigInputBody: Swift.Equatable {
}

extension DeleteProvisionedConcurrencyConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProvisionedConcurrencyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProvisionedConcurrencyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProvisionedConcurrencyConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProvisionedConcurrencyConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProvisionedConcurrencyConfigOutputResponse()"}
}

extension DeleteProvisionedConcurrencyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProvisionedConcurrencyConfigOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteProvisionedConcurrencyConfigOutputResponseBody: Swift.Equatable {
}

extension DeleteProvisionedConcurrencyConfigOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension LambdaClientTypes.DestinationConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case onFailure = "OnFailure"
        case onSuccess = "OnSuccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onFailure = onFailure {
            try encodeContainer.encode(onFailure, forKey: .onFailure)
        }
        if let onSuccess = onSuccess {
            try encodeContainer.encode(onSuccess, forKey: .onSuccess)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onSuccessDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.OnSuccess.self, forKey: .onSuccess)
        onSuccess = onSuccessDecoded
        let onFailureDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.OnFailure.self, forKey: .onFailure)
        onFailure = onFailureDecoded
    }
}

extension LambdaClientTypes.DestinationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DestinationConfig(onFailure: \(Swift.String(describing: onFailure)), onSuccess: \(Swift.String(describing: onSuccess)))"}
}

extension LambdaClientTypes {
    /// A configuration object that specifies the destination of an event after Lambda processes it.
    public struct DestinationConfig: Swift.Equatable {
        /// The destination configuration for failed invocations.
        public var onFailure: LambdaClientTypes.OnFailure?
        /// The destination configuration for successful invocations.
        public var onSuccess: LambdaClientTypes.OnSuccess?

        public init (
            onFailure: LambdaClientTypes.OnFailure? = nil,
            onSuccess: LambdaClientTypes.OnSuccess? = nil
        )
        {
            self.onFailure = onFailure
            self.onSuccess = onSuccess
        }
    }

}

extension EC2AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EC2AccessDeniedException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension EC2AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EC2AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Need additional permissions to configure VPC settings.
public struct EC2AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EC2AccessDeniedExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension EC2AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EC2ThrottledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EC2ThrottledException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension EC2ThrottledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EC2ThrottledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda was throttled by Amazon EC2 during Lambda function initialization using the execution role provided
///       for the Lambda function.
public struct EC2ThrottledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EC2ThrottledExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension EC2ThrottledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EC2UnexpectedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EC2UnexpectedException(eC2ErrorCode: \(Swift.String(describing: eC2ErrorCode)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension EC2UnexpectedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EC2UnexpectedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.eC2ErrorCode = output.eC2ErrorCode
            self.message = output.message
            self.type = output.type
        } else {
            self.eC2ErrorCode = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda received an unexpected EC2 client exception while setting up for the Lambda function.
public struct EC2UnexpectedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var eC2ErrorCode: Swift.String?
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        eC2ErrorCode: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.eC2ErrorCode = eC2ErrorCode
        self.message = message
        self.type = type
    }
}

struct EC2UnexpectedExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
    public let eC2ErrorCode: Swift.String?
}

extension EC2UnexpectedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eC2ErrorCode = "EC2ErrorCode"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let eC2ErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2ErrorCode)
        eC2ErrorCode = eC2ErrorCodeDecoded
    }
}

extension EFSIOException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EFSIOException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension EFSIOException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EFSIOExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred when reading from or writing to a connected file system.
public struct EFSIOException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EFSIOExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension EFSIOExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSMountConnectivityException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EFSMountConnectivityException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension EFSMountConnectivityException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EFSMountConnectivityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The function couldn't make a network connection to the configured file system.
public struct EFSMountConnectivityException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EFSMountConnectivityExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension EFSMountConnectivityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSMountFailureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EFSMountFailureException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension EFSMountFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EFSMountFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The function couldn't mount the configured file system due to a permission or configuration issue.
public struct EFSMountFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EFSMountFailureExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension EFSMountFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSMountTimeoutException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EFSMountTimeoutException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension EFSMountTimeoutException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EFSMountTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The function was able to make a network connection to the configured file system, but the mount operation
///       timed out.
public struct EFSMountTimeoutException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EFSMountTimeoutExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension EFSMountTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ENILimitReachedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ENILimitReachedException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension ENILimitReachedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ENILimitReachedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda was not able to create an elastic network interface in the VPC, specified as part of Lambda
///       function configuration, because the limit for network interfaces has been reached.
public struct ENILimitReachedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ENILimitReachedExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension ENILimitReachedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum EndPointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kafkaBootstrapServers
        case sdkUnknown(Swift.String)

        public static var allCases: [EndPointType] {
            return [
                .kafkaBootstrapServers,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kafkaBootstrapServers: return "KAFKA_BOOTSTRAP_SERVERS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndPointType(rawValue: rawValue) ?? EndPointType.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.Environment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case variables = "Variables"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, environmentvariables0) in variables {
                try variablesContainer.encode(environmentvariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, environmentvariablevalue0) in variablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    variablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        variables = variablesDecoded0
    }
}

extension LambdaClientTypes.Environment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Environment(variables: \(Swift.String(describing: variables)))"}
}

extension LambdaClientTypes {
    /// A function's environment variable settings.
    ///     You can use environment variables to adjust your function's behavior without updating code.
    ///     An environment variable is a pair of strings that are stored in a function's version-specific configuration.
    public struct Environment: Swift.Equatable {
        /// Environment variable key-value pairs. For more information, see
        ///     <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">Using Lambda environment variables.
        public var variables: [Swift.String:Swift.String]?

        public init (
            variables: [Swift.String:Swift.String]? = nil
        )
        {
            self.variables = variables
        }
    }

}

extension LambdaClientTypes.EnvironmentError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.EnvironmentError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentError(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension LambdaClientTypes {
    /// Error messages for environment variables that couldn't be applied.
    public struct EnvironmentError: Swift.Equatable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
        }
    }

}

extension LambdaClientTypes.EnvironmentResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case variables = "Variables"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, environmentvariables0) in variables {
                try variablesContainer.encode(environmentvariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, environmentvariablevalue0) in variablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    variablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        variables = variablesDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LambdaClientTypes.EnvironmentResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentResponse(error: \(Swift.String(describing: error)), variables: \(Swift.String(describing: variables)))"}
}

extension LambdaClientTypes {
    /// The results of an operation to update or read environment variables. If the operation is successful, the
    ///       response contains the environment variables. If it failed, the response contains details about the error.
    public struct EnvironmentResponse: Swift.Equatable {
        /// Error messages for environment variables that couldn't be applied.
        public var error: LambdaClientTypes.EnvironmentError?
        /// Environment variable key-value pairs.
        public var variables: [Swift.String:Swift.String]?

        public init (
            error: LambdaClientTypes.EnvironmentError? = nil,
            variables: [Swift.String:Swift.String]? = nil
        )
        {
            self.error = error
            self.variables = variables
        }
    }

}

extension LambdaClientTypes.EventSourceMappingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case eventSourceArn = "EventSourceArn"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uUID = "UUID"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSize = batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let bisectBatchOnFunctionError = bisectBatchOnFunctionError {
            try encodeContainer.encode(bisectBatchOnFunctionError, forKey: .bisectBatchOnFunctionError)
        }
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionResponseTypes = functionResponseTypes {
            var functionResponseTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionResponseTypes)
            for functionresponsetypelist0 in functionResponseTypes {
                try functionResponseTypesContainer.encode(functionresponsetypelist0.rawValue)
            }
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let lastProcessingResult = lastProcessingResult {
            try encodeContainer.encode(lastProcessingResult, forKey: .lastProcessingResult)
        }
        if let maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds {
            try encodeContainer.encode(maximumBatchingWindowInSeconds, forKey: .maximumBatchingWindowInSeconds)
        }
        if let maximumRecordAgeInSeconds = maximumRecordAgeInSeconds {
            try encodeContainer.encode(maximumRecordAgeInSeconds, forKey: .maximumRecordAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
        if let parallelizationFactor = parallelizationFactor {
            try encodeContainer.encode(parallelizationFactor, forKey: .parallelizationFactor)
        }
        if let queues = queues {
            var queuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queues)
            for queues0 in queues {
                try queuesContainer.encode(queues0)
            }
        }
        if let selfManagedEventSource = selfManagedEventSource {
            try encodeContainer.encode(selfManagedEventSource, forKey: .selfManagedEventSource)
        }
        if let sourceAccessConfigurations = sourceAccessConfigurations {
            var sourceAccessConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceAccessConfigurations)
            for sourceaccessconfigurations0 in sourceAccessConfigurations {
                try sourceAccessConfigurationsContainer.encode(sourceaccessconfigurations0)
            }
        }
        if let startingPosition = startingPosition {
            try encodeContainer.encode(startingPosition.rawValue, forKey: .startingPosition)
        }
        if let startingPositionTimestamp = startingPositionTimestamp {
            try encodeContainer.encode(startingPositionTimestamp.timeIntervalSince1970, forKey: .startingPositionTimestamp)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let stateTransitionReason = stateTransitionReason {
            try encodeContainer.encode(stateTransitionReason, forKey: .stateTransitionReason)
        }
        if let topics = topics {
            var topicsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topics)
            for topics0 in topics {
                try topicsContainer.encode(topics0)
            }
        }
        if let tumblingWindowInSeconds = tumblingWindowInSeconds {
            try encodeContainer.encode(tumblingWindowInSeconds, forKey: .tumblingWindowInSeconds)
        }
        if let uUID = uUID {
            try encodeContainer.encode(uUID, forKey: .uUID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uUIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uUID)
        uUID = uUIDDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension LambdaClientTypes.EventSourceMappingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventSourceMappingConfiguration(batchSize: \(Swift.String(describing: batchSize)), bisectBatchOnFunctionError: \(Swift.String(describing: bisectBatchOnFunctionError)), destinationConfig: \(Swift.String(describing: destinationConfig)), eventSourceArn: \(Swift.String(describing: eventSourceArn)), functionArn: \(Swift.String(describing: functionArn)), functionResponseTypes: \(Swift.String(describing: functionResponseTypes)), lastModified: \(Swift.String(describing: lastModified)), lastProcessingResult: \(Swift.String(describing: lastProcessingResult)), maximumBatchingWindowInSeconds: \(Swift.String(describing: maximumBatchingWindowInSeconds)), maximumRecordAgeInSeconds: \(Swift.String(describing: maximumRecordAgeInSeconds)), maximumRetryAttempts: \(Swift.String(describing: maximumRetryAttempts)), parallelizationFactor: \(Swift.String(describing: parallelizationFactor)), queues: \(Swift.String(describing: queues)), selfManagedEventSource: \(Swift.String(describing: selfManagedEventSource)), sourceAccessConfigurations: \(Swift.String(describing: sourceAccessConfigurations)), startingPosition: \(Swift.String(describing: startingPosition)), startingPositionTimestamp: \(Swift.String(describing: startingPositionTimestamp)), state: \(Swift.String(describing: state)), stateTransitionReason: \(Swift.String(describing: stateTransitionReason)), topics: \(Swift.String(describing: topics)), tumblingWindowInSeconds: \(Swift.String(describing: tumblingWindowInSeconds)), uUID: \(Swift.String(describing: uUID)))"}
}

extension LambdaClientTypes {
    /// A mapping between an Amazon Web Services resource and a Lambda function. For details, see CreateEventSourceMapping.
    public struct EventSourceMappingConfiguration: Swift.Equatable {
        /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).
        ///          Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100.
        ///          Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
        public var batchSize: Swift.Int?
        /// (Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
        public var bisectBatchOnFunctionError: Swift.Bool?
        /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
        public var destinationConfig: LambdaClientTypes.DestinationConfig?
        /// The Amazon Resource Name (ARN) of the event source.
        public var eventSourceArn: Swift.String?
        /// The ARN of the Lambda function.
        public var functionArn: Swift.String?
        /// (Streams only) A list of current response type enums applied to the event source mapping.
        public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
        /// The date that the event source mapping was last updated or that its state changed.
        public var lastModified: ClientRuntime.Date?
        /// The result of the last Lambda invocation of your function.
        public var lastProcessingResult: Swift.String?
        /// (Streams and Amazon SQS standard queues) The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function.
        ///          Default: 0
        ///          Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
        public var maximumBatchingWindowInSeconds: Swift.Int?
        /// (Streams only) Discard records older than the specified age. The default value is -1,
        /// which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records.
        public var maximumRecordAgeInSeconds: Swift.Int?
        /// (Streams only) Discard records after the specified number of retries. The default value is -1,
        /// which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
        public var maximumRetryAttempts: Swift.Int?
        /// (Streams only) The number of batches to process concurrently from each shard. The default value is 1.
        public var parallelizationFactor: Swift.Int?
        ///  (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
        public var queues: [Swift.String]?
        /// The self-managed Apache Kafka cluster for your event source.
        public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
        /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
        public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
        /// The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK stream sources. AT_TIMESTAMP is supported only for Amazon Kinesis
        ///       streams.
        public var startingPosition: LambdaClientTypes.EventSourcePosition?
        /// With StartingPosition set to AT_TIMESTAMP, the time from which to start
        ///       reading.
        public var startingPositionTimestamp: ClientRuntime.Date?
        /// The state of the event source mapping. It can be one of the following: Creating,
        ///         Enabling, Enabled, Disabling, Disabled,
        ///         Updating, or Deleting.
        public var state: Swift.String?
        /// Indicates whether a user or Lambda made the last change to the event source mapping.
        public var stateTransitionReason: Swift.String?
        /// The name of the Kafka topic.
        public var topics: [Swift.String]?
        /// (Streams only) The duration in seconds of a processing window. The range is 1–900 seconds.
        public var tumblingWindowInSeconds: Swift.Int?
        /// The identifier of the event source mapping.
        public var uUID: Swift.String?

        public init (
            batchSize: Swift.Int? = nil,
            bisectBatchOnFunctionError: Swift.Bool? = nil,
            destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
            eventSourceArn: Swift.String? = nil,
            functionArn: Swift.String? = nil,
            functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
            lastModified: ClientRuntime.Date? = nil,
            lastProcessingResult: Swift.String? = nil,
            maximumBatchingWindowInSeconds: Swift.Int? = nil,
            maximumRecordAgeInSeconds: Swift.Int? = nil,
            maximumRetryAttempts: Swift.Int? = nil,
            parallelizationFactor: Swift.Int? = nil,
            queues: [Swift.String]? = nil,
            selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
            sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
            startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
            startingPositionTimestamp: ClientRuntime.Date? = nil,
            state: Swift.String? = nil,
            stateTransitionReason: Swift.String? = nil,
            topics: [Swift.String]? = nil,
            tumblingWindowInSeconds: Swift.Int? = nil,
            uUID: Swift.String? = nil
        )
        {
            self.batchSize = batchSize
            self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
            self.destinationConfig = destinationConfig
            self.eventSourceArn = eventSourceArn
            self.functionArn = functionArn
            self.functionResponseTypes = functionResponseTypes
            self.lastModified = lastModified
            self.lastProcessingResult = lastProcessingResult
            self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
            self.parallelizationFactor = parallelizationFactor
            self.queues = queues
            self.selfManagedEventSource = selfManagedEventSource
            self.sourceAccessConfigurations = sourceAccessConfigurations
            self.startingPosition = startingPosition
            self.startingPositionTimestamp = startingPositionTimestamp
            self.state = state
            self.stateTransitionReason = stateTransitionReason
            self.topics = topics
            self.tumblingWindowInSeconds = tumblingWindowInSeconds
            self.uUID = uUID
        }
    }

}

extension LambdaClientTypes {
    public enum EventSourcePosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case atTimestamp
        case latest
        case trimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSourcePosition] {
            return [
                .atTimestamp,
                .latest,
                .trimHorizon,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .atTimestamp: return "AT_TIMESTAMP"
            case .latest: return "LATEST"
            case .trimHorizon: return "TRIM_HORIZON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventSourcePosition(rawValue: rawValue) ?? EventSourcePosition.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.FileSystemConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case localMountPath = "LocalMountPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let localMountPath = localMountPath {
            try encodeContainer.encode(localMountPath, forKey: .localMountPath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let localMountPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localMountPath)
        localMountPath = localMountPathDecoded
    }
}

extension LambdaClientTypes.FileSystemConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FileSystemConfig(arn: \(Swift.String(describing: arn)), localMountPath: \(Swift.String(describing: localMountPath)))"}
}

extension LambdaClientTypes {
    /// Details about the connection between a Lambda function and an
    ///       <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html">Amazon EFS file system.
    public struct FileSystemConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        /// This member is required.
        public var arn: Swift.String?
        /// The path where the function can access the file system, starting with /mnt/.
        /// This member is required.
        public var localMountPath: Swift.String?

        public init (
            arn: Swift.String? = nil,
            localMountPath: Swift.String? = nil
        )
        {
            self.arn = arn
            self.localMountPath = localMountPath
        }
    }

}

extension LambdaClientTypes.FunctionCode: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageUri = "ImageUri"
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageUri = imageUri {
            try encodeContainer.encode(imageUri, forKey: .imageUri)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3ObjectVersion = s3ObjectVersion {
            try encodeContainer.encode(s3ObjectVersion, forKey: .s3ObjectVersion)
        }
        if let zipFile = zipFile {
            try encodeContainer.encode(zipFile.base64EncodedString(), forKey: .zipFile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zipFileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .zipFile)
        zipFile = zipFileDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectVersion)
        s3ObjectVersion = s3ObjectVersionDecoded
        let imageUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUri)
        imageUri = imageUriDecoded
    }
}

extension LambdaClientTypes.FunctionCode: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionCode(imageUri: \(Swift.String(describing: imageUri)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)), s3ObjectVersion: \(Swift.String(describing: s3ObjectVersion)), zipFile: \(Swift.String(describing: zipFile)))"}
}

extension LambdaClientTypes {
    /// The code for the Lambda function. You can specify either an object in Amazon S3, upload a .zip file archive deployment
    ///       package directly, or specify the URI of a container image.
    public struct FunctionCode: Swift.Equatable {
        /// URI of a <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html">container image in the Amazon ECR registry.
        public var imageUri: Swift.String?
        /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key of the deployment package.
        public var s3Key: Swift.String?
        /// For versioned objects, the version of the deployment package object to use.
        public var s3ObjectVersion: Swift.String?
        /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for
        ///   you.
        public var zipFile: ClientRuntime.Data?

        public init (
            imageUri: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            s3ObjectVersion: Swift.String? = nil,
            zipFile: ClientRuntime.Data? = nil
        )
        {
            self.imageUri = imageUri
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }
    }

}

extension LambdaClientTypes.FunctionCodeLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageUri = "ImageUri"
        case location = "Location"
        case repositoryType = "RepositoryType"
        case resolvedImageUri = "ResolvedImageUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageUri = imageUri {
            try encodeContainer.encode(imageUri, forKey: .imageUri)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let repositoryType = repositoryType {
            try encodeContainer.encode(repositoryType, forKey: .repositoryType)
        }
        if let resolvedImageUri = resolvedImageUri {
            try encodeContainer.encode(resolvedImageUri, forKey: .resolvedImageUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryType)
        repositoryType = repositoryTypeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let imageUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUri)
        imageUri = imageUriDecoded
        let resolvedImageUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolvedImageUri)
        resolvedImageUri = resolvedImageUriDecoded
    }
}

extension LambdaClientTypes.FunctionCodeLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionCodeLocation(imageUri: \(Swift.String(describing: imageUri)), location: \(Swift.String(describing: location)), repositoryType: \(Swift.String(describing: repositoryType)), resolvedImageUri: \(Swift.String(describing: resolvedImageUri)))"}
}

extension LambdaClientTypes {
    /// Details about a function's deployment package.
    public struct FunctionCodeLocation: Swift.Equatable {
        /// URI of a container image in the Amazon ECR registry.
        public var imageUri: Swift.String?
        /// A presigned URL that you can use to download the deployment package.
        public var location: Swift.String?
        /// The service that's hosting the file.
        public var repositoryType: Swift.String?
        /// The resolved URI for the image.
        public var resolvedImageUri: Swift.String?

        public init (
            imageUri: Swift.String? = nil,
            location: Swift.String? = nil,
            repositoryType: Swift.String? = nil,
            resolvedImageUri: Swift.String? = nil
        )
        {
            self.imageUri = imageUri
            self.location = location
            self.repositoryType = repositoryType
            self.resolvedImageUri = resolvedImageUri
        }
    }

}

extension LambdaClientTypes.FunctionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architectureslist0 in architectures {
                try architecturesContainer.encode(architectureslist0.rawValue)
            }
        }
        if let codeSha256 = codeSha256 {
            try encodeContainer.encode(codeSha256, forKey: .codeSha256)
        }
        if codeSize != 0 {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let deadLetterConfig = deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemConfigs = fileSystemConfigs {
            var fileSystemConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemConfigs)
            for filesystemconfiglist0 in fileSystemConfigs {
                try fileSystemConfigsContainer.encode(filesystemconfiglist0)
            }
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let handler = handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let imageConfigResponse = imageConfigResponse {
            try encodeContainer.encode(imageConfigResponse, forKey: .imageConfigResponse)
        }
        if let kMSKeyArn = kMSKeyArn {
            try encodeContainer.encode(kMSKeyArn, forKey: .kMSKeyArn)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
        if let lastUpdateStatus = lastUpdateStatus {
            try encodeContainer.encode(lastUpdateStatus.rawValue, forKey: .lastUpdateStatus)
        }
        if let lastUpdateStatusReason = lastUpdateStatusReason {
            try encodeContainer.encode(lastUpdateStatusReason, forKey: .lastUpdateStatusReason)
        }
        if let lastUpdateStatusReasonCode = lastUpdateStatusReasonCode {
            try encodeContainer.encode(lastUpdateStatusReasonCode.rawValue, forKey: .lastUpdateStatusReasonCode)
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for layersreferencelist0 in layers {
                try layersContainer.encode(layersreferencelist0)
            }
        }
        if let masterArn = masterArn {
            try encodeContainer.encode(masterArn, forKey: .masterArn)
        }
        if let memorySize = memorySize {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let packageType = packageType {
            try encodeContainer.encode(packageType.rawValue, forKey: .packageType)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let runtime = runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let signingJobArn = signingJobArn {
            try encodeContainer.encode(signingJobArn, forKey: .signingJobArn)
        }
        if let signingProfileVersionArn = signingProfileVersionArn {
            try encodeContainer.encode(signingProfileVersionArn, forKey: .signingProfileVersionArn)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
        if let stateReasonCode = stateReasonCode {
            try encodeContainer.encode(stateReasonCode.rawValue, forKey: .stateReasonCode)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tracingConfig = tracingConfig {
            try encodeContainer.encode(tracingConfig, forKey: .tracingConfig)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

extension LambdaClientTypes.FunctionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionConfiguration(architectures: \(Swift.String(describing: architectures)), codeSha256: \(Swift.String(describing: codeSha256)), codeSize: \(Swift.String(describing: codeSize)), deadLetterConfig: \(Swift.String(describing: deadLetterConfig)), description: \(Swift.String(describing: description)), environment: \(Swift.String(describing: environment)), fileSystemConfigs: \(Swift.String(describing: fileSystemConfigs)), functionArn: \(Swift.String(describing: functionArn)), functionName: \(Swift.String(describing: functionName)), handler: \(Swift.String(describing: handler)), imageConfigResponse: \(Swift.String(describing: imageConfigResponse)), kMSKeyArn: \(Swift.String(describing: kMSKeyArn)), lastModified: \(Swift.String(describing: lastModified)), lastUpdateStatus: \(Swift.String(describing: lastUpdateStatus)), lastUpdateStatusReason: \(Swift.String(describing: lastUpdateStatusReason)), lastUpdateStatusReasonCode: \(Swift.String(describing: lastUpdateStatusReasonCode)), layers: \(Swift.String(describing: layers)), masterArn: \(Swift.String(describing: masterArn)), memorySize: \(Swift.String(describing: memorySize)), packageType: \(Swift.String(describing: packageType)), revisionId: \(Swift.String(describing: revisionId)), role: \(Swift.String(describing: role)), runtime: \(Swift.String(describing: runtime)), signingJobArn: \(Swift.String(describing: signingJobArn)), signingProfileVersionArn: \(Swift.String(describing: signingProfileVersionArn)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)), stateReasonCode: \(Swift.String(describing: stateReasonCode)), timeout: \(Swift.String(describing: timeout)), tracingConfig: \(Swift.String(describing: tracingConfig)), version: \(Swift.String(describing: version)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension LambdaClientTypes {
    /// Details about a function's configuration.
    public struct FunctionConfiguration: Swift.Equatable {
        /// The instruction set architecture that the function supports. Architecture is a string array with one of the
        ///       valid values. The default architecture value is x86_64.
        public var architectures: [LambdaClientTypes.Architecture]?
        /// The SHA256 hash of the function's deployment package.
        public var codeSha256: Swift.String?
        /// The size of the function's deployment package, in bytes.
        public var codeSize: Swift.Int
        /// The function's dead letter queue.
        public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
        /// The function's description.
        public var description: Swift.String?
        /// The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">environment variables.
        public var environment: LambdaClientTypes.EnvironmentResponse?
        /// Connection settings for an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html">Amazon EFS file system.
        public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
        /// The function's Amazon Resource Name (ARN).
        public var functionArn: Swift.String?
        /// The name of the function.
        public var functionName: Swift.String?
        /// The function that Lambda calls to begin executing your function.
        public var handler: Swift.String?
        /// The function's image configuration values.
        public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
        /// The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
        ///       configured a customer managed CMK.
        public var kMSKeyArn: Swift.String?
        /// The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
        public var lastModified: Swift.String?
        /// The status of the last update that was performed on the function. This is first set to Successful
        ///       after function creation completes.
        public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
        /// The reason for the last update that was performed on the function.
        public var lastUpdateStatusReason: Swift.String?
        /// The reason code for the last update that was performed on the function.
        public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
        /// The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
        ///       layers.
        public var layers: [LambdaClientTypes.Layer]?
        /// For Lambda@Edge functions, the ARN of the master function.
        public var masterArn: Swift.String?
        /// The amount of memory available to the function at runtime.
        public var memorySize: Swift.Int?
        /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
        public var packageType: LambdaClientTypes.PackageType?
        /// The latest updated revision of the function or alias.
        public var revisionId: Swift.String?
        /// The function's execution role.
        public var role: Swift.String?
        /// The runtime environment for the Lambda function.
        public var runtime: LambdaClientTypes.Runtime?
        /// The ARN of the signing job.
        public var signingJobArn: Swift.String?
        /// The ARN of the signing profile version.
        public var signingProfileVersionArn: Swift.String?
        /// The current state of the function. When the state is Inactive, you can reactivate the function by
        ///       invoking it.
        public var state: LambdaClientTypes.State?
        /// The reason for the function's current state.
        public var stateReason: Swift.String?
        /// The reason code for the function's current state. When the code is Creating, you can't invoke or
        ///       modify the function.
        public var stateReasonCode: LambdaClientTypes.StateReasonCode?
        /// The amount of time in seconds that Lambda allows a function to run before stopping it.
        public var timeout: Swift.Int?
        /// The function's X-Ray tracing configuration.
        public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
        /// The version of the Lambda function.
        public var version: Swift.String?
        /// The function's networking configuration.
        public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

        public init (
            architectures: [LambdaClientTypes.Architecture]? = nil,
            codeSha256: Swift.String? = nil,
            codeSize: Swift.Int = 0,
            deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
            description: Swift.String? = nil,
            environment: LambdaClientTypes.EnvironmentResponse? = nil,
            fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
            functionArn: Swift.String? = nil,
            functionName: Swift.String? = nil,
            handler: Swift.String? = nil,
            imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
            kMSKeyArn: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
            lastUpdateStatusReason: Swift.String? = nil,
            lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
            layers: [LambdaClientTypes.Layer]? = nil,
            masterArn: Swift.String? = nil,
            memorySize: Swift.Int? = nil,
            packageType: LambdaClientTypes.PackageType? = nil,
            revisionId: Swift.String? = nil,
            role: Swift.String? = nil,
            runtime: LambdaClientTypes.Runtime? = nil,
            signingJobArn: Swift.String? = nil,
            signingProfileVersionArn: Swift.String? = nil,
            state: LambdaClientTypes.State? = nil,
            stateReason: Swift.String? = nil,
            stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
            timeout: Swift.Int? = nil,
            tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
            version: Swift.String? = nil,
            vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
        )
        {
            self.architectures = architectures
            self.codeSha256 = codeSha256
            self.codeSize = codeSize
            self.deadLetterConfig = deadLetterConfig
            self.description = description
            self.environment = environment
            self.fileSystemConfigs = fileSystemConfigs
            self.functionArn = functionArn
            self.functionName = functionName
            self.handler = handler
            self.imageConfigResponse = imageConfigResponse
            self.kMSKeyArn = kMSKeyArn
            self.lastModified = lastModified
            self.lastUpdateStatus = lastUpdateStatus
            self.lastUpdateStatusReason = lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
            self.layers = layers
            self.masterArn = masterArn
            self.memorySize = memorySize
            self.packageType = packageType
            self.revisionId = revisionId
            self.role = role
            self.runtime = runtime
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
            self.state = state
            self.stateReason = stateReason
            self.stateReasonCode = stateReasonCode
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.version = version
            self.vpcConfig = vpcConfig
        }
    }

}

extension LambdaClientTypes.FunctionEventInvokeConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let maximumEventAgeInSeconds = maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension LambdaClientTypes.FunctionEventInvokeConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionEventInvokeConfig(destinationConfig: \(Swift.String(describing: destinationConfig)), functionArn: \(Swift.String(describing: functionArn)), lastModified: \(Swift.String(describing: lastModified)), maximumEventAgeInSeconds: \(Swift.String(describing: maximumEventAgeInSeconds)), maximumRetryAttempts: \(Swift.String(describing: maximumRetryAttempts)))"}
}

extension LambdaClientTypes {
    public struct FunctionEventInvokeConfig: Swift.Equatable {
        /// A destination for events after they have been sent to a function for processing.
        ///          <p class="title">
        ///             Destinations
        ///
        ///
        ///
        ///
        ///                   Function - The Amazon Resource Name (ARN) of a Lambda function.
        ///
        ///
        ///
        ///                   Queue - The ARN of an SQS queue.
        ///
        ///
        ///
        ///                   Topic - The ARN of an SNS topic.
        ///
        ///
        ///
        ///                   Event Bus - The ARN of an Amazon EventBridge event bus.
        ///
        ///
        public var destinationConfig: LambdaClientTypes.DestinationConfig?
        /// The Amazon Resource Name (ARN) of the function.
        public var functionArn: Swift.String?
        /// The date and time that the configuration was last updated.
        public var lastModified: ClientRuntime.Date?
        /// The maximum age of a request that Lambda sends to a function for processing.
        public var maximumEventAgeInSeconds: Swift.Int?
        /// The maximum number of times to retry when the function returns an error.
        public var maximumRetryAttempts: Swift.Int?

        public init (
            destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
            functionArn: Swift.String? = nil,
            lastModified: ClientRuntime.Date? = nil,
            maximumEventAgeInSeconds: Swift.Int? = nil,
            maximumRetryAttempts: Swift.Int? = nil
        )
        {
            self.destinationConfig = destinationConfig
            self.functionArn = functionArn
            self.lastModified = lastModified
            self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
        }
    }

}

extension LambdaClientTypes {
    public enum FunctionResponseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case reportbatchitemfailures
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionResponseType] {
            return [
                .reportbatchitemfailures,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .reportbatchitemfailures: return "ReportBatchItemFailures"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionResponseType(rawValue: rawValue) ?? FunctionResponseType.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes {
    public enum FunctionVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionVersion] {
            return [
                .all,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionVersion(rawValue: rawValue) ?? FunctionVersion.sdkUnknown(rawValue)
        }
    }
}

extension GetAccountSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccountSettingsInput()"}
}

extension GetAccountSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAccountSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccountSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccountSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccountSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccountSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAccountSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccountSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAccountSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2016-08-19/account-settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccountSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInput: Swift.Equatable {

    public init() {}
}

struct GetAccountSettingsInputBody: Swift.Equatable {
}

extension GetAccountSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountSettingsOutputError: Swift.Error, Swift.Equatable {
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccountSettingsOutputResponse(accountLimit: \(Swift.String(describing: accountLimit)), accountUsage: \(Swift.String(describing: accountUsage)))"}
}

extension GetAccountSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountLimit = output.accountLimit
            self.accountUsage = output.accountUsage
        } else {
            self.accountLimit = nil
            self.accountUsage = nil
        }
    }
}

public struct GetAccountSettingsOutputResponse: Swift.Equatable {
    /// Limits that are related to concurrency and code storage.
    public var accountLimit: LambdaClientTypes.AccountLimit?
    /// The number of functions and amount of storage in use.
    public var accountUsage: LambdaClientTypes.AccountUsage?

    public init (
        accountLimit: LambdaClientTypes.AccountLimit? = nil,
        accountUsage: LambdaClientTypes.AccountUsage? = nil
    )
    {
        self.accountLimit = accountLimit
        self.accountUsage = accountUsage
    }
}

struct GetAccountSettingsOutputResponseBody: Swift.Equatable {
    public let accountLimit: LambdaClientTypes.AccountLimit?
    public let accountUsage: LambdaClientTypes.AccountUsage?
}

extension GetAccountSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountLimit = "AccountLimit"
        case accountUsage = "AccountUsage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountLimitDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AccountLimit.self, forKey: .accountLimit)
        accountLimit = accountLimitDecoded
        let accountUsageDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AccountUsage.self, forKey: .accountUsage)
        accountUsage = accountUsageDecoded
    }
}

extension GetAliasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAliasInput(functionName: \(Swift.String(describing: functionName)), name: \(Swift.String(describing: name)))"}
}

extension GetAliasInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAliasInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAliasOutputError>
}

public struct GetAliasInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAliasOutputError>
}

public struct GetAliasInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAliasInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAliasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAliasInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAliasOutputError>
}

public struct GetAliasInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAliasInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAliasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases/\(name.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAliasInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAliasOutputError>
}

public struct GetAliasInput: Swift.Equatable {
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - MyFunction.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.name = name
    }
}

struct GetAliasInputBody: Swift.Equatable {
}

extension GetAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAliasOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAliasOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAliasOutputResponse(aliasArn: \(Swift.String(describing: aliasArn)), description: \(Swift.String(describing: description)), functionVersion: \(Swift.String(describing: functionVersion)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), routingConfig: \(Swift.String(describing: routingConfig)))"}
}

extension GetAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliasArn = output.aliasArn
            self.description = output.description
            self.functionVersion = output.functionVersion
            self.name = output.name
            self.revisionId = output.revisionId
            self.routingConfig = output.routingConfig
        } else {
            self.aliasArn = nil
            self.description = nil
            self.functionVersion = nil
            self.name = nil
            self.revisionId = nil
            self.routingConfig = nil
        }
    }
}

/// Provides configuration information about a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias.
public struct GetAliasOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the alias.
    public var aliasArn: Swift.String?
    /// A description of the alias.
    public var description: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    public var name: Swift.String?
    /// A unique identifier that changes when you update the alias.
    public var revisionId: Swift.String?
    /// The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">routing
    ///         configuration of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init (
        aliasArn: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct GetAliasOutputResponseBody: Swift.Equatable {
    public let aliasArn: Swift.String?
    public let name: Swift.String?
    public let functionVersion: Swift.String?
    public let description: Swift.String?
    public let routingConfig: LambdaClientTypes.AliasRoutingConfiguration?
    public let revisionId: Swift.String?
}

extension GetAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetCodeSigningConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCodeSigningConfigInput(codeSigningConfigArn: \(Swift.String(describing: codeSigningConfigArn)))"}
}

extension GetCodeSigningConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCodeSigningConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCodeSigningConfigOutputError>
}

public struct GetCodeSigningConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCodeSigningConfigOutputError>
}

public struct GetCodeSigningConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCodeSigningConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCodeSigningConfigOutputError>
}

public struct GetCodeSigningConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCodeSigningConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let codeSigningConfigArn = input.codeSigningConfigArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("codeSigningConfigArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCodeSigningConfigOutputError>
}

public struct GetCodeSigningConfigInput: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?

    public init (
        codeSigningConfigArn: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
    }
}

struct GetCodeSigningConfigInputBody: Swift.Equatable {
}

extension GetCodeSigningConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCodeSigningConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCodeSigningConfigOutputResponse(codeSigningConfig: \(Swift.String(describing: codeSigningConfig)))"}
}

extension GetCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfig = output.codeSigningConfig
        } else {
            self.codeSigningConfig = nil
        }
    }
}

public struct GetCodeSigningConfigOutputResponse: Swift.Equatable {
    /// The code signing configuration
    /// This member is required.
    public var codeSigningConfig: LambdaClientTypes.CodeSigningConfig?

    public init (
        codeSigningConfig: LambdaClientTypes.CodeSigningConfig? = nil
    )
    {
        self.codeSigningConfig = codeSigningConfig
    }
}

struct GetCodeSigningConfigOutputResponseBody: Swift.Equatable {
    public let codeSigningConfig: LambdaClientTypes.CodeSigningConfig?
}

extension GetCodeSigningConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfig = "CodeSigningConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningConfig.self, forKey: .codeSigningConfig)
        codeSigningConfig = codeSigningConfigDecoded
    }
}

extension GetEventSourceMappingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEventSourceMappingInput(uUID: \(Swift.String(describing: uUID)))"}
}

extension GetEventSourceMappingInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetEventSourceMappingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventSourceMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEventSourceMappingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEventSourceMappingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventSourceMappingOutputError>
}

public struct GetEventSourceMappingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventSourceMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEventSourceMappingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEventSourceMappingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventSourceMappingOutputError>
}

public struct GetEventSourceMappingInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventSourceMappingInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetEventSourceMappingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEventSourceMappingInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventSourceMappingOutputError>
}

public struct GetEventSourceMappingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventSourceMappingInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetEventSourceMappingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let uUID = input.uUID else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("uUID is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/event-source-mappings/\(uUID.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEventSourceMappingInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventSourceMappingOutputError>
}

public struct GetEventSourceMappingInput: Swift.Equatable {
    /// The identifier of the event source mapping.
    /// This member is required.
    public var uUID: Swift.String?

    public init (
        uUID: Swift.String? = nil
    )
    {
        self.uUID = uUID
    }
}

struct GetEventSourceMappingInputBody: Swift.Equatable {
}

extension GetEventSourceMappingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEventSourceMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventSourceMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEventSourceMappingOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventSourceMappingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEventSourceMappingOutputResponse(batchSize: \(Swift.String(describing: batchSize)), bisectBatchOnFunctionError: \(Swift.String(describing: bisectBatchOnFunctionError)), destinationConfig: \(Swift.String(describing: destinationConfig)), eventSourceArn: \(Swift.String(describing: eventSourceArn)), functionArn: \(Swift.String(describing: functionArn)), functionResponseTypes: \(Swift.String(describing: functionResponseTypes)), lastModified: \(Swift.String(describing: lastModified)), lastProcessingResult: \(Swift.String(describing: lastProcessingResult)), maximumBatchingWindowInSeconds: \(Swift.String(describing: maximumBatchingWindowInSeconds)), maximumRecordAgeInSeconds: \(Swift.String(describing: maximumRecordAgeInSeconds)), maximumRetryAttempts: \(Swift.String(describing: maximumRetryAttempts)), parallelizationFactor: \(Swift.String(describing: parallelizationFactor)), queues: \(Swift.String(describing: queues)), selfManagedEventSource: \(Swift.String(describing: selfManagedEventSource)), sourceAccessConfigurations: \(Swift.String(describing: sourceAccessConfigurations)), startingPosition: \(Swift.String(describing: startingPosition)), startingPositionTimestamp: \(Swift.String(describing: startingPositionTimestamp)), state: \(Swift.String(describing: state)), stateTransitionReason: \(Swift.String(describing: stateTransitionReason)), topics: \(Swift.String(describing: topics)), tumblingWindowInSeconds: \(Swift.String(describing: tumblingWindowInSeconds)), uUID: \(Swift.String(describing: uUID)))"}
}

extension GetEventSourceMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEventSourceMappingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.eventSourceArn = output.eventSourceArn
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.selfManagedEventSource = output.selfManagedEventSource
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uUID = output.uUID
        } else {
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.eventSourceArn = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.selfManagedEventSource = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uUID = nil
        }
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see CreateEventSourceMapping.
public struct GetEventSourceMappingOutputResponse: Swift.Equatable {
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).
    ///          Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100.
    ///          Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Streams only) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: ClientRuntime.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// (Streams and Amazon SQS standard queues) The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function.
    ///          Default: 0
    ///          Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Streams only) Discard records older than the specified age. The default value is -1,
    /// which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records.
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Streams only) Discard records after the specified number of retries. The default value is -1,
    /// which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    ///  (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK stream sources. AT_TIMESTAMP is supported only for Amazon Kinesis
    ///       streams.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start
    ///       reading.
    public var startingPositionTimestamp: ClientRuntime.Date?
    /// The state of the event source mapping. It can be one of the following: Creating,
    ///         Enabling, Enabled, Disabling, Disabled,
    ///         Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Streams only) The duration in seconds of a processing window. The range is 1–900 seconds.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uUID: Swift.String?

    public init (
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        lastModified: ClientRuntime.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: ClientRuntime.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uUID: Swift.String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.eventSourceArn = eventSourceArn
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

struct GetEventSourceMappingOutputResponseBody: Swift.Equatable {
    public let uUID: Swift.String?
    public let startingPosition: LambdaClientTypes.EventSourcePosition?
    public let startingPositionTimestamp: ClientRuntime.Date?
    public let batchSize: Swift.Int?
    public let maximumBatchingWindowInSeconds: Swift.Int?
    public let parallelizationFactor: Swift.Int?
    public let eventSourceArn: Swift.String?
    public let functionArn: Swift.String?
    public let lastModified: ClientRuntime.Date?
    public let lastProcessingResult: Swift.String?
    public let state: Swift.String?
    public let stateTransitionReason: Swift.String?
    public let destinationConfig: LambdaClientTypes.DestinationConfig?
    public let topics: [Swift.String]?
    public let queues: [Swift.String]?
    public let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    public let selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    public let maximumRecordAgeInSeconds: Swift.Int?
    public let bisectBatchOnFunctionError: Swift.Bool?
    public let maximumRetryAttempts: Swift.Int?
    public let tumblingWindowInSeconds: Swift.Int?
    public let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
}

extension GetEventSourceMappingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case eventSourceArn = "EventSourceArn"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uUID = "UUID"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uUIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uUID)
        uUID = uUIDDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension GetFunctionCodeSigningConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionCodeSigningConfigInput(functionName: \(Swift.String(describing: functionName)))"}
}

extension GetFunctionCodeSigningConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFunctionCodeSigningConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionCodeSigningConfigOutputError>
}

public struct GetFunctionCodeSigningConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionCodeSigningConfigOutputError>
}

public struct GetFunctionCodeSigningConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionCodeSigningConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetFunctionCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFunctionCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionCodeSigningConfigOutputError>
}

public struct GetFunctionCodeSigningConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionCodeSigningConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetFunctionCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-06-30/functions/\(functionName.urlPercentEncoding())/code-signing-config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFunctionCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionCodeSigningConfigOutputError>
}

public struct GetFunctionCodeSigningConfigInput: Swift.Equatable {
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - MyFunction.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init (
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct GetFunctionCodeSigningConfigInputBody: Swift.Equatable {
}

extension GetFunctionCodeSigningConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionCodeSigningConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionCodeSigningConfigOutputResponse(codeSigningConfigArn: \(Swift.String(describing: codeSigningConfigArn)), functionName: \(Swift.String(describing: functionName)))"}
}

extension GetFunctionCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFunctionCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfigArn = output.codeSigningConfigArn
            self.functionName = output.functionName
        } else {
            self.codeSigningConfigArn = nil
            self.functionName = nil
        }
    }
}

public struct GetFunctionCodeSigningConfigOutputResponse: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - MyFunction.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init (
        codeSigningConfigArn: Swift.String? = nil,
        functionName: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

struct GetFunctionCodeSigningConfigOutputResponseBody: Swift.Equatable {
    public let codeSigningConfigArn: Swift.String?
    public let functionName: Swift.String?
}

extension GetFunctionCodeSigningConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case functionName = "FunctionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
    }
}

extension GetFunctionConcurrencyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionConcurrencyInput(functionName: \(Swift.String(describing: functionName)))"}
}

extension GetFunctionConcurrencyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFunctionConcurrencyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionConcurrencyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionConcurrencyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionConcurrencyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionConcurrencyOutputError>
}

public struct GetFunctionConcurrencyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionConcurrencyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionConcurrencyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionConcurrencyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionConcurrencyOutputError>
}

public struct GetFunctionConcurrencyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionConcurrencyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetFunctionConcurrencyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFunctionConcurrencyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionConcurrencyOutputError>
}

public struct GetFunctionConcurrencyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionConcurrencyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetFunctionConcurrencyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2019-09-30/functions/\(functionName.urlPercentEncoding())/concurrency"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFunctionConcurrencyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionConcurrencyOutputError>
}

public struct GetFunctionConcurrencyInput: Swift.Equatable {
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init (
        functionName: Swift.String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct GetFunctionConcurrencyInputBody: Swift.Equatable {
}

extension GetFunctionConcurrencyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionConcurrencyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionConcurrencyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionConcurrencyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionConcurrencyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionConcurrencyOutputResponse(reservedConcurrentExecutions: \(Swift.String(describing: reservedConcurrentExecutions)))"}
}

extension GetFunctionConcurrencyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFunctionConcurrencyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reservedConcurrentExecutions = output.reservedConcurrentExecutions
        } else {
            self.reservedConcurrentExecutions = nil
        }
    }
}

public struct GetFunctionConcurrencyOutputResponse: Swift.Equatable {
    /// The number of simultaneous executions that are reserved for the function.
    public var reservedConcurrentExecutions: Swift.Int?

    public init (
        reservedConcurrentExecutions: Swift.Int? = nil
    )
    {
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

struct GetFunctionConcurrencyOutputResponseBody: Swift.Equatable {
    public let reservedConcurrentExecutions: Swift.Int?
}

extension GetFunctionConcurrencyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

extension GetFunctionConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionConfigurationInput(functionName: \(Swift.String(describing: functionName)), qualifier: \(Swift.String(describing: qualifier)))"}
}

extension GetFunctionConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFunctionConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionConfigurationOutputError>
}

public struct GetFunctionConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionConfigurationOutputError>
}

public struct GetFunctionConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetFunctionConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFunctionConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionConfigurationOutputError>
}

public struct GetFunctionConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetFunctionConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())/configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFunctionConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionConfigurationOutputError>
}

public struct GetFunctionConfigurationInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get details about a published version of the function.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetFunctionConfigurationInputBody: Swift.Equatable {
}

extension GetFunctionConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionConfigurationOutputResponse(architectures: \(Swift.String(describing: architectures)), codeSha256: \(Swift.String(describing: codeSha256)), codeSize: \(Swift.String(describing: codeSize)), deadLetterConfig: \(Swift.String(describing: deadLetterConfig)), description: \(Swift.String(describing: description)), environment: \(Swift.String(describing: environment)), fileSystemConfigs: \(Swift.String(describing: fileSystemConfigs)), functionArn: \(Swift.String(describing: functionArn)), functionName: \(Swift.String(describing: functionName)), handler: \(Swift.String(describing: handler)), imageConfigResponse: \(Swift.String(describing: imageConfigResponse)), kMSKeyArn: \(Swift.String(describing: kMSKeyArn)), lastModified: \(Swift.String(describing: lastModified)), lastUpdateStatus: \(Swift.String(describing: lastUpdateStatus)), lastUpdateStatusReason: \(Swift.String(describing: lastUpdateStatusReason)), lastUpdateStatusReasonCode: \(Swift.String(describing: lastUpdateStatusReasonCode)), layers: \(Swift.String(describing: layers)), masterArn: \(Swift.String(describing: masterArn)), memorySize: \(Swift.String(describing: memorySize)), packageType: \(Swift.String(describing: packageType)), revisionId: \(Swift.String(describing: revisionId)), role: \(Swift.String(describing: role)), runtime: \(Swift.String(describing: runtime)), signingJobArn: \(Swift.String(describing: signingJobArn)), signingProfileVersionArn: \(Swift.String(describing: signingProfileVersionArn)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)), stateReasonCode: \(Swift.String(describing: stateReasonCode)), timeout: \(Swift.String(describing: timeout)), tracingConfig: \(Swift.String(describing: tracingConfig)), version: \(Swift.String(describing: version)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension GetFunctionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFunctionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architectures = output.architectures
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kMSKeyArn = output.kMSKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.architectures = nil
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kMSKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// Details about a function's configuration.
public struct GetFunctionConfigurationOutputResponse: Swift.Equatable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the
    ///       valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">environment variables.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// Connection settings for an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html">Amazon EFS file system.
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin executing your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    ///       configured a customer managed CMK.
    public var kMSKeyArn: Swift.String?
    /// The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful
    ///       after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    ///       layers.
    public var layers: [LambdaClientTypes.Layer]?
    /// For Lambda@Edge functions, the ARN of the master function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The runtime environment for the Lambda function.
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by
    ///       invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or
    ///       modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init (
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kMSKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct GetFunctionConfigurationOutputResponseBody: Swift.Equatable {
    public let functionName: Swift.String?
    public let functionArn: Swift.String?
    public let runtime: LambdaClientTypes.Runtime?
    public let role: Swift.String?
    public let handler: Swift.String?
    public let codeSize: Swift.Int
    public let description: Swift.String?
    public let timeout: Swift.Int?
    public let memorySize: Swift.Int?
    public let lastModified: Swift.String?
    public let codeSha256: Swift.String?
    public let version: Swift.String?
    public let vpcConfig: LambdaClientTypes.VpcConfigResponse?
    public let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    public let environment: LambdaClientTypes.EnvironmentResponse?
    public let kMSKeyArn: Swift.String?
    public let tracingConfig: LambdaClientTypes.TracingConfigResponse?
    public let masterArn: Swift.String?
    public let revisionId: Swift.String?
    public let layers: [LambdaClientTypes.Layer]?
    public let state: LambdaClientTypes.State?
    public let stateReason: Swift.String?
    public let stateReasonCode: LambdaClientTypes.StateReasonCode?
    public let lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    public let lastUpdateStatusReason: Swift.String?
    public let lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    public let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    public let packageType: LambdaClientTypes.PackageType?
    public let imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    public let signingProfileVersionArn: Swift.String?
    public let signingJobArn: Swift.String?
    public let architectures: [LambdaClientTypes.Architecture]?
}

extension GetFunctionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

extension GetFunctionEventInvokeConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionEventInvokeConfigInput(functionName: \(Swift.String(describing: functionName)), qualifier: \(Swift.String(describing: qualifier)))"}
}

extension GetFunctionEventInvokeConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFunctionEventInvokeConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionEventInvokeConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionEventInvokeConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionEventInvokeConfigOutputError>
}

public struct GetFunctionEventInvokeConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionEventInvokeConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionEventInvokeConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionEventInvokeConfigOutputError>
}

public struct GetFunctionEventInvokeConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionEventInvokeConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetFunctionEventInvokeConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFunctionEventInvokeConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionEventInvokeConfigOutputError>
}

public struct GetFunctionEventInvokeConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionEventInvokeConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetFunctionEventInvokeConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFunctionEventInvokeConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionEventInvokeConfigOutputError>
}

public struct GetFunctionEventInvokeConfigInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetFunctionEventInvokeConfigInputBody: Swift.Equatable {
}

extension GetFunctionEventInvokeConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionEventInvokeConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionEventInvokeConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionEventInvokeConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionEventInvokeConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionEventInvokeConfigOutputResponse(destinationConfig: \(Swift.String(describing: destinationConfig)), functionArn: \(Swift.String(describing: functionArn)), lastModified: \(Swift.String(describing: lastModified)), maximumEventAgeInSeconds: \(Swift.String(describing: maximumEventAgeInSeconds)), maximumRetryAttempts: \(Swift.String(describing: maximumRetryAttempts)))"}
}

extension GetFunctionEventInvokeConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFunctionEventInvokeConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationConfig = output.destinationConfig
            self.functionArn = output.functionArn
            self.lastModified = output.lastModified
            self.maximumEventAgeInSeconds = output.maximumEventAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
        } else {
            self.destinationConfig = nil
            self.functionArn = nil
            self.lastModified = nil
            self.maximumEventAgeInSeconds = nil
            self.maximumRetryAttempts = nil
        }
    }
}

public struct GetFunctionEventInvokeConfigOutputResponse: Swift.Equatable {
    /// A destination for events after they have been sent to a function for processing.
    ///          <p class="title">
    ///             Destinations
    ///
    ///
    ///
    ///
    ///                   Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    ///
    ///
    ///                   Queue - The ARN of an SQS queue.
    ///
    ///
    ///
    ///                   Topic - The ARN of an SNS topic.
    ///
    ///
    ///
    ///                   Event Bus - The ARN of an Amazon EventBridge event bus.
    ///
    ///
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The date and time that the configuration was last updated.
    public var lastModified: ClientRuntime.Date?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?

    public init (
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionArn: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

struct GetFunctionEventInvokeConfigOutputResponseBody: Swift.Equatable {
    public let lastModified: ClientRuntime.Date?
    public let functionArn: Swift.String?
    public let maximumRetryAttempts: Swift.Int?
    public let maximumEventAgeInSeconds: Swift.Int?
    public let destinationConfig: LambdaClientTypes.DestinationConfig?
}

extension GetFunctionEventInvokeConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension GetFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionInput(functionName: \(Swift.String(describing: functionName)), qualifier: \(Swift.String(describing: qualifier)))"}
}

extension GetFunctionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionOutputError>
}

public struct GetFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionOutputError>
}

public struct GetFunctionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionOutputError>
}

public struct GetFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionOutputError>
}

public struct GetFunctionInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get details about a published version of the function.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetFunctionInputBody: Swift.Equatable {
}

extension GetFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionOutputResponse(code: \(Swift.String(describing: code)), concurrency: \(Swift.String(describing: concurrency)), configuration: \(Swift.String(describing: configuration)), tags: \(Swift.String(describing: tags)))"}
}

extension GetFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFunctionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.concurrency = output.concurrency
            self.configuration = output.configuration
            self.tags = output.tags
        } else {
            self.code = nil
            self.concurrency = nil
            self.configuration = nil
            self.tags = nil
        }
    }
}

public struct GetFunctionOutputResponse: Swift.Equatable {
    /// The deployment package of the function or version.
    public var code: LambdaClientTypes.FunctionCodeLocation?
    /// The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html">reserved
    ///         concurrency.
    public var concurrency: LambdaClientTypes.Concurrency?
    /// The configuration of the function or version.
    public var configuration: LambdaClientTypes.FunctionConfiguration?
    /// The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/tagging.html">tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        code: LambdaClientTypes.FunctionCodeLocation? = nil,
        concurrency: LambdaClientTypes.Concurrency? = nil,
        configuration: LambdaClientTypes.FunctionConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.code = code
        self.concurrency = concurrency
        self.configuration = configuration
        self.tags = tags
    }
}

struct GetFunctionOutputResponseBody: Swift.Equatable {
    public let configuration: LambdaClientTypes.FunctionConfiguration?
    public let code: LambdaClientTypes.FunctionCodeLocation?
    public let tags: [Swift.String:Swift.String]?
    public let concurrency: LambdaClientTypes.Concurrency?
}

extension GetFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case concurrency = "Concurrency"
        case configuration = "Configuration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let codeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.FunctionCodeLocation.self, forKey: .code)
        code = codeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let concurrencyDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Concurrency.self, forKey: .concurrency)
        concurrency = concurrencyDecoded
    }
}

extension GetLayerVersionByArnInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLayerVersionByArnInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetLayerVersionByArnInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLayerVersionByArnInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLayerVersionByArnInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLayerVersionByArnInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLayerVersionByArnOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLayerVersionByArnInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLayerVersionByArnOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLayerVersionByArnOutputError>
}

public struct GetLayerVersionByArnInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLayerVersionByArnInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLayerVersionByArnInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLayerVersionByArnOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "find", value: "LayerVersion"))
        if let arn = input.operationInput.arn {
            let arnQueryItem = ClientRuntime.URLQueryItem(name: "Arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
            input.builder.withQueryItem(arnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLayerVersionByArnInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLayerVersionByArnOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLayerVersionByArnOutputError>
}

public struct GetLayerVersionByArnInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLayerVersionByArnInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLayerVersionByArnInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLayerVersionByArnOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLayerVersionByArnInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLayerVersionByArnOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLayerVersionByArnOutputError>
}

public struct GetLayerVersionByArnInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLayerVersionByArnInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLayerVersionByArnInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLayerVersionByArnOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2018-10-31/layers"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLayerVersionByArnInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLayerVersionByArnOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLayerVersionByArnOutputError>
}

public struct GetLayerVersionByArnInput: Swift.Equatable {
    /// The ARN of the layer version.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetLayerVersionByArnInputBody: Swift.Equatable {
}

extension GetLayerVersionByArnInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLayerVersionByArnOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLayerVersionByArnOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLayerVersionByArnOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLayerVersionByArnOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLayerVersionByArnOutputResponse(compatibleArchitectures: \(Swift.String(describing: compatibleArchitectures)), compatibleRuntimes: \(Swift.String(describing: compatibleRuntimes)), content: \(Swift.String(describing: content)), createdDate: \(Swift.String(describing: createdDate)), description: \(Swift.String(describing: description)), layerArn: \(Swift.String(describing: layerArn)), layerVersionArn: \(Swift.String(describing: layerVersionArn)), licenseInfo: \(Swift.String(describing: licenseInfo)), version: \(Swift.String(describing: version)))"}
}

extension GetLayerVersionByArnOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLayerVersionByArnOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.compatibleArchitectures = output.compatibleArchitectures
            self.compatibleRuntimes = output.compatibleRuntimes
            self.content = output.content
            self.createdDate = output.createdDate
            self.description = output.description
            self.layerArn = output.layerArn
            self.layerVersionArn = output.layerVersionArn
            self.licenseInfo = output.licenseInfo
            self.version = output.version
        } else {
            self.compatibleArchitectures = nil
            self.compatibleRuntimes = nil
            self.content = nil
            self.createdDate = nil
            self.description = nil
            self.layerArn = nil
            self.layerVersionArn = nil
            self.licenseInfo = nil
            self.version = 0
        }
    }
}

public struct GetLayerVersionByArnOutputResponse: Swift.Equatable {
    /// A list of compatible
    /// <a href="https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html">instruction set architectures.
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// The layer's compatible runtimes.
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// Details about the layer version.
    public var content: LambdaClientTypes.LayerVersionContentOutput?
    /// The date that the layer version was created, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
    public var createdDate: Swift.String?
    /// The description of the version.
    public var description: Swift.String?
    /// The ARN of the layer.
    public var layerArn: Swift.String?
    /// The ARN of the layer version.
    public var layerVersionArn: Swift.String?
    /// The layer's software license.
    public var licenseInfo: Swift.String?
    /// The version number.
    public var version: Swift.Int

    public init (
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentOutput? = nil,
        createdDate: Swift.String? = nil,
        description: Swift.String? = nil,
        layerArn: Swift.String? = nil,
        layerVersionArn: Swift.String? = nil,
        licenseInfo: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

struct GetLayerVersionByArnOutputResponseBody: Swift.Equatable {
    public let content: LambdaClientTypes.LayerVersionContentOutput?
    public let layerArn: Swift.String?
    public let layerVersionArn: Swift.String?
    public let description: Swift.String?
    public let createdDate: Swift.String?
    public let version: Swift.Int
    public let compatibleRuntimes: [LambdaClientTypes.Runtime]?
    public let licenseInfo: Swift.String?
    public let compatibleArchitectures: [LambdaClientTypes.Architecture]?
}

extension GetLayerVersionByArnOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerArn = "LayerArn"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LayerVersionContentOutput.self, forKey: .content)
        content = contentDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[LambdaClientTypes.Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [LambdaClientTypes.Runtime]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
        let compatibleArchitecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .compatibleArchitectures)
        var compatibleArchitecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let compatibleArchitecturesContainer = compatibleArchitecturesContainer {
            compatibleArchitecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in compatibleArchitecturesContainer {
                if let string0 = string0 {
                    compatibleArchitecturesDecoded0?.append(string0)
                }
            }
        }
        compatibleArchitectures = compatibleArchitecturesDecoded0
    }
}

extension GetLayerVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLayerVersionInput(layerName: \(Swift.String(describing: layerName)), versionNumber: \(Swift.String(describing: versionNumber)))"}
}

extension GetLayerVersionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLayerVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLayerVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLayerVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLayerVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLayerVersionOutputError>
}

public struct GetLayerVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLayerVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLayerVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLayerVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLayerVersionOutputError>
}

public struct GetLayerVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLayerVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLayerVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLayerVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLayerVersionOutputError>
}

public struct GetLayerVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLayerVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLayerVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let layerName = input.layerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("layerName is nil and needs a value for the path of this operation"))))
        }
        let versionNumber = input.versionNumber
        var urlPath = "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLayerVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLayerVersionOutputError>
}

public struct GetLayerVersionInput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int

    public init (
        layerName: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

struct GetLayerVersionInputBody: Swift.Equatable {
}

extension GetLayerVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLayerVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLayerVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLayerVersionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLayerVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLayerVersionOutputResponse(compatibleArchitectures: \(Swift.String(describing: compatibleArchitectures)), compatibleRuntimes: \(Swift.String(describing: compatibleRuntimes)), content: \(Swift.String(describing: content)), createdDate: \(Swift.String(describing: createdDate)), description: \(Swift.String(describing: description)), layerArn: \(Swift.String(describing: layerArn)), layerVersionArn: \(Swift.String(describing: layerVersionArn)), licenseInfo: \(Swift.String(describing: licenseInfo)), version: \(Swift.String(describing: version)))"}
}

extension GetLayerVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLayerVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.compatibleArchitectures = output.compatibleArchitectures
            self.compatibleRuntimes = output.compatibleRuntimes
            self.content = output.content
            self.createdDate = output.createdDate
            self.description = output.description
            self.layerArn = output.layerArn
            self.layerVersionArn = output.layerVersionArn
            self.licenseInfo = output.licenseInfo
            self.version = output.version
        } else {
            self.compatibleArchitectures = nil
            self.compatibleRuntimes = nil
            self.content = nil
            self.createdDate = nil
            self.description = nil
            self.layerArn = nil
            self.layerVersionArn = nil
            self.licenseInfo = nil
            self.version = 0
        }
    }
}

public struct GetLayerVersionOutputResponse: Swift.Equatable {
    /// A list of compatible
    /// <a href="https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html">instruction set architectures.
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// The layer's compatible runtimes.
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// Details about the layer version.
    public var content: LambdaClientTypes.LayerVersionContentOutput?
    /// The date that the layer version was created, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
    public var createdDate: Swift.String?
    /// The description of the version.
    public var description: Swift.String?
    /// The ARN of the layer.
    public var layerArn: Swift.String?
    /// The ARN of the layer version.
    public var layerVersionArn: Swift.String?
    /// The layer's software license.
    public var licenseInfo: Swift.String?
    /// The version number.
    public var version: Swift.Int

    public init (
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentOutput? = nil,
        createdDate: Swift.String? = nil,
        description: Swift.String? = nil,
        layerArn: Swift.String? = nil,
        layerVersionArn: Swift.String? = nil,
        licenseInfo: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

struct GetLayerVersionOutputResponseBody: Swift.Equatable {
    public let content: LambdaClientTypes.LayerVersionContentOutput?
    public let layerArn: Swift.String?
    public let layerVersionArn: Swift.String?
    public let description: Swift.String?
    public let createdDate: Swift.String?
    public let version: Swift.Int
    public let compatibleRuntimes: [LambdaClientTypes.Runtime]?
    public let licenseInfo: Swift.String?
    public let compatibleArchitectures: [LambdaClientTypes.Architecture]?
}

extension GetLayerVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerArn = "LayerArn"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LayerVersionContentOutput.self, forKey: .content)
        content = contentDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[LambdaClientTypes.Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [LambdaClientTypes.Runtime]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
        let compatibleArchitecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .compatibleArchitectures)
        var compatibleArchitecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let compatibleArchitecturesContainer = compatibleArchitecturesContainer {
            compatibleArchitecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in compatibleArchitecturesContainer {
                if let string0 = string0 {
                    compatibleArchitecturesDecoded0?.append(string0)
                }
            }
        }
        compatibleArchitectures = compatibleArchitecturesDecoded0
    }
}

extension GetLayerVersionPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLayerVersionPolicyInput(layerName: \(Swift.String(describing: layerName)), versionNumber: \(Swift.String(describing: versionNumber)))"}
}

extension GetLayerVersionPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLayerVersionPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLayerVersionPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLayerVersionPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLayerVersionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLayerVersionPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLayerVersionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLayerVersionPolicyOutputError>
}

public struct GetLayerVersionPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLayerVersionPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLayerVersionPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLayerVersionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLayerVersionPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLayerVersionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLayerVersionPolicyOutputError>
}

public struct GetLayerVersionPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLayerVersionPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLayerVersionPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLayerVersionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLayerVersionPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLayerVersionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLayerVersionPolicyOutputError>
}

public struct GetLayerVersionPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLayerVersionPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLayerVersionPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLayerVersionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let layerName = input.layerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("layerName is nil and needs a value for the path of this operation"))))
        }
        let versionNumber = input.versionNumber
        var urlPath = "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)/policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLayerVersionPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLayerVersionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLayerVersionPolicyOutputError>
}

public struct GetLayerVersionPolicyInput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int

    public init (
        layerName: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

struct GetLayerVersionPolicyInputBody: Swift.Equatable {
}

extension GetLayerVersionPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLayerVersionPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLayerVersionPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLayerVersionPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLayerVersionPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLayerVersionPolicyOutputResponse(policy: \(Swift.String(describing: policy)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension GetLayerVersionPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLayerVersionPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct GetLayerVersionPolicyOutputResponse: Swift.Equatable {
    /// The policy document.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    public var revisionId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct GetLayerVersionPolicyOutputResponseBody: Swift.Equatable {
    public let policy: Swift.String?
    public let revisionId: Swift.String?
}

extension GetLayerVersionPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPolicyInput(functionName: \(Swift.String(describing: functionName)), qualifier: \(Swift.String(describing: qualifier)))"}
}

extension GetPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPolicyOutputError>
}

public struct GetPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPolicyOutputError>
}

public struct GetPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPolicyOutputError>
}

public struct GetPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())/policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPolicyOutputError>
}

public struct GetPolicyInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to get the policy for that resource.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetPolicyInputBody: Swift.Equatable {
}

extension GetPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPolicyOutputResponse(policy: \(Swift.String(describing: policy)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension GetPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct GetPolicyOutputResponse: Swift.Equatable {
    /// The resource-based policy.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the policy.
    public var revisionId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct GetPolicyOutputResponseBody: Swift.Equatable {
    public let policy: Swift.String?
    public let revisionId: Swift.String?
}

extension GetPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetProvisionedConcurrencyConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProvisionedConcurrencyConfigInput(functionName: \(Swift.String(describing: functionName)), qualifier: \(Swift.String(describing: qualifier)))"}
}

extension GetProvisionedConcurrencyConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetProvisionedConcurrencyConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProvisionedConcurrencyConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProvisionedConcurrencyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProvisionedConcurrencyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProvisionedConcurrencyConfigOutputError>
}

public struct GetProvisionedConcurrencyConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProvisionedConcurrencyConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProvisionedConcurrencyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProvisionedConcurrencyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProvisionedConcurrencyConfigOutputError>
}

public struct GetProvisionedConcurrencyConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProvisionedConcurrencyConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetProvisionedConcurrencyConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetProvisionedConcurrencyConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProvisionedConcurrencyConfigOutputError>
}

public struct GetProvisionedConcurrencyConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProvisionedConcurrencyConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetProvisionedConcurrencyConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetProvisionedConcurrencyConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProvisionedConcurrencyConfigOutputError>
}

public struct GetProvisionedConcurrencyConfigInput: Swift.Equatable {
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The version number or alias name.
    /// This member is required.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetProvisionedConcurrencyConfigInputBody: Swift.Equatable {
}

extension GetProvisionedConcurrencyConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetProvisionedConcurrencyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProvisionedConcurrencyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedConcurrencyConfigNotFoundException" : self = .provisionedConcurrencyConfigNotFoundException(try ProvisionedConcurrencyConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProvisionedConcurrencyConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case provisionedConcurrencyConfigNotFoundException(ProvisionedConcurrencyConfigNotFoundException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProvisionedConcurrencyConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProvisionedConcurrencyConfigOutputResponse(allocatedProvisionedConcurrentExecutions: \(Swift.String(describing: allocatedProvisionedConcurrentExecutions)), availableProvisionedConcurrentExecutions: \(Swift.String(describing: availableProvisionedConcurrentExecutions)), lastModified: \(Swift.String(describing: lastModified)), requestedProvisionedConcurrentExecutions: \(Swift.String(describing: requestedProvisionedConcurrentExecutions)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)))"}
}

extension GetProvisionedConcurrencyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetProvisionedConcurrencyConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allocatedProvisionedConcurrentExecutions = output.allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = output.availableProvisionedConcurrentExecutions
            self.lastModified = output.lastModified
            self.requestedProvisionedConcurrentExecutions = output.requestedProvisionedConcurrentExecutions
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.allocatedProvisionedConcurrentExecutions = nil
            self.availableProvisionedConcurrentExecutions = nil
            self.lastModified = nil
            self.requestedProvisionedConcurrentExecutions = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct GetProvisionedConcurrencyConfigOutputResponse: Swift.Equatable {
    /// The amount of provisioned concurrency allocated.
    public var allocatedProvisionedConcurrentExecutions: Swift.Int?
    /// The amount of provisioned concurrency available.
    public var availableProvisionedConcurrentExecutions: Swift.Int?
    /// The date and time that a user last updated the configuration, in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format.
    public var lastModified: Swift.String?
    /// The amount of provisioned concurrency requested.
    public var requestedProvisionedConcurrentExecutions: Swift.Int?
    /// The status of the allocation process.
    public var status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    /// For failed allocations, the reason that provisioned concurrency could not be allocated.
    public var statusReason: Swift.String?

    public init (
        allocatedProvisionedConcurrentExecutions: Swift.Int? = nil,
        availableProvisionedConcurrentExecutions: Swift.Int? = nil,
        lastModified: Swift.String? = nil,
        requestedProvisionedConcurrentExecutions: Swift.Int? = nil,
        status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
        self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
        self.lastModified = lastModified
        self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
        self.status = status
        self.statusReason = statusReason
    }
}

struct GetProvisionedConcurrencyConfigOutputResponseBody: Swift.Equatable {
    public let requestedProvisionedConcurrentExecutions: Swift.Int?
    public let availableProvisionedConcurrentExecutions: Swift.Int?
    public let allocatedProvisionedConcurrentExecutions: Swift.Int?
    public let status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    public let statusReason: Swift.String?
    public let lastModified: Swift.String?
}

extension GetProvisionedConcurrencyConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
        case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
        case lastModified = "LastModified"
        case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requestedProvisionedConcurrentExecutions)
        requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutionsDecoded
        let availableProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availableProvisionedConcurrentExecutions)
        availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutionsDecoded
        let allocatedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedProvisionedConcurrentExecutions)
        allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ProvisionedConcurrencyStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension LambdaClientTypes.ImageConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command = "Command"
        case entryPoint = "EntryPoint"
        case workingDirectory = "WorkingDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = command {
            var commandContainer = encodeContainer.nestedUnkeyedContainer(forKey: .command)
            for stringlist0 in command {
                try commandContainer.encode(stringlist0)
            }
        }
        if let entryPoint = entryPoint {
            var entryPointContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entryPoint)
            for stringlist0 in entryPoint {
                try entryPointContainer.encode(stringlist0)
            }
        }
        if let workingDirectory = workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryPointContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entryPoint)
        var entryPointDecoded0:[Swift.String]? = nil
        if let entryPointContainer = entryPointContainer {
            entryPointDecoded0 = [Swift.String]()
            for string0 in entryPointContainer {
                if let string0 = string0 {
                    entryPointDecoded0?.append(string0)
                }
            }
        }
        entryPoint = entryPointDecoded0
        let commandContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .command)
        var commandDecoded0:[Swift.String]? = nil
        if let commandContainer = commandContainer {
            commandDecoded0 = [Swift.String]()
            for string0 in commandContainer {
                if let string0 = string0 {
                    commandDecoded0?.append(string0)
                }
            }
        }
        command = commandDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
    }
}

extension LambdaClientTypes.ImageConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageConfig(command: \(Swift.String(describing: command)), entryPoint: \(Swift.String(describing: entryPoint)), workingDirectory: \(Swift.String(describing: workingDirectory)))"}
}

extension LambdaClientTypes {
    /// Configuration values that override the container image Dockerfile settings. See
    ///       <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms">Container settings.
    public struct ImageConfig: Swift.Equatable {
        /// Specifies parameters that you want to pass in with ENTRYPOINT.
        public var command: [Swift.String]?
        /// Specifies the entry point to their application, which is typically the location of the runtime
        ///       executable.
        public var entryPoint: [Swift.String]?
        /// Specifies the working directory.
        public var workingDirectory: Swift.String?

        public init (
            command: [Swift.String]? = nil,
            entryPoint: [Swift.String]? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.command = command
            self.entryPoint = entryPoint
            self.workingDirectory = workingDirectory
        }
    }

}

extension LambdaClientTypes.ImageConfigError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.ImageConfigError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageConfigError(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension LambdaClientTypes {
    /// Error response to GetFunctionConfiguration.
    public struct ImageConfigError: Swift.Equatable {
        /// Error code.
        public var errorCode: Swift.String?
        /// Error message.
        public var message: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
        }
    }

}

extension LambdaClientTypes.ImageConfigResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case imageConfig = "ImageConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let imageConfig = imageConfig {
            try encodeContainer.encode(imageConfig, forKey: .imageConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfig.self, forKey: .imageConfig)
        imageConfig = imageConfigDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LambdaClientTypes.ImageConfigResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageConfigResponse(error: \(Swift.String(describing: error)), imageConfig: \(Swift.String(describing: imageConfig)))"}
}

extension LambdaClientTypes {
    /// Response to GetFunctionConfiguration request.
    public struct ImageConfigResponse: Swift.Equatable {
        /// Error response to GetFunctionConfiguration.
        public var error: LambdaClientTypes.ImageConfigError?
        /// Configuration values that override the container image Dockerfile.
        public var imageConfig: LambdaClientTypes.ImageConfig?

        public init (
            error: LambdaClientTypes.ImageConfigError? = nil,
            imageConfig: LambdaClientTypes.ImageConfig? = nil
        )
        {
            self.error = error
            self.imageConfig = imageConfig
        }
    }

}

extension InvalidCodeSignatureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidCodeSignatureException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension InvalidCodeSignatureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidCodeSignatureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The code signature failed the integrity check. Lambda always blocks deployment if the integrity check
///       fails, even if code signing policy is set to WARN.
public struct InvalidCodeSignatureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidCodeSignatureExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension InvalidCodeSignatureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterValueException(type: \(Swift.String(describing: type)), message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One of the parameters in the request is invalid.
public struct InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception message.
    public var message: Swift.String?
    /// The exception type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestContentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestContentException(type: \(Swift.String(describing: type)), message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestContentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestContentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request body could not be parsed as JSON.
public struct InvalidRequestContentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception message.
    public var message: Swift.String?
    /// The exception type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidRequestContentExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension InvalidRequestContentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRuntimeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRuntimeException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension InvalidRuntimeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRuntimeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The runtime or runtime version specified is not supported.
public struct InvalidRuntimeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidRuntimeExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension InvalidRuntimeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSecurityGroupIDException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSecurityGroupIDException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension InvalidSecurityGroupIDException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidSecurityGroupIDExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Security Group ID provided in the Lambda function VPC configuration is invalid.
public struct InvalidSecurityGroupIDException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidSecurityGroupIDExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension InvalidSecurityGroupIDExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnetIDException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSubnetIDException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension InvalidSubnetIDException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidSubnetIDExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Subnet ID provided in the Lambda function VPC configuration is invalid.
public struct InvalidSubnetIDException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidSubnetIDExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension InvalidSubnetIDExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidZipFileException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidZipFileException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension InvalidZipFileException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidZipFileExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda could not unzip the deployment package.
public struct InvalidZipFileException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidZipFileExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension InvalidZipFileExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum InvocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dryrun
        case event
        case requestresponse
        case sdkUnknown(Swift.String)

        public static var allCases: [InvocationType] {
            return [
                .dryrun,
                .event,
                .requestresponse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dryrun: return "DryRun"
            case .event: return "Event"
            case .requestresponse: return "RequestResponse"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InvocationType(rawValue: rawValue) ?? InvocationType.sdkUnknown(rawValue)
        }
    }
}

public struct InvokeAsyncInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeAsyncInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeAsyncInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeAsyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let invokeArgs = input.operationInput.invokeArgs {
            let invokeArgsdata = invokeArgs
            let invokeArgsbody = ClientRuntime.HttpBody.stream(invokeArgsdata)
            input.builder.withBody(invokeArgsbody)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeAsyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeAsyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeAsyncOutputError>
}

extension InvokeAsyncInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeAsyncInput(functionName: \(Swift.String(describing: functionName)), invokeArgs: \(Swift.String(describing: invokeArgs)))"}
}

extension InvokeAsyncInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invokeArgs = "InvokeArgs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invokeArgs = invokeArgs {
            try encodeContainer.encode(invokeArgs.toBytes().toData(), forKey: .invokeArgs)
        }
    }
}

public struct InvokeAsyncInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeAsyncInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeAsyncInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeAsyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeAsyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeAsyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeAsyncOutputError>
}

public struct InvokeAsyncInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeAsyncInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeAsyncInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeAsyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeAsyncInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeAsyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeAsyncOutputError>
}

public struct InvokeAsyncInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeAsyncInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: InvokeAsyncInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeAsyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = InvokeAsyncInput
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeAsyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeAsyncOutputError>
}

public struct InvokeAsyncInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeAsyncInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: InvokeAsyncInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeAsyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2014-11-13/functions/\(functionName.urlPercentEncoding())/invoke-async"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = InvokeAsyncInput
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeAsyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeAsyncOutputError>
}

@available(*, deprecated)
public struct InvokeAsyncInput: Swift.Equatable {
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The JSON that you want to provide to your Lambda function as input.
    /// This member is required.
    public var invokeArgs: ClientRuntime.ByteStream?

    public init (
        functionName: Swift.String? = nil,
        invokeArgs: ClientRuntime.ByteStream? = nil
    )
    {
        self.functionName = functionName
        self.invokeArgs = invokeArgs
    }
}

struct InvokeAsyncInputBody: Swift.Equatable {
    public let invokeArgs: ClientRuntime.ByteStream?
}

extension InvokeAsyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invokeArgs = "InvokeArgs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invokeArgsDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .invokeArgs)
        invokeArgs = invokeArgsDecoded
    }
}

extension InvokeAsyncOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InvokeAsyncOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidRequestContentException" : self = .invalidRequestContentException(try InvalidRequestContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuntimeException" : self = .invalidRuntimeException(try InvalidRuntimeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InvokeAsyncOutputError: Swift.Error, Swift.Equatable {
    case invalidRequestContentException(InvalidRequestContentException)
    case invalidRuntimeException(InvalidRuntimeException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InvokeAsyncOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeAsyncOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension InvokeAsyncOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        self.status = httpResponse.statusCode.rawValue
    }
}

/// A success response (202 Accepted) indicates that the request is queued for invocation.
@available(*, deprecated)
public struct InvokeAsyncOutputResponse: Swift.Equatable {
    /// The status code.
    public var status: Swift.Int

    public init (
        status: Swift.Int = 0
    )
    {
        self.status = status
    }
}

struct InvokeAsyncOutputResponseBody: Swift.Equatable {
    public let status: Swift.Int
}

extension InvokeAsyncOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct InvokeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let payload = input.operationInput.payload {
            let payloaddata = payload
            let payloadbody = ClientRuntime.HttpBody.data(payloaddata)
            input.builder.withBody(payloadbody)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeOutputError>
}

extension InvokeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeInput(clientContext: \(Swift.String(describing: clientContext)), functionName: \(Swift.String(describing: functionName)), invocationType: \(Swift.String(describing: invocationType)), logType: \(Swift.String(describing: logType)), payload: \(Swift.String(describing: payload)), qualifier: \(Swift.String(describing: qualifier)))"}
}

extension InvokeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload = "Payload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
    }
}

public struct InvokeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientContext = input.operationInput.clientContext {
            input.builder.withHeader(name: "X-Amz-Client-Context", value: Swift.String(clientContext))
        }
        if let invocationType = input.operationInput.invocationType {
            input.builder.withHeader(name: "X-Amz-Invocation-Type", value: Swift.String(invocationType.rawValue))
        }
        if let logType = input.operationInput.logType {
            input.builder.withHeader(name: "X-Amz-Log-Type", value: Swift.String(logType.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeOutputError>
}

public struct InvokeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeOutputError>
}

public struct InvokeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: InvokeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = InvokeInput
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeOutputError>
}

public struct InvokeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: InvokeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())/invocations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = InvokeInput
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeOutputError>
}

public struct InvokeInput: Swift.Equatable {
    /// Up to 3583 bytes of base64-encoded data about the invoking client to pass to the function in the context
    ///       object.
    public var clientContext: Swift.String?
    /// The name of the Lambda function, version, or alias.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Choose from the following options.
    ///
    ///
    ///
    ///                   RequestResponse (default) - Invoke the function synchronously. Keep the connection open until
    ///           the function returns a response or times out. The API response includes the function response and additional
    ///           data.
    ///
    ///
    ///
    ///                   Event - Invoke the function asynchronously. Send events that fail multiple times to the
    ///           function's dead-letter queue (if it's configured). The API response only includes a status code.
    ///
    ///
    ///
    ///                   DryRun - Validate parameter values and verify that the user or role has permission to invoke
    ///           the function.
    ///
    ///
    public var invocationType: LambdaClientTypes.InvocationType?
    /// Set to Tail to include the execution log in the response. Applies to synchronously invoked functions only.
    public var logType: LambdaClientTypes.LogType?
    /// The JSON that you want to provide to your Lambda function as input.
    public var payload: ClientRuntime.Data?
    /// Specify a version or alias to invoke a published version of the function.
    public var qualifier: Swift.String?

    public init (
        clientContext: Swift.String? = nil,
        functionName: Swift.String? = nil,
        invocationType: LambdaClientTypes.InvocationType? = nil,
        logType: LambdaClientTypes.LogType? = nil,
        payload: ClientRuntime.Data? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.clientContext = clientContext
        self.functionName = functionName
        self.invocationType = invocationType
        self.logType = logType
        self.payload = payload
        self.qualifier = qualifier
    }
}

struct InvokeInputBody: Swift.Equatable {
    public let payload: ClientRuntime.Data?
}

extension InvokeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload = "Payload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension InvokeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InvokeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EC2AccessDeniedException" : self = .eC2AccessDeniedException(try EC2AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EC2ThrottledException" : self = .eC2ThrottledException(try EC2ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EC2UnexpectedException" : self = .eC2UnexpectedException(try EC2UnexpectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EFSIOException" : self = .eFSIOException(try EFSIOException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EFSMountConnectivityException" : self = .eFSMountConnectivityException(try EFSMountConnectivityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EFSMountFailureException" : self = .eFSMountFailureException(try EFSMountFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EFSMountTimeoutException" : self = .eFSMountTimeoutException(try EFSMountTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ENILimitReachedException" : self = .eNILimitReachedException(try ENILimitReachedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestContentException" : self = .invalidRequestContentException(try InvalidRequestContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuntimeException" : self = .invalidRuntimeException(try InvalidRuntimeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityGroupIDException" : self = .invalidSecurityGroupIDException(try InvalidSecurityGroupIDException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnetIDException" : self = .invalidSubnetIDException(try InvalidSubnetIDException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidZipFileException" : self = .invalidZipFileException(try InvalidZipFileException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedException" : self = .kMSAccessDeniedException(try KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledException" : self = .kMSDisabledException(try KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundException" : self = .kMSNotFoundException(try KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTooLargeException" : self = .requestTooLargeException(try RequestTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotReadyException" : self = .resourceNotReadyException(try ResourceNotReadyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetIPAddressLimitReachedException" : self = .subnetIPAddressLimitReachedException(try SubnetIPAddressLimitReachedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedMediaTypeException" : self = .unsupportedMediaTypeException(try UnsupportedMediaTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InvokeOutputError: Swift.Error, Swift.Equatable {
    case eC2AccessDeniedException(EC2AccessDeniedException)
    case eC2ThrottledException(EC2ThrottledException)
    case eC2UnexpectedException(EC2UnexpectedException)
    case eFSIOException(EFSIOException)
    case eFSMountConnectivityException(EFSMountConnectivityException)
    case eFSMountFailureException(EFSMountFailureException)
    case eFSMountTimeoutException(EFSMountTimeoutException)
    case eNILimitReachedException(ENILimitReachedException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestContentException(InvalidRequestContentException)
    case invalidRuntimeException(InvalidRuntimeException)
    case invalidSecurityGroupIDException(InvalidSecurityGroupIDException)
    case invalidSubnetIDException(InvalidSubnetIDException)
    case invalidZipFileException(InvalidZipFileException)
    case kMSAccessDeniedException(KMSAccessDeniedException)
    case kMSDisabledException(KMSDisabledException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case kMSNotFoundException(KMSNotFoundException)
    case requestTooLargeException(RequestTooLargeException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceNotReadyException(ResourceNotReadyException)
    case serviceException(ServiceException)
    case subnetIPAddressLimitReachedException(SubnetIPAddressLimitReachedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unsupportedMediaTypeException(UnsupportedMediaTypeException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InvokeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeOutputResponse(executedVersion: \(Swift.String(describing: executedVersion)), functionError: \(Swift.String(describing: functionError)), logResult: \(Swift.String(describing: logResult)), payload: \(Swift.String(describing: payload)), statusCode: \(Swift.String(describing: statusCode)))"}
}

extension InvokeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let executedVersionHeaderValue = httpResponse.headers.value(for: "X-Amz-Executed-Version") {
            self.executedVersion = executedVersionHeaderValue
        } else {
            self.executedVersion = nil
        }
        if let functionErrorHeaderValue = httpResponse.headers.value(for: "X-Amz-Function-Error") {
            self.functionError = functionErrorHeaderValue
        } else {
            self.functionError = nil
        }
        if let logResultHeaderValue = httpResponse.headers.value(for: "X-Amz-Log-Result") {
            self.logResult = logResultHeaderValue
        } else {
            self.logResult = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.payload = data
        } else {
            self.payload = nil
        }
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct InvokeOutputResponse: Swift.Equatable {
    /// The version of the function that executed. When you invoke a function with an alias, this indicates which
    ///       version the alias resolved to.
    public var executedVersion: Swift.String?
    /// If present, indicates that an error occurred during function execution. Details about the error are included
    ///       in the response payload.
    public var functionError: Swift.String?
    /// The last 4 KB of the execution log, which is base64 encoded.
    public var logResult: Swift.String?
    /// The response from the function, or an error object.
    public var payload: ClientRuntime.Data?
    /// The HTTP status code is in the 200 range for a successful request. For the RequestResponse
    ///       invocation type, this status code is 200. For the Event invocation type, this status code is 202. For
    ///       the DryRun invocation type, the status code is 204.
    public var statusCode: Swift.Int

    public init (
        executedVersion: Swift.String? = nil,
        functionError: Swift.String? = nil,
        logResult: Swift.String? = nil,
        payload: ClientRuntime.Data? = nil,
        statusCode: Swift.Int = 0
    )
    {
        self.executedVersion = executedVersion
        self.functionError = functionError
        self.logResult = logResult
        self.payload = payload
        self.statusCode = statusCode
    }
}

struct InvokeOutputResponseBody: Swift.Equatable {
    public let statusCode: Swift.Int
    public let payload: ClientRuntime.Data?
}

extension InvokeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload = "Payload"
        case statusCode = "StatusCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decode(Swift.Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension KMSAccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSAccessDeniedException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension KMSAccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda was unable to decrypt the environment variables because KMS access was denied. Check the Lambda
///       function's KMS permissions.
public struct KMSAccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct KMSAccessDeniedExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension KMSAccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSDisabledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSDisabledException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension KMSDisabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda was unable to decrypt the environment variables because the KMS key used is disabled. Check the Lambda
///       function's KMS key settings.
public struct KMSDisabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct KMSDisabledExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension KMSDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSInvalidStateException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension KMSInvalidStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSInvalidStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda was unable to decrypt the environment variables because the KMS key used is in an invalid state for
///       Decrypt. Check the function's KMS key settings.
public struct KMSInvalidStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct KMSInvalidStateExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension KMSInvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSNotFoundException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension KMSNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda was unable to decrypt the environment variables because the KMS key was not found. Check the function's
///       KMS key settings.
public struct KMSNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct KMSNotFoundExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension KMSNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum LastUpdateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [LastUpdateStatus] {
            return [
                .failed,
                .inprogress,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LastUpdateStatus(rawValue: rawValue) ?? LastUpdateStatus.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes {
    public enum LastUpdateStatusReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enilimitexceeded
        case imageaccessdenied
        case imagedeleted
        case insufficientrolepermissions
        case internalerror
        case invalidconfiguration
        case invalidimage
        case invalidsecuritygroup
        case invalidsubnet
        case subnetoutofipaddresses
        case sdkUnknown(Swift.String)

        public static var allCases: [LastUpdateStatusReasonCode] {
            return [
                .enilimitexceeded,
                .imageaccessdenied,
                .imagedeleted,
                .insufficientrolepermissions,
                .internalerror,
                .invalidconfiguration,
                .invalidimage,
                .invalidsecuritygroup,
                .invalidsubnet,
                .subnetoutofipaddresses,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enilimitexceeded: return "EniLimitExceeded"
            case .imageaccessdenied: return "ImageAccessDenied"
            case .imagedeleted: return "ImageDeleted"
            case .insufficientrolepermissions: return "InsufficientRolePermissions"
            case .internalerror: return "InternalError"
            case .invalidconfiguration: return "InvalidConfiguration"
            case .invalidimage: return "InvalidImage"
            case .invalidsecuritygroup: return "InvalidSecurityGroup"
            case .invalidsubnet: return "InvalidSubnet"
            case .subnetoutofipaddresses: return "SubnetOutOfIPAddresses"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LastUpdateStatusReasonCode(rawValue: rawValue) ?? LastUpdateStatusReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.Layer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case codeSize = "CodeSize"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if codeSize != 0 {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let signingJobArn = signingJobArn {
            try encodeContainer.encode(signingJobArn, forKey: .signingJobArn)
        }
        if let signingProfileVersionArn = signingProfileVersionArn {
            try encodeContainer.encode(signingProfileVersionArn, forKey: .signingProfileVersionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
    }
}

extension LambdaClientTypes.Layer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Layer(arn: \(Swift.String(describing: arn)), codeSize: \(Swift.String(describing: codeSize)), signingJobArn: \(Swift.String(describing: signingJobArn)), signingProfileVersionArn: \(Swift.String(describing: signingProfileVersionArn)))"}
}

extension LambdaClientTypes {
    /// An <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda
    ///         layer.
    public struct Layer: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the function layer.
        public var arn: Swift.String?
        /// The size of the layer archive in bytes.
        public var codeSize: Swift.Int
        /// The Amazon Resource Name (ARN)  of a signing job.
        public var signingJobArn: Swift.String?
        /// The Amazon Resource Name (ARN) for a signing profile version.
        public var signingProfileVersionArn: Swift.String?

        public init (
            arn: Swift.String? = nil,
            codeSize: Swift.Int = 0,
            signingJobArn: Swift.String? = nil,
            signingProfileVersionArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.codeSize = codeSize
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
        }
    }

}

extension LambdaClientTypes.LayerVersionContentInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3ObjectVersion = s3ObjectVersion {
            try encodeContainer.encode(s3ObjectVersion, forKey: .s3ObjectVersion)
        }
        if let zipFile = zipFile {
            try encodeContainer.encode(zipFile.base64EncodedString(), forKey: .zipFile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectVersion)
        s3ObjectVersion = s3ObjectVersionDecoded
        let zipFileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .zipFile)
        zipFile = zipFileDecoded
    }
}

extension LambdaClientTypes.LayerVersionContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayerVersionContentInput(s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)), s3ObjectVersion: \(Swift.String(describing: s3ObjectVersion)), zipFile: \(Swift.String(describing: zipFile)))"}
}

extension LambdaClientTypes {
    /// A ZIP archive that contains the contents of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda
    ///         layer. You can specify either an Amazon S3 location,
    ///       or upload a layer archive directly.
    public struct LayerVersionContentInput: Swift.Equatable {
        /// The Amazon S3 bucket of the layer archive.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key of the layer archive.
        public var s3Key: Swift.String?
        /// For versioned objects, the version of the layer archive object to use.
        public var s3ObjectVersion: Swift.String?
        /// The base64-encoded contents of the layer archive. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for
        ///       you.
        public var zipFile: ClientRuntime.Data?

        public init (
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            s3ObjectVersion: Swift.String? = nil,
            zipFile: ClientRuntime.Data? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }
    }

}

extension LambdaClientTypes.LayerVersionContentOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case location = "Location"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeSha256 = codeSha256 {
            try encodeContainer.encode(codeSha256, forKey: .codeSha256)
        }
        if codeSize != 0 {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let signingJobArn = signingJobArn {
            try encodeContainer.encode(signingJobArn, forKey: .signingJobArn)
        }
        if let signingProfileVersionArn = signingProfileVersionArn {
            try encodeContainer.encode(signingProfileVersionArn, forKey: .signingProfileVersionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
    }
}

extension LambdaClientTypes.LayerVersionContentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayerVersionContentOutput(codeSha256: \(Swift.String(describing: codeSha256)), codeSize: \(Swift.String(describing: codeSize)), location: \(Swift.String(describing: location)), signingJobArn: \(Swift.String(describing: signingJobArn)), signingProfileVersionArn: \(Swift.String(describing: signingProfileVersionArn)))"}
}

extension LambdaClientTypes {
    /// Details about a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda
    ///         layer.
    public struct LayerVersionContentOutput: Swift.Equatable {
        /// The SHA-256 hash of the layer archive.
        public var codeSha256: Swift.String?
        /// The size of the layer archive in bytes.
        public var codeSize: Swift.Int
        /// A link to the layer archive in Amazon S3 that is valid for 10 minutes.
        public var location: Swift.String?
        /// The Amazon Resource Name (ARN)  of a signing job.
        public var signingJobArn: Swift.String?
        /// The Amazon Resource Name (ARN) for a signing profile version.
        public var signingProfileVersionArn: Swift.String?

        public init (
            codeSha256: Swift.String? = nil,
            codeSize: Swift.Int = 0,
            location: Swift.String? = nil,
            signingJobArn: Swift.String? = nil,
            signingProfileVersionArn: Swift.String? = nil
        )
        {
            self.codeSha256 = codeSha256
            self.codeSize = codeSize
            self.location = location
            self.signingJobArn = signingJobArn
            self.signingProfileVersionArn = signingProfileVersionArn
        }
    }

}

extension LambdaClientTypes.LayerVersionsListItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleArchitectures = compatibleArchitectures {
            var compatibleArchitecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleArchitectures)
            for compatiblearchitectures0 in compatibleArchitectures {
                try compatibleArchitecturesContainer.encode(compatiblearchitectures0.rawValue)
            }
        }
        if let compatibleRuntimes = compatibleRuntimes {
            var compatibleRuntimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleRuntimes)
            for compatibleruntimes0 in compatibleRuntimes {
                try compatibleRuntimesContainer.encode(compatibleruntimes0.rawValue)
            }
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let layerVersionArn = layerVersionArn {
            try encodeContainer.encode(layerVersionArn, forKey: .layerVersionArn)
        }
        if let licenseInfo = licenseInfo {
            try encodeContainer.encode(licenseInfo, forKey: .licenseInfo)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[LambdaClientTypes.Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [LambdaClientTypes.Runtime]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
        let compatibleArchitecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .compatibleArchitectures)
        var compatibleArchitecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let compatibleArchitecturesContainer = compatibleArchitecturesContainer {
            compatibleArchitecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in compatibleArchitecturesContainer {
                if let string0 = string0 {
                    compatibleArchitecturesDecoded0?.append(string0)
                }
            }
        }
        compatibleArchitectures = compatibleArchitecturesDecoded0
    }
}

extension LambdaClientTypes.LayerVersionsListItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayerVersionsListItem(compatibleArchitectures: \(Swift.String(describing: compatibleArchitectures)), compatibleRuntimes: \(Swift.String(describing: compatibleRuntimes)), createdDate: \(Swift.String(describing: createdDate)), description: \(Swift.String(describing: description)), layerVersionArn: \(Swift.String(describing: layerVersionArn)), licenseInfo: \(Swift.String(describing: licenseInfo)), version: \(Swift.String(describing: version)))"}
}

extension LambdaClientTypes {
    /// Details about a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda
    ///         layer.
    public struct LayerVersionsListItem: Swift.Equatable {
        /// A list of compatible
        ///       <a href="https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html">instruction set architectures.
        public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
        /// The layer's compatible runtimes.
        public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
        /// The date that the version was created, in ISO 8601 format. For example, 2018-11-27T15:10:45.123+0000.
        public var createdDate: Swift.String?
        /// The description of the version.
        public var description: Swift.String?
        /// The ARN of the layer version.
        public var layerVersionArn: Swift.String?
        /// The layer's open-source license.
        public var licenseInfo: Swift.String?
        /// The version number.
        public var version: Swift.Int

        public init (
            compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
            compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
            createdDate: Swift.String? = nil,
            description: Swift.String? = nil,
            layerVersionArn: Swift.String? = nil,
            licenseInfo: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.compatibleArchitectures = compatibleArchitectures
            self.compatibleRuntimes = compatibleRuntimes
            self.createdDate = createdDate
            self.description = description
            self.layerVersionArn = layerVersionArn
            self.licenseInfo = licenseInfo
            self.version = version
        }
    }

}

extension LambdaClientTypes.LayersListItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestMatchingVersion = "LatestMatchingVersion"
        case layerArn = "LayerArn"
        case layerName = "LayerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestMatchingVersion = latestMatchingVersion {
            try encodeContainer.encode(latestMatchingVersion, forKey: .latestMatchingVersion)
        }
        if let layerArn = layerArn {
            try encodeContainer.encode(layerArn, forKey: .layerArn)
        }
        if let layerName = layerName {
            try encodeContainer.encode(layerName, forKey: .layerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerName)
        layerName = layerNameDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let latestMatchingVersionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LayerVersionsListItem.self, forKey: .latestMatchingVersion)
        latestMatchingVersion = latestMatchingVersionDecoded
    }
}

extension LambdaClientTypes.LayersListItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayersListItem(latestMatchingVersion: \(Swift.String(describing: latestMatchingVersion)), layerArn: \(Swift.String(describing: layerArn)), layerName: \(Swift.String(describing: layerName)))"}
}

extension LambdaClientTypes {
    /// Details about an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda
    ///         layer.
    public struct LayersListItem: Swift.Equatable {
        /// The newest version of the layer.
        public var latestMatchingVersion: LambdaClientTypes.LayerVersionsListItem?
        /// The Amazon Resource Name (ARN) of the function layer.
        public var layerArn: Swift.String?
        /// The name of the layer.
        public var layerName: Swift.String?

        public init (
            latestMatchingVersion: LambdaClientTypes.LayerVersionsListItem? = nil,
            layerArn: Swift.String? = nil,
            layerName: Swift.String? = nil
        )
        {
            self.latestMatchingVersion = latestMatchingVersion
            self.layerArn = layerArn
            self.layerName = layerName
        }
    }

}

extension ListAliasesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAliasesInput(functionName: \(Swift.String(describing: functionName)), functionVersion: \(Swift.String(describing: functionVersion)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListAliasesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAliasesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAliasesOutputError>
}

public struct ListAliasesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let functionVersion = input.operationInput.functionVersion {
            let functionVersionQueryItem = ClientRuntime.URLQueryItem(name: "FunctionVersion".urlPercentEncoding(), value: Swift.String(functionVersion).urlPercentEncoding())
            input.builder.withQueryItem(functionVersionQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAliasesOutputError>
}

public struct ListAliasesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAliasesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAliasesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAliasesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAliasesOutputError>
}

public struct ListAliasesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAliasesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAliasesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAliasesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAliasesOutputError>
}

public struct ListAliasesInput: Swift.Equatable {
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - MyFunction.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a function version to only list aliases that invoke that version.
    public var functionVersion: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Limit the number of aliases returned.
    public var maxItems: Swift.Int?

    public init (
        functionName: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListAliasesInputBody: Swift.Equatable {
}

extension ListAliasesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAliasesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAliasesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAliasesOutputResponse(aliases: \(Swift.String(describing: aliases)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension ListAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAliasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliases = output.aliases
            self.nextMarker = output.nextMarker
        } else {
            self.aliases = nil
            self.nextMarker = nil
        }
    }
}

public struct ListAliasesOutputResponse: Swift.Equatable {
    /// A list of aliases.
    public var aliases: [LambdaClientTypes.AliasConfiguration]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init (
        aliases: [LambdaClientTypes.AliasConfiguration]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.aliases = aliases
        self.nextMarker = nextMarker
    }
}

struct ListAliasesOutputResponseBody: Swift.Equatable {
    public let nextMarker: Swift.String?
    public let aliases: [LambdaClientTypes.AliasConfiguration]?
}

extension ListAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let aliasesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.AliasConfiguration?].self, forKey: .aliases)
        var aliasesDecoded0:[LambdaClientTypes.AliasConfiguration]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [LambdaClientTypes.AliasConfiguration]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension ListCodeSigningConfigsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCodeSigningConfigsInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListCodeSigningConfigsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListCodeSigningConfigsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCodeSigningConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCodeSigningConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCodeSigningConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCodeSigningConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCodeSigningConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCodeSigningConfigsOutputError>
}

public struct ListCodeSigningConfigsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCodeSigningConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCodeSigningConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCodeSigningConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCodeSigningConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCodeSigningConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCodeSigningConfigsOutputError>
}

public struct ListCodeSigningConfigsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCodeSigningConfigsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListCodeSigningConfigsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCodeSigningConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCodeSigningConfigsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCodeSigningConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCodeSigningConfigsOutputError>
}

public struct ListCodeSigningConfigsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCodeSigningConfigsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListCodeSigningConfigsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCodeSigningConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-04-22/code-signing-configs"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCodeSigningConfigsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCodeSigningConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCodeSigningConfigsOutputError>
}

public struct ListCodeSigningConfigsInput: Swift.Equatable {
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Maximum number of items to return.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListCodeSigningConfigsInputBody: Swift.Equatable {
}

extension ListCodeSigningConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCodeSigningConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCodeSigningConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCodeSigningConfigsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCodeSigningConfigsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCodeSigningConfigsOutputResponse(codeSigningConfigs: \(Swift.String(describing: codeSigningConfigs)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension ListCodeSigningConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCodeSigningConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfigs = output.codeSigningConfigs
            self.nextMarker = output.nextMarker
        } else {
            self.codeSigningConfigs = nil
            self.nextMarker = nil
        }
    }
}

public struct ListCodeSigningConfigsOutputResponse: Swift.Equatable {
    /// The code signing configurations
    public var codeSigningConfigs: [LambdaClientTypes.CodeSigningConfig]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init (
        codeSigningConfigs: [LambdaClientTypes.CodeSigningConfig]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.codeSigningConfigs = codeSigningConfigs
        self.nextMarker = nextMarker
    }
}

struct ListCodeSigningConfigsOutputResponseBody: Swift.Equatable {
    public let nextMarker: Swift.String?
    public let codeSigningConfigs: [LambdaClientTypes.CodeSigningConfig]?
}

extension ListCodeSigningConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfigs = "CodeSigningConfigs"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let codeSigningConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.CodeSigningConfig?].self, forKey: .codeSigningConfigs)
        var codeSigningConfigsDecoded0:[LambdaClientTypes.CodeSigningConfig]? = nil
        if let codeSigningConfigsContainer = codeSigningConfigsContainer {
            codeSigningConfigsDecoded0 = [LambdaClientTypes.CodeSigningConfig]()
            for structure0 in codeSigningConfigsContainer {
                if let structure0 = structure0 {
                    codeSigningConfigsDecoded0?.append(structure0)
                }
            }
        }
        codeSigningConfigs = codeSigningConfigsDecoded0
    }
}

extension ListEventSourceMappingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEventSourceMappingsInput(eventSourceArn: \(Swift.String(describing: eventSourceArn)), functionName: \(Swift.String(describing: functionName)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListEventSourceMappingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListEventSourceMappingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventSourceMappingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventSourceMappingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventSourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventSourceMappingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventSourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventSourceMappingsOutputError>
}

public struct ListEventSourceMappingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventSourceMappingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventSourceMappingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventSourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let functionName = input.operationInput.functionName {
            let functionNameQueryItem = ClientRuntime.URLQueryItem(name: "FunctionName".urlPercentEncoding(), value: Swift.String(functionName).urlPercentEncoding())
            input.builder.withQueryItem(functionNameQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        if let eventSourceArn = input.operationInput.eventSourceArn {
            let eventSourceArnQueryItem = ClientRuntime.URLQueryItem(name: "EventSourceArn".urlPercentEncoding(), value: Swift.String(eventSourceArn).urlPercentEncoding())
            input.builder.withQueryItem(eventSourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventSourceMappingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventSourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventSourceMappingsOutputError>
}

public struct ListEventSourceMappingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventSourceMappingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListEventSourceMappingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventSourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEventSourceMappingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventSourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventSourceMappingsOutputError>
}

public struct ListEventSourceMappingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventSourceMappingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListEventSourceMappingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventSourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2015-03-31/event-source-mappings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEventSourceMappingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventSourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventSourceMappingsOutputError>
}

public struct ListEventSourceMappingsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the event source.
    ///
    ///
    ///
    ///                   Amazon Kinesis - The ARN of the data stream or a stream consumer.
    ///
    ///
    ///
    ///                   Amazon DynamoDB Streams - The ARN of the stream.
    ///
    ///
    ///
    ///                   Amazon Simple Queue Service - The ARN of the queue.
    ///
    ///
    ///
    ///                   Amazon Managed Streaming for Apache Kafka - The ARN of the cluster.
    ///
    ///
    public var eventSourceArn: Swift.String?
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - MyFunction.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    ///
    ///
    ///                   Version or Alias ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64
    ///       characters in length.
    public var functionName: Swift.String?
    /// A pagination token returned by a previous call.
    public var marker: Swift.String?
    /// The maximum number of event source mappings to return. Note that ListEventSourceMappings returns a maximum of
    ///       100 items in each response, even if you set the number higher.
    public var maxItems: Swift.Int?

    public init (
        eventSourceArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.eventSourceArn = eventSourceArn
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListEventSourceMappingsInputBody: Swift.Equatable {
}

extension ListEventSourceMappingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEventSourceMappingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventSourceMappingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventSourceMappingsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventSourceMappingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEventSourceMappingsOutputResponse(eventSourceMappings: \(Swift.String(describing: eventSourceMappings)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension ListEventSourceMappingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEventSourceMappingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSourceMappings = output.eventSourceMappings
            self.nextMarker = output.nextMarker
        } else {
            self.eventSourceMappings = nil
            self.nextMarker = nil
        }
    }
}

public struct ListEventSourceMappingsOutputResponse: Swift.Equatable {
    /// A list of event source mappings.
    public var eventSourceMappings: [LambdaClientTypes.EventSourceMappingConfiguration]?
    /// A pagination token that's returned when the response doesn't contain all event source mappings.
    public var nextMarker: Swift.String?

    public init (
        eventSourceMappings: [LambdaClientTypes.EventSourceMappingConfiguration]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.eventSourceMappings = eventSourceMappings
        self.nextMarker = nextMarker
    }
}

struct ListEventSourceMappingsOutputResponseBody: Swift.Equatable {
    public let nextMarker: Swift.String?
    public let eventSourceMappings: [LambdaClientTypes.EventSourceMappingConfiguration]?
}

extension ListEventSourceMappingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSourceMappings = "EventSourceMappings"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let eventSourceMappingsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.EventSourceMappingConfiguration?].self, forKey: .eventSourceMappings)
        var eventSourceMappingsDecoded0:[LambdaClientTypes.EventSourceMappingConfiguration]? = nil
        if let eventSourceMappingsContainer = eventSourceMappingsContainer {
            eventSourceMappingsDecoded0 = [LambdaClientTypes.EventSourceMappingConfiguration]()
            for structure0 in eventSourceMappingsContainer {
                if let structure0 = structure0 {
                    eventSourceMappingsDecoded0?.append(structure0)
                }
            }
        }
        eventSourceMappings = eventSourceMappingsDecoded0
    }
}

extension ListFunctionEventInvokeConfigsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFunctionEventInvokeConfigsInput(functionName: \(Swift.String(describing: functionName)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListFunctionEventInvokeConfigsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListFunctionEventInvokeConfigsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionEventInvokeConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFunctionEventInvokeConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionEventInvokeConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFunctionEventInvokeConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionEventInvokeConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionEventInvokeConfigsOutputError>
}

public struct ListFunctionEventInvokeConfigsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionEventInvokeConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFunctionEventInvokeConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionEventInvokeConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFunctionEventInvokeConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionEventInvokeConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionEventInvokeConfigsOutputError>
}

public struct ListFunctionEventInvokeConfigsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionEventInvokeConfigsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListFunctionEventInvokeConfigsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionEventInvokeConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFunctionEventInvokeConfigsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionEventInvokeConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionEventInvokeConfigsOutputError>
}

public struct ListFunctionEventInvokeConfigsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionEventInvokeConfigsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListFunctionEventInvokeConfigsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionEventInvokeConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config/list"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFunctionEventInvokeConfigsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionEventInvokeConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionEventInvokeConfigsOutputError>
}

public struct ListFunctionEventInvokeConfigsInput: Swift.Equatable {
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// The maximum number of configurations to return.
    public var maxItems: Swift.Int?

    public init (
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFunctionEventInvokeConfigsInputBody: Swift.Equatable {
}

extension ListFunctionEventInvokeConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionEventInvokeConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionEventInvokeConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionEventInvokeConfigsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionEventInvokeConfigsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFunctionEventInvokeConfigsOutputResponse(functionEventInvokeConfigs: \(Swift.String(describing: functionEventInvokeConfigs)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension ListFunctionEventInvokeConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFunctionEventInvokeConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functionEventInvokeConfigs = output.functionEventInvokeConfigs
            self.nextMarker = output.nextMarker
        } else {
            self.functionEventInvokeConfigs = nil
            self.nextMarker = nil
        }
    }
}

public struct ListFunctionEventInvokeConfigsOutputResponse: Swift.Equatable {
    /// A list of configurations.
    public var functionEventInvokeConfigs: [LambdaClientTypes.FunctionEventInvokeConfig]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init (
        functionEventInvokeConfigs: [LambdaClientTypes.FunctionEventInvokeConfig]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.functionEventInvokeConfigs = functionEventInvokeConfigs
        self.nextMarker = nextMarker
    }
}

struct ListFunctionEventInvokeConfigsOutputResponseBody: Swift.Equatable {
    public let functionEventInvokeConfigs: [LambdaClientTypes.FunctionEventInvokeConfig]?
    public let nextMarker: Swift.String?
}

extension ListFunctionEventInvokeConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionEventInvokeConfigs = "FunctionEventInvokeConfigs"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionEventInvokeConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionEventInvokeConfig?].self, forKey: .functionEventInvokeConfigs)
        var functionEventInvokeConfigsDecoded0:[LambdaClientTypes.FunctionEventInvokeConfig]? = nil
        if let functionEventInvokeConfigsContainer = functionEventInvokeConfigsContainer {
            functionEventInvokeConfigsDecoded0 = [LambdaClientTypes.FunctionEventInvokeConfig]()
            for structure0 in functionEventInvokeConfigsContainer {
                if let structure0 = structure0 {
                    functionEventInvokeConfigsDecoded0?.append(structure0)
                }
            }
        }
        functionEventInvokeConfigs = functionEventInvokeConfigsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListFunctionsByCodeSigningConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFunctionsByCodeSigningConfigInput(codeSigningConfigArn: \(Swift.String(describing: codeSigningConfigArn)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListFunctionsByCodeSigningConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListFunctionsByCodeSigningConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsByCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFunctionsByCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsByCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFunctionsByCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsByCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsByCodeSigningConfigOutputError>
}

public struct ListFunctionsByCodeSigningConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsByCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFunctionsByCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsByCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFunctionsByCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsByCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsByCodeSigningConfigOutputError>
}

public struct ListFunctionsByCodeSigningConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsByCodeSigningConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListFunctionsByCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsByCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFunctionsByCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsByCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsByCodeSigningConfigOutputError>
}

public struct ListFunctionsByCodeSigningConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsByCodeSigningConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListFunctionsByCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsByCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let codeSigningConfigArn = input.codeSigningConfigArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("codeSigningConfigArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())/functions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFunctionsByCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsByCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsByCodeSigningConfigOutputError>
}

public struct ListFunctionsByCodeSigningConfigInput: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Maximum number of items to return.
    public var maxItems: Swift.Int?

    public init (
        codeSigningConfigArn: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFunctionsByCodeSigningConfigInputBody: Swift.Equatable {
}

extension ListFunctionsByCodeSigningConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionsByCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionsByCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionsByCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionsByCodeSigningConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFunctionsByCodeSigningConfigOutputResponse(functionArns: \(Swift.String(describing: functionArns)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension ListFunctionsByCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFunctionsByCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functionArns = output.functionArns
            self.nextMarker = output.nextMarker
        } else {
            self.functionArns = nil
            self.nextMarker = nil
        }
    }
}

public struct ListFunctionsByCodeSigningConfigOutputResponse: Swift.Equatable {
    /// The function ARNs.
    public var functionArns: [Swift.String]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init (
        functionArns: [Swift.String]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.functionArns = functionArns
        self.nextMarker = nextMarker
    }
}

struct ListFunctionsByCodeSigningConfigOutputResponseBody: Swift.Equatable {
    public let nextMarker: Swift.String?
    public let functionArns: [Swift.String]?
}

extension ListFunctionsByCodeSigningConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArns = "FunctionArns"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let functionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .functionArns)
        var functionArnsDecoded0:[Swift.String]? = nil
        if let functionArnsContainer = functionArnsContainer {
            functionArnsDecoded0 = [Swift.String]()
            for string0 in functionArnsContainer {
                if let string0 = string0 {
                    functionArnsDecoded0?.append(string0)
                }
            }
        }
        functionArns = functionArnsDecoded0
    }
}

extension ListFunctionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFunctionsInput(functionVersion: \(Swift.String(describing: functionVersion)), marker: \(Swift.String(describing: marker)), masterRegion: \(Swift.String(describing: masterRegion)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListFunctionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListFunctionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFunctionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFunctionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFunctionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let masterRegion = input.operationInput.masterRegion {
            let masterRegionQueryItem = ClientRuntime.URLQueryItem(name: "MasterRegion".urlPercentEncoding(), value: Swift.String(masterRegion).urlPercentEncoding())
            input.builder.withQueryItem(masterRegionQueryItem)
        }
        if let functionVersion = input.operationInput.functionVersion {
            let functionVersionQueryItem = ClientRuntime.URLQueryItem(name: "FunctionVersion".urlPercentEncoding(), value: Swift.String(functionVersion.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(functionVersionQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFunctionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListFunctionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFunctionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListFunctionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2015-03-31/functions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFunctionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInput: Swift.Equatable {
    /// Set to ALL to include entries for all published versions of each function.
    public var functionVersion: LambdaClientTypes.FunctionVersion?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// For Lambda@Edge functions, the Amazon Web Services Region of the master function. For example, us-east-1 filters
    ///       the list of functions to only include Lambda@Edge functions replicated from a master function in US East (N.
    ///       Virginia). If specified, you must set FunctionVersion to ALL.
    public var masterRegion: Swift.String?
    /// The maximum number of functions to return in the response. Note that ListFunctions returns a maximum of 50 items in each response,
    ///       even if you set the number higher.
    public var maxItems: Swift.Int?

    public init (
        functionVersion: LambdaClientTypes.FunctionVersion? = nil,
        marker: Swift.String? = nil,
        masterRegion: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionVersion = functionVersion
        self.marker = marker
        self.masterRegion = masterRegion
        self.maxItems = maxItems
    }
}

struct ListFunctionsInputBody: Swift.Equatable {
}

extension ListFunctionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFunctionsOutputResponse(functions: \(Swift.String(describing: functions)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension ListFunctionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFunctionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.functions = output.functions
            self.nextMarker = output.nextMarker
        } else {
            self.functions = nil
            self.nextMarker = nil
        }
    }
}

/// A list of Lambda functions.
public struct ListFunctionsOutputResponse: Swift.Equatable {
    /// A list of Lambda functions.
    public var functions: [LambdaClientTypes.FunctionConfiguration]?
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?

    public init (
        functions: [LambdaClientTypes.FunctionConfiguration]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.functions = functions
        self.nextMarker = nextMarker
    }
}

struct ListFunctionsOutputResponseBody: Swift.Equatable {
    public let nextMarker: Swift.String?
    public let functions: [LambdaClientTypes.FunctionConfiguration]?
}

extension ListFunctionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functions = "Functions"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let functionsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionConfiguration?].self, forKey: .functions)
        var functionsDecoded0:[LambdaClientTypes.FunctionConfiguration]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [LambdaClientTypes.FunctionConfiguration]()
            for structure0 in functionsContainer {
                if let structure0 = structure0 {
                    functionsDecoded0?.append(structure0)
                }
            }
        }
        functions = functionsDecoded0
    }
}

extension ListLayerVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLayerVersionsInput(compatibleArchitecture: \(Swift.String(describing: compatibleArchitecture)), compatibleRuntime: \(Swift.String(describing: compatibleRuntime)), layerName: \(Swift.String(describing: layerName)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListLayerVersionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListLayerVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLayerVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLayerVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLayerVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLayerVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLayerVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLayerVersionsOutputError>
}

public struct ListLayerVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLayerVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLayerVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLayerVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let compatibleRuntime = input.operationInput.compatibleRuntime {
            let compatibleRuntimeQueryItem = ClientRuntime.URLQueryItem(name: "CompatibleRuntime".urlPercentEncoding(), value: Swift.String(compatibleRuntime.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(compatibleRuntimeQueryItem)
        }
        if let compatibleArchitecture = input.operationInput.compatibleArchitecture {
            let compatibleArchitectureQueryItem = ClientRuntime.URLQueryItem(name: "CompatibleArchitecture".urlPercentEncoding(), value: Swift.String(compatibleArchitecture.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(compatibleArchitectureQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLayerVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLayerVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLayerVersionsOutputError>
}

public struct ListLayerVersionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLayerVersionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListLayerVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLayerVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLayerVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLayerVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLayerVersionsOutputError>
}

public struct ListLayerVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLayerVersionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListLayerVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLayerVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let layerName = input.layerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("layerName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLayerVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLayerVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLayerVersionsOutputError>
}

public struct ListLayerVersionsInput: Swift.Equatable {
    /// The compatible
    /// <a href="https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html">instruction set architecture.
    public var compatibleArchitecture: LambdaClientTypes.Architecture?
    /// A runtime identifier. For example, go1.x.
    public var compatibleRuntime: LambdaClientTypes.Runtime?
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// A pagination token returned by a previous call.
    public var marker: Swift.String?
    /// The maximum number of versions to return.
    public var maxItems: Swift.Int?

    public init (
        compatibleArchitecture: LambdaClientTypes.Architecture? = nil,
        compatibleRuntime: LambdaClientTypes.Runtime? = nil,
        layerName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.compatibleArchitecture = compatibleArchitecture
        self.compatibleRuntime = compatibleRuntime
        self.layerName = layerName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListLayerVersionsInputBody: Swift.Equatable {
}

extension ListLayerVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLayerVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLayerVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLayerVersionsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLayerVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLayerVersionsOutputResponse(layerVersions: \(Swift.String(describing: layerVersions)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension ListLayerVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLayerVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.layerVersions = output.layerVersions
            self.nextMarker = output.nextMarker
        } else {
            self.layerVersions = nil
            self.nextMarker = nil
        }
    }
}

public struct ListLayerVersionsOutputResponse: Swift.Equatable {
    /// A list of versions.
    public var layerVersions: [LambdaClientTypes.LayerVersionsListItem]?
    /// A pagination token returned when the response doesn't contain all versions.
    public var nextMarker: Swift.String?

    public init (
        layerVersions: [LambdaClientTypes.LayerVersionsListItem]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.layerVersions = layerVersions
        self.nextMarker = nextMarker
    }
}

struct ListLayerVersionsOutputResponseBody: Swift.Equatable {
    public let nextMarker: Swift.String?
    public let layerVersions: [LambdaClientTypes.LayerVersionsListItem]?
}

extension ListLayerVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerVersions = "LayerVersions"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let layerVersionsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.LayerVersionsListItem?].self, forKey: .layerVersions)
        var layerVersionsDecoded0:[LambdaClientTypes.LayerVersionsListItem]? = nil
        if let layerVersionsContainer = layerVersionsContainer {
            layerVersionsDecoded0 = [LambdaClientTypes.LayerVersionsListItem]()
            for structure0 in layerVersionsContainer {
                if let structure0 = structure0 {
                    layerVersionsDecoded0?.append(structure0)
                }
            }
        }
        layerVersions = layerVersionsDecoded0
    }
}

extension ListLayersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLayersInput(compatibleArchitecture: \(Swift.String(describing: compatibleArchitecture)), compatibleRuntime: \(Swift.String(describing: compatibleRuntime)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListLayersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListLayersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLayersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLayersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLayersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLayersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLayersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLayersOutputError>
}

public struct ListLayersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLayersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLayersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLayersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let compatibleRuntime = input.operationInput.compatibleRuntime {
            let compatibleRuntimeQueryItem = ClientRuntime.URLQueryItem(name: "CompatibleRuntime".urlPercentEncoding(), value: Swift.String(compatibleRuntime.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(compatibleRuntimeQueryItem)
        }
        if let compatibleArchitecture = input.operationInput.compatibleArchitecture {
            let compatibleArchitectureQueryItem = ClientRuntime.URLQueryItem(name: "CompatibleArchitecture".urlPercentEncoding(), value: Swift.String(compatibleArchitecture.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(compatibleArchitectureQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLayersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLayersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLayersOutputError>
}

public struct ListLayersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLayersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListLayersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLayersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLayersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLayersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLayersOutputError>
}

public struct ListLayersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLayersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListLayersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLayersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2018-10-31/layers"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLayersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLayersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLayersOutputError>
}

public struct ListLayersInput: Swift.Equatable {
    /// The compatible
    /// <a href="https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html">instruction set architecture.
    public var compatibleArchitecture: LambdaClientTypes.Architecture?
    /// A runtime identifier. For example, go1.x.
    public var compatibleRuntime: LambdaClientTypes.Runtime?
    /// A pagination token returned by a previous call.
    public var marker: Swift.String?
    /// The maximum number of layers to return.
    public var maxItems: Swift.Int?

    public init (
        compatibleArchitecture: LambdaClientTypes.Architecture? = nil,
        compatibleRuntime: LambdaClientTypes.Runtime? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.compatibleArchitecture = compatibleArchitecture
        self.compatibleRuntime = compatibleRuntime
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListLayersInputBody: Swift.Equatable {
}

extension ListLayersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLayersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLayersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLayersOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLayersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLayersOutputResponse(layers: \(Swift.String(describing: layers)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension ListLayersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLayersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.layers = output.layers
            self.nextMarker = output.nextMarker
        } else {
            self.layers = nil
            self.nextMarker = nil
        }
    }
}

public struct ListLayersOutputResponse: Swift.Equatable {
    /// A list of function layers.
    public var layers: [LambdaClientTypes.LayersListItem]?
    /// A pagination token returned when the response doesn't contain all layers.
    public var nextMarker: Swift.String?

    public init (
        layers: [LambdaClientTypes.LayersListItem]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.layers = layers
        self.nextMarker = nextMarker
    }
}

struct ListLayersOutputResponseBody: Swift.Equatable {
    public let nextMarker: Swift.String?
    public let layers: [LambdaClientTypes.LayersListItem]?
}

extension ListLayersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layers = "Layers"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.LayersListItem?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.LayersListItem]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.LayersListItem]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
    }
}

extension ListProvisionedConcurrencyConfigsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProvisionedConcurrencyConfigsInput(functionName: \(Swift.String(describing: functionName)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListProvisionedConcurrencyConfigsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListProvisionedConcurrencyConfigsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisionedConcurrencyConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProvisionedConcurrencyConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisionedConcurrencyConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProvisionedConcurrencyConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisionedConcurrencyConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisionedConcurrencyConfigsOutputError>
}

public struct ListProvisionedConcurrencyConfigsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisionedConcurrencyConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProvisionedConcurrencyConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisionedConcurrencyConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "List", value: "ALL"))
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProvisionedConcurrencyConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisionedConcurrencyConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisionedConcurrencyConfigsOutputError>
}

public struct ListProvisionedConcurrencyConfigsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisionedConcurrencyConfigsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListProvisionedConcurrencyConfigsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisionedConcurrencyConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProvisionedConcurrencyConfigsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisionedConcurrencyConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisionedConcurrencyConfigsOutputError>
}

public struct ListProvisionedConcurrencyConfigsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisionedConcurrencyConfigsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListProvisionedConcurrencyConfigsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisionedConcurrencyConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProvisionedConcurrencyConfigsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisionedConcurrencyConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisionedConcurrencyConfigsOutputError>
}

public struct ListProvisionedConcurrencyConfigsInput: Swift.Equatable {
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// Specify a number to limit the number of configurations returned.
    public var maxItems: Swift.Int?

    public init (
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListProvisionedConcurrencyConfigsInputBody: Swift.Equatable {
}

extension ListProvisionedConcurrencyConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProvisionedConcurrencyConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProvisionedConcurrencyConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProvisionedConcurrencyConfigsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProvisionedConcurrencyConfigsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProvisionedConcurrencyConfigsOutputResponse(nextMarker: \(Swift.String(describing: nextMarker)), provisionedConcurrencyConfigs: \(Swift.String(describing: provisionedConcurrencyConfigs)))"}
}

extension ListProvisionedConcurrencyConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProvisionedConcurrencyConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.provisionedConcurrencyConfigs = output.provisionedConcurrencyConfigs
        } else {
            self.nextMarker = nil
            self.provisionedConcurrencyConfigs = nil
        }
    }
}

public struct ListProvisionedConcurrencyConfigsOutputResponse: Swift.Equatable {
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?
    /// A list of provisioned concurrency configurations.
    public var provisionedConcurrencyConfigs: [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]?

    public init (
        nextMarker: Swift.String? = nil,
        provisionedConcurrencyConfigs: [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.provisionedConcurrencyConfigs = provisionedConcurrencyConfigs
    }
}

struct ListProvisionedConcurrencyConfigsOutputResponseBody: Swift.Equatable {
    public let provisionedConcurrencyConfigs: [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]?
    public let nextMarker: Swift.String?
}

extension ListProvisionedConcurrencyConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker = "NextMarker"
        case provisionedConcurrencyConfigs = "ProvisionedConcurrencyConfigs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedConcurrencyConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.ProvisionedConcurrencyConfigListItem?].self, forKey: .provisionedConcurrencyConfigs)
        var provisionedConcurrencyConfigsDecoded0:[LambdaClientTypes.ProvisionedConcurrencyConfigListItem]? = nil
        if let provisionedConcurrencyConfigsContainer = provisionedConcurrencyConfigsContainer {
            provisionedConcurrencyConfigsDecoded0 = [LambdaClientTypes.ProvisionedConcurrencyConfigListItem]()
            for structure0 in provisionedConcurrencyConfigsContainer {
                if let structure0 = structure0 {
                    provisionedConcurrencyConfigsDecoded0?.append(structure0)
                }
            }
        }
        provisionedConcurrencyConfigs = provisionedConcurrencyConfigsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsInput(resource: \(Swift.String(describing: resource)))"}
}

extension ListTagsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resource = input.resource else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resource is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2017-03-31/tags/\(resource.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInput: Swift.Equatable {
    /// The function's Amazon Resource Name (ARN).
    ///       Note: Lambda does not support adding tags to aliases or versions.
    /// This member is required.
    public var resource: Swift.String?

    public init (
        resource: Swift.String? = nil
    )
    {
        self.resource = resource
    }
}

struct ListTagsInputBody: Swift.Equatable {
}

extension ListTagsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Swift.Equatable {
    /// The function's tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVersionsByFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVersionsByFunctionInput(functionName: \(Swift.String(describing: functionName)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListVersionsByFunctionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListVersionsByFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVersionsByFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVersionsByFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVersionsByFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVersionsByFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVersionsByFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVersionsByFunctionOutputError>
}

public struct ListVersionsByFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVersionsByFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVersionsByFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVersionsByFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVersionsByFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVersionsByFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVersionsByFunctionOutputError>
}

public struct ListVersionsByFunctionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVersionsByFunctionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListVersionsByFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVersionsByFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVersionsByFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVersionsByFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVersionsByFunctionOutputError>
}

public struct ListVersionsByFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVersionsByFunctionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListVersionsByFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVersionsByFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())/versions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVersionsByFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVersionsByFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVersionsByFunctionOutputError>
}

public struct ListVersionsByFunctionInput: Swift.Equatable {
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - MyFunction.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var marker: Swift.String?
    /// The maximum number of versions to return. Note that ListVersionsByFunction returns a maximum of 50 items in each response,
    ///       even if you set the number higher.
    public var maxItems: Swift.Int?

    public init (
        functionName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListVersionsByFunctionInputBody: Swift.Equatable {
}

extension ListVersionsByFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVersionsByFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVersionsByFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVersionsByFunctionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVersionsByFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVersionsByFunctionOutputResponse(nextMarker: \(Swift.String(describing: nextMarker)), versions: \(Swift.String(describing: versions)))"}
}

extension ListVersionsByFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListVersionsByFunctionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.versions = output.versions
        } else {
            self.nextMarker = nil
            self.versions = nil
        }
    }
}

public struct ListVersionsByFunctionOutputResponse: Swift.Equatable {
    /// The pagination token that's included if more results are available.
    public var nextMarker: Swift.String?
    /// A list of Lambda function versions.
    public var versions: [LambdaClientTypes.FunctionConfiguration]?

    public init (
        nextMarker: Swift.String? = nil,
        versions: [LambdaClientTypes.FunctionConfiguration]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.versions = versions
    }
}

struct ListVersionsByFunctionOutputResponseBody: Swift.Equatable {
    public let nextMarker: Swift.String?
    public let versions: [LambdaClientTypes.FunctionConfiguration]?
}

extension ListVersionsByFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker = "NextMarker"
        case versions = "Versions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let versionsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionConfiguration?].self, forKey: .versions)
        var versionsDecoded0:[LambdaClientTypes.FunctionConfiguration]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [LambdaClientTypes.FunctionConfiguration]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension LambdaClientTypes {
    public enum LogType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case tail
        case sdkUnknown(Swift.String)

        public static var allCases: [LogType] {
            return [
                .none,
                .tail,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "None"
            case .tail: return "Tail"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogType(rawValue: rawValue) ?? LogType.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.OnFailure: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension LambdaClientTypes.OnFailure: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OnFailure(destination: \(Swift.String(describing: destination)))"}
}

extension LambdaClientTypes {
    /// A destination for events that failed processing.
    public struct OnFailure: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the destination resource.
        public var destination: Swift.String?

        public init (
            destination: Swift.String? = nil
        )
        {
            self.destination = destination
        }
    }

}

extension LambdaClientTypes.OnSuccess: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension LambdaClientTypes.OnSuccess: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OnSuccess(destination: \(Swift.String(describing: destination)))"}
}

extension LambdaClientTypes {
    /// A destination for events that were processed successfully.
    public struct OnSuccess: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the destination resource.
        public var destination: Swift.String?

        public init (
            destination: Swift.String? = nil
        )
        {
            self.destination = destination
        }
    }

}

extension LambdaClientTypes {
    public enum PackageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case image
        case zip
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageType] {
            return [
                .image,
                .zip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .image: return "Image"
            case .zip: return "Zip"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageType(rawValue: rawValue) ?? PackageType.sdkUnknown(rawValue)
        }
    }
}

extension PolicyLengthExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyLengthExceededException(type: \(Swift.String(describing: type)), message: \(Swift.String(describing: message)))"}
}

extension PolicyLengthExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PolicyLengthExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The permissions policy for the resource is too large. <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">Learn more
///
public struct PolicyLengthExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct PolicyLengthExceededExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension PolicyLengthExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PreconditionFailedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PreconditionFailedException(type: \(Swift.String(describing: type)), message: \(Swift.String(describing: message)))"}
}

extension PreconditionFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PreconditionFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call the
///         GetFunction or the GetAlias API to retrieve the latest RevisionId for your
///       resource.
public struct PreconditionFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception message.
    public var message: Swift.String?
    /// The exception type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct PreconditionFailedExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension PreconditionFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.ProvisionedConcurrencyConfigListItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
        case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions {
            try encodeContainer.encode(allocatedProvisionedConcurrentExecutions, forKey: .allocatedProvisionedConcurrentExecutions)
        }
        if let availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions {
            try encodeContainer.encode(availableProvisionedConcurrentExecutions, forKey: .availableProvisionedConcurrentExecutions)
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
        if let requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions {
            try encodeContainer.encode(requestedProvisionedConcurrentExecutions, forKey: .requestedProvisionedConcurrentExecutions)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let requestedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requestedProvisionedConcurrentExecutions)
        requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutionsDecoded
        let availableProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availableProvisionedConcurrentExecutions)
        availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutionsDecoded
        let allocatedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedProvisionedConcurrentExecutions)
        allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ProvisionedConcurrencyStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension LambdaClientTypes.ProvisionedConcurrencyConfigListItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionedConcurrencyConfigListItem(allocatedProvisionedConcurrentExecutions: \(Swift.String(describing: allocatedProvisionedConcurrentExecutions)), availableProvisionedConcurrentExecutions: \(Swift.String(describing: availableProvisionedConcurrentExecutions)), functionArn: \(Swift.String(describing: functionArn)), lastModified: \(Swift.String(describing: lastModified)), requestedProvisionedConcurrentExecutions: \(Swift.String(describing: requestedProvisionedConcurrentExecutions)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)))"}
}

extension LambdaClientTypes {
    /// Details about the provisioned concurrency configuration for a function alias or version.
    public struct ProvisionedConcurrencyConfigListItem: Swift.Equatable {
        /// The amount of provisioned concurrency allocated.
        public var allocatedProvisionedConcurrentExecutions: Swift.Int?
        /// The amount of provisioned concurrency available.
        public var availableProvisionedConcurrentExecutions: Swift.Int?
        /// The Amazon Resource Name (ARN) of the alias or version.
        public var functionArn: Swift.String?
        /// The date and time that a user last updated the configuration, in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format.
        public var lastModified: Swift.String?
        /// The amount of provisioned concurrency requested.
        public var requestedProvisionedConcurrentExecutions: Swift.Int?
        /// The status of the allocation process.
        public var status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
        /// For failed allocations, the reason that provisioned concurrency could not be allocated.
        public var statusReason: Swift.String?

        public init (
            allocatedProvisionedConcurrentExecutions: Swift.Int? = nil,
            availableProvisionedConcurrentExecutions: Swift.Int? = nil,
            functionArn: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            requestedProvisionedConcurrentExecutions: Swift.Int? = nil,
            status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
            self.functionArn = functionArn
            self.lastModified = lastModified
            self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension ProvisionedConcurrencyConfigNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionedConcurrencyConfigNotFoundException(type: \(Swift.String(describing: type)), message: \(Swift.String(describing: message)))"}
}

extension ProvisionedConcurrencyConfigNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ProvisionedConcurrencyConfigNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified configuration does not exist.
public struct ProvisionedConcurrencyConfigNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ProvisionedConcurrencyConfigNotFoundExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension ProvisionedConcurrencyConfigNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum ProvisionedConcurrencyStatusEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedConcurrencyStatusEnum] {
            return [
                .failed,
                .inProgress,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionedConcurrencyStatusEnum(rawValue: rawValue) ?? ProvisionedConcurrencyStatusEnum.sdkUnknown(rawValue)
        }
    }
}

public struct PublishLayerVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishLayerVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishLayerVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishLayerVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishLayerVersionOutputError>
}

extension PublishLayerVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishLayerVersionInput(compatibleArchitectures: \(Swift.String(describing: compatibleArchitectures)), compatibleRuntimes: \(Swift.String(describing: compatibleRuntimes)), content: \(Swift.String(describing: content)), description: \(Swift.String(describing: description)), layerName: \(Swift.String(describing: layerName)), licenseInfo: \(Swift.String(describing: licenseInfo)))"}
}

extension PublishLayerVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case description = "Description"
        case licenseInfo = "LicenseInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleArchitectures = compatibleArchitectures {
            var compatibleArchitecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleArchitectures)
            for compatiblearchitectures0 in compatibleArchitectures {
                try compatibleArchitecturesContainer.encode(compatiblearchitectures0.rawValue)
            }
        }
        if let compatibleRuntimes = compatibleRuntimes {
            var compatibleRuntimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleRuntimes)
            for compatibleruntimes0 in compatibleRuntimes {
                try compatibleRuntimesContainer.encode(compatibleruntimes0.rawValue)
            }
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let licenseInfo = licenseInfo {
            try encodeContainer.encode(licenseInfo, forKey: .licenseInfo)
        }
    }
}

public struct PublishLayerVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishLayerVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishLayerVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishLayerVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishLayerVersionOutputError>
}

public struct PublishLayerVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishLayerVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishLayerVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishLayerVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishLayerVersionOutputError>
}

public struct PublishLayerVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishLayerVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PublishLayerVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PublishLayerVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<PublishLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishLayerVersionOutputError>
}

public struct PublishLayerVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishLayerVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PublishLayerVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let layerName = input.layerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("layerName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PublishLayerVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<PublishLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishLayerVersionOutputError>
}

public struct PublishLayerVersionInput: Swift.Equatable {
    /// A list of compatible
    /// <a href="https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html">instruction set architectures.
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// A list of compatible <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">function
    ///         runtimes. Used for filtering with ListLayers and ListLayerVersions.
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// The function layer archive.
    /// This member is required.
    public var content: LambdaClientTypes.LayerVersionContentInput?
    /// The description of the version.
    public var description: Swift.String?
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// The layer's software license. It can be any of the following:
    ///
    ///
    ///                An <a href="https://spdx.org/licenses/">SPDX license identifier. For example,
    ///           MIT.
    ///
    ///
    ///                The URL of a license hosted on the internet. For example,
    ///           https://opensource.org/licenses/MIT.
    ///
    ///
    ///                The full text of the license.
    ///
    ///
    public var licenseInfo: Swift.String?

    public init (
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentInput? = nil,
        description: Swift.String? = nil,
        layerName: Swift.String? = nil,
        licenseInfo: Swift.String? = nil
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.description = description
        self.layerName = layerName
        self.licenseInfo = licenseInfo
    }
}

struct PublishLayerVersionInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let content: LambdaClientTypes.LayerVersionContentInput?
    public let compatibleRuntimes: [LambdaClientTypes.Runtime]?
    public let licenseInfo: Swift.String?
    public let compatibleArchitectures: [LambdaClientTypes.Architecture]?
}

extension PublishLayerVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case description = "Description"
        case licenseInfo = "LicenseInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LayerVersionContentInput.self, forKey: .content)
        content = contentDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[LambdaClientTypes.Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [LambdaClientTypes.Runtime]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
        let compatibleArchitecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .compatibleArchitectures)
        var compatibleArchitecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let compatibleArchitecturesContainer = compatibleArchitecturesContainer {
            compatibleArchitecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in compatibleArchitecturesContainer {
                if let string0 = string0 {
                    compatibleArchitecturesDecoded0?.append(string0)
                }
            }
        }
        compatibleArchitectures = compatibleArchitecturesDecoded0
    }
}

extension PublishLayerVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PublishLayerVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeStorageExceededException" : self = .codeStorageExceededException(try CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishLayerVersionOutputError: Swift.Error, Swift.Equatable {
    case codeStorageExceededException(CodeStorageExceededException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishLayerVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishLayerVersionOutputResponse(compatibleArchitectures: \(Swift.String(describing: compatibleArchitectures)), compatibleRuntimes: \(Swift.String(describing: compatibleRuntimes)), content: \(Swift.String(describing: content)), createdDate: \(Swift.String(describing: createdDate)), description: \(Swift.String(describing: description)), layerArn: \(Swift.String(describing: layerArn)), layerVersionArn: \(Swift.String(describing: layerVersionArn)), licenseInfo: \(Swift.String(describing: licenseInfo)), version: \(Swift.String(describing: version)))"}
}

extension PublishLayerVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PublishLayerVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.compatibleArchitectures = output.compatibleArchitectures
            self.compatibleRuntimes = output.compatibleRuntimes
            self.content = output.content
            self.createdDate = output.createdDate
            self.description = output.description
            self.layerArn = output.layerArn
            self.layerVersionArn = output.layerVersionArn
            self.licenseInfo = output.licenseInfo
            self.version = output.version
        } else {
            self.compatibleArchitectures = nil
            self.compatibleRuntimes = nil
            self.content = nil
            self.createdDate = nil
            self.description = nil
            self.layerArn = nil
            self.layerVersionArn = nil
            self.licenseInfo = nil
            self.version = 0
        }
    }
}

public struct PublishLayerVersionOutputResponse: Swift.Equatable {
    /// A list of compatible
    /// <a href="https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html">instruction set architectures.
    public var compatibleArchitectures: [LambdaClientTypes.Architecture]?
    /// The layer's compatible runtimes.
    public var compatibleRuntimes: [LambdaClientTypes.Runtime]?
    /// Details about the layer version.
    public var content: LambdaClientTypes.LayerVersionContentOutput?
    /// The date that the layer version was created, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
    public var createdDate: Swift.String?
    /// The description of the version.
    public var description: Swift.String?
    /// The ARN of the layer.
    public var layerArn: Swift.String?
    /// The ARN of the layer version.
    public var layerVersionArn: Swift.String?
    /// The layer's software license.
    public var licenseInfo: Swift.String?
    /// The version number.
    public var version: Swift.Int

    public init (
        compatibleArchitectures: [LambdaClientTypes.Architecture]? = nil,
        compatibleRuntimes: [LambdaClientTypes.Runtime]? = nil,
        content: LambdaClientTypes.LayerVersionContentOutput? = nil,
        createdDate: Swift.String? = nil,
        description: Swift.String? = nil,
        layerArn: Swift.String? = nil,
        layerVersionArn: Swift.String? = nil,
        licenseInfo: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.compatibleArchitectures = compatibleArchitectures
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

struct PublishLayerVersionOutputResponseBody: Swift.Equatable {
    public let content: LambdaClientTypes.LayerVersionContentOutput?
    public let layerArn: Swift.String?
    public let layerVersionArn: Swift.String?
    public let description: Swift.String?
    public let createdDate: Swift.String?
    public let version: Swift.Int
    public let compatibleRuntimes: [LambdaClientTypes.Runtime]?
    public let licenseInfo: Swift.String?
    public let compatibleArchitectures: [LambdaClientTypes.Architecture]?
}

extension PublishLayerVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleArchitectures = "CompatibleArchitectures"
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerArn = "LayerArn"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LayerVersionContentOutput.self, forKey: .content)
        content = contentDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[LambdaClientTypes.Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [LambdaClientTypes.Runtime]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
        let compatibleArchitecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .compatibleArchitectures)
        var compatibleArchitecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let compatibleArchitecturesContainer = compatibleArchitecturesContainer {
            compatibleArchitecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in compatibleArchitecturesContainer {
                if let string0 = string0 {
                    compatibleArchitecturesDecoded0?.append(string0)
                }
            }
        }
        compatibleArchitectures = compatibleArchitecturesDecoded0
    }
}

public struct PublishVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishVersionOutputError>
}

extension PublishVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishVersionInput(codeSha256: \(Swift.String(describing: codeSha256)), description: \(Swift.String(describing: description)), functionName: \(Swift.String(describing: functionName)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension PublishVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSha256 = "CodeSha256"
        case description = "Description"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeSha256 = codeSha256 {
            try encodeContainer.encode(codeSha256, forKey: .codeSha256)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

public struct PublishVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishVersionOutputError>
}

public struct PublishVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishVersionOutputError>
}

public struct PublishVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PublishVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PublishVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<PublishVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishVersionOutputError>
}

public struct PublishVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PublishVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())/versions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PublishVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<PublishVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishVersionOutputError>
}

public struct PublishVersionInput: Swift.Equatable {
    /// Only publish a version if the hash value matches the value that's specified. Use this option to avoid
    ///       publishing a version if the function code has changed since you last updated it. You can get the hash for the
    ///       version that you uploaded from the output of UpdateFunctionCode.
    public var codeSha256: Swift.String?
    /// A description for the version to override the description in the function configuration.
    public var description: Swift.String?
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - MyFunction.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Only update the function if the revision ID matches the ID that's specified. Use this option to avoid
    ///       publishing a version if the function configuration has changed since you last updated it.
    public var revisionId: Swift.String?

    public init (
        codeSha256: Swift.String? = nil,
        description: Swift.String? = nil,
        functionName: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.codeSha256 = codeSha256
        self.description = description
        self.functionName = functionName
        self.revisionId = revisionId
    }
}

struct PublishVersionInputBody: Swift.Equatable {
    public let codeSha256: Swift.String?
    public let description: Swift.String?
    public let revisionId: Swift.String?
}

extension PublishVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSha256 = "CodeSha256"
        case description = "Description"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension PublishVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PublishVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeStorageExceededException" : self = .codeStorageExceededException(try CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishVersionOutputError: Swift.Error, Swift.Equatable {
    case codeStorageExceededException(CodeStorageExceededException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishVersionOutputResponse(architectures: \(Swift.String(describing: architectures)), codeSha256: \(Swift.String(describing: codeSha256)), codeSize: \(Swift.String(describing: codeSize)), deadLetterConfig: \(Swift.String(describing: deadLetterConfig)), description: \(Swift.String(describing: description)), environment: \(Swift.String(describing: environment)), fileSystemConfigs: \(Swift.String(describing: fileSystemConfigs)), functionArn: \(Swift.String(describing: functionArn)), functionName: \(Swift.String(describing: functionName)), handler: \(Swift.String(describing: handler)), imageConfigResponse: \(Swift.String(describing: imageConfigResponse)), kMSKeyArn: \(Swift.String(describing: kMSKeyArn)), lastModified: \(Swift.String(describing: lastModified)), lastUpdateStatus: \(Swift.String(describing: lastUpdateStatus)), lastUpdateStatusReason: \(Swift.String(describing: lastUpdateStatusReason)), lastUpdateStatusReasonCode: \(Swift.String(describing: lastUpdateStatusReasonCode)), layers: \(Swift.String(describing: layers)), masterArn: \(Swift.String(describing: masterArn)), memorySize: \(Swift.String(describing: memorySize)), packageType: \(Swift.String(describing: packageType)), revisionId: \(Swift.String(describing: revisionId)), role: \(Swift.String(describing: role)), runtime: \(Swift.String(describing: runtime)), signingJobArn: \(Swift.String(describing: signingJobArn)), signingProfileVersionArn: \(Swift.String(describing: signingProfileVersionArn)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)), stateReasonCode: \(Swift.String(describing: stateReasonCode)), timeout: \(Swift.String(describing: timeout)), tracingConfig: \(Swift.String(describing: tracingConfig)), version: \(Swift.String(describing: version)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension PublishVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PublishVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architectures = output.architectures
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kMSKeyArn = output.kMSKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.architectures = nil
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kMSKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// Details about a function's configuration.
public struct PublishVersionOutputResponse: Swift.Equatable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the
    ///       valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">environment variables.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// Connection settings for an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html">Amazon EFS file system.
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin executing your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    ///       configured a customer managed CMK.
    public var kMSKeyArn: Swift.String?
    /// The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful
    ///       after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    ///       layers.
    public var layers: [LambdaClientTypes.Layer]?
    /// For Lambda@Edge functions, the ARN of the master function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The runtime environment for the Lambda function.
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by
    ///       invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or
    ///       modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init (
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kMSKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct PublishVersionOutputResponseBody: Swift.Equatable {
    public let functionName: Swift.String?
    public let functionArn: Swift.String?
    public let runtime: LambdaClientTypes.Runtime?
    public let role: Swift.String?
    public let handler: Swift.String?
    public let codeSize: Swift.Int
    public let description: Swift.String?
    public let timeout: Swift.Int?
    public let memorySize: Swift.Int?
    public let lastModified: Swift.String?
    public let codeSha256: Swift.String?
    public let version: Swift.String?
    public let vpcConfig: LambdaClientTypes.VpcConfigResponse?
    public let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    public let environment: LambdaClientTypes.EnvironmentResponse?
    public let kMSKeyArn: Swift.String?
    public let tracingConfig: LambdaClientTypes.TracingConfigResponse?
    public let masterArn: Swift.String?
    public let revisionId: Swift.String?
    public let layers: [LambdaClientTypes.Layer]?
    public let state: LambdaClientTypes.State?
    public let stateReason: Swift.String?
    public let stateReasonCode: LambdaClientTypes.StateReasonCode?
    public let lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    public let lastUpdateStatusReason: Swift.String?
    public let lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    public let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    public let packageType: LambdaClientTypes.PackageType?
    public let imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    public let signingProfileVersionArn: Swift.String?
    public let signingJobArn: Swift.String?
    public let architectures: [LambdaClientTypes.Architecture]?
}

extension PublishVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

public struct PutFunctionCodeSigningConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFunctionCodeSigningConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutFunctionCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutFunctionCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFunctionCodeSigningConfigOutputError>
}

extension PutFunctionCodeSigningConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutFunctionCodeSigningConfigInput(codeSigningConfigArn: \(Swift.String(describing: codeSigningConfigArn)), functionName: \(Swift.String(describing: functionName)))"}
}

extension PutFunctionCodeSigningConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeSigningConfigArn = codeSigningConfigArn {
            try encodeContainer.encode(codeSigningConfigArn, forKey: .codeSigningConfigArn)
        }
    }
}

public struct PutFunctionCodeSigningConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFunctionCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutFunctionCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutFunctionCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFunctionCodeSigningConfigOutputError>
}

public struct PutFunctionCodeSigningConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFunctionCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutFunctionCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutFunctionCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFunctionCodeSigningConfigOutputError>
}

public struct PutFunctionCodeSigningConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFunctionCodeSigningConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutFunctionCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutFunctionCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFunctionCodeSigningConfigOutputError>
}

public struct PutFunctionCodeSigningConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFunctionCodeSigningConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutFunctionCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-06-30/functions/\(functionName.urlPercentEncoding())/code-signing-config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutFunctionCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFunctionCodeSigningConfigOutputError>
}

public struct PutFunctionCodeSigningConfigInput: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - MyFunction.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init (
        codeSigningConfigArn: Swift.String? = nil,
        functionName: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

struct PutFunctionCodeSigningConfigInputBody: Swift.Equatable {
    public let codeSigningConfigArn: Swift.String?
}

extension PutFunctionCodeSigningConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
    }
}

extension PutFunctionCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFunctionCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeSigningConfigNotFoundException" : self = .codeSigningConfigNotFoundException(try CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFunctionCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case codeSigningConfigNotFoundException(CodeSigningConfigNotFoundException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFunctionCodeSigningConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutFunctionCodeSigningConfigOutputResponse(codeSigningConfigArn: \(Swift.String(describing: codeSigningConfigArn)), functionName: \(Swift.String(describing: functionName)))"}
}

extension PutFunctionCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutFunctionCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfigArn = output.codeSigningConfigArn
            self.functionName = output.functionName
        } else {
            self.codeSigningConfigArn = nil
            self.functionName = nil
        }
    }
}

public struct PutFunctionCodeSigningConfigOutputResponse: Swift.Equatable {
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - MyFunction.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?

    public init (
        codeSigningConfigArn: Swift.String? = nil,
        functionName: Swift.String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

struct PutFunctionCodeSigningConfigOutputResponseBody: Swift.Equatable {
    public let codeSigningConfigArn: Swift.String?
    public let functionName: Swift.String?
}

extension PutFunctionCodeSigningConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case functionName = "FunctionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
    }
}

public struct PutFunctionConcurrencyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFunctionConcurrencyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutFunctionConcurrencyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutFunctionConcurrencyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFunctionConcurrencyOutputError>
}

extension PutFunctionConcurrencyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutFunctionConcurrencyInput(functionName: \(Swift.String(describing: functionName)), reservedConcurrentExecutions: \(Swift.String(describing: reservedConcurrentExecutions)))"}
}

extension PutFunctionConcurrencyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reservedConcurrentExecutions = reservedConcurrentExecutions {
            try encodeContainer.encode(reservedConcurrentExecutions, forKey: .reservedConcurrentExecutions)
        }
    }
}

public struct PutFunctionConcurrencyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFunctionConcurrencyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutFunctionConcurrencyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutFunctionConcurrencyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFunctionConcurrencyOutputError>
}

public struct PutFunctionConcurrencyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFunctionConcurrencyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutFunctionConcurrencyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutFunctionConcurrencyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFunctionConcurrencyOutputError>
}

public struct PutFunctionConcurrencyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFunctionConcurrencyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutFunctionConcurrencyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutFunctionConcurrencyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFunctionConcurrencyOutputError>
}

public struct PutFunctionConcurrencyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFunctionConcurrencyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutFunctionConcurrencyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2017-10-31/functions/\(functionName.urlPercentEncoding())/concurrency"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutFunctionConcurrencyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFunctionConcurrencyOutputError>
}

public struct PutFunctionConcurrencyInput: Swift.Equatable {
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The number of simultaneous executions to reserve for the function.
    /// This member is required.
    public var reservedConcurrentExecutions: Swift.Int?

    public init (
        functionName: Swift.String? = nil,
        reservedConcurrentExecutions: Swift.Int? = nil
    )
    {
        self.functionName = functionName
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

struct PutFunctionConcurrencyInputBody: Swift.Equatable {
    public let reservedConcurrentExecutions: Swift.Int?
}

extension PutFunctionConcurrencyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

extension PutFunctionConcurrencyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFunctionConcurrencyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFunctionConcurrencyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFunctionConcurrencyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutFunctionConcurrencyOutputResponse(reservedConcurrentExecutions: \(Swift.String(describing: reservedConcurrentExecutions)))"}
}

extension PutFunctionConcurrencyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutFunctionConcurrencyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reservedConcurrentExecutions = output.reservedConcurrentExecutions
        } else {
            self.reservedConcurrentExecutions = nil
        }
    }
}

public struct PutFunctionConcurrencyOutputResponse: Swift.Equatable {
    /// The number of concurrent executions that are reserved for this function. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html">Managing Concurrency.
    public var reservedConcurrentExecutions: Swift.Int?

    public init (
        reservedConcurrentExecutions: Swift.Int? = nil
    )
    {
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

struct PutFunctionConcurrencyOutputResponseBody: Swift.Equatable {
    public let reservedConcurrentExecutions: Swift.Int?
}

extension PutFunctionConcurrencyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

public struct PutFunctionEventInvokeConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFunctionEventInvokeConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutFunctionEventInvokeConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFunctionEventInvokeConfigOutputError>
}

extension PutFunctionEventInvokeConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutFunctionEventInvokeConfigInput(destinationConfig: \(Swift.String(describing: destinationConfig)), functionName: \(Swift.String(describing: functionName)), maximumEventAgeInSeconds: \(Swift.String(describing: maximumEventAgeInSeconds)), maximumRetryAttempts: \(Swift.String(describing: maximumRetryAttempts)), qualifier: \(Swift.String(describing: qualifier)))"}
}

extension PutFunctionEventInvokeConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let maximumEventAgeInSeconds = maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }
}

public struct PutFunctionEventInvokeConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFunctionEventInvokeConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutFunctionEventInvokeConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFunctionEventInvokeConfigOutputError>
}

public struct PutFunctionEventInvokeConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFunctionEventInvokeConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutFunctionEventInvokeConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFunctionEventInvokeConfigOutputError>
}

public struct PutFunctionEventInvokeConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFunctionEventInvokeConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutFunctionEventInvokeConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutFunctionEventInvokeConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFunctionEventInvokeConfigOutputError>
}

public struct PutFunctionEventInvokeConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutFunctionEventInvokeConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutFunctionEventInvokeConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutFunctionEventInvokeConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutFunctionEventInvokeConfigOutputError>
}

public struct PutFunctionEventInvokeConfigInput: Swift.Equatable {
    /// A destination for events after they have been sent to a function for processing.
    ///          <p class="title">
    ///             Destinations
    ///
    ///
    ///
    ///
    ///                   Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    ///
    ///
    ///                   Queue - The ARN of an SQS queue.
    ///
    ///
    ///
    ///                   Topic - The ARN of an SNS topic.
    ///
    ///
    ///
    ///                   Event Bus - The ARN of an Amazon EventBridge event bus.
    ///
    ///
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The name of the Lambda function, version, or alias.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init (
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionName: Swift.String? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionName = functionName
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.qualifier = qualifier
    }
}

struct PutFunctionEventInvokeConfigInputBody: Swift.Equatable {
    public let maximumRetryAttempts: Swift.Int?
    public let maximumEventAgeInSeconds: Swift.Int?
    public let destinationConfig: LambdaClientTypes.DestinationConfig?
}

extension PutFunctionEventInvokeConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension PutFunctionEventInvokeConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFunctionEventInvokeConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFunctionEventInvokeConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFunctionEventInvokeConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutFunctionEventInvokeConfigOutputResponse(destinationConfig: \(Swift.String(describing: destinationConfig)), functionArn: \(Swift.String(describing: functionArn)), lastModified: \(Swift.String(describing: lastModified)), maximumEventAgeInSeconds: \(Swift.String(describing: maximumEventAgeInSeconds)), maximumRetryAttempts: \(Swift.String(describing: maximumRetryAttempts)))"}
}

extension PutFunctionEventInvokeConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutFunctionEventInvokeConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationConfig = output.destinationConfig
            self.functionArn = output.functionArn
            self.lastModified = output.lastModified
            self.maximumEventAgeInSeconds = output.maximumEventAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
        } else {
            self.destinationConfig = nil
            self.functionArn = nil
            self.lastModified = nil
            self.maximumEventAgeInSeconds = nil
            self.maximumRetryAttempts = nil
        }
    }
}

public struct PutFunctionEventInvokeConfigOutputResponse: Swift.Equatable {
    /// A destination for events after they have been sent to a function for processing.
    ///          <p class="title">
    ///             Destinations
    ///
    ///
    ///
    ///
    ///                   Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    ///
    ///
    ///                   Queue - The ARN of an SQS queue.
    ///
    ///
    ///
    ///                   Topic - The ARN of an SNS topic.
    ///
    ///
    ///
    ///                   Event Bus - The ARN of an Amazon EventBridge event bus.
    ///
    ///
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The date and time that the configuration was last updated.
    public var lastModified: ClientRuntime.Date?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?

    public init (
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionArn: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

struct PutFunctionEventInvokeConfigOutputResponseBody: Swift.Equatable {
    public let lastModified: ClientRuntime.Date?
    public let functionArn: Swift.String?
    public let maximumRetryAttempts: Swift.Int?
    public let maximumEventAgeInSeconds: Swift.Int?
    public let destinationConfig: LambdaClientTypes.DestinationConfig?
}

extension PutFunctionEventInvokeConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

public struct PutProvisionedConcurrencyConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutProvisionedConcurrencyConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutProvisionedConcurrencyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutProvisionedConcurrencyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutProvisionedConcurrencyConfigOutputError>
}

extension PutProvisionedConcurrencyConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutProvisionedConcurrencyConfigInput(functionName: \(Swift.String(describing: functionName)), provisionedConcurrentExecutions: \(Swift.String(describing: provisionedConcurrentExecutions)), qualifier: \(Swift.String(describing: qualifier)))"}
}

extension PutProvisionedConcurrencyConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedConcurrentExecutions = "ProvisionedConcurrentExecutions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let provisionedConcurrentExecutions = provisionedConcurrentExecutions {
            try encodeContainer.encode(provisionedConcurrentExecutions, forKey: .provisionedConcurrentExecutions)
        }
    }
}

public struct PutProvisionedConcurrencyConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutProvisionedConcurrencyConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutProvisionedConcurrencyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutProvisionedConcurrencyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutProvisionedConcurrencyConfigOutputError>
}

public struct PutProvisionedConcurrencyConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutProvisionedConcurrencyConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutProvisionedConcurrencyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutProvisionedConcurrencyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutProvisionedConcurrencyConfigOutputError>
}

public struct PutProvisionedConcurrencyConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutProvisionedConcurrencyConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutProvisionedConcurrencyConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutProvisionedConcurrencyConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutProvisionedConcurrencyConfigOutputError>
}

public struct PutProvisionedConcurrencyConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutProvisionedConcurrencyConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutProvisionedConcurrencyConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2019-09-30/functions/\(functionName.urlPercentEncoding())/provisioned-concurrency"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutProvisionedConcurrencyConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutProvisionedConcurrencyConfigOutputError>
}

public struct PutProvisionedConcurrencyConfigInput: Swift.Equatable {
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The amount of provisioned concurrency to allocate for the version or alias.
    /// This member is required.
    public var provisionedConcurrentExecutions: Swift.Int?
    /// The version number or alias name.
    /// This member is required.
    public var qualifier: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        provisionedConcurrentExecutions: Swift.Int? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.provisionedConcurrentExecutions = provisionedConcurrentExecutions
        self.qualifier = qualifier
    }
}

struct PutProvisionedConcurrencyConfigInputBody: Swift.Equatable {
    public let provisionedConcurrentExecutions: Swift.Int?
}

extension PutProvisionedConcurrencyConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedConcurrentExecutions = "ProvisionedConcurrentExecutions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedConcurrentExecutions)
        provisionedConcurrentExecutions = provisionedConcurrentExecutionsDecoded
    }
}

extension PutProvisionedConcurrencyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutProvisionedConcurrencyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutProvisionedConcurrencyConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutProvisionedConcurrencyConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutProvisionedConcurrencyConfigOutputResponse(allocatedProvisionedConcurrentExecutions: \(Swift.String(describing: allocatedProvisionedConcurrentExecutions)), availableProvisionedConcurrentExecutions: \(Swift.String(describing: availableProvisionedConcurrentExecutions)), lastModified: \(Swift.String(describing: lastModified)), requestedProvisionedConcurrentExecutions: \(Swift.String(describing: requestedProvisionedConcurrentExecutions)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)))"}
}

extension PutProvisionedConcurrencyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutProvisionedConcurrencyConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.allocatedProvisionedConcurrentExecutions = output.allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = output.availableProvisionedConcurrentExecutions
            self.lastModified = output.lastModified
            self.requestedProvisionedConcurrentExecutions = output.requestedProvisionedConcurrentExecutions
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.allocatedProvisionedConcurrentExecutions = nil
            self.availableProvisionedConcurrentExecutions = nil
            self.lastModified = nil
            self.requestedProvisionedConcurrentExecutions = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct PutProvisionedConcurrencyConfigOutputResponse: Swift.Equatable {
    /// The amount of provisioned concurrency allocated.
    public var allocatedProvisionedConcurrentExecutions: Swift.Int?
    /// The amount of provisioned concurrency available.
    public var availableProvisionedConcurrentExecutions: Swift.Int?
    /// The date and time that a user last updated the configuration, in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format.
    public var lastModified: Swift.String?
    /// The amount of provisioned concurrency requested.
    public var requestedProvisionedConcurrentExecutions: Swift.Int?
    /// The status of the allocation process.
    public var status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    /// For failed allocations, the reason that provisioned concurrency could not be allocated.
    public var statusReason: Swift.String?

    public init (
        allocatedProvisionedConcurrentExecutions: Swift.Int? = nil,
        availableProvisionedConcurrentExecutions: Swift.Int? = nil,
        lastModified: Swift.String? = nil,
        requestedProvisionedConcurrentExecutions: Swift.Int? = nil,
        status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
        self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
        self.lastModified = lastModified
        self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
        self.status = status
        self.statusReason = statusReason
    }
}

struct PutProvisionedConcurrencyConfigOutputResponseBody: Swift.Equatable {
    public let requestedProvisionedConcurrentExecutions: Swift.Int?
    public let availableProvisionedConcurrentExecutions: Swift.Int?
    public let allocatedProvisionedConcurrentExecutions: Swift.Int?
    public let status: LambdaClientTypes.ProvisionedConcurrencyStatusEnum?
    public let statusReason: Swift.String?
    public let lastModified: Swift.String?
}

extension PutProvisionedConcurrencyConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
        case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
        case lastModified = "LastModified"
        case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requestedProvisionedConcurrentExecutions)
        requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutionsDecoded
        let availableProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availableProvisionedConcurrentExecutions)
        availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutionsDecoded
        let allocatedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedProvisionedConcurrentExecutions)
        allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ProvisionedConcurrencyStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension RemoveLayerVersionPermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveLayerVersionPermissionInput(layerName: \(Swift.String(describing: layerName)), revisionId: \(Swift.String(describing: revisionId)), statementId: \(Swift.String(describing: statementId)), versionNumber: \(Swift.String(describing: versionNumber)))"}
}

extension RemoveLayerVersionPermissionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RemoveLayerVersionPermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveLayerVersionPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveLayerVersionPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveLayerVersionPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveLayerVersionPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveLayerVersionPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveLayerVersionPermissionOutputError>
}

public struct RemoveLayerVersionPermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveLayerVersionPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveLayerVersionPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveLayerVersionPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let revisionId = input.operationInput.revisionId {
            let revisionIdQueryItem = ClientRuntime.URLQueryItem(name: "RevisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            input.builder.withQueryItem(revisionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveLayerVersionPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveLayerVersionPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveLayerVersionPermissionOutputError>
}

public struct RemoveLayerVersionPermissionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveLayerVersionPermissionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RemoveLayerVersionPermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveLayerVersionPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveLayerVersionPermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveLayerVersionPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveLayerVersionPermissionOutputError>
}

public struct RemoveLayerVersionPermissionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveLayerVersionPermissionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RemoveLayerVersionPermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveLayerVersionPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let layerName = input.layerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("layerName is nil and needs a value for the path of this operation"))))
        }
        let versionNumber = input.versionNumber
        guard let statementId = input.statementId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("statementId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2018-10-31/layers/\(layerName.urlPercentEncoding())/versions/\(versionNumber)/policy/\(statementId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveLayerVersionPermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveLayerVersionPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveLayerVersionPermissionOutputError>
}

public struct RemoveLayerVersionPermissionInput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) of the layer.
    /// This member is required.
    public var layerName: Swift.String?
    /// Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a
    ///       policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// The identifier that was specified when the statement was added.
    /// This member is required.
    public var statementId: Swift.String?
    /// The version number.
    /// This member is required.
    public var versionNumber: Swift.Int

    public init (
        layerName: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.layerName = layerName
        self.revisionId = revisionId
        self.statementId = statementId
        self.versionNumber = versionNumber
    }
}

struct RemoveLayerVersionPermissionInputBody: Swift.Equatable {
}

extension RemoveLayerVersionPermissionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveLayerVersionPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveLayerVersionPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveLayerVersionPermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveLayerVersionPermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveLayerVersionPermissionOutputResponse()"}
}

extension RemoveLayerVersionPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveLayerVersionPermissionOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemoveLayerVersionPermissionOutputResponseBody: Swift.Equatable {
}

extension RemoveLayerVersionPermissionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemovePermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemovePermissionInput(functionName: \(Swift.String(describing: functionName)), qualifier: \(Swift.String(describing: qualifier)), revisionId: \(Swift.String(describing: revisionId)), statementId: \(Swift.String(describing: statementId)))"}
}

extension RemovePermissionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RemovePermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemovePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemovePermissionOutputError>
}

public struct RemovePermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemovePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        if let revisionId = input.operationInput.revisionId {
            let revisionIdQueryItem = ClientRuntime.URLQueryItem(name: "RevisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            input.builder.withQueryItem(revisionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemovePermissionOutputError>
}

public struct RemovePermissionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemovePermissionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RemovePermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemovePermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemovePermissionOutputError>
}

public struct RemovePermissionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemovePermissionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RemovePermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        guard let statementId = input.statementId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("statementId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())/policy/\(statementId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemovePermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemovePermissionOutputError>
}

public struct RemovePermissionInput: Swift.Equatable {
    /// The name of the Lambda function, version, or alias.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// Specify a version or alias to remove permissions from a published version of the function.
    public var qualifier: Swift.String?
    /// Only update the policy if the revision ID matches the ID that's specified. Use this option to avoid modifying a
    ///       policy that has changed since you last read it.
    public var revisionId: Swift.String?
    /// Statement ID of the permission to remove.
    /// This member is required.
    public var statementId: Swift.String?

    public init (
        functionName: Swift.String? = nil,
        qualifier: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
        self.revisionId = revisionId
        self.statementId = statementId
    }
}

struct RemovePermissionInputBody: Swift.Equatable {
}

extension RemovePermissionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemovePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemovePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemovePermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemovePermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemovePermissionOutputResponse()"}
}

extension RemovePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemovePermissionOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemovePermissionOutputResponseBody: Swift.Equatable {
}

extension RemovePermissionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RequestTooLargeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestTooLargeException(type: \(Swift.String(describing: type)), message: \(Swift.String(describing: message)))"}
}

extension RequestTooLargeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestTooLargeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request payload exceeded the Invoke request body JSON input limit. For more information, see
///         <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">Limits.
public struct RequestTooLargeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct RequestTooLargeExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension RequestTooLargeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceConflictException(type: \(Swift.String(describing: type)), message: \(Swift.String(describing: message)))"}
}

extension ResourceConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource already exists, or another operation is in progress.
public struct ResourceConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception message.
    public var message: Swift.String?
    /// The exception type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUseException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation conflicts with the resource's availability. For example, you attempted to update an EventSource
///       Mapping in CREATING, or tried to delete a EventSource mapping currently in the UPDATING state.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource specified in the request does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotReadyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotReadyException(type: \(Swift.String(describing: type)), message: \(Swift.String(describing: message)))"}
}

extension ResourceNotReadyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotReadyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The function is inactive and its VPC connection is no longer available. Wait for the VPC connection to
///       reestablish and try again.
public struct ResourceNotReadyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The exception message.
    public var message: Swift.String?
    /// The exception type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ResourceNotReadyExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension ResourceNotReadyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes {
    public enum Runtime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dotnetcore10
        case dotnetcore20
        case dotnetcore21
        case dotnetcore31
        case go1x
        case java11
        case java8
        case java8al2
        case nodejs
        case nodejs10x
        case nodejs12x
        case nodejs14x
        case nodejs43
        case nodejs43edge
        case nodejs610
        case nodejs810
        case provided
        case providedal2
        case python27
        case python36
        case python37
        case python38
        case python39
        case ruby25
        case ruby27
        case sdkUnknown(Swift.String)

        public static var allCases: [Runtime] {
            return [
                .dotnetcore10,
                .dotnetcore20,
                .dotnetcore21,
                .dotnetcore31,
                .go1x,
                .java11,
                .java8,
                .java8al2,
                .nodejs,
                .nodejs10x,
                .nodejs12x,
                .nodejs14x,
                .nodejs43,
                .nodejs43edge,
                .nodejs610,
                .nodejs810,
                .provided,
                .providedal2,
                .python27,
                .python36,
                .python37,
                .python38,
                .python39,
                .ruby25,
                .ruby27,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dotnetcore10: return "dotnetcore1.0"
            case .dotnetcore20: return "dotnetcore2.0"
            case .dotnetcore21: return "dotnetcore2.1"
            case .dotnetcore31: return "dotnetcore3.1"
            case .go1x: return "go1.x"
            case .java11: return "java11"
            case .java8: return "java8"
            case .java8al2: return "java8.al2"
            case .nodejs: return "nodejs"
            case .nodejs10x: return "nodejs10.x"
            case .nodejs12x: return "nodejs12.x"
            case .nodejs14x: return "nodejs14.x"
            case .nodejs43: return "nodejs4.3"
            case .nodejs43edge: return "nodejs4.3-edge"
            case .nodejs610: return "nodejs6.10"
            case .nodejs810: return "nodejs8.10"
            case .provided: return "provided"
            case .providedal2: return "provided.al2"
            case .python27: return "python2.7"
            case .python36: return "python3.6"
            case .python37: return "python3.7"
            case .python38: return "python3.8"
            case .python39: return "python3.9"
            case .ruby25: return "ruby2.5"
            case .ruby27: return "ruby2.7"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Runtime(rawValue: rawValue) ?? Runtime.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes.SelfManagedEventSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .endpoints)
            for (dictKey0, endpoints0) in endpoints {
                try endpointsContainer.encode(endpoints0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .endpoints)
        var endpointsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, endpointlists0) in endpointsContainer {
                var endpointlists0Decoded0: [Swift.String]? = nil
                if let endpointlists0 = endpointlists0 {
                    endpointlists0Decoded0 = [Swift.String]()
                    for string1 in endpointlists0 {
                        if let string1 = string1 {
                            endpointlists0Decoded0?.append(string1)
                        }
                    }
                }
                endpointsDecoded0?[key0] = endpointlists0Decoded0
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension LambdaClientTypes.SelfManagedEventSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SelfManagedEventSource(endpoints: \(Swift.String(describing: endpoints)))"}
}

extension LambdaClientTypes {
    /// The self-managed Apache Kafka cluster for your event source.
    public struct SelfManagedEventSource: Swift.Equatable {
        /// The list of bootstrap servers for your Kafka brokers in the following format: "KAFKA_BOOTSTRAP_SERVERS":
        ///         ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"].
        public var endpoints: [Swift.String:[Swift.String]]?

        public init (
            endpoints: [Swift.String:[Swift.String]]? = nil
        )
        {
            self.endpoints = endpoints
        }
    }

}

extension ServiceException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension ServiceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Lambda service encountered an internal error.
public struct ServiceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ServiceExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension ServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaClientTypes.SourceAccessConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case uRI = "URI"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uRI = uRI {
            try encodeContainer.encode(uRI, forKey: .uRI)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SourceAccessType.self, forKey: .type)
        type = typeDecoded
        let uRIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uRI)
        uRI = uRIDecoded
    }
}

extension LambdaClientTypes.SourceAccessConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceAccessConfiguration(type: \(Swift.String(describing: type)), uRI: \(Swift.String(describing: uRI)))"}
}

extension LambdaClientTypes {
    /// To secure and define access to your event source, you can specify the authentication protocol, VPC components, or virtual host.
    public struct SourceAccessConfiguration: Swift.Equatable {
        /// The type of authentication protocol, VPC components, or virtual host for your event source. For example: "Type":"SASL_SCRAM_512_AUTH".
        ///
        ///
        ///
        ///                   BASIC_AUTH - (Amazon MQ) The Secrets Manager secret that stores your broker credentials.
        ///
        ///
        ///
        ///                   BASIC_AUTH - (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL/PLAIN authentication of your Apache Kafka brokers.
        ///
        ///
        ///
        ///                   VPC_SUBNET - The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your self-managed Apache Kafka cluster.
        ///
        ///
        ///
        ///                   VPC_SECURITY_GROUP - The VPC security group used to manage access to your self-managed Apache Kafka brokers.
        ///
        ///
        ///
        ///                   SASL_SCRAM_256_AUTH - The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.
        ///
        ///
        ///
        ///                   SASL_SCRAM_512_AUTH - The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka brokers.
        ///
        ///
        ///
        ///                   VIRTUAL_HOST - (Amazon MQ) The name of the virtual host in your RabbitMQ broker. Lambda uses this RabbitMQ host as the event source.
        ///
        ///
        public var type: LambdaClientTypes.SourceAccessType?
        /// The value for your chosen configuration in Type. For example: "URI": "arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName".
        public var uRI: Swift.String?

        public init (
            type: LambdaClientTypes.SourceAccessType? = nil,
            uRI: Swift.String? = nil
        )
        {
            self.type = type
            self.uRI = uRI
        }
    }

}

extension LambdaClientTypes {
    public enum SourceAccessType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basicAuth
        case saslScram256Auth
        case saslScram512Auth
        case virtualHost
        case vpcSecurityGroup
        case vpcSubnet
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceAccessType] {
            return [
                .basicAuth,
                .saslScram256Auth,
                .saslScram512Auth,
                .virtualHost,
                .vpcSecurityGroup,
                .vpcSubnet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basicAuth: return "BASIC_AUTH"
            case .saslScram256Auth: return "SASL_SCRAM_256_AUTH"
            case .saslScram512Auth: return "SASL_SCRAM_512_AUTH"
            case .virtualHost: return "VIRTUAL_HOST"
            case .vpcSecurityGroup: return "VPC_SECURITY_GROUP"
            case .vpcSubnet: return "VPC_SUBNET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceAccessType(rawValue: rawValue) ?? SourceAccessType.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes {
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case failed
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .failed,
                .inactive,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .failed: return "Failed"
            case .inactive: return "Inactive"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension LambdaClientTypes {
    public enum StateReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case enilimitexceeded
        case idle
        case imageaccessdenied
        case imagedeleted
        case insufficientrolepermissions
        case internalerror
        case invalidconfiguration
        case invalidimage
        case invalidsecuritygroup
        case invalidsubnet
        case restoring
        case subnetoutofipaddresses
        case sdkUnknown(Swift.String)

        public static var allCases: [StateReasonCode] {
            return [
                .creating,
                .enilimitexceeded,
                .idle,
                .imageaccessdenied,
                .imagedeleted,
                .insufficientrolepermissions,
                .internalerror,
                .invalidconfiguration,
                .invalidimage,
                .invalidsecuritygroup,
                .invalidsubnet,
                .restoring,
                .subnetoutofipaddresses,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "Creating"
            case .enilimitexceeded: return "EniLimitExceeded"
            case .idle: return "Idle"
            case .imageaccessdenied: return "ImageAccessDenied"
            case .imagedeleted: return "ImageDeleted"
            case .insufficientrolepermissions: return "InsufficientRolePermissions"
            case .internalerror: return "InternalError"
            case .invalidconfiguration: return "InvalidConfiguration"
            case .invalidimage: return "InvalidImage"
            case .invalidsecuritygroup: return "InvalidSecurityGroup"
            case .invalidsubnet: return "InvalidSubnet"
            case .restoring: return "Restoring"
            case .subnetoutofipaddresses: return "SubnetOutOfIPAddresses"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StateReasonCode(rawValue: rawValue) ?? StateReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension SubnetIPAddressLimitReachedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetIPAddressLimitReachedException(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension SubnetIPAddressLimitReachedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetIPAddressLimitReachedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Lambda was not able to set up VPC access for the Lambda function because one or more configured subnets
///       has no available IP addresses.
public struct SubnetIPAddressLimitReachedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct SubnetIPAddressLimitReachedExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension SubnetIPAddressLimitReachedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resource: \(Swift.String(describing: resource)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resource = input.resource else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resource is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2017-03-31/tags/\(resource.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The function's Amazon Resource Name (ARN).
    /// This member is required.
    public var resource: Swift.String?
    /// A list of tags to apply to the function.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension LambdaClientTypes {
    public enum ThrottleReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case callerratelimitexceeded
        case concurrentinvocationlimitexceeded
        case functioninvocationratelimitexceeded
        case reservedfunctionconcurrentinvocationlimitexceeded
        case reservedfunctioninvocationratelimitexceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ThrottleReason] {
            return [
                .callerratelimitexceeded,
                .concurrentinvocationlimitexceeded,
                .functioninvocationratelimitexceeded,
                .reservedfunctionconcurrentinvocationlimitexceeded,
                .reservedfunctioninvocationratelimitexceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .callerratelimitexceeded: return "CallerRateLimitExceeded"
            case .concurrentinvocationlimitexceeded: return "ConcurrentInvocationLimitExceeded"
            case .functioninvocationratelimitexceeded: return "FunctionInvocationRateLimitExceeded"
            case .reservedfunctionconcurrentinvocationlimitexceeded: return "ReservedFunctionConcurrentInvocationLimitExceeded"
            case .reservedfunctioninvocationratelimitexceeded: return "ReservedFunctionInvocationRateLimitExceeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThrottleReason(rawValue: rawValue) ?? ThrottleReason.sdkUnknown(rawValue)
        }
    }
}

extension TooManyRequestsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequestsException(reason: \(Swift.String(describing: reason)), type: \(Swift.String(describing: type)), message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
            self.type = output.type
        } else {
            self.reason = nil
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request throughput limit was exceeded.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var reason: LambdaClientTypes.ThrottleReason?
    /// The number of seconds the caller should wait before retrying.
    public var retryAfterSeconds: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        reason: LambdaClientTypes.ThrottleReason? = nil,
        retryAfterSeconds: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.reason = reason
        self.retryAfterSeconds = retryAfterSeconds
        self.type = type
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
    public let reason: LambdaClientTypes.ThrottleReason?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "Reason"
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ThrottleReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension LambdaClientTypes.TracingConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "Mode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension LambdaClientTypes.TracingConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TracingConfig(mode: \(Swift.String(describing: mode)))"}
}

extension LambdaClientTypes {
    /// The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html">X-Ray tracing configuration.
    ///       To sample and record incoming requests, set Mode to Active.
    public struct TracingConfig: Swift.Equatable {
        /// The tracing mode.
        public var mode: LambdaClientTypes.TracingMode?

        public init (
            mode: LambdaClientTypes.TracingMode? = nil
        )
        {
            self.mode = mode
        }
    }

}

extension LambdaClientTypes.TracingConfigResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "Mode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension LambdaClientTypes.TracingConfigResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TracingConfigResponse(mode: \(Swift.String(describing: mode)))"}
}

extension LambdaClientTypes {
    /// The function's X-Ray tracing configuration.
    public struct TracingConfigResponse: Swift.Equatable {
        /// The tracing mode.
        public var mode: LambdaClientTypes.TracingMode?

        public init (
            mode: LambdaClientTypes.TracingMode? = nil
        )
        {
            self.mode = mode
        }
    }

}

extension LambdaClientTypes {
    public enum TracingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case passthrough
        case sdkUnknown(Swift.String)

        public static var allCases: [TracingMode] {
            return [
                .active,
                .passthrough,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .passthrough: return "PassThrough"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TracingMode(rawValue: rawValue) ?? TracingMode.sdkUnknown(rawValue)
        }
    }
}

extension UnsupportedMediaTypeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedMediaTypeException(type: \(Swift.String(describing: type)), message: \(Swift.String(describing: message)))"}
}

extension UnsupportedMediaTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedMediaTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The content type of the Invoke request body is not JSON.
public struct UnsupportedMediaTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct UnsupportedMediaTypeExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let message: Swift.String?
}

extension UnsupportedMediaTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resource: \(Swift.String(describing: resource)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resource = input.resource else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resource is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2017-03-31/tags/\(resource.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The function's Amazon Resource Name (ARN).
    /// This member is required.
    public var resource: Swift.String?
    /// A list of tag keys to remove from the function.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resource: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateAliasInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAliasOutputError>
}

extension UpdateAliasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAliasInput(description: \(Swift.String(describing: description)), functionName: \(Swift.String(describing: functionName)), functionVersion: \(Swift.String(describing: functionVersion)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), routingConfig: \(Swift.String(describing: routingConfig)))"}
}

extension UpdateAliasInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let routingConfig = routingConfig {
            try encodeContainer.encode(routingConfig, forKey: .routingConfig)
        }
    }
}

public struct UpdateAliasInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAliasOutputError>
}

public struct UpdateAliasInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAliasOutputError>
}

public struct UpdateAliasInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAliasInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateAliasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAliasInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAliasOutputError>
}

public struct UpdateAliasInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAliasInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateAliasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())/aliases/\(name.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAliasInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAliasOutputError>
}

public struct UpdateAliasInput: Swift.Equatable {
    /// A description of the alias.
    public var description: Swift.String?
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - MyFunction.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?
    /// Only update the alias if the revision ID matches the ID that's specified. Use this option to avoid modifying
    ///       an alias that has changed since you last read it.
    public var revisionId: Swift.String?
    /// The <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing">routing
    ///         configuration of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init (
        description: Swift.String? = nil,
        functionName: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.description = description
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct UpdateAliasInputBody: Swift.Equatable {
    public let functionVersion: Swift.String?
    public let description: Swift.String?
    public let routingConfig: LambdaClientTypes.AliasRoutingConfiguration?
    public let revisionId: Swift.String?
}

extension UpdateAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension UpdateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAliasOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAliasOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAliasOutputResponse(aliasArn: \(Swift.String(describing: aliasArn)), description: \(Swift.String(describing: description)), functionVersion: \(Swift.String(describing: functionVersion)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), routingConfig: \(Swift.String(describing: routingConfig)))"}
}

extension UpdateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliasArn = output.aliasArn
            self.description = output.description
            self.functionVersion = output.functionVersion
            self.name = output.name
            self.revisionId = output.revisionId
            self.routingConfig = output.routingConfig
        } else {
            self.aliasArn = nil
            self.description = nil
            self.functionVersion = nil
            self.name = nil
            self.revisionId = nil
            self.routingConfig = nil
        }
    }
}

/// Provides configuration information about a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias.
public struct UpdateAliasOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the alias.
    public var aliasArn: Swift.String?
    /// A description of the alias.
    public var description: Swift.String?
    /// The function version that the alias invokes.
    public var functionVersion: Swift.String?
    /// The name of the alias.
    public var name: Swift.String?
    /// A unique identifier that changes when you update the alias.
    public var revisionId: Swift.String?
    /// The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">routing
    ///         configuration of the alias.
    public var routingConfig: LambdaClientTypes.AliasRoutingConfiguration?

    public init (
        aliasArn: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        routingConfig: LambdaClientTypes.AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct UpdateAliasOutputResponseBody: Swift.Equatable {
    public let aliasArn: Swift.String?
    public let name: Swift.String?
    public let functionVersion: Swift.String?
    public let description: Swift.String?
    public let routingConfig: LambdaClientTypes.AliasRoutingConfiguration?
    public let revisionId: Swift.String?
}

extension UpdateAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

public struct UpdateCodeSigningConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCodeSigningConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCodeSigningConfigOutputError>
}

extension UpdateCodeSigningConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCodeSigningConfigInput(allowedPublishers: \(Swift.String(describing: allowedPublishers)), codeSigningConfigArn: \(Swift.String(describing: codeSigningConfigArn)), codeSigningPolicies: \(Swift.String(describing: codeSigningPolicies)), description: \(Swift.String(describing: description)))"}
}

extension UpdateCodeSigningConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPublishers = allowedPublishers {
            try encodeContainer.encode(allowedPublishers, forKey: .allowedPublishers)
        }
        if let codeSigningPolicies = codeSigningPolicies {
            try encodeContainer.encode(codeSigningPolicies, forKey: .codeSigningPolicies)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateCodeSigningConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCodeSigningConfigOutputError>
}

public struct UpdateCodeSigningConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCodeSigningConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCodeSigningConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCodeSigningConfigOutputError>
}

public struct UpdateCodeSigningConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCodeSigningConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCodeSigningConfigOutputError>
}

public struct UpdateCodeSigningConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCodeSigningConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateCodeSigningConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let codeSigningConfigArn = input.codeSigningConfigArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("codeSigningConfigArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-04-22/code-signing-configs/\(codeSigningConfigArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateCodeSigningConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCodeSigningConfigOutputError>
}

public struct UpdateCodeSigningConfigInput: Swift.Equatable {
    /// Signing profiles for this code signing configuration.
    public var allowedPublishers: LambdaClientTypes.AllowedPublishers?
    /// The The Amazon Resource Name (ARN) of the code signing configuration.
    /// This member is required.
    public var codeSigningConfigArn: Swift.String?
    /// The code signing policy.
    public var codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
    /// Descriptive name for this code signing configuration.
    public var description: Swift.String?

    public init (
        allowedPublishers: LambdaClientTypes.AllowedPublishers? = nil,
        codeSigningConfigArn: Swift.String? = nil,
        codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies? = nil,
        description: Swift.String? = nil
    )
    {
        self.allowedPublishers = allowedPublishers
        self.codeSigningConfigArn = codeSigningConfigArn
        self.codeSigningPolicies = codeSigningPolicies
        self.description = description
    }
}

struct UpdateCodeSigningConfigInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let allowedPublishers: LambdaClientTypes.AllowedPublishers?
    public let codeSigningPolicies: LambdaClientTypes.CodeSigningPolicies?
}

extension UpdateCodeSigningConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let allowedPublishersDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.AllowedPublishers.self, forKey: .allowedPublishers)
        allowedPublishers = allowedPublishersDecoded
        let codeSigningPoliciesDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningPolicies.self, forKey: .codeSigningPolicies)
        codeSigningPolicies = codeSigningPoliciesDecoded
    }
}

extension UpdateCodeSigningConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCodeSigningConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCodeSigningConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCodeSigningConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCodeSigningConfigOutputResponse(codeSigningConfig: \(Swift.String(describing: codeSigningConfig)))"}
}

extension UpdateCodeSigningConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeSigningConfig = output.codeSigningConfig
        } else {
            self.codeSigningConfig = nil
        }
    }
}

public struct UpdateCodeSigningConfigOutputResponse: Swift.Equatable {
    /// The code signing configuration
    /// This member is required.
    public var codeSigningConfig: LambdaClientTypes.CodeSigningConfig?

    public init (
        codeSigningConfig: LambdaClientTypes.CodeSigningConfig? = nil
    )
    {
        self.codeSigningConfig = codeSigningConfig
    }
}

struct UpdateCodeSigningConfigOutputResponseBody: Swift.Equatable {
    public let codeSigningConfig: LambdaClientTypes.CodeSigningConfig?
}

extension UpdateCodeSigningConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSigningConfig = "CodeSigningConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.CodeSigningConfig.self, forKey: .codeSigningConfig)
        codeSigningConfig = codeSigningConfigDecoded
    }
}

public struct UpdateEventSourceMappingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEventSourceMappingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEventSourceMappingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEventSourceMappingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEventSourceMappingOutputError>
}

extension UpdateEventSourceMappingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEventSourceMappingInput(batchSize: \(Swift.String(describing: batchSize)), bisectBatchOnFunctionError: \(Swift.String(describing: bisectBatchOnFunctionError)), destinationConfig: \(Swift.String(describing: destinationConfig)), enabled: \(Swift.String(describing: enabled)), functionName: \(Swift.String(describing: functionName)), functionResponseTypes: \(Swift.String(describing: functionResponseTypes)), maximumBatchingWindowInSeconds: \(Swift.String(describing: maximumBatchingWindowInSeconds)), maximumRecordAgeInSeconds: \(Swift.String(describing: maximumRecordAgeInSeconds)), maximumRetryAttempts: \(Swift.String(describing: maximumRetryAttempts)), parallelizationFactor: \(Swift.String(describing: parallelizationFactor)), sourceAccessConfigurations: \(Swift.String(describing: sourceAccessConfigurations)), tumblingWindowInSeconds: \(Swift.String(describing: tumblingWindowInSeconds)), uUID: \(Swift.String(describing: uUID)))"}
}

extension UpdateEventSourceMappingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case enabled = "Enabled"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSize = batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let bisectBatchOnFunctionError = bisectBatchOnFunctionError {
            try encodeContainer.encode(bisectBatchOnFunctionError, forKey: .bisectBatchOnFunctionError)
        }
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let functionResponseTypes = functionResponseTypes {
            var functionResponseTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionResponseTypes)
            for functionresponsetypelist0 in functionResponseTypes {
                try functionResponseTypesContainer.encode(functionresponsetypelist0.rawValue)
            }
        }
        if let maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds {
            try encodeContainer.encode(maximumBatchingWindowInSeconds, forKey: .maximumBatchingWindowInSeconds)
        }
        if let maximumRecordAgeInSeconds = maximumRecordAgeInSeconds {
            try encodeContainer.encode(maximumRecordAgeInSeconds, forKey: .maximumRecordAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
        if let parallelizationFactor = parallelizationFactor {
            try encodeContainer.encode(parallelizationFactor, forKey: .parallelizationFactor)
        }
        if let sourceAccessConfigurations = sourceAccessConfigurations {
            var sourceAccessConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceAccessConfigurations)
            for sourceaccessconfigurations0 in sourceAccessConfigurations {
                try sourceAccessConfigurationsContainer.encode(sourceaccessconfigurations0)
            }
        }
        if let tumblingWindowInSeconds = tumblingWindowInSeconds {
            try encodeContainer.encode(tumblingWindowInSeconds, forKey: .tumblingWindowInSeconds)
        }
    }
}

public struct UpdateEventSourceMappingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEventSourceMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEventSourceMappingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEventSourceMappingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEventSourceMappingOutputError>
}

public struct UpdateEventSourceMappingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEventSourceMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEventSourceMappingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEventSourceMappingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEventSourceMappingOutputError>
}

public struct UpdateEventSourceMappingInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEventSourceMappingInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateEventSourceMappingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEventSourceMappingInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEventSourceMappingOutputError>
}

public struct UpdateEventSourceMappingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEventSourceMappingInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateEventSourceMappingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let uUID = input.uUID else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("uUID is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/event-source-mappings/\(uUID.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEventSourceMappingInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEventSourceMappingOutputError>
}

public struct UpdateEventSourceMappingInput: Swift.Equatable {
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation
    ///   (6 MB).
    ///
    ///
    ///
    ///                   Amazon Kinesis - Default 100. Max 10,000.
    ///
    ///
    ///
    ///                   Amazon DynamoDB Streams - Default 100. Max 1,000.
    ///
    ///
    ///
    ///                   Amazon Simple Queue Service - Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.
    ///
    ///
    ///
    ///                   Amazon Managed Streaming for Apache Kafka - Default 100. Max 10,000.
    ///
    ///
    ///
    ///                   Self-Managed Apache Kafka - Default 100. Max 10,000.
    ///
    ///
    public var batchSize: Swift.Int?
    /// (Streams only) If the function returns an error, split the batch in two and retry.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// When true, the event source mapping is active. When false, Lambda pauses polling and invocation.
    ///          Default: True
    public var enabled: Swift.Bool?
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - MyFunction.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
    ///
    ///
    ///
    ///                   Version or Alias ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:MyFunction.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64
    ///       characters in length.
    public var functionName: Swift.String?
    /// (Streams only) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// (Streams and Amazon SQS standard queues) The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function.
    ///          Default: 0
    ///          Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Streams only) Discard records older than the specified age. The default value is infinite (-1).
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Streams only) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records will be retried until the record expires.
    public var maximumRetryAttempts: Swift.Int?
    /// (Streams only) The number of batches to process from each shard concurrently.
    public var parallelizationFactor: Swift.Int?
    /// An array of authentication protocols or VPC components required to secure your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// (Streams only) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    /// This member is required.
    public var uUID: Swift.String?

    public init (
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        enabled: Swift.Bool? = nil,
        functionName: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uUID: Swift.String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.enabled = enabled
        self.functionName = functionName
        self.functionResponseTypes = functionResponseTypes
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

struct UpdateEventSourceMappingInputBody: Swift.Equatable {
    public let functionName: Swift.String?
    public let enabled: Swift.Bool?
    public let batchSize: Swift.Int?
    public let maximumBatchingWindowInSeconds: Swift.Int?
    public let destinationConfig: LambdaClientTypes.DestinationConfig?
    public let maximumRecordAgeInSeconds: Swift.Int?
    public let bisectBatchOnFunctionError: Swift.Bool?
    public let maximumRetryAttempts: Swift.Int?
    public let parallelizationFactor: Swift.Int?
    public let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    public let tumblingWindowInSeconds: Swift.Int?
    public let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
}

extension UpdateEventSourceMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case enabled = "Enabled"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension UpdateEventSourceMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEventSourceMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEventSourceMappingOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEventSourceMappingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEventSourceMappingOutputResponse(batchSize: \(Swift.String(describing: batchSize)), bisectBatchOnFunctionError: \(Swift.String(describing: bisectBatchOnFunctionError)), destinationConfig: \(Swift.String(describing: destinationConfig)), eventSourceArn: \(Swift.String(describing: eventSourceArn)), functionArn: \(Swift.String(describing: functionArn)), functionResponseTypes: \(Swift.String(describing: functionResponseTypes)), lastModified: \(Swift.String(describing: lastModified)), lastProcessingResult: \(Swift.String(describing: lastProcessingResult)), maximumBatchingWindowInSeconds: \(Swift.String(describing: maximumBatchingWindowInSeconds)), maximumRecordAgeInSeconds: \(Swift.String(describing: maximumRecordAgeInSeconds)), maximumRetryAttempts: \(Swift.String(describing: maximumRetryAttempts)), parallelizationFactor: \(Swift.String(describing: parallelizationFactor)), queues: \(Swift.String(describing: queues)), selfManagedEventSource: \(Swift.String(describing: selfManagedEventSource)), sourceAccessConfigurations: \(Swift.String(describing: sourceAccessConfigurations)), startingPosition: \(Swift.String(describing: startingPosition)), startingPositionTimestamp: \(Swift.String(describing: startingPositionTimestamp)), state: \(Swift.String(describing: state)), stateTransitionReason: \(Swift.String(describing: stateTransitionReason)), topics: \(Swift.String(describing: topics)), tumblingWindowInSeconds: \(Swift.String(describing: tumblingWindowInSeconds)), uUID: \(Swift.String(describing: uUID)))"}
}

extension UpdateEventSourceMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateEventSourceMappingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.eventSourceArn = output.eventSourceArn
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.selfManagedEventSource = output.selfManagedEventSource
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uUID = output.uUID
        } else {
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.eventSourceArn = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.selfManagedEventSource = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uUID = nil
        }
    }
}

/// A mapping between an Amazon Web Services resource and a Lambda function. For details, see CreateEventSourceMapping.
public struct UpdateEventSourceMappingOutputResponse: Swift.Equatable {
    /// The maximum number of records in each batch that Lambda pulls from your stream or queue and sends to your function. Lambda passes all of the records in the batch to the function in a single call, up to the payload limit for synchronous invocation (6 MB).
    ///          Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default is 100.
    ///          Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var batchSize: Swift.Int?
    /// (Streams only) If the function returns an error, split the batch in two and retry. The default value is false.
    public var bisectBatchOnFunctionError: Swift.Bool?
    /// (Streams only) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the event source.
    public var eventSourceArn: Swift.String?
    /// The ARN of the Lambda function.
    public var functionArn: Swift.String?
    /// (Streams only) A list of current response type enums applied to the event source mapping.
    public var functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
    /// The date that the event source mapping was last updated or that its state changed.
    public var lastModified: ClientRuntime.Date?
    /// The result of the last Lambda invocation of your function.
    public var lastProcessingResult: Swift.String?
    /// (Streams and Amazon SQS standard queues) The maximum amount of time, in seconds, that Lambda spends gathering records before invoking the function.
    ///          Default: 0
    ///          Related setting: When you set BatchSize to a value greater than 10, you must set MaximumBatchingWindowInSeconds to at least 1.
    public var maximumBatchingWindowInSeconds: Swift.Int?
    /// (Streams only) Discard records older than the specified age. The default value is -1,
    /// which sets the maximum age to infinite. When the value is set to infinite, Lambda never discards old records.
    public var maximumRecordAgeInSeconds: Swift.Int?
    /// (Streams only) Discard records after the specified number of retries. The default value is -1,
    /// which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, Lambda retries failed records until the record expires in the event source.
    public var maximumRetryAttempts: Swift.Int?
    /// (Streams only) The number of batches to process concurrently from each shard. The default value is 1.
    public var parallelizationFactor: Swift.Int?
    ///  (Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
    public var queues: [Swift.String]?
    /// The self-managed Apache Kafka cluster for your event source.
    public var selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    /// An array of the authentication protocol, VPC components, or virtual host to secure and define your event source.
    public var sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    /// The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK stream sources. AT_TIMESTAMP is supported only for Amazon Kinesis
    ///       streams.
    public var startingPosition: LambdaClientTypes.EventSourcePosition?
    /// With StartingPosition set to AT_TIMESTAMP, the time from which to start
    ///       reading.
    public var startingPositionTimestamp: ClientRuntime.Date?
    /// The state of the event source mapping. It can be one of the following: Creating,
    ///         Enabling, Enabled, Disabling, Disabled,
    ///         Updating, or Deleting.
    public var state: Swift.String?
    /// Indicates whether a user or Lambda made the last change to the event source mapping.
    public var stateTransitionReason: Swift.String?
    /// The name of the Kafka topic.
    public var topics: [Swift.String]?
    /// (Streams only) The duration in seconds of a processing window. The range is 1–900 seconds.
    public var tumblingWindowInSeconds: Swift.Int?
    /// The identifier of the event source mapping.
    public var uUID: Swift.String?

    public init (
        batchSize: Swift.Int? = nil,
        bisectBatchOnFunctionError: Swift.Bool? = nil,
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        eventSourceArn: Swift.String? = nil,
        functionArn: Swift.String? = nil,
        functionResponseTypes: [LambdaClientTypes.FunctionResponseType]? = nil,
        lastModified: ClientRuntime.Date? = nil,
        lastProcessingResult: Swift.String? = nil,
        maximumBatchingWindowInSeconds: Swift.Int? = nil,
        maximumRecordAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        parallelizationFactor: Swift.Int? = nil,
        queues: [Swift.String]? = nil,
        selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]? = nil,
        startingPosition: LambdaClientTypes.EventSourcePosition? = nil,
        startingPositionTimestamp: ClientRuntime.Date? = nil,
        state: Swift.String? = nil,
        stateTransitionReason: Swift.String? = nil,
        topics: [Swift.String]? = nil,
        tumblingWindowInSeconds: Swift.Int? = nil,
        uUID: Swift.String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.eventSourceArn = eventSourceArn
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

struct UpdateEventSourceMappingOutputResponseBody: Swift.Equatable {
    public let uUID: Swift.String?
    public let startingPosition: LambdaClientTypes.EventSourcePosition?
    public let startingPositionTimestamp: ClientRuntime.Date?
    public let batchSize: Swift.Int?
    public let maximumBatchingWindowInSeconds: Swift.Int?
    public let parallelizationFactor: Swift.Int?
    public let eventSourceArn: Swift.String?
    public let functionArn: Swift.String?
    public let lastModified: ClientRuntime.Date?
    public let lastProcessingResult: Swift.String?
    public let state: Swift.String?
    public let stateTransitionReason: Swift.String?
    public let destinationConfig: LambdaClientTypes.DestinationConfig?
    public let topics: [Swift.String]?
    public let queues: [Swift.String]?
    public let sourceAccessConfigurations: [LambdaClientTypes.SourceAccessConfiguration]?
    public let selfManagedEventSource: LambdaClientTypes.SelfManagedEventSource?
    public let maximumRecordAgeInSeconds: Swift.Int?
    public let bisectBatchOnFunctionError: Swift.Bool?
    public let maximumRetryAttempts: Swift.Int?
    public let tumblingWindowInSeconds: Swift.Int?
    public let functionResponseTypes: [LambdaClientTypes.FunctionResponseType]?
}

extension UpdateEventSourceMappingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case eventSourceArn = "EventSourceArn"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uUID = "UUID"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uUIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uUID)
        uUID = uUIDDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queues)
        var queuesDecoded0:[Swift.String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [Swift.String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[LambdaClientTypes.SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [LambdaClientTypes.SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[LambdaClientTypes.FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [LambdaClientTypes.FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

public struct UpdateFunctionCodeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionCodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionCodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionCodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionCodeOutputError>
}

extension UpdateFunctionCodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionCodeInput(architectures: \(Swift.String(describing: architectures)), dryRun: \(Swift.String(describing: dryRun)), functionName: \(Swift.String(describing: functionName)), imageUri: \(Swift.String(describing: imageUri)), publish: \(Swift.String(describing: publish)), revisionId: \(Swift.String(describing: revisionId)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Key: \(Swift.String(describing: s3Key)), s3ObjectVersion: \(Swift.String(describing: s3ObjectVersion)), zipFile: \(Swift.String(describing: zipFile)))"}
}

extension UpdateFunctionCodeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case dryRun = "DryRun"
        case imageUri = "ImageUri"
        case publish = "Publish"
        case revisionId = "RevisionId"
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architectureslist0 in architectures {
                try architecturesContainer.encode(architectureslist0.rawValue)
            }
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let imageUri = imageUri {
            try encodeContainer.encode(imageUri, forKey: .imageUri)
        }
        if publish != false {
            try encodeContainer.encode(publish, forKey: .publish)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3ObjectVersion = s3ObjectVersion {
            try encodeContainer.encode(s3ObjectVersion, forKey: .s3ObjectVersion)
        }
        if let zipFile = zipFile {
            try encodeContainer.encode(zipFile.base64EncodedString(), forKey: .zipFile)
        }
    }
}

public struct UpdateFunctionCodeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionCodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionCodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionCodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionCodeOutputError>
}

public struct UpdateFunctionCodeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionCodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionCodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionCodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionCodeOutputError>
}

public struct UpdateFunctionCodeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionCodeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateFunctionCodeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFunctionCodeInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionCodeOutputError>
}

public struct UpdateFunctionCodeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionCodeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateFunctionCodeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())/code"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFunctionCodeInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionCodeOutputError>
}

public struct UpdateFunctionCodeInput: Swift.Equatable {
    /// The instruction set architecture that the function supports. Enter a string array with one of the valid values.
    ///     The default value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// Set to true to validate the request parameters and access permissions without modifying the function
    ///       code.
    public var dryRun: Swift.Bool
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// URI of a container image in the Amazon ECR registry.
    public var imageUri: Swift.String?
    /// Set to true to publish a new version of the function after updating the code. This has the same effect as
    ///       calling PublishVersion separately.
    public var publish: Swift.Bool
    /// Only update the function if the revision ID matches the ID that's specified. Use this option to avoid modifying a
    ///       function that has changed since you last read it.
    public var revisionId: Swift.String?
    /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
    public var s3Bucket: Swift.String?
    /// The Amazon S3 key of the deployment package.
    public var s3Key: Swift.String?
    /// For versioned objects, the version of the deployment package object to use.
    public var s3ObjectVersion: Swift.String?
    /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for
    ///       you.
    public var zipFile: ClientRuntime.Data?

    public init (
        architectures: [LambdaClientTypes.Architecture]? = nil,
        dryRun: Swift.Bool = false,
        functionName: Swift.String? = nil,
        imageUri: Swift.String? = nil,
        publish: Swift.Bool = false,
        revisionId: Swift.String? = nil,
        s3Bucket: Swift.String? = nil,
        s3Key: Swift.String? = nil,
        s3ObjectVersion: Swift.String? = nil,
        zipFile: ClientRuntime.Data? = nil
    )
    {
        self.architectures = architectures
        self.dryRun = dryRun
        self.functionName = functionName
        self.imageUri = imageUri
        self.publish = publish
        self.revisionId = revisionId
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
        self.s3ObjectVersion = s3ObjectVersion
        self.zipFile = zipFile
    }
}

struct UpdateFunctionCodeInputBody: Swift.Equatable {
    public let zipFile: ClientRuntime.Data?
    public let s3Bucket: Swift.String?
    public let s3Key: Swift.String?
    public let s3ObjectVersion: Swift.String?
    public let imageUri: Swift.String?
    public let publish: Swift.Bool
    public let dryRun: Swift.Bool
    public let revisionId: Swift.String?
    public let architectures: [LambdaClientTypes.Architecture]?
}

extension UpdateFunctionCodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case dryRun = "DryRun"
        case imageUri = "ImageUri"
        case publish = "Publish"
        case revisionId = "RevisionId"
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zipFileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .zipFile)
        zipFile = zipFileDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectVersion)
        s3ObjectVersion = s3ObjectVersionDecoded
        let imageUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUri)
        imageUri = imageUriDecoded
        let publishDecoded = try containerValues.decode(Swift.Bool.self, forKey: .publish)
        publish = publishDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

extension UpdateFunctionCodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFunctionCodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeSigningConfigNotFoundException" : self = .codeSigningConfigNotFoundException(try CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeStorageExceededException" : self = .codeStorageExceededException(try CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeVerificationFailedException" : self = .codeVerificationFailedException(try CodeVerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCodeSignatureException" : self = .invalidCodeSignatureException(try InvalidCodeSignatureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionCodeOutputError: Swift.Error, Swift.Equatable {
    case codeSigningConfigNotFoundException(CodeSigningConfigNotFoundException)
    case codeStorageExceededException(CodeStorageExceededException)
    case codeVerificationFailedException(CodeVerificationFailedException)
    case invalidCodeSignatureException(InvalidCodeSignatureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionCodeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionCodeOutputResponse(architectures: \(Swift.String(describing: architectures)), codeSha256: \(Swift.String(describing: codeSha256)), codeSize: \(Swift.String(describing: codeSize)), deadLetterConfig: \(Swift.String(describing: deadLetterConfig)), description: \(Swift.String(describing: description)), environment: \(Swift.String(describing: environment)), fileSystemConfigs: \(Swift.String(describing: fileSystemConfigs)), functionArn: \(Swift.String(describing: functionArn)), functionName: \(Swift.String(describing: functionName)), handler: \(Swift.String(describing: handler)), imageConfigResponse: \(Swift.String(describing: imageConfigResponse)), kMSKeyArn: \(Swift.String(describing: kMSKeyArn)), lastModified: \(Swift.String(describing: lastModified)), lastUpdateStatus: \(Swift.String(describing: lastUpdateStatus)), lastUpdateStatusReason: \(Swift.String(describing: lastUpdateStatusReason)), lastUpdateStatusReasonCode: \(Swift.String(describing: lastUpdateStatusReasonCode)), layers: \(Swift.String(describing: layers)), masterArn: \(Swift.String(describing: masterArn)), memorySize: \(Swift.String(describing: memorySize)), packageType: \(Swift.String(describing: packageType)), revisionId: \(Swift.String(describing: revisionId)), role: \(Swift.String(describing: role)), runtime: \(Swift.String(describing: runtime)), signingJobArn: \(Swift.String(describing: signingJobArn)), signingProfileVersionArn: \(Swift.String(describing: signingProfileVersionArn)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)), stateReasonCode: \(Swift.String(describing: stateReasonCode)), timeout: \(Swift.String(describing: timeout)), tracingConfig: \(Swift.String(describing: tracingConfig)), version: \(Swift.String(describing: version)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension UpdateFunctionCodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFunctionCodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architectures = output.architectures
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kMSKeyArn = output.kMSKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.architectures = nil
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kMSKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// Details about a function's configuration.
public struct UpdateFunctionCodeOutputResponse: Swift.Equatable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the
    ///       valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">environment variables.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// Connection settings for an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html">Amazon EFS file system.
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin executing your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    ///       configured a customer managed CMK.
    public var kMSKeyArn: Swift.String?
    /// The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful
    ///       after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    ///       layers.
    public var layers: [LambdaClientTypes.Layer]?
    /// For Lambda@Edge functions, the ARN of the master function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The runtime environment for the Lambda function.
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by
    ///       invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or
    ///       modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init (
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kMSKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFunctionCodeOutputResponseBody: Swift.Equatable {
    public let functionName: Swift.String?
    public let functionArn: Swift.String?
    public let runtime: LambdaClientTypes.Runtime?
    public let role: Swift.String?
    public let handler: Swift.String?
    public let codeSize: Swift.Int
    public let description: Swift.String?
    public let timeout: Swift.Int?
    public let memorySize: Swift.Int?
    public let lastModified: Swift.String?
    public let codeSha256: Swift.String?
    public let version: Swift.String?
    public let vpcConfig: LambdaClientTypes.VpcConfigResponse?
    public let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    public let environment: LambdaClientTypes.EnvironmentResponse?
    public let kMSKeyArn: Swift.String?
    public let tracingConfig: LambdaClientTypes.TracingConfigResponse?
    public let masterArn: Swift.String?
    public let revisionId: Swift.String?
    public let layers: [LambdaClientTypes.Layer]?
    public let state: LambdaClientTypes.State?
    public let stateReason: Swift.String?
    public let stateReasonCode: LambdaClientTypes.StateReasonCode?
    public let lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    public let lastUpdateStatusReason: Swift.String?
    public let lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    public let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    public let packageType: LambdaClientTypes.PackageType?
    public let imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    public let signingProfileVersionArn: Swift.String?
    public let signingJobArn: Swift.String?
    public let architectures: [LambdaClientTypes.Architecture]?
}

extension UpdateFunctionCodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

public struct UpdateFunctionConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionConfigurationOutputError>
}

extension UpdateFunctionConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionConfigurationInput(deadLetterConfig: \(Swift.String(describing: deadLetterConfig)), description: \(Swift.String(describing: description)), environment: \(Swift.String(describing: environment)), fileSystemConfigs: \(Swift.String(describing: fileSystemConfigs)), functionName: \(Swift.String(describing: functionName)), handler: \(Swift.String(describing: handler)), imageConfig: \(Swift.String(describing: imageConfig)), kMSKeyArn: \(Swift.String(describing: kMSKeyArn)), layers: \(Swift.String(describing: layers)), memorySize: \(Swift.String(describing: memorySize)), revisionId: \(Swift.String(describing: revisionId)), role: \(Swift.String(describing: role)), runtime: \(Swift.String(describing: runtime)), timeout: \(Swift.String(describing: timeout)), tracingConfig: \(Swift.String(describing: tracingConfig)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension UpdateFunctionConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kMSKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deadLetterConfig = deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemConfigs = fileSystemConfigs {
            var fileSystemConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemConfigs)
            for filesystemconfiglist0 in fileSystemConfigs {
                try fileSystemConfigsContainer.encode(filesystemconfiglist0)
            }
        }
        if let handler = handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let imageConfig = imageConfig {
            try encodeContainer.encode(imageConfig, forKey: .imageConfig)
        }
        if let kMSKeyArn = kMSKeyArn {
            try encodeContainer.encode(kMSKeyArn, forKey: .kMSKeyArn)
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for layerlist0 in layers {
                try layersContainer.encode(layerlist0)
            }
        }
        if let memorySize = memorySize {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let runtime = runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tracingConfig = tracingConfig {
            try encodeContainer.encode(tracingConfig, forKey: .tracingConfig)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct UpdateFunctionConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionConfigurationOutputError>
}

public struct UpdateFunctionConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionConfigurationOutputError>
}

public struct UpdateFunctionConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateFunctionConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFunctionConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionConfigurationOutputError>
}

public struct UpdateFunctionConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateFunctionConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2015-03-31/functions/\(functionName.urlPercentEncoding())/configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFunctionConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionConfigurationOutputError>
}

public struct UpdateFunctionConfigurationInput: Swift.Equatable {
    /// A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events
    ///       when they fail processing. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">Dead Letter Queues.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// A description of the function.
    public var description: Swift.String?
    /// Environment variables that are accessible from function code during execution.
    public var environment: LambdaClientTypes.Environment?
    /// Connection settings for an Amazon EFS file system.
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The name of the Lambda function.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function.
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The name of the method within your code that Lambda calls to execute your function. The format includes the
    ///       file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information,
    ///       see <a href="https://docs.aws.amazon.com/lambda/latest/dg/programming-model-v2.html">Programming Model.
    public var handler: Swift.String?
    ///
    ///             <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-parms.html">Container image configuration
    ///         values that override the values in the container image Docker file.
    public var imageConfig: LambdaClientTypes.ImageConfig?
    /// The ARN of the Amazon Web Services Key Management Service (KMS) key that's used to encrypt your function's environment
    ///       variables. If it's not provided, Lambda uses a default service key.
    public var kMSKeyArn: Swift.String?
    /// A list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">function layers
    ///       to add to the function's execution environment. Specify each layer by its ARN, including the version.
    public var layers: [Swift.String]?
    /// The amount of  <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-memory.html">memory available to the function at runtime.
    ///       Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
    public var memorySize: Swift.Int?
    /// Only update the function if the revision ID matches the ID that's specified. Use this option to avoid modifying a
    ///       function that has changed since you last read it.
    public var revisionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the function's execution role.
    public var role: Swift.String?
    /// The identifier of the function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">runtime.
    public var runtime: LambdaClientTypes.Runtime?
    /// The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The
    ///       maximum allowed value is 900 seconds. For additional information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html">Lambda execution environment.
    public var timeout: Swift.Int?
    /// Set Mode to Active to sample and trace a subset of incoming requests with
    /// <a href="https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html">X-Ray.
    public var tracingConfig: LambdaClientTypes.TracingConfig?
    /// For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC.
    ///       When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more
    ///       information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html">VPC Settings.
    public var vpcConfig: LambdaClientTypes.VpcConfig?

    public init (
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.Environment? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfig: LambdaClientTypes.ImageConfig? = nil,
        kMSKeyArn: Swift.String? = nil,
        layers: [Swift.String]? = nil,
        memorySize: Swift.Int? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfig? = nil,
        vpcConfig: LambdaClientTypes.VpcConfig? = nil
    )
    {
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionName = functionName
        self.handler = handler
        self.imageConfig = imageConfig
        self.kMSKeyArn = kMSKeyArn
        self.layers = layers
        self.memorySize = memorySize
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFunctionConfigurationInputBody: Swift.Equatable {
    public let role: Swift.String?
    public let handler: Swift.String?
    public let description: Swift.String?
    public let timeout: Swift.Int?
    public let memorySize: Swift.Int?
    public let vpcConfig: LambdaClientTypes.VpcConfig?
    public let environment: LambdaClientTypes.Environment?
    public let runtime: LambdaClientTypes.Runtime?
    public let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    public let kMSKeyArn: Swift.String?
    public let tracingConfig: LambdaClientTypes.TracingConfig?
    public let revisionId: Swift.String?
    public let layers: [Swift.String]?
    public let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    public let imageConfig: LambdaClientTypes.ImageConfig?
}

extension UpdateFunctionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kMSKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfig.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layers)
        var layersDecoded0:[Swift.String]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Swift.String]()
            for string0 in layersContainer {
                if let string0 = string0 {
                    layersDecoded0?.append(string0)
                }
            }
        }
        layers = layersDecoded0
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let imageConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfig.self, forKey: .imageConfig)
        imageConfig = imageConfigDecoded
    }
}

extension UpdateFunctionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFunctionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeSigningConfigNotFoundException" : self = .codeSigningConfigNotFoundException(try CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeVerificationFailedException" : self = .codeVerificationFailedException(try CodeVerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCodeSignatureException" : self = .invalidCodeSignatureException(try InvalidCodeSignatureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case codeSigningConfigNotFoundException(CodeSigningConfigNotFoundException)
    case codeVerificationFailedException(CodeVerificationFailedException)
    case invalidCodeSignatureException(InvalidCodeSignatureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionConfigurationOutputResponse(architectures: \(Swift.String(describing: architectures)), codeSha256: \(Swift.String(describing: codeSha256)), codeSize: \(Swift.String(describing: codeSize)), deadLetterConfig: \(Swift.String(describing: deadLetterConfig)), description: \(Swift.String(describing: description)), environment: \(Swift.String(describing: environment)), fileSystemConfigs: \(Swift.String(describing: fileSystemConfigs)), functionArn: \(Swift.String(describing: functionArn)), functionName: \(Swift.String(describing: functionName)), handler: \(Swift.String(describing: handler)), imageConfigResponse: \(Swift.String(describing: imageConfigResponse)), kMSKeyArn: \(Swift.String(describing: kMSKeyArn)), lastModified: \(Swift.String(describing: lastModified)), lastUpdateStatus: \(Swift.String(describing: lastUpdateStatus)), lastUpdateStatusReason: \(Swift.String(describing: lastUpdateStatusReason)), lastUpdateStatusReasonCode: \(Swift.String(describing: lastUpdateStatusReasonCode)), layers: \(Swift.String(describing: layers)), masterArn: \(Swift.String(describing: masterArn)), memorySize: \(Swift.String(describing: memorySize)), packageType: \(Swift.String(describing: packageType)), revisionId: \(Swift.String(describing: revisionId)), role: \(Swift.String(describing: role)), runtime: \(Swift.String(describing: runtime)), signingJobArn: \(Swift.String(describing: signingJobArn)), signingProfileVersionArn: \(Swift.String(describing: signingProfileVersionArn)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)), stateReasonCode: \(Swift.String(describing: stateReasonCode)), timeout: \(Swift.String(describing: timeout)), tracingConfig: \(Swift.String(describing: tracingConfig)), version: \(Swift.String(describing: version)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension UpdateFunctionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFunctionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architectures = output.architectures
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kMSKeyArn = output.kMSKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.architectures = nil
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kMSKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// Details about a function's configuration.
public struct UpdateFunctionConfigurationOutputResponse: Swift.Equatable {
    /// The instruction set architecture that the function supports. Architecture is a string array with one of the
    ///       valid values. The default architecture value is x86_64.
    public var architectures: [LambdaClientTypes.Architecture]?
    /// The SHA256 hash of the function's deployment package.
    public var codeSha256: Swift.String?
    /// The size of the function's deployment package, in bytes.
    public var codeSize: Swift.Int
    /// The function's dead letter queue.
    public var deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    /// The function's description.
    public var description: Swift.String?
    /// The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html">environment variables.
    public var environment: LambdaClientTypes.EnvironmentResponse?
    /// Connection settings for an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-filesystem.html">Amazon EFS file system.
    public var fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    /// The function's Amazon Resource Name (ARN).
    public var functionArn: Swift.String?
    /// The name of the function.
    public var functionName: Swift.String?
    /// The function that Lambda calls to begin executing your function.
    public var handler: Swift.String?
    /// The function's image configuration values.
    public var imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    /// The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    ///       configured a customer managed CMK.
    public var kMSKeyArn: Swift.String?
    /// The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
    public var lastModified: Swift.String?
    /// The status of the last update that was performed on the function. This is first set to Successful
    ///       after function creation completes.
    public var lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    /// The reason for the last update that was performed on the function.
    public var lastUpdateStatusReason: Swift.String?
    /// The reason code for the last update that was performed on the function.
    public var lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    /// The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    ///       layers.
    public var layers: [LambdaClientTypes.Layer]?
    /// For Lambda@Edge functions, the ARN of the master function.
    public var masterArn: Swift.String?
    /// The amount of memory available to the function at runtime.
    public var memorySize: Swift.Int?
    /// The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
    public var packageType: LambdaClientTypes.PackageType?
    /// The latest updated revision of the function or alias.
    public var revisionId: Swift.String?
    /// The function's execution role.
    public var role: Swift.String?
    /// The runtime environment for the Lambda function.
    public var runtime: LambdaClientTypes.Runtime?
    /// The ARN of the signing job.
    public var signingJobArn: Swift.String?
    /// The ARN of the signing profile version.
    public var signingProfileVersionArn: Swift.String?
    /// The current state of the function. When the state is Inactive, you can reactivate the function by
    ///       invoking it.
    public var state: LambdaClientTypes.State?
    /// The reason for the function's current state.
    public var stateReason: Swift.String?
    /// The reason code for the function's current state. When the code is Creating, you can't invoke or
    ///       modify the function.
    public var stateReasonCode: LambdaClientTypes.StateReasonCode?
    /// The amount of time in seconds that Lambda allows a function to run before stopping it.
    public var timeout: Swift.Int?
    /// The function's X-Ray tracing configuration.
    public var tracingConfig: LambdaClientTypes.TracingConfigResponse?
    /// The version of the Lambda function.
    public var version: Swift.String?
    /// The function's networking configuration.
    public var vpcConfig: LambdaClientTypes.VpcConfigResponse?

    public init (
        architectures: [LambdaClientTypes.Architecture]? = nil,
        codeSha256: Swift.String? = nil,
        codeSize: Swift.Int = 0,
        deadLetterConfig: LambdaClientTypes.DeadLetterConfig? = nil,
        description: Swift.String? = nil,
        environment: LambdaClientTypes.EnvironmentResponse? = nil,
        fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]? = nil,
        functionArn: Swift.String? = nil,
        functionName: Swift.String? = nil,
        handler: Swift.String? = nil,
        imageConfigResponse: LambdaClientTypes.ImageConfigResponse? = nil,
        kMSKeyArn: Swift.String? = nil,
        lastModified: Swift.String? = nil,
        lastUpdateStatus: LambdaClientTypes.LastUpdateStatus? = nil,
        lastUpdateStatusReason: Swift.String? = nil,
        lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode? = nil,
        layers: [LambdaClientTypes.Layer]? = nil,
        masterArn: Swift.String? = nil,
        memorySize: Swift.Int? = nil,
        packageType: LambdaClientTypes.PackageType? = nil,
        revisionId: Swift.String? = nil,
        role: Swift.String? = nil,
        runtime: LambdaClientTypes.Runtime? = nil,
        signingJobArn: Swift.String? = nil,
        signingProfileVersionArn: Swift.String? = nil,
        state: LambdaClientTypes.State? = nil,
        stateReason: Swift.String? = nil,
        stateReasonCode: LambdaClientTypes.StateReasonCode? = nil,
        timeout: Swift.Int? = nil,
        tracingConfig: LambdaClientTypes.TracingConfigResponse? = nil,
        version: Swift.String? = nil,
        vpcConfig: LambdaClientTypes.VpcConfigResponse? = nil
    )
    {
        self.architectures = architectures
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFunctionConfigurationOutputResponseBody: Swift.Equatable {
    public let functionName: Swift.String?
    public let functionArn: Swift.String?
    public let runtime: LambdaClientTypes.Runtime?
    public let role: Swift.String?
    public let handler: Swift.String?
    public let codeSize: Swift.Int
    public let description: Swift.String?
    public let timeout: Swift.Int?
    public let memorySize: Swift.Int?
    public let lastModified: Swift.String?
    public let codeSha256: Swift.String?
    public let version: Swift.String?
    public let vpcConfig: LambdaClientTypes.VpcConfigResponse?
    public let deadLetterConfig: LambdaClientTypes.DeadLetterConfig?
    public let environment: LambdaClientTypes.EnvironmentResponse?
    public let kMSKeyArn: Swift.String?
    public let tracingConfig: LambdaClientTypes.TracingConfigResponse?
    public let masterArn: Swift.String?
    public let revisionId: Swift.String?
    public let layers: [LambdaClientTypes.Layer]?
    public let state: LambdaClientTypes.State?
    public let stateReason: Swift.String?
    public let stateReasonCode: LambdaClientTypes.StateReasonCode?
    public let lastUpdateStatus: LambdaClientTypes.LastUpdateStatus?
    public let lastUpdateStatusReason: Swift.String?
    public let lastUpdateStatusReasonCode: LambdaClientTypes.LastUpdateStatusReasonCode?
    public let fileSystemConfigs: [LambdaClientTypes.FileSystemConfig]?
    public let packageType: LambdaClientTypes.PackageType?
    public let imageConfigResponse: LambdaClientTypes.ImageConfigResponse?
    public let signingProfileVersionArn: Swift.String?
    public let signingJobArn: Swift.String?
    public let architectures: [LambdaClientTypes.Architecture]?
}

extension UpdateFunctionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[LambdaClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LambdaClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([LambdaClientTypes.FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[LambdaClientTypes.FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [LambdaClientTypes.FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([LambdaClientTypes.Architecture?].self, forKey: .architectures)
        var architecturesDecoded0:[LambdaClientTypes.Architecture]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [LambdaClientTypes.Architecture]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
    }
}

public struct UpdateFunctionEventInvokeConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionEventInvokeConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionEventInvokeConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionEventInvokeConfigOutputError>
}

extension UpdateFunctionEventInvokeConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionEventInvokeConfigInput(destinationConfig: \(Swift.String(describing: destinationConfig)), functionName: \(Swift.String(describing: functionName)), maximumEventAgeInSeconds: \(Swift.String(describing: maximumEventAgeInSeconds)), maximumRetryAttempts: \(Swift.String(describing: maximumRetryAttempts)), qualifier: \(Swift.String(describing: qualifier)))"}
}

extension UpdateFunctionEventInvokeConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let maximumEventAgeInSeconds = maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }
}

public struct UpdateFunctionEventInvokeConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionEventInvokeConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionEventInvokeConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionEventInvokeConfigOutputError>
}

public struct UpdateFunctionEventInvokeConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionEventInvokeConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = ClientRuntime.URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: Swift.String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionEventInvokeConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionEventInvokeConfigOutputError>
}

public struct UpdateFunctionEventInvokeConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionEventInvokeConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateFunctionEventInvokeConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFunctionEventInvokeConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionEventInvokeConfigOutputError>
}

public struct UpdateFunctionEventInvokeConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionEventInvokeConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateFunctionEventInvokeConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let functionName = input.functionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("functionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2019-09-25/functions/\(functionName.urlPercentEncoding())/event-invoke-config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFunctionEventInvokeConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionEventInvokeConfigOutputError>
}

public struct UpdateFunctionEventInvokeConfigInput: Swift.Equatable {
    /// A destination for events after they have been sent to a function for processing.
    ///          <p class="title">
    ///             Destinations
    ///
    ///
    ///
    ///
    ///                   Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    ///
    ///
    ///                   Queue - The ARN of an SQS queue.
    ///
    ///
    ///
    ///                   Topic - The ARN of an SNS topic.
    ///
    ///
    ///
    ///                   Event Bus - The ARN of an Amazon EventBridge event bus.
    ///
    ///
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The name of the Lambda function, version, or alias.
    ///          <p class="title">
    ///             Name formats
    ///
    ///
    ///
    ///
    ///                   Function name - my-function (name-only), my-function:v1 (with alias).
    ///
    ///
    ///
    ///                   Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function.
    ///
    ///
    ///
    ///                   Partial ARN - 123456789012:function:my-function.
    ///
    ///
    ///          You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.
    /// This member is required.
    public var functionName: Swift.String?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?
    /// A version number or alias name.
    public var qualifier: Swift.String?

    public init (
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionName: Swift.String? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil,
        qualifier: Swift.String? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionName = functionName
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.qualifier = qualifier
    }
}

struct UpdateFunctionEventInvokeConfigInputBody: Swift.Equatable {
    public let maximumRetryAttempts: Swift.Int?
    public let maximumEventAgeInSeconds: Swift.Int?
    public let destinationConfig: LambdaClientTypes.DestinationConfig?
}

extension UpdateFunctionEventInvokeConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension UpdateFunctionEventInvokeConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFunctionEventInvokeConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionEventInvokeConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionEventInvokeConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionEventInvokeConfigOutputResponse(destinationConfig: \(Swift.String(describing: destinationConfig)), functionArn: \(Swift.String(describing: functionArn)), lastModified: \(Swift.String(describing: lastModified)), maximumEventAgeInSeconds: \(Swift.String(describing: maximumEventAgeInSeconds)), maximumRetryAttempts: \(Swift.String(describing: maximumRetryAttempts)))"}
}

extension UpdateFunctionEventInvokeConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFunctionEventInvokeConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationConfig = output.destinationConfig
            self.functionArn = output.functionArn
            self.lastModified = output.lastModified
            self.maximumEventAgeInSeconds = output.maximumEventAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
        } else {
            self.destinationConfig = nil
            self.functionArn = nil
            self.lastModified = nil
            self.maximumEventAgeInSeconds = nil
            self.maximumRetryAttempts = nil
        }
    }
}

public struct UpdateFunctionEventInvokeConfigOutputResponse: Swift.Equatable {
    /// A destination for events after they have been sent to a function for processing.
    ///          <p class="title">
    ///             Destinations
    ///
    ///
    ///
    ///
    ///                   Function - The Amazon Resource Name (ARN) of a Lambda function.
    ///
    ///
    ///
    ///                   Queue - The ARN of an SQS queue.
    ///
    ///
    ///
    ///                   Topic - The ARN of an SNS topic.
    ///
    ///
    ///
    ///                   Event Bus - The ARN of an Amazon EventBridge event bus.
    ///
    ///
    public var destinationConfig: LambdaClientTypes.DestinationConfig?
    /// The Amazon Resource Name (ARN) of the function.
    public var functionArn: Swift.String?
    /// The date and time that the configuration was last updated.
    public var lastModified: ClientRuntime.Date?
    /// The maximum age of a request that Lambda sends to a function for processing.
    public var maximumEventAgeInSeconds: Swift.Int?
    /// The maximum number of times to retry when the function returns an error.
    public var maximumRetryAttempts: Swift.Int?

    public init (
        destinationConfig: LambdaClientTypes.DestinationConfig? = nil,
        functionArn: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        maximumEventAgeInSeconds: Swift.Int? = nil,
        maximumRetryAttempts: Swift.Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

struct UpdateFunctionEventInvokeConfigOutputResponseBody: Swift.Equatable {
    public let lastModified: ClientRuntime.Date?
    public let functionArn: Swift.String?
    public let maximumRetryAttempts: Swift.Int?
    public let maximumEventAgeInSeconds: Swift.Int?
    public let destinationConfig: LambdaClientTypes.DestinationConfig?
}

extension UpdateFunctionEventInvokeConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(LambdaClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension LambdaClientTypes.VpcConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension LambdaClientTypes.VpcConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VpcConfig(securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)))"}
}

extension LambdaClientTypes {
    /// The VPC security groups and subnets that are attached to a Lambda function. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html">VPC Settings.
    public struct VpcConfig: Swift.Equatable {
        /// A list of VPC security groups IDs.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs.
        public var subnetIds: [Swift.String]?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension LambdaClientTypes.VpcConfigResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension LambdaClientTypes.VpcConfigResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VpcConfigResponse(securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension LambdaClientTypes {
    /// The VPC security groups and subnets that are attached to a Lambda function.
    public struct VpcConfigResponse: Swift.Equatable {
        /// A list of VPC security groups IDs.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}
