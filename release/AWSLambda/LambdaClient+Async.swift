// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension LambdaClient {
    /// Adds permissions to the resource-based policy of a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda
    ///         layer. Use this action to grant layer
    ///       usage permission to other accounts. You can grant permission to a single account, all accounts in an organization,
    ///       or all Amazon Web Services accounts.
    ///          To revoke permission, call RemoveLayerVersionPermission with the statement ID that you
    ///       specified when you added it.
    func addLayerVersionPermission(input: AddLayerVersionPermissionInput) async throws -> AddLayerVersionPermissionOutputResponse
    {
        typealias addLayerVersionPermissionContinuation = CheckedContinuation<AddLayerVersionPermissionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: addLayerVersionPermissionContinuation) in
            addLayerVersionPermission(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Grants an Amazon Web Services service or another account permission to use a function. You can apply the policy at the
    ///       function level, or specify a qualifier to restrict access to a single version or alias. If you use a qualifier,
    ///       the invoker must use the full Amazon Resource Name (ARN) of that version or alias to invoke the function.
    ///
    ///          To grant permission to another account, specify the account ID as the Principal. For Amazon Web Services
    ///       services, the principal is a domain-style identifier defined by the service, like s3.amazonaws.com or
    ///         sns.amazonaws.com. For Amazon Web Services services, you can also specify the ARN of the associated resource as the
    ///         SourceArn. If you grant permission to a service principal without specifying the source, other
    ///       accounts could potentially configure resources in their account to invoke your Lambda function.
    ///
    ///          This action adds a statement to a resource-based permissions policy for the function. For more information
    ///       about function policies, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/access-control-resource-based.html">Lambda Function Policies.
    func addPermission(input: AddPermissionInput) async throws -> AddPermissionOutputResponse
    {
        typealias addPermissionContinuation = CheckedContinuation<AddPermissionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: addPermissionContinuation) in
            addPermission(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates an <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias for a
    ///       Lambda function version. Use aliases to provide clients with a function identifier that you can update to invoke a
    ///       different version.
    ///          You can also map an alias to split invocation requests between two versions. Use the
    ///         RoutingConfig parameter to specify a second version and the percentage of invocation requests that
    ///       it receives.
    func createAlias(input: CreateAliasInput) async throws -> CreateAliasOutputResponse
    {
        typealias createAliasContinuation = CheckedContinuation<CreateAliasOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createAliasContinuation) in
            createAlias(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a code signing configuration. A <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-trustedcode.html">code signing configuration defines a list of
    ///       allowed signing profiles and defines the code-signing validation policy (action to be taken if deployment
    ///       validation checks fail).
    func createCodeSigningConfig(input: CreateCodeSigningConfigInput) async throws -> CreateCodeSigningConfigOutputResponse
    {
        typealias createCodeSigningConfigContinuation = CheckedContinuation<CreateCodeSigningConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createCodeSigningConfigContinuation) in
            createCodeSigningConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a mapping between an event source and an Lambda function. Lambda reads items from the event source
    ///       and triggers the function.
    ///          For details about each event source type, see the following topics. In particular, each of the topics
    ///       describes the required and optional parameters for the specific event source.
    ///
    ///
    ///
    ///                   <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html#services-dynamodb-eventsourcemapping">
    ///           Configuring a Dynamo DB stream as an event source
    ///
    ///
    ///
    ///
    ///                   <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html#services-kinesis-eventsourcemapping">
    ///           Configuring a Kinesis stream as an event source
    ///
    ///
    ///
    ///
    ///                   <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-eventsource">
    ///           Configuring an SQS queue as an event source
    ///
    ///
    ///
    ///
    ///                   <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-mq.html#services-mq-eventsourcemapping">
    ///           Configuring an MQ broker as an event source
    ///
    ///
    ///
    ///
    ///                   <a href="https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html">
    ///           Configuring MSK as an event source
    ///
    ///
    ///
    ///
    ///                   <a href="https://docs.aws.amazon.com/lambda/latest/dg/kafka-smaa.html">
    ///           Configuring Self-Managed Apache Kafka as an event source
    ///
    ///
    ///
    ///          The following error handling options are only available for stream sources (DynamoDB and Kinesis):
    ///
    ///
    ///
    ///                   BisectBatchOnFunctionError - If the function returns an error, split the batch in two and retry.
    ///
    ///
    ///
    ///                   DestinationConfig - Send discarded records to an Amazon SQS queue or Amazon SNS topic.
    ///
    ///
    ///
    ///                   MaximumRecordAgeInSeconds - Discard records older than the specified age. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires
    ///
    ///
    ///
    ///                   MaximumRetryAttempts - Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.
    ///
    ///
    ///
    ///                   ParallelizationFactor - Process multiple batches from each shard concurrently.
    ///
    ///
    func createEventSourceMapping(input: CreateEventSourceMappingInput) async throws -> CreateEventSourceMappingOutputResponse
    {
        typealias createEventSourceMappingContinuation = CheckedContinuation<CreateEventSourceMappingOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createEventSourceMappingContinuation) in
            createEventSourceMapping(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a Lambda function. To create a function, you need a <a href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html">deployment package and an <a href="https://docs.aws.amazon.com/lambda/latest/dg/intro-permission-model.html#lambda-intro-execution-role">execution role. The
    ///       deployment package is a .zip file  archive or container image that contains your function code. The execution role grants the function permission to use Amazon Web Services
    ///       services, such as Amazon CloudWatch Logs for log streaming and X-Ray for request tracing.
    ///
    ///          You set the package type to Image if the deployment package is a
    ///       <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html">container image. For a container image,
    ///       the code property must include the URI of a container image in the Amazon ECR registry.
    ///       You do not need to specify the handler and runtime properties.
    ///
    ///          You set the package type to Zip if the deployment package is a
    ///       <a href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html#gettingstarted-package-zip">.zip file archive.
    ///       For a .zip file archive, the code property specifies the location of the .zip file. You must also specify the handler and
    ///       runtime properties.
    ///
    ///          When you create a function, Lambda provisions an instance of the function and its supporting resources. If
    ///       your function connects to a VPC, this process can take a minute or so. During this time, you can't invoke or
    ///       modify the function. The State, StateReason, and StateReasonCode fields in
    ///       the response from GetFunctionConfiguration indicate when the function is ready to invoke. For
    ///       more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/functions-states.html">Function
    ///         States.
    ///
    ///          A function has an unpublished version, and can have published versions and aliases. The unpublished version
    ///       changes when you update your function's code and configuration. A published version is a snapshot of your function
    ///       code and configuration that can't be changed. An alias is a named resource that maps to a version, and can be
    ///       changed to map to a different version. Use the Publish parameter to create version 1 of
    ///       your function from its initial configuration.
    ///
    ///          The other parameters let you configure version-specific and function-level settings. You can modify
    ///       version-specific settings later with UpdateFunctionConfiguration. Function-level settings apply
    ///       to both the unpublished and published versions of the function, and include tags (TagResource)
    ///       and per-function concurrency limits (PutFunctionConcurrency).
    ///
    ///          You can use code signing if your deployment package is a .zip file archive. To enable code signing for this function,
    ///       specify the ARN of a code-signing configuration. When a user
    ///       attempts to deploy a code package with UpdateFunctionCode, Lambda checks that the code
    ///       package has a valid signature from a trusted publisher. The code-signing configuration
    ///       includes set set of signing profiles, which define the trusted publishers for this function.
    ///
    ///          If another account or an Amazon Web Services service invokes your function, use AddPermission to grant
    ///       permission by creating a resource-based IAM policy. You can grant permissions at the function level, on a version,
    ///       or on an alias.
    ///
    ///          To invoke your function directly, use Invoke. To invoke your function in response to events
    ///       in other Amazon Web Services services, create an event source mapping (CreateEventSourceMapping), or configure a
    ///       function trigger in the other service. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-invocation.html">Invoking Functions.
    func createFunction(input: CreateFunctionInput) async throws -> CreateFunctionOutputResponse
    {
        typealias createFunctionContinuation = CheckedContinuation<CreateFunctionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFunctionContinuation) in
            createFunction(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias.
    func deleteAlias(input: DeleteAliasInput) async throws -> DeleteAliasOutputResponse
    {
        typealias deleteAliasContinuation = CheckedContinuation<DeleteAliasOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteAliasContinuation) in
            deleteAlias(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the code signing configuration. You can delete the code signing configuration only if no function is
    ///       using it.
    func deleteCodeSigningConfig(input: DeleteCodeSigningConfigInput) async throws -> DeleteCodeSigningConfigOutputResponse
    {
        typealias deleteCodeSigningConfigContinuation = CheckedContinuation<DeleteCodeSigningConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteCodeSigningConfigContinuation) in
            deleteCodeSigningConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes an <a href="https://docs.aws.amazon.com/lambda/latest/dg/intro-invocation-modes.html">event source
    ///       mapping. You can get the identifier of a mapping from the output of ListEventSourceMappings.
    ///          When you delete an event source mapping, it enters a Deleting state and might not be completely deleted for several seconds.
    func deleteEventSourceMapping(input: DeleteEventSourceMappingInput) async throws -> DeleteEventSourceMappingOutputResponse
    {
        typealias deleteEventSourceMappingContinuation = CheckedContinuation<DeleteEventSourceMappingOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteEventSourceMappingContinuation) in
            deleteEventSourceMapping(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a Lambda function. To delete a specific function version, use the Qualifier parameter.
    ///       Otherwise, all versions and aliases are deleted.
    ///
    ///          To delete Lambda event source mappings that invoke a function, use DeleteEventSourceMapping.
    ///       For Amazon Web Services services and resources that invoke your function directly, delete the trigger in the service where you
    ///       originally configured it.
    func deleteFunction(input: DeleteFunctionInput) async throws -> DeleteFunctionOutputResponse
    {
        typealias deleteFunctionContinuation = CheckedContinuation<DeleteFunctionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFunctionContinuation) in
            deleteFunction(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes the code signing configuration from the function.
    func deleteFunctionCodeSigningConfig(input: DeleteFunctionCodeSigningConfigInput) async throws -> DeleteFunctionCodeSigningConfigOutputResponse
    {
        typealias deleteFunctionCodeSigningConfigContinuation = CheckedContinuation<DeleteFunctionCodeSigningConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFunctionCodeSigningConfigContinuation) in
            deleteFunctionCodeSigningConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes a concurrent execution limit from a function.
    func deleteFunctionConcurrency(input: DeleteFunctionConcurrencyInput) async throws -> DeleteFunctionConcurrencyOutputResponse
    {
        typealias deleteFunctionConcurrencyContinuation = CheckedContinuation<DeleteFunctionConcurrencyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFunctionConcurrencyContinuation) in
            deleteFunctionConcurrency(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the configuration for asynchronous invocation for a function, version, or alias.
    ///          To configure options for asynchronous invocation, use PutFunctionEventInvokeConfig.
    func deleteFunctionEventInvokeConfig(input: DeleteFunctionEventInvokeConfigInput) async throws -> DeleteFunctionEventInvokeConfigOutputResponse
    {
        typealias deleteFunctionEventInvokeConfigContinuation = CheckedContinuation<DeleteFunctionEventInvokeConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFunctionEventInvokeConfigContinuation) in
            deleteFunctionEventInvokeConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda
    ///         layer. Deleted versions can no longer be viewed or added to functions. To avoid
    ///       breaking functions, a copy of the version remains in Lambda until no functions refer to it.
    func deleteLayerVersion(input: DeleteLayerVersionInput) async throws -> DeleteLayerVersionOutputResponse
    {
        typealias deleteLayerVersionContinuation = CheckedContinuation<DeleteLayerVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteLayerVersionContinuation) in
            deleteLayerVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the provisioned concurrency configuration for a function.
    func deleteProvisionedConcurrencyConfig(input: DeleteProvisionedConcurrencyConfigInput) async throws -> DeleteProvisionedConcurrencyConfigOutputResponse
    {
        typealias deleteProvisionedConcurrencyConfigContinuation = CheckedContinuation<DeleteProvisionedConcurrencyConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteProvisionedConcurrencyConfigContinuation) in
            deleteProvisionedConcurrencyConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves details about your account's <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">limits and usage in an Amazon Web Services Region.
    func getAccountSettings(input: GetAccountSettingsInput) async throws -> GetAccountSettingsOutputResponse
    {
        typealias getAccountSettingsContinuation = CheckedContinuation<GetAccountSettingsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getAccountSettingsContinuation) in
            getAccountSettings(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns details about a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias.
    func getAlias(input: GetAliasInput) async throws -> GetAliasOutputResponse
    {
        typealias getAliasContinuation = CheckedContinuation<GetAliasOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getAliasContinuation) in
            getAlias(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns information about the specified code signing configuration.
    func getCodeSigningConfig(input: GetCodeSigningConfigInput) async throws -> GetCodeSigningConfigOutputResponse
    {
        typealias getCodeSigningConfigContinuation = CheckedContinuation<GetCodeSigningConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getCodeSigningConfigContinuation) in
            getCodeSigningConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns details about an event source mapping. You can get the identifier of a mapping from the output of ListEventSourceMappings.
    func getEventSourceMapping(input: GetEventSourceMappingInput) async throws -> GetEventSourceMappingOutputResponse
    {
        typealias getEventSourceMappingContinuation = CheckedContinuation<GetEventSourceMappingOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getEventSourceMappingContinuation) in
            getEventSourceMapping(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns information about the function or function version, with a link to download the deployment package
    ///       that's valid for 10 minutes. If you specify a function version, only details that are specific to that version are
    ///       returned.
    func getFunction(input: GetFunctionInput) async throws -> GetFunctionOutputResponse
    {
        typealias getFunctionContinuation = CheckedContinuation<GetFunctionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFunctionContinuation) in
            getFunction(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns the code signing configuration for the specified function.
    func getFunctionCodeSigningConfig(input: GetFunctionCodeSigningConfigInput) async throws -> GetFunctionCodeSigningConfigOutputResponse
    {
        typealias getFunctionCodeSigningConfigContinuation = CheckedContinuation<GetFunctionCodeSigningConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFunctionCodeSigningConfigContinuation) in
            getFunctionCodeSigningConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns details about the reserved concurrency configuration for a function. To set a concurrency limit for a
    ///       function, use PutFunctionConcurrency.
    func getFunctionConcurrency(input: GetFunctionConcurrencyInput) async throws -> GetFunctionConcurrencyOutputResponse
    {
        typealias getFunctionConcurrencyContinuation = CheckedContinuation<GetFunctionConcurrencyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFunctionConcurrencyContinuation) in
            getFunctionConcurrency(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns the version-specific settings of a Lambda function or version. The output includes only options that
    ///       can vary between versions of a function. To modify these settings, use UpdateFunctionConfiguration.
    ///          To get all of a function's details, including function-level settings, use GetFunction.
    func getFunctionConfiguration(input: GetFunctionConfigurationInput) async throws -> GetFunctionConfigurationOutputResponse
    {
        typealias getFunctionConfigurationContinuation = CheckedContinuation<GetFunctionConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFunctionConfigurationContinuation) in
            getFunctionConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the configuration for asynchronous invocation for a function, version, or alias.
    ///          To configure options for asynchronous invocation, use PutFunctionEventInvokeConfig.
    func getFunctionEventInvokeConfig(input: GetFunctionEventInvokeConfigInput) async throws -> GetFunctionEventInvokeConfigOutputResponse
    {
        typealias getFunctionEventInvokeConfigContinuation = CheckedContinuation<GetFunctionEventInvokeConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFunctionEventInvokeConfigContinuation) in
            getFunctionEventInvokeConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns information about a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda
    ///         layer, with a link to download the layer archive
    ///         that's valid for 10 minutes.
    func getLayerVersion(input: GetLayerVersionInput) async throws -> GetLayerVersionOutputResponse
    {
        typealias getLayerVersionContinuation = CheckedContinuation<GetLayerVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getLayerVersionContinuation) in
            getLayerVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns information about a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda
    ///         layer, with a link to download the layer archive
    ///         that's valid for 10 minutes.
    func getLayerVersionByArn(input: GetLayerVersionByArnInput) async throws -> GetLayerVersionByArnOutputResponse
    {
        typealias getLayerVersionByArnContinuation = CheckedContinuation<GetLayerVersionByArnOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getLayerVersionByArnContinuation) in
            getLayerVersionByArn(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns the permission policy for a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda
    ///         layer. For more information, see AddLayerVersionPermission.
    func getLayerVersionPolicy(input: GetLayerVersionPolicyInput) async throws -> GetLayerVersionPolicyOutputResponse
    {
        typealias getLayerVersionPolicyContinuation = CheckedContinuation<GetLayerVersionPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getLayerVersionPolicyContinuation) in
            getLayerVersionPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns the <a href="https://docs.aws.amazon.com/lambda/latest/dg/access-control-resource-based.html">resource-based IAM policy for a function, version, or alias.
    func getPolicy(input: GetPolicyInput) async throws -> GetPolicyOutputResponse
    {
        typealias getPolicyContinuation = CheckedContinuation<GetPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getPolicyContinuation) in
            getPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the provisioned concurrency configuration for a function's alias or version.
    func getProvisionedConcurrencyConfig(input: GetProvisionedConcurrencyConfigInput) async throws -> GetProvisionedConcurrencyConfigOutputResponse
    {
        typealias getProvisionedConcurrencyConfigContinuation = CheckedContinuation<GetProvisionedConcurrencyConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getProvisionedConcurrencyConfigContinuation) in
            getProvisionedConcurrencyConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Invokes a Lambda function. You can invoke a function synchronously (and wait for the response), or
    ///       asynchronously. To invoke a function asynchronously, set InvocationType to Event.
    ///
    ///          For <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-sync.html">synchronous invocation,
    ///       details about the function response, including errors, are included in the response body and headers. For either
    ///       invocation type, you can find more information in the <a href="https://docs.aws.amazon.com/lambda/latest/dg/monitoring-functions.html">execution log and <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-x-ray.html">trace.
    ///
    ///          When an error occurs, your function may be invoked multiple times. Retry behavior varies by error type,
    ///       client, event source, and invocation type. For example, if you invoke a function asynchronously and it returns an
    ///       error, Lambda executes the function up to two more times. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/retries-on-errors.html">Retry Behavior.
    ///
    ///          For <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html">asynchronous invocation,
    ///       Lambda adds events to a queue before sending them to your function. If your function does not have enough capacity
    ///       to keep up with the queue, events may be lost. Occasionally, your function may receive the same event multiple
    ///       times, even if no error occurs. To retain events that were not processed, configure your function with a <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">dead-letter queue.
    ///
    ///          The status code in the API response doesn't reflect function errors. Error codes are reserved for errors that
    ///       prevent your function from executing, such as permissions errors, <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">limit errors, or issues with your function's code and configuration.
    ///       For example, Lambda returns TooManyRequestsException if executing the function would cause you to
    ///       exceed a concurrency limit at either the account level (ConcurrentInvocationLimitExceeded) or
    ///       function level (ReservedFunctionConcurrentInvocationLimitExceeded).
    ///
    ///          For functions with a long timeout, your client might be disconnected during synchronous invocation while it
    ///       waits for a response. Configure your HTTP client, SDK, firewall, proxy, or operating system to allow for long
    ///       connections with timeout or keep-alive settings.
    ///
    ///          This operation requires permission for the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_awslambda.html">lambda:InvokeFunction action.
    func invoke(input: InvokeInput) async throws -> InvokeOutputResponse
    {
        typealias invokeContinuation = CheckedContinuation<InvokeOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: invokeContinuation) in
            invoke(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///
    ///             For asynchronous function invocation, use Invoke.
    ///
    ///          Invokes a function asynchronously.
    @available(*, deprecated)
    func invokeAsync(input: InvokeAsyncInput) async throws -> InvokeAsyncOutputResponse
    {
        typealias invokeAsyncContinuation = CheckedContinuation<InvokeAsyncOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: invokeAsyncContinuation) in
            invokeAsync(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">aliases
    ///       for a Lambda function.
    func listAliases(input: ListAliasesInput) async throws -> ListAliasesOutputResponse
    {
        typealias listAliasesContinuation = CheckedContinuation<ListAliasesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listAliasesContinuation) in
            listAliases(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuring-codesigning.html">code
    ///         signing configurations. A request returns up to 10,000 configurations per
    ///       call. You can use the MaxItems parameter to return fewer configurations per call.
    func listCodeSigningConfigs(input: ListCodeSigningConfigsInput) async throws -> ListCodeSigningConfigsOutputResponse
    {
        typealias listCodeSigningConfigsContinuation = CheckedContinuation<ListCodeSigningConfigsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listCodeSigningConfigsContinuation) in
            listCodeSigningConfigs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists event source mappings. Specify an EventSourceArn to only show event source mappings for a
    ///       single event source.
    func listEventSourceMappings(input: ListEventSourceMappingsInput) async throws -> ListEventSourceMappingsOutputResponse
    {
        typealias listEventSourceMappingsContinuation = CheckedContinuation<ListEventSourceMappingsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listEventSourceMappingsContinuation) in
            listEventSourceMappings(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of configurations for asynchronous invocation for a function.
    ///          To configure options for asynchronous invocation, use PutFunctionEventInvokeConfig.
    func listFunctionEventInvokeConfigs(input: ListFunctionEventInvokeConfigsInput) async throws -> ListFunctionEventInvokeConfigsOutputResponse
    {
        typealias listFunctionEventInvokeConfigsContinuation = CheckedContinuation<ListFunctionEventInvokeConfigsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFunctionEventInvokeConfigsContinuation) in
            listFunctionEventInvokeConfigs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of Lambda functions, with the version-specific configuration of each. Lambda returns up to 50
    ///       functions per call.
    ///          Set FunctionVersion to ALL to include all published versions of each function in
    ///       addition to the unpublished version.
    ///
    ///             The ListFunctions action returns a subset of the FunctionConfiguration fields.
    ///       To get the additional fields (State, StateReasonCode, StateReason, LastUpdateStatus, LastUpdateStatusReason, LastUpdateStatusReasonCode)
    ///       for a function or version, use GetFunction.
    ///
    func listFunctions(input: ListFunctionsInput) async throws -> ListFunctionsOutputResponse
    {
        typealias listFunctionsContinuation = CheckedContinuation<ListFunctionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFunctionsContinuation) in
            listFunctions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List the functions that use the specified code signing configuration. You can use this method prior to deleting a
    ///       code signing configuration, to verify that no functions are using it.
    func listFunctionsByCodeSigningConfig(input: ListFunctionsByCodeSigningConfigInput) async throws -> ListFunctionsByCodeSigningConfigOutputResponse
    {
        typealias listFunctionsByCodeSigningConfigContinuation = CheckedContinuation<ListFunctionsByCodeSigningConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFunctionsByCodeSigningConfigContinuation) in
            listFunctionsByCodeSigningConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the versions of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda
    ///         layer. Versions that have been deleted aren't listed. Specify a <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">runtime identifier to list only
    ///       versions that indicate that they're compatible with that runtime.
    func listLayerVersions(input: ListLayerVersionsInput) async throws -> ListLayerVersionsOutputResponse
    {
        typealias listLayerVersionsContinuation = CheckedContinuation<ListLayerVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listLayerVersionsContinuation) in
            listLayerVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda
    ///         layers and shows information about the latest version of each. Specify a <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">runtime identifier to list only layers
    ///       that indicate that they're compatible with that runtime.
    func listLayers(input: ListLayersInput) async throws -> ListLayersOutputResponse
    {
        typealias listLayersContinuation = CheckedContinuation<ListLayersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listLayersContinuation) in
            listLayers(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a list of provisioned concurrency configurations for a function.
    func listProvisionedConcurrencyConfigs(input: ListProvisionedConcurrencyConfigsInput) async throws -> ListProvisionedConcurrencyConfigsOutputResponse
    {
        typealias listProvisionedConcurrencyConfigsContinuation = CheckedContinuation<ListProvisionedConcurrencyConfigsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listProvisionedConcurrencyConfigsContinuation) in
            listProvisionedConcurrencyConfigs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/tagging.html">tags. You can
    ///       also view tags with GetFunction.
    func listTags(input: ListTagsInput) async throws -> ListTagsOutputResponse
    {
        typealias listTagsContinuation = CheckedContinuation<ListTagsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsContinuation) in
            listTags(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">versions,
    ///       with the version-specific configuration of each. Lambda returns up to 50 versions per call.
    func listVersionsByFunction(input: ListVersionsByFunctionInput) async throws -> ListVersionsByFunctionOutputResponse
    {
        typealias listVersionsByFunctionContinuation = CheckedContinuation<ListVersionsByFunctionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listVersionsByFunctionContinuation) in
            listVersionsByFunction(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda
    ///         layer from a ZIP archive. Each time you call PublishLayerVersion with the same
    ///       layer name, a new version is created.
    ///          Add layers to your function with CreateFunction or UpdateFunctionConfiguration.
    func publishLayerVersion(input: PublishLayerVersionInput) async throws -> PublishLayerVersionOutputResponse
    {
        typealias publishLayerVersionContinuation = CheckedContinuation<PublishLayerVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: publishLayerVersionContinuation) in
            publishLayerVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">version from the
    ///       current code and configuration of a function. Use versions to create a snapshot of your function code and
    ///       configuration that doesn't change.
    ///
    ///          Lambda doesn't publish a version if the function's configuration and code haven't changed since the last
    ///       version. Use UpdateFunctionCode or UpdateFunctionConfiguration to update the
    ///       function before publishing a version.
    ///
    ///          Clients can invoke versions directly or with an alias. To create an alias, use CreateAlias.
    func publishVersion(input: PublishVersionInput) async throws -> PublishVersionOutputResponse
    {
        typealias publishVersionContinuation = CheckedContinuation<PublishVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: publishVersionContinuation) in
            publishVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Update the code signing configuration for the function. Changes to the code signing configuration take effect the
    ///       next time a user tries to deploy a code package to the function.
    func putFunctionCodeSigningConfig(input: PutFunctionCodeSigningConfigInput) async throws -> PutFunctionCodeSigningConfigOutputResponse
    {
        typealias putFunctionCodeSigningConfigContinuation = CheckedContinuation<PutFunctionCodeSigningConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putFunctionCodeSigningConfigContinuation) in
            putFunctionCodeSigningConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Sets the maximum number of simultaneous executions for a function, and reserves capacity for that concurrency
    ///       level.
    ///          Concurrency settings apply to the function as a whole, including all published versions and the unpublished
    ///       version. Reserving concurrency both ensures that your function has capacity to process the specified number of
    ///       events simultaneously, and prevents it from scaling beyond that level. Use GetFunction to see
    ///       the current setting for a function.
    ///          Use GetAccountSettings to see your Regional concurrency limit. You can reserve concurrency
    ///       for as many functions as you like, as long as you leave at least 100 simultaneous executions unreserved for
    ///       functions that aren't configured with a per-function limit. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html">Managing Concurrency.
    func putFunctionConcurrency(input: PutFunctionConcurrencyInput) async throws -> PutFunctionConcurrencyOutputResponse
    {
        typealias putFunctionConcurrencyContinuation = CheckedContinuation<PutFunctionConcurrencyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putFunctionConcurrencyContinuation) in
            putFunctionConcurrency(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Configures options for <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html">asynchronous
    ///         invocation on a function, version, or alias. If a configuration already exists for a function, version,
    ///       or alias, this operation overwrites it. If you exclude any settings, they are removed. To set one option without
    ///       affecting existing settings for other options, use UpdateFunctionEventInvokeConfig.
    ///          By default, Lambda retries an asynchronous invocation twice if the function returns an error. It retains
    ///       events in a queue for up to six hours. When an event fails all processing attempts or stays in the asynchronous
    ///       invocation queue for too long, Lambda discards it. To retain discarded events, configure a dead-letter queue with
    ///         UpdateFunctionConfiguration.
    ///          To send an invocation record to a queue, topic, function, or event bus, specify a <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations">destination. You can configure separate destinations for successful invocations (on-success) and events
    ///       that fail all processing attempts (on-failure). You can configure destinations in addition to or instead of a
    ///       dead-letter queue.
    func putFunctionEventInvokeConfig(input: PutFunctionEventInvokeConfigInput) async throws -> PutFunctionEventInvokeConfigOutputResponse
    {
        typealias putFunctionEventInvokeConfigContinuation = CheckedContinuation<PutFunctionEventInvokeConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putFunctionEventInvokeConfigContinuation) in
            putFunctionEventInvokeConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Adds a provisioned concurrency configuration to a function's alias or version.
    func putProvisionedConcurrencyConfig(input: PutProvisionedConcurrencyConfigInput) async throws -> PutProvisionedConcurrencyConfigOutputResponse
    {
        typealias putProvisionedConcurrencyConfigContinuation = CheckedContinuation<PutProvisionedConcurrencyConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putProvisionedConcurrencyConfigContinuation) in
            putProvisionedConcurrencyConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes a statement from the permissions policy for a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">Lambda
    ///         layer. For more information, see
    ///         AddLayerVersionPermission.
    func removeLayerVersionPermission(input: RemoveLayerVersionPermissionInput) async throws -> RemoveLayerVersionPermissionOutputResponse
    {
        typealias removeLayerVersionPermissionContinuation = CheckedContinuation<RemoveLayerVersionPermissionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: removeLayerVersionPermissionContinuation) in
            removeLayerVersionPermission(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Revokes function-use permission from an Amazon Web Services service or another account. You can get the ID of the statement
    ///       from the output of GetPolicy.
    func removePermission(input: RemovePermissionInput) async throws -> RemovePermissionOutputResponse
    {
        typealias removePermissionContinuation = CheckedContinuation<RemovePermissionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: removePermissionContinuation) in
            removePermission(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Adds <a href="https://docs.aws.amazon.com/lambda/latest/dg/tagging.html">tags to a function.
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes <a href="https://docs.aws.amazon.com/lambda/latest/dg/tagging.html">tags from a function.
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the configuration of a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias.
    func updateAlias(input: UpdateAliasInput) async throws -> UpdateAliasOutputResponse
    {
        typealias updateAliasContinuation = CheckedContinuation<UpdateAliasOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateAliasContinuation) in
            updateAlias(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Update the code signing configuration. Changes to the code signing configuration take effect the next time a
    ///       user tries to deploy a code package to the function.
    func updateCodeSigningConfig(input: UpdateCodeSigningConfigInput) async throws -> UpdateCodeSigningConfigOutputResponse
    {
        typealias updateCodeSigningConfigContinuation = CheckedContinuation<UpdateCodeSigningConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateCodeSigningConfigContinuation) in
            updateCodeSigningConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates an event source mapping. You can change the function that Lambda invokes, or pause invocation and resume later from the same location.
    ///          The following error handling options are only available for stream sources (DynamoDB and Kinesis):
    ///
    ///
    ///
    ///                   BisectBatchOnFunctionError - If the function returns an error, split the batch in two and retry.
    ///
    ///
    ///
    ///                   DestinationConfig - Send discarded records to an Amazon SQS queue or Amazon SNS topic.
    ///
    ///
    ///
    ///                   MaximumRecordAgeInSeconds - Discard records older than the specified age. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires
    ///
    ///
    ///
    ///                   MaximumRetryAttempts - Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.
    ///
    ///
    ///
    ///                   ParallelizationFactor - Process multiple batches from each shard concurrently.
    ///
    ///
    func updateEventSourceMapping(input: UpdateEventSourceMappingInput) async throws -> UpdateEventSourceMappingOutputResponse
    {
        typealias updateEventSourceMappingContinuation = CheckedContinuation<UpdateEventSourceMappingOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateEventSourceMappingContinuation) in
            updateEventSourceMapping(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a Lambda function's code. If code signing is enabled for the function, the code package must be signed
    ///       by a trusted publisher. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-trustedcode.html">Configuring code signing.
    ///
    ///          The function's code is locked when you publish a version. You can't modify the code of a published version,
    ///       only the unpublished version.
    ///
    ///             For a function defined as a container image, Lambda resolves the image tag to an image digest. In Amazon ECR, if
    ///         you update the image tag to a new image, Lambda does not automatically update the function.
    ///
    func updateFunctionCode(input: UpdateFunctionCodeInput) async throws -> UpdateFunctionCodeOutputResponse
    {
        typealias updateFunctionCodeContinuation = CheckedContinuation<UpdateFunctionCodeOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateFunctionCodeContinuation) in
            updateFunctionCode(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Modify the version-specific settings of a Lambda function.
    ///
    ///          When you update a function, Lambda provisions an instance of the function and its supporting resources. If
    ///       your function connects to a VPC, this process can take a minute. During this time, you can't modify the function,
    ///       but you can still invoke it. The LastUpdateStatus, LastUpdateStatusReason, and
    ///         LastUpdateStatusReasonCode fields in the response from GetFunctionConfiguration
    ///       indicate when the update is complete and the function is processing events with the new configuration. For more
    ///       information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/functions-states.html">Function
    ///       States.
    ///
    ///          These settings can vary between versions of a function and are locked when you publish a version. You can't
    ///       modify the configuration of a published version, only the unpublished version.
    ///
    ///          To configure function concurrency, use PutFunctionConcurrency. To grant invoke permissions
    ///       to an account or Amazon Web Services service, use AddPermission.
    func updateFunctionConfiguration(input: UpdateFunctionConfigurationInput) async throws -> UpdateFunctionConfigurationOutputResponse
    {
        typealias updateFunctionConfigurationContinuation = CheckedContinuation<UpdateFunctionConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateFunctionConfigurationContinuation) in
            updateFunctionConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the configuration for asynchronous invocation for a function, version, or alias.
    ///          To configure options for asynchronous invocation, use PutFunctionEventInvokeConfig.
    func updateFunctionEventInvokeConfig(input: UpdateFunctionEventInvokeConfigInput) async throws -> UpdateFunctionEventInvokeConfigOutputResponse
    {
        typealias updateFunctionEventInvokeConfigContinuation = CheckedContinuation<UpdateFunctionEventInvokeConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateFunctionEventInvokeConfigContinuation) in
            updateFunctionEventInvokeConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
