// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AddPermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddPermissionOutputError>
}

extension AddPermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddPermissionInput(aWSAccountId: \(Swift.String(describing: aWSAccountId)), actionName: \(Swift.String(describing: actionName)), label: \(Swift.String(describing: label)), topicArn: \(Swift.String(describing: topicArn)))"}
}

extension AddPermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let aWSAccountId = aWSAccountId {
            var aWSAccountIdContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AWSAccountId"))
            for (index0, delegate0) in aWSAccountId.enumerated() {
                try aWSAccountIdContainer.encode(delegate0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let actionName = actionName {
            var actionNameContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionName"))
            for (index0, action0) in actionName.enumerated() {
                try actionNameContainer.encode(action0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let label = label {
            try container.encode(label, forKey: ClientRuntime.Key("Label"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("AddPermission", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AddPermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddPermissionOutputError>
}

public struct AddPermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddPermissionOutputError>
}

public struct AddPermissionInput: Swift.Equatable {
    /// <p>The AWS account IDs of the users (principals) who will be given access to the
    ///             specified actions. The users must have AWS accounts, but do not need to be signed up for
    ///             this service.</p>
    public let aWSAccountId: [Swift.String]?
    /// <p>The action you want to allow for the specified principal(s).</p>
    ///         <p>Valid values: Any Amazon SNS action name, for example <code>Publish</code>.</p>
    public let actionName: [Swift.String]?
    /// <p>A unique identifier for the new policy statement.</p>
    public let label: Swift.String?
    /// <p>The ARN of the topic whose access control policy you wish to modify.</p>
    public let topicArn: Swift.String?

    public init (
        aWSAccountId: [Swift.String]? = nil,
        actionName: [Swift.String]? = nil,
        label: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.aWSAccountId = aWSAccountId
        self.actionName = actionName
        self.label = label
        self.topicArn = topicArn
    }
}

extension AddPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddPermissionOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddPermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddPermissionOutputResponse()"}
}

extension AddPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddPermissionOutputResponse: Swift.Equatable {

    public init() {}
}

struct AddPermissionOutputResponseBody: Swift.Equatable {
}

extension AddPermissionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AuthorizationErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizationErrorException(message: \(Swift.String(describing: message)))"}
}

extension AuthorizationErrorException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<AuthorizationErrorExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the user has been denied access to the requested resource.</p>
public struct AuthorizationErrorException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationErrorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AuthorizationErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CheckIfPhoneNumberIsOptedOutInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckIfPhoneNumberIsOptedOutInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CheckIfPhoneNumberIsOptedOutInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckIfPhoneNumberIsOptedOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CheckIfPhoneNumberIsOptedOutInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CheckIfPhoneNumberIsOptedOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckIfPhoneNumberIsOptedOutOutputError>
}

extension CheckIfPhoneNumberIsOptedOutInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CheckIfPhoneNumberIsOptedOutInput(phoneNumber: \(Swift.String(describing: phoneNumber)))"}
}

extension CheckIfPhoneNumberIsOptedOutInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("phoneNumber"))
        }
        try container.encode("CheckIfPhoneNumberIsOptedOut", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CheckIfPhoneNumberIsOptedOutInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckIfPhoneNumberIsOptedOutInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CheckIfPhoneNumberIsOptedOutInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckIfPhoneNumberIsOptedOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CheckIfPhoneNumberIsOptedOutInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CheckIfPhoneNumberIsOptedOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckIfPhoneNumberIsOptedOutOutputError>
}

public struct CheckIfPhoneNumberIsOptedOutInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckIfPhoneNumberIsOptedOutInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CheckIfPhoneNumberIsOptedOutInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckIfPhoneNumberIsOptedOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CheckIfPhoneNumberIsOptedOutInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CheckIfPhoneNumberIsOptedOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckIfPhoneNumberIsOptedOutOutputError>
}

/// <p>The input for the <code>CheckIfPhoneNumberIsOptedOut</code> action.</p>
public struct CheckIfPhoneNumberIsOptedOutInput: Swift.Equatable {
    /// <p>The phone number for which you want to check the opt out status.</p>
    public let phoneNumber: Swift.String?

    public init (
        phoneNumber: Swift.String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

extension CheckIfPhoneNumberIsOptedOutOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CheckIfPhoneNumberIsOptedOutOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CheckIfPhoneNumberIsOptedOutOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckIfPhoneNumberIsOptedOutOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CheckIfPhoneNumberIsOptedOutOutputResponse(isOptedOut: \(Swift.String(describing: isOptedOut)))"}
}

extension CheckIfPhoneNumberIsOptedOutOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CheckIfPhoneNumberIsOptedOutOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isOptedOut = output.isOptedOut
        } else {
            self.isOptedOut = false
        }
    }
}

/// <p>The response from the <code>CheckIfPhoneNumberIsOptedOut</code> action.</p>
public struct CheckIfPhoneNumberIsOptedOutOutputResponse: Swift.Equatable {
    /// <p>Indicates whether the phone number is opted out:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>true</code> – The phone number is opted out, meaning you cannot publish
    ///                     SMS messages to it.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>false</code> – The phone number is opted in, meaning you can publish SMS
    ///                     messages to it.</p>
    ///             </li>
    ///          </ul>
    public let isOptedOut: Swift.Bool

    public init (
        isOptedOut: Swift.Bool = false
    )
    {
        self.isOptedOut = isOptedOut
    }
}

struct CheckIfPhoneNumberIsOptedOutOutputResponseBody: Swift.Equatable {
    public let isOptedOut: Swift.Bool
}

extension CheckIfPhoneNumberIsOptedOutOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isOptedOut
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CheckIfPhoneNumberIsOptedOutResult"))
        let isOptedOutDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isOptedOut)
        isOptedOut = isOptedOutDecoded
    }
}

extension ConcurrentAccessException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConcurrentAccessException(message: \(Swift.String(describing: message)))"}
}

extension ConcurrentAccessException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ConcurrentAccessExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Can't perform multiple operations on a tag simultaneously. Perform the operations
///             sequentially.</p>
public struct ConcurrentAccessException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentAccessExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConcurrentAccessExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ConfirmSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ConfirmSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ConfirmSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ConfirmSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ConfirmSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ConfirmSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ConfirmSubscriptionOutputError>
}

extension ConfirmSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfirmSubscriptionInput(authenticateOnUnsubscribe: \(Swift.String(describing: authenticateOnUnsubscribe)), token: \(Swift.String(describing: token)), topicArn: \(Swift.String(describing: topicArn)))"}
}

extension ConfirmSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authenticateOnUnsubscribe = authenticateOnUnsubscribe {
            try container.encode(authenticateOnUnsubscribe, forKey: ClientRuntime.Key("AuthenticateOnUnsubscribe"))
        }
        if let token = token {
            try container.encode(token, forKey: ClientRuntime.Key("Token"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("ConfirmSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ConfirmSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ConfirmSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ConfirmSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ConfirmSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ConfirmSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ConfirmSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ConfirmSubscriptionOutputError>
}

public struct ConfirmSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ConfirmSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ConfirmSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ConfirmSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ConfirmSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ConfirmSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ConfirmSubscriptionOutputError>
}

/// <p>Input for ConfirmSubscription action.</p>
public struct ConfirmSubscriptionInput: Swift.Equatable {
    /// <p>Disallows unauthenticated unsubscribes of the subscription. If the value of this
    ///             parameter is <code>true</code> and the request has an AWS signature, then only the topic
    ///             owner and the subscription owner can unsubscribe the endpoint. The unsubscribe action
    ///             requires AWS authentication. </p>
    public let authenticateOnUnsubscribe: Swift.String?
    /// <p>Short-lived token sent to an endpoint during the <code>Subscribe</code> action.</p>
    public let token: Swift.String?
    /// <p>The ARN of the topic for which you wish to confirm a subscription.</p>
    public let topicArn: Swift.String?

    public init (
        authenticateOnUnsubscribe: Swift.String? = nil,
        token: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.authenticateOnUnsubscribe = authenticateOnUnsubscribe
        self.token = token
        self.topicArn = topicArn
    }
}

extension ConfirmSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ConfirmSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterPolicyLimitExceededException" : self = .filterPolicyLimitExceededException(try FilterPolicyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionLimitExceededException" : self = .subscriptionLimitExceededException(try SubscriptionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfirmSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case filterPolicyLimitExceededException(FilterPolicyLimitExceededException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case subscriptionLimitExceededException(SubscriptionLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfirmSubscriptionOutputResponse(subscriptionArn: \(Swift.String(describing: subscriptionArn)))"}
}

extension ConfirmSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConfirmSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subscriptionArn = output.subscriptionArn
        } else {
            self.subscriptionArn = nil
        }
    }
}

/// <p>Response for ConfirmSubscriptions action.</p>
public struct ConfirmSubscriptionOutputResponse: Swift.Equatable {
    /// <p>The ARN of the created subscription.</p>
    public let subscriptionArn: Swift.String?

    public init (
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct ConfirmSubscriptionOutputResponseBody: Swift.Equatable {
    public let subscriptionArn: Swift.String?
}

extension ConfirmSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ConfirmSubscriptionResult"))
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

public struct CreatePlatformApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlatformApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePlatformApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePlatformApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlatformApplicationOutputError>
}

extension CreatePlatformApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePlatformApplicationInput(attributes: \(Swift.String(describing: attributes)), name: \(Swift.String(describing: name)), platform: \(Swift.String(describing: platform)))"}
}

extension CreatePlatformApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let platform = platform {
            try container.encode(platform, forKey: ClientRuntime.Key("Platform"))
        }
        try container.encode("CreatePlatformApplication", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreatePlatformApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlatformApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePlatformApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePlatformApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlatformApplicationOutputError>
}

public struct CreatePlatformApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlatformApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePlatformApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePlatformApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlatformApplicationOutputError>
}

/// <p>Input for CreatePlatformApplication action.</p>
public struct CreatePlatformApplicationInput: Swift.Equatable {
    /// <p>For a list of attributes, see <a href="https://docs.aws.amazon.com/sns/latest/api/API_SetPlatformApplicationAttributes.html">SetPlatformApplicationAttributes</a>.</p>
    public let attributes: [Swift.String:Swift.String]?
    /// <p>Application names must be made up of only uppercase and lowercase ASCII letters,
    ///             numbers, underscores, hyphens, and periods, and must be between 1 and 256 characters
    ///             long.</p>
    public let name: Swift.String?
    /// <p>The following platforms are supported: ADM (Amazon Device Messaging), APNS (Apple Push
    ///             Notification Service), APNS_SANDBOX, and GCM (Firebase Cloud Messaging).</p>
    public let platform: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        name: Swift.String? = nil,
        platform: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.name = name
        self.platform = platform
    }
}

extension CreatePlatformApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreatePlatformApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePlatformApplicationOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePlatformApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePlatformApplicationOutputResponse(platformApplicationArn: \(Swift.String(describing: platformApplicationArn)))"}
}

extension CreatePlatformApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePlatformApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.platformApplicationArn = output.platformApplicationArn
        } else {
            self.platformApplicationArn = nil
        }
    }
}

/// <p>Response from CreatePlatformApplication action.</p>
public struct CreatePlatformApplicationOutputResponse: Swift.Equatable {
    /// <p>PlatformApplicationArn is returned.</p>
    public let platformApplicationArn: Swift.String?

    public init (
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.platformApplicationArn = platformApplicationArn
    }
}

struct CreatePlatformApplicationOutputResponseBody: Swift.Equatable {
    public let platformApplicationArn: Swift.String?
}

extension CreatePlatformApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platformApplicationArn = "PlatformApplicationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreatePlatformApplicationResult"))
        let platformApplicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformApplicationArn)
        platformApplicationArn = platformApplicationArnDecoded
    }
}

public struct CreatePlatformEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlatformEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePlatformEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlatformEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePlatformEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlatformEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlatformEndpointOutputError>
}

extension CreatePlatformEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePlatformEndpointInput(attributes: \(Swift.String(describing: attributes)), customUserData: \(Swift.String(describing: customUserData)), platformApplicationArn: \(Swift.String(describing: platformApplicationArn)), token: \(Swift.String(describing: token)))"}
}

extension CreatePlatformEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let customUserData = customUserData {
            try container.encode(customUserData, forKey: ClientRuntime.Key("CustomUserData"))
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
        if let token = token {
            try container.encode(token, forKey: ClientRuntime.Key("Token"))
        }
        try container.encode("CreatePlatformEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreatePlatformEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlatformEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePlatformEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlatformEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePlatformEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlatformEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlatformEndpointOutputError>
}

public struct CreatePlatformEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlatformEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePlatformEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlatformEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePlatformEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlatformEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlatformEndpointOutputError>
}

/// <p>Input for CreatePlatformEndpoint action.</p>
public struct CreatePlatformEndpointInput: Swift.Equatable {
    /// <p>For a list of attributes, see <a href="https://docs.aws.amazon.com/sns/latest/api/API_SetEndpointAttributes.html">SetEndpointAttributes</a>.</p>
    public let attributes: [Swift.String:Swift.String]?
    /// <p>Arbitrary user data to associate with the endpoint. Amazon SNS does not use this data. The
    ///             data must be in UTF-8 format and less than 2KB.</p>
    public let customUserData: Swift.String?
    /// <p>PlatformApplicationArn returned from CreatePlatformApplication is used to create a an
    ///             endpoint.</p>
    public let platformApplicationArn: Swift.String?
    /// <p>Unique identifier created by the notification service for an app on a device. The
    ///             specific name for Token will vary, depending on which notification service is being
    ///             used. For example, when using APNS as the notification service, you need the device
    ///             token. Alternatively, when using GCM (Firebase Cloud Messaging) or ADM, the device token
    ///             equivalent is called the registration ID.</p>
    public let token: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        customUserData: Swift.String? = nil,
        platformApplicationArn: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.customUserData = customUserData
        self.platformApplicationArn = platformApplicationArn
        self.token = token
    }
}

extension CreatePlatformEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreatePlatformEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePlatformEndpointOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePlatformEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePlatformEndpointOutputResponse(endpointArn: \(Swift.String(describing: endpointArn)))"}
}

extension CreatePlatformEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePlatformEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointArn = output.endpointArn
        } else {
            self.endpointArn = nil
        }
    }
}

/// <p>Response from CreateEndpoint action.</p>
public struct CreatePlatformEndpointOutputResponse: Swift.Equatable {
    /// <p>EndpointArn returned from CreateEndpoint action.</p>
    public let endpointArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct CreatePlatformEndpointOutputResponseBody: Swift.Equatable {
    public let endpointArn: Swift.String?
}

extension CreatePlatformEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreatePlatformEndpointResult"))
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

public struct CreateSMSSandboxPhoneNumberInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSMSSandboxPhoneNumberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSMSSandboxPhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSMSSandboxPhoneNumberOutputError>
}

extension CreateSMSSandboxPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSMSSandboxPhoneNumberInput(languageCode: \(Swift.String(describing: languageCode)), phoneNumber: \(Swift.String(describing: phoneNumber)))"}
}

extension CreateSMSSandboxPhoneNumberInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let languageCode = languageCode {
            try container.encode(languageCode, forKey: ClientRuntime.Key("LanguageCode"))
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        try container.encode("CreateSMSSandboxPhoneNumber", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateSMSSandboxPhoneNumberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSMSSandboxPhoneNumberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSMSSandboxPhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSMSSandboxPhoneNumberOutputError>
}

public struct CreateSMSSandboxPhoneNumberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSMSSandboxPhoneNumberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSMSSandboxPhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSMSSandboxPhoneNumberOutputError>
}

public struct CreateSMSSandboxPhoneNumberInput: Swift.Equatable {
    /// <p>The language to use for sending the OTP. The default value is
    ///             <code>en-US</code>.</p>
    public let languageCode: SnsClientTypes.LanguageCodeString?
    /// <p>The destination phone number to verify. On verification, Amazon SNS adds this phone number
    ///             to the list of verified phone numbers that you can send SMS messages to.</p>
    public let phoneNumber: Swift.String?

    public init (
        languageCode: SnsClientTypes.LanguageCodeString? = nil,
        phoneNumber: Swift.String? = nil
    )
    {
        self.languageCode = languageCode
        self.phoneNumber = phoneNumber
    }
}

extension CreateSMSSandboxPhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateSMSSandboxPhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptedOutException" : self = .optedOutException(try OptedOutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserErrorException" : self = .userErrorException(try UserErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSMSSandboxPhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case optedOutException(OptedOutException)
    case throttledException(ThrottledException)
    case userErrorException(UserErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSMSSandboxPhoneNumberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSMSSandboxPhoneNumberOutputResponse()"}
}

extension CreateSMSSandboxPhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateSMSSandboxPhoneNumberOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateSMSSandboxPhoneNumberOutputResponseBody: Swift.Equatable {
}

extension CreateSMSSandboxPhoneNumberOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateTopicInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTopicInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTopicInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTopicInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTopicOutputError>
}

extension CreateTopicInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTopicInput(attributes: \(Swift.String(describing: attributes)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateTopicInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let attributenameKey0 = element0.key
                let attributevalueValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(attributenameKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(attributevalueValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateTopic", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateTopicInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTopicInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTopicInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTopicInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTopicOutputError>
}

public struct CreateTopicInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTopicInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTopicInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTopicInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTopicOutputError>
}

/// <p>Input for CreateTopic action.</p>
public struct CreateTopicInput: Swift.Equatable {
    /// <p>A map of attributes with their corresponding values.</p>
    ///         <p>The following lists the names, descriptions, and values of the special request
    ///             parameters that the <code>CreateTopic</code> action uses:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>DeliveryPolicy</code> – The policy that defines how Amazon SNS retries
    ///                     failed deliveries to HTTP/S endpoints.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DisplayName</code> – The display name to use for a topic with SMS
    ///                     subscriptions.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FifoTopic</code> – Set to true to create a FIFO topic.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Policy</code> – The policy that defines who can access your
    ///                     topic. By default, only the topic owner can publish or subscribe to the
    ///                     topic.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>The following attribute applies only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html">server-side
    ///             encryption</a>:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>KmsMasterKeyId</code> – The ID of an AWS managed customer master
    ///                     key (CMK) for Amazon SNS or a custom CMK. For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms">Key
    ///                         Terms</a>. For more examples, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters">KeyId</a> in the <i>AWS Key Management Service API
    ///                         Reference</i>. </p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///         <p>The following attributes apply only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html">FIFO topics</a>:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>FifoTopic</code> – When this is set to <code>true</code>, a FIFO
    ///                 topic is created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                     <code>ContentBasedDeduplication</code> –  Enables content-based deduplication for
    ///                     FIFO topics.</p>
    ///
    ///                 <ul>
    ///                   <li>
    ///                         <p>By default, <code>ContentBasedDeduplication</code> is set to <code>false</code>.
    ///                             If you create a FIFO topic and this attribute is <code>false</code>, you must
    ///                             specify a value for the <code>MessageDeduplicationId</code> parameter for the
    ///                             <a href="https://docs.aws.amazon.com/sns/latest/api/API_Publish.html">Publish</a> action. </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>When you set <code>ContentBasedDeduplication</code> to <code>true</code>,
    ///                             Amazon SNS uses a SHA-256 hash to generate the <code>MessageDeduplicationId</code> using
    ///                             the body of the message (but not the attributes of the message).</p>
    ///                         <p>(Optional) To override the generated value, you can specify a value
    ///                             for the <code>MessageDeduplicationId</code> parameter for the <code>Publish</code>
    ///                             action.</p>
    ///                      </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let attributes: [Swift.String:Swift.String]?
    /// <p>The name of the topic you want to create.</p>
    ///         <p>Constraints: Topic names must be made up of only uppercase and lowercase ASCII
    ///             letters, numbers, underscores, and hyphens, and must be between 1 and 256 characters
    ///             long.</p>
    ///         <p>For a FIFO (first-in-first-out) topic, the name must end with the <code>.fifo</code>
    ///             suffix. </p>
    public let name: Swift.String?
    /// <p>The list of tags to add to a new topic.</p>
    ///         <note>
    ///             <p>To be able to tag a topic on creation, you must have the
    ///                     <code>sns:CreateTopic</code> and <code>sns:TagResource</code>
    ///                 permissions.</p>
    ///         </note>
    public let tags: [SnsClientTypes.Tag]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [SnsClientTypes.Tag]? = nil
    )
    {
        self.attributes = attributes
        self.name = name
        self.tags = tags
    }
}

extension CreateTopicOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateTopicOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccessException" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityException" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleTagException" : self = .staleTagException(try StaleTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededException" : self = .tagLimitExceededException(try TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TopicLimitExceededException" : self = .topicLimitExceededException(try TopicLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTopicOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case concurrentAccessException(ConcurrentAccessException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSecurityException(InvalidSecurityException)
    case staleTagException(StaleTagException)
    case tagLimitExceededException(TagLimitExceededException)
    case tagPolicyException(TagPolicyException)
    case topicLimitExceededException(TopicLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTopicOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTopicOutputResponse(topicArn: \(Swift.String(describing: topicArn)))"}
}

extension CreateTopicOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTopicOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.topicArn = output.topicArn
        } else {
            self.topicArn = nil
        }
    }
}

/// <p>Response from CreateTopic action.</p>
public struct CreateTopicOutputResponse: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) assigned to the created topic.</p>
    public let topicArn: Swift.String?

    public init (
        topicArn: Swift.String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

struct CreateTopicOutputResponseBody: Swift.Equatable {
    public let topicArn: Swift.String?
}

extension CreateTopicOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateTopicResult"))
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

public struct DeleteEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEndpointOutputError>
}

extension DeleteEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEndpointInput(endpointArn: \(Swift.String(describing: endpointArn)))"}
}

extension DeleteEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: ClientRuntime.Key("EndpointArn"))
        }
        try container.encode("DeleteEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEndpointOutputError>
}

public struct DeleteEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEndpointOutputError>
}

/// <p>Input for DeleteEndpoint action.</p>
public struct DeleteEndpointInput: Swift.Equatable {
    /// <p>EndpointArn of endpoint to delete.</p>
    public let endpointArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

extension DeleteEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEndpointOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEndpointOutputResponse()"}
}

extension DeleteEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEndpointOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteEndpointOutputResponseBody: Swift.Equatable {
}

extension DeleteEndpointOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeletePlatformApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlatformApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePlatformApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePlatformApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlatformApplicationOutputError>
}

extension DeletePlatformApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePlatformApplicationInput(platformApplicationArn: \(Swift.String(describing: platformApplicationArn)))"}
}

extension DeletePlatformApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
        try container.encode("DeletePlatformApplication", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeletePlatformApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlatformApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePlatformApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePlatformApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlatformApplicationOutputError>
}

public struct DeletePlatformApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlatformApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePlatformApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePlatformApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlatformApplicationOutputError>
}

/// <p>Input for DeletePlatformApplication action.</p>
public struct DeletePlatformApplicationInput: Swift.Equatable {
    /// <p>PlatformApplicationArn of platform application object to delete.</p>
    public let platformApplicationArn: Swift.String?

    public init (
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.platformApplicationArn = platformApplicationArn
    }
}

extension DeletePlatformApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePlatformApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePlatformApplicationOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePlatformApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePlatformApplicationOutputResponse()"}
}

extension DeletePlatformApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePlatformApplicationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePlatformApplicationOutputResponseBody: Swift.Equatable {
}

extension DeletePlatformApplicationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteSMSSandboxPhoneNumberInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSMSSandboxPhoneNumberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSMSSandboxPhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSMSSandboxPhoneNumberOutputError>
}

extension DeleteSMSSandboxPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSMSSandboxPhoneNumberInput(phoneNumber: \(Swift.String(describing: phoneNumber)))"}
}

extension DeleteSMSSandboxPhoneNumberInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        try container.encode("DeleteSMSSandboxPhoneNumber", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteSMSSandboxPhoneNumberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSMSSandboxPhoneNumberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSMSSandboxPhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSMSSandboxPhoneNumberOutputError>
}

public struct DeleteSMSSandboxPhoneNumberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSMSSandboxPhoneNumberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSMSSandboxPhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSMSSandboxPhoneNumberOutputError>
}

public struct DeleteSMSSandboxPhoneNumberInput: Swift.Equatable {
    /// <p>The destination phone number to delete.</p>
    public let phoneNumber: Swift.String?

    public init (
        phoneNumber: Swift.String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

extension DeleteSMSSandboxPhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSMSSandboxPhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserErrorException" : self = .userErrorException(try UserErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSMSSandboxPhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttledException(ThrottledException)
    case userErrorException(UserErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSMSSandboxPhoneNumberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSMSSandboxPhoneNumberOutputResponse()"}
}

extension DeleteSMSSandboxPhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSMSSandboxPhoneNumberOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteSMSSandboxPhoneNumberOutputResponseBody: Swift.Equatable {
}

extension DeleteSMSSandboxPhoneNumberOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteTopicInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTopicInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTopicInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTopicInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTopicOutputError>
}

extension DeleteTopicInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTopicInput(topicArn: \(Swift.String(describing: topicArn)))"}
}

extension DeleteTopicInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("DeleteTopic", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteTopicInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTopicInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTopicInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTopicInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTopicOutputError>
}

public struct DeleteTopicInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTopicInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTopicInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTopicInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTopicOutputError>
}

public struct DeleteTopicInput: Swift.Equatable {
    /// <p>The ARN of the topic you want to delete.</p>
    public let topicArn: Swift.String?

    public init (
        topicArn: Swift.String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

extension DeleteTopicOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteTopicOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccessException" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleTagException" : self = .staleTagException(try StaleTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTopicOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case concurrentAccessException(ConcurrentAccessException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case staleTagException(StaleTagException)
    case tagPolicyException(TagPolicyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTopicOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTopicOutputResponse()"}
}

extension DeleteTopicOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTopicOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteTopicOutputResponseBody: Swift.Equatable {
}

extension DeleteTopicOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SnsClientTypes.Endpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: ClientRuntime.Key("EndpointArn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension SnsClientTypes.Endpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Endpoint(attributes: \(Swift.String(describing: attributes)), endpointArn: \(Swift.String(describing: endpointArn)))"}
}

extension SnsClientTypes {
    /// <p>Endpoint for mobile app and device.</p>
    public struct Endpoint: Swift.Equatable {
        /// <p>Attributes for endpoint.</p>
        public let attributes: [Swift.String:Swift.String]?
        /// <p>EndpointArn for mobile app and device.</p>
        public let endpointArn: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            endpointArn: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.endpointArn = endpointArn
        }
    }

}

extension EndpointDisabledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointDisabledException(message: \(Swift.String(describing: message)))"}
}

extension EndpointDisabledException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<EndpointDisabledExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception error indicating endpoint disabled.</p>
public struct EndpointDisabledException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>Message for endpoint disabled.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointDisabledExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EndpointDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FilterPolicyLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FilterPolicyLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension FilterPolicyLimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<FilterPolicyLimitExceededExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the number of filter polices in your AWS account exceeds the limit. To
///             add more filter polices, submit an SNS Limit Increase case in the AWS Support
///             Center.</p>
public struct FilterPolicyLimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FilterPolicyLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FilterPolicyLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetEndpointAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEndpointAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEndpointAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEndpointAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEndpointAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEndpointAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEndpointAttributesOutputError>
}

extension GetEndpointAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEndpointAttributesInput(endpointArn: \(Swift.String(describing: endpointArn)))"}
}

extension GetEndpointAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: ClientRuntime.Key("EndpointArn"))
        }
        try container.encode("GetEndpointAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetEndpointAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEndpointAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEndpointAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEndpointAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEndpointAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEndpointAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEndpointAttributesOutputError>
}

public struct GetEndpointAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEndpointAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEndpointAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEndpointAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEndpointAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEndpointAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEndpointAttributesOutputError>
}

/// <p>Input for GetEndpointAttributes action.</p>
public struct GetEndpointAttributesInput: Swift.Equatable {
    /// <p>EndpointArn for GetEndpointAttributes input.</p>
    public let endpointArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

extension GetEndpointAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetEndpointAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEndpointAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEndpointAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEndpointAttributesOutputResponse(attributes: \(Swift.String(describing: attributes)))"}
}

extension GetEndpointAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEndpointAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

/// <p>Response from GetEndpointAttributes of the EndpointArn.</p>
public struct GetEndpointAttributesOutputResponse: Swift.Equatable {
    /// <p>Attributes include the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>CustomUserData</code> – arbitrary user data to associate with the
    ///                     endpoint. Amazon SNS does not use this data. The data must be in UTF-8 format and
    ///                     less than 2KB.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>Enabled</code> – flag that enables/disables delivery to the
    ///                     endpoint. Amazon SNS will set this to false when a notification service indicates to
    ///                     Amazon SNS that the endpoint is invalid. Users can set it back to true, typically
    ///                     after updating Token.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>Token</code> – device token, also referred to as a registration id,
    ///                     for an app and mobile device. This is returned from the notification service
    ///                     when an app and mobile device are registered with the notification
    ///                     service.</p>
    ///                 <note>
    ///                     <p>The device token for the iOS platform is returned in lowercase.</p>
    ///                 </note>
    ///             </li>
    ///          </ul>
    public let attributes: [Swift.String:Swift.String]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetEndpointAttributesOutputResponseBody: Swift.Equatable {
    public let attributes: [Swift.String:Swift.String]?
}

extension GetEndpointAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetEndpointAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

public struct GetPlatformApplicationAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPlatformApplicationAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPlatformApplicationAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPlatformApplicationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPlatformApplicationAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPlatformApplicationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPlatformApplicationAttributesOutputError>
}

extension GetPlatformApplicationAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPlatformApplicationAttributesInput(platformApplicationArn: \(Swift.String(describing: platformApplicationArn)))"}
}

extension GetPlatformApplicationAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
        try container.encode("GetPlatformApplicationAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetPlatformApplicationAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPlatformApplicationAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPlatformApplicationAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPlatformApplicationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPlatformApplicationAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPlatformApplicationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPlatformApplicationAttributesOutputError>
}

public struct GetPlatformApplicationAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPlatformApplicationAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPlatformApplicationAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPlatformApplicationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPlatformApplicationAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPlatformApplicationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPlatformApplicationAttributesOutputError>
}

/// <p>Input for GetPlatformApplicationAttributes action.</p>
public struct GetPlatformApplicationAttributesInput: Swift.Equatable {
    /// <p>PlatformApplicationArn for GetPlatformApplicationAttributesInput.</p>
    public let platformApplicationArn: Swift.String?

    public init (
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.platformApplicationArn = platformApplicationArn
    }
}

extension GetPlatformApplicationAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPlatformApplicationAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPlatformApplicationAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPlatformApplicationAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPlatformApplicationAttributesOutputResponse(attributes: \(Swift.String(describing: attributes)))"}
}

extension GetPlatformApplicationAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPlatformApplicationAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

/// <p>Response for GetPlatformApplicationAttributes action.</p>
public struct GetPlatformApplicationAttributesOutputResponse: Swift.Equatable {
    /// <p>Attributes include the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>EventEndpointCreated</code> – Topic ARN to which EndpointCreated
    ///                     event notifications should be sent.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EventEndpointDeleted</code> – Topic ARN to which EndpointDeleted
    ///                     event notifications should be sent.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EventEndpointUpdated</code> – Topic ARN to which EndpointUpdate
    ///                     event notifications should be sent.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EventDeliveryFailure</code> – Topic ARN to which DeliveryFailure
    ///                     event notifications should be sent upon Direct Publish delivery failure
    ///                     (permanent) to one of the application's endpoints.</p>
    ///             </li>
    ///          </ul>
    public let attributes: [Swift.String:Swift.String]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetPlatformApplicationAttributesOutputResponseBody: Swift.Equatable {
    public let attributes: [Swift.String:Swift.String]?
}

extension GetPlatformApplicationAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetPlatformApplicationAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

public struct GetSMSAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSMSAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSMSAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSMSAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSMSAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSMSAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSMSAttributesOutputError>
}

extension GetSMSAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSMSAttributesInput(attributes: \(Swift.String(describing: attributes)))"}
}

extension GetSMSAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("attributes"))
            for (index0, string0) in attributes.enumerated() {
                try attributesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("GetSMSAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetSMSAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSMSAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSMSAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSMSAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSMSAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSMSAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSMSAttributesOutputError>
}

public struct GetSMSAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSMSAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSMSAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSMSAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSMSAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSMSAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSMSAttributesOutputError>
}

/// <p>The input for the <code>GetSMSAttributes</code> request.</p>
public struct GetSMSAttributesInput: Swift.Equatable {
    /// <p>A list of the individual attribute names, such as <code>MonthlySpendLimit</code>, for
    ///             which you want values.</p>
    ///         <p>For all attribute names, see <a href="https://docs.aws.amazon.com/sns/latest/api/API_SetSMSAttributes.html">SetSMSAttributes</a>.</p>
    ///         <p>If you don't use this parameter, Amazon SNS returns all SMS attributes.</p>
    public let attributes: [Swift.String]?

    public init (
        attributes: [Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

extension GetSMSAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSMSAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSMSAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSMSAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSMSAttributesOutputResponse(attributes: \(Swift.String(describing: attributes)))"}
}

extension GetSMSAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSMSAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

/// <p>The response from the <code>GetSMSAttributes</code> request.</p>
public struct GetSMSAttributesOutputResponse: Swift.Equatable {
    /// <p>The SMS attribute names and their values.</p>
    public let attributes: [Swift.String:Swift.String]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetSMSAttributesOutputResponseBody: Swift.Equatable {
    public let attributes: [Swift.String:Swift.String]?
}

extension GetSMSAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetSMSAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

public struct GetSMSSandboxAccountStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSMSSandboxAccountStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSMSSandboxAccountStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSMSSandboxAccountStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSMSSandboxAccountStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSMSSandboxAccountStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSMSSandboxAccountStatusOutputError>
}

extension GetSMSSandboxAccountStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSMSSandboxAccountStatusInput()"}
}

extension GetSMSSandboxAccountStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GetSMSSandboxAccountStatus", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetSMSSandboxAccountStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSMSSandboxAccountStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSMSSandboxAccountStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSMSSandboxAccountStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSMSSandboxAccountStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSMSSandboxAccountStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSMSSandboxAccountStatusOutputError>
}

public struct GetSMSSandboxAccountStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSMSSandboxAccountStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSMSSandboxAccountStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSMSSandboxAccountStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSMSSandboxAccountStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSMSSandboxAccountStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSMSSandboxAccountStatusOutputError>
}

public struct GetSMSSandboxAccountStatusInput: Swift.Equatable {

    public init() {}
}

extension GetSMSSandboxAccountStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSMSSandboxAccountStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSMSSandboxAccountStatusOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSMSSandboxAccountStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSMSSandboxAccountStatusOutputResponse(isInSandbox: \(Swift.String(describing: isInSandbox)))"}
}

extension GetSMSSandboxAccountStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSMSSandboxAccountStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isInSandbox = output.isInSandbox
        } else {
            self.isInSandbox = false
        }
    }
}

public struct GetSMSSandboxAccountStatusOutputResponse: Swift.Equatable {
    /// <p>Indicates whether the calling account is in the SMS sandbox.</p>
    public let isInSandbox: Swift.Bool

    public init (
        isInSandbox: Swift.Bool = false
    )
    {
        self.isInSandbox = isInSandbox
    }
}

struct GetSMSSandboxAccountStatusOutputResponseBody: Swift.Equatable {
    public let isInSandbox: Swift.Bool
}

extension GetSMSSandboxAccountStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isInSandbox = "IsInSandbox"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetSMSSandboxAccountStatusResult"))
        let isInSandboxDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isInSandbox)
        isInSandbox = isInSandboxDecoded
    }
}

public struct GetSubscriptionAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSubscriptionAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSubscriptionAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSubscriptionAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSubscriptionAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSubscriptionAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSubscriptionAttributesOutputError>
}

extension GetSubscriptionAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSubscriptionAttributesInput(subscriptionArn: \(Swift.String(describing: subscriptionArn)))"}
}

extension GetSubscriptionAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: ClientRuntime.Key("SubscriptionArn"))
        }
        try container.encode("GetSubscriptionAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetSubscriptionAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSubscriptionAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSubscriptionAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSubscriptionAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSubscriptionAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSubscriptionAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSubscriptionAttributesOutputError>
}

public struct GetSubscriptionAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSubscriptionAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSubscriptionAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSubscriptionAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSubscriptionAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSubscriptionAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSubscriptionAttributesOutputError>
}

/// <p>Input for GetSubscriptionAttributes.</p>
public struct GetSubscriptionAttributesInput: Swift.Equatable {
    /// <p>The ARN of the subscription whose properties you want to get.</p>
    public let subscriptionArn: Swift.String?

    public init (
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

extension GetSubscriptionAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSubscriptionAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSubscriptionAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSubscriptionAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSubscriptionAttributesOutputResponse(attributes: \(Swift.String(describing: attributes)))"}
}

extension GetSubscriptionAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSubscriptionAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

/// <p>Response for GetSubscriptionAttributes action.</p>
public struct GetSubscriptionAttributesOutputResponse: Swift.Equatable {
    /// <p>A map of the subscription's attributes. Attributes in this map include the
    ///             following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>ConfirmationWasAuthenticated</code> – <code>true</code> if the
    ///                     subscription confirmation request was authenticated.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>DeliveryPolicy</code> – The JSON serialization of the
    ///                     subscription's delivery policy.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EffectiveDeliveryPolicy</code> – The JSON serialization of the
    ///                     effective delivery policy that takes into account the topic delivery policy and
    ///                     account system defaults.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>FilterPolicy</code> – The filter policy JSON that is assigned to
    ///                     the subscription. For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-message-filtering.html">Amazon SNS Message
    ///                         Filtering</a> in the <i>Amazon SNS Developer Guide</i>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>Owner</code> – The AWS account ID of the subscription's
    ///                     owner.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>PendingConfirmation</code> – <code>true</code> if the subscription
    ///                     hasn't been confirmed. To confirm a pending subscription, call the
    ///                         <code>ConfirmSubscription</code> action with a confirmation token.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>RawMessageDelivery</code> – <code>true</code> if raw message
    ///                     delivery is enabled for the subscription. Raw messages are free of JSON
    ///                     formatting and can be sent to HTTP/S and Amazon SQS endpoints.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>RedrivePolicy</code> – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue.
    ///     Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable)
    ///     or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held
    ///     in the dead-letter queue for further analysis or reprocessing.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>SubscriptionArn</code> – The subscription's ARN.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>TopicArn</code> – The topic ARN that the subscription is associated
    ///                     with.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>The following attribute applies only to Amazon Kinesis Data Firehose delivery stream subscriptions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SubscriptionRoleArn</code> – The ARN of the IAM role that has the following:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>Permission to write to the Kinesis Data Firehose delivery stream</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>Amazon SNS listed as a trusted entity</p>
    ///                     </li>
    ///                </ul>
    ///                 <p>Specifying a valid ARN for this attribute is required for Kinesis Data Firehose delivery stream subscriptions.
    ///                 For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html">Fanout
    ///                     to Kinesis Data Firehose delivery streams</a> in the <i>Amazon SNS Developer Guide</i>.</p>
    ///                     </li>
    ///          </ul>
    public let attributes: [Swift.String:Swift.String]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetSubscriptionAttributesOutputResponseBody: Swift.Equatable {
    public let attributes: [Swift.String:Swift.String]?
}

extension GetSubscriptionAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetSubscriptionAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

public struct GetTopicAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTopicAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTopicAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTopicAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTopicAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTopicAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTopicAttributesOutputError>
}

extension GetTopicAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTopicAttributesInput(topicArn: \(Swift.String(describing: topicArn)))"}
}

extension GetTopicAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("GetTopicAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetTopicAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTopicAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTopicAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTopicAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTopicAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTopicAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTopicAttributesOutputError>
}

public struct GetTopicAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTopicAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTopicAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTopicAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTopicAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTopicAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTopicAttributesOutputError>
}

/// <p>Input for GetTopicAttributes action.</p>
public struct GetTopicAttributesInput: Swift.Equatable {
    /// <p>The ARN of the topic whose properties you want to get.</p>
    public let topicArn: Swift.String?

    public init (
        topicArn: Swift.String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

extension GetTopicAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetTopicAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityException" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTopicAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSecurityException(InvalidSecurityException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTopicAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTopicAttributesOutputResponse(attributes: \(Swift.String(describing: attributes)))"}
}

extension GetTopicAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTopicAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

/// <p>Response for GetTopicAttributes action.</p>
public struct GetTopicAttributesOutputResponse: Swift.Equatable {
    /// <p>A map of the topic's attributes. Attributes in this map include the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>DeliveryPolicy</code> – The JSON serialization of the topic's
    ///                     delivery policy.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DisplayName</code> – The human-readable name used in the
    ///                         <code>From</code> field for notifications to <code>email</code> and
    ///                         <code>email-json</code> endpoints.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Owner</code> – The AWS account ID of the topic's owner.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Policy</code> – The JSON serialization of the topic's access
    ///                     control policy.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SubscriptionsConfirmed</code> – The number of confirmed
    ///                     subscriptions for the topic.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SubscriptionsDeleted</code> – The number of deleted subscriptions
    ///                     for the topic.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SubscriptionsPending</code> – The number of subscriptions pending
    ///                     confirmation for the topic.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>TopicArn</code> – The topic's ARN.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>EffectiveDeliveryPolicy</code> – The JSON serialization of the
    ///                     effective delivery policy, taking system defaults into account.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>The following attribute applies only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html">server-side-encryption</a>:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>KmsMasterKeyId</code> - The ID of an AWS-managed customer master key
    ///                     (CMK) for Amazon SNS or a custom CMK. For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms">Key
    ///                         Terms</a>. For more examples, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters">KeyId</a> in the <i>AWS Key Management Service API
    ///                         Reference</i>.</p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///         <p>The following attributes apply only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html">FIFO topics</a>:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>FifoTopic</code> – When this is set to <code>true</code>, a FIFO
    ///                 topic is created.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                     <code>ContentBasedDeduplication</code> –  Enables content-based deduplication for
    ///                     FIFO topics.</p>
    ///
    ///                 <ul>
    ///                   <li>
    ///                         <p>By default, <code>ContentBasedDeduplication</code> is set to <code>false</code>.
    ///                             If you create a FIFO topic and this attribute is <code>false</code>, you must
    ///                             specify a value for the <code>MessageDeduplicationId</code> parameter for the
    ///                             <a href="https://docs.aws.amazon.com/sns/latest/api/API_Publish.html">Publish</a> action. </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>When you set <code>ContentBasedDeduplication</code> to <code>true</code>,
    ///                             Amazon SNS uses a SHA-256 hash to generate the <code>MessageDeduplicationId</code> using
    ///                             the body of the message (but not the attributes of the message).</p>
    ///                         <p>(Optional) To override the generated value, you can specify a value
    ///                             for the <code>MessageDeduplicationId</code> parameter for the <code>Publish</code>
    ///                             action.</p>
    ///                      </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let attributes: [Swift.String:Swift.String]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetTopicAttributesOutputResponseBody: Swift.Equatable {
    public let attributes: [Swift.String:Swift.String]?
}

extension GetTopicAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetTopicAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension InternalErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalErrorException(message: \(Swift.String(describing: message)))"}
}

extension InternalErrorException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InternalErrorExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates an internal service error.</p>
public struct InternalErrorException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidParameterExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a request parameter does not comply with the associated
///             constraints.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterValueException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidParameterValueExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a request parameter does not comply with the associated
///             constraints.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The parameter value is invalid.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSecurityException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSecurityException(message: \(Swift.String(describing: message)))"}
}

extension InvalidSecurityException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidSecurityExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The credential signature isn't valid. You must use an HTTPS endpoint and sign your
///             request using Signature Version 4.</p>
public struct InvalidSecurityException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSecurityExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidSecurityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSAccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSAccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension KMSAccessDeniedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<KMSAccessDeniedExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The ciphertext references a key that doesn't exist or that you don't have access
///             to.</p>
public struct KMSAccessDeniedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSAccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSAccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSDisabledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSDisabledException(message: \(Swift.String(describing: message)))"}
}

extension KMSDisabledException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<KMSDisabledExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified customer master key (CMK) isn't
///             enabled.</p>
public struct KMSDisabledException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSDisabledExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSInvalidStateException(message: \(Swift.String(describing: message)))"}
}

extension KMSInvalidStateException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<KMSInvalidStateExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the state of the specified resource isn't valid for
///             this request. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
///                 Customer Master Key</a> in the <i>AWS Key Management Service Developer
///                 Guide</i>.</p>
public struct KMSInvalidStateException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSInvalidStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSInvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension KMSNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<KMSNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the specified entity or resource can't be
///             found.</p>
public struct KMSNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSOptInRequired: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSOptInRequired(message: \(Swift.String(describing: message)))"}
}

extension KMSOptInRequired: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<KMSOptInRequiredBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS access key ID needs a subscription for the service.</p>
public struct KMSOptInRequired: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSOptInRequiredBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSOptInRequiredBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension KMSThrottlingException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<KMSThrottlingExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling. For more information about
///             throttling, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html#requests-per-second">Limits</a> in
///             the <i>AWS Key Management Service Developer Guide.</i>
///          </p>
public struct KMSThrottlingException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsClientTypes {
    /// Supported language code for sending OTP message
    public enum LanguageCodeString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deDe
        case enGb
        case enUs
        case es419
        case esEs
        case frCa
        case frFr
        case itIt
        case jpJp
        case krKr
        case ptBr
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCodeString] {
            return [
                .deDe,
                .enGb,
                .enUs,
                .es419,
                .esEs,
                .frCa,
                .frFr,
                .itIt,
                .jpJp,
                .krKr,
                .ptBr,
                .zhCn,
                .zhTw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .es419: return "es-419"
            case .esEs: return "es-ES"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .itIt: return "it-IT"
            case .jpJp: return "ja-JP"
            case .krKr: return "kr-KR"
            case .ptBr: return "pt-BR"
            case .zhCn: return "zh-CN"
            case .zhTw: return "zh-TW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LanguageCodeString(rawValue: rawValue) ?? LanguageCodeString.sdkUnknown(rawValue)
        }
    }
}

public struct ListEndpointsByPlatformApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEndpointsByPlatformApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEndpointsByPlatformApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEndpointsByPlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEndpointsByPlatformApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEndpointsByPlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEndpointsByPlatformApplicationOutputError>
}

extension ListEndpointsByPlatformApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEndpointsByPlatformApplicationInput(nextToken: \(Swift.String(describing: nextToken)), platformApplicationArn: \(Swift.String(describing: platformApplicationArn)))"}
}

extension ListEndpointsByPlatformApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
        try container.encode("ListEndpointsByPlatformApplication", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ListEndpointsByPlatformApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEndpointsByPlatformApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEndpointsByPlatformApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEndpointsByPlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEndpointsByPlatformApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEndpointsByPlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEndpointsByPlatformApplicationOutputError>
}

public struct ListEndpointsByPlatformApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEndpointsByPlatformApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEndpointsByPlatformApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEndpointsByPlatformApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEndpointsByPlatformApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEndpointsByPlatformApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEndpointsByPlatformApplicationOutputError>
}

/// <p>Input for ListEndpointsByPlatformApplication action.</p>
public struct ListEndpointsByPlatformApplicationInput: Swift.Equatable {
    /// <p>NextToken string is used when calling ListEndpointsByPlatformApplication action to
    ///             retrieve additional records that are available after the first page results.</p>
    public let nextToken: Swift.String?
    /// <p>PlatformApplicationArn for ListEndpointsByPlatformApplicationInput action.</p>
    public let platformApplicationArn: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.platformApplicationArn = platformApplicationArn
    }
}

extension ListEndpointsByPlatformApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListEndpointsByPlatformApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEndpointsByPlatformApplicationOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEndpointsByPlatformApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEndpointsByPlatformApplicationOutputResponse(endpoints: \(Swift.String(describing: endpoints)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEndpointsByPlatformApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEndpointsByPlatformApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
            self.nextToken = output.nextToken
        } else {
            self.endpoints = nil
            self.nextToken = nil
        }
    }
}

/// <p>Response for ListEndpointsByPlatformApplication action.</p>
public struct ListEndpointsByPlatformApplicationOutputResponse: Swift.Equatable {
    /// <p>Endpoints returned for ListEndpointsByPlatformApplication action.</p>
    public let endpoints: [SnsClientTypes.Endpoint]?
    /// <p>NextToken string is returned when calling ListEndpointsByPlatformApplication action if
    ///             additional records are available after the first page results.</p>
    public let nextToken: Swift.String?

    public init (
        endpoints: [SnsClientTypes.Endpoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

struct ListEndpointsByPlatformApplicationOutputResponseBody: Swift.Equatable {
    public let endpoints: [SnsClientTypes.Endpoint]?
    public let nextToken: Swift.String?
}

extension ListEndpointsByPlatformApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListEndpointsByPlatformApplicationResult"))
        if containerValues.contains(.endpoints) {
            struct KeyVal0{struct member{}}
            let endpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endpoints)
            if let endpointsWrappedContainer = endpointsWrappedContainer {
                let endpointsContainer = try endpointsWrappedContainer.decodeIfPresent([SnsClientTypes.Endpoint].self, forKey: .member)
                var endpointsBuffer:[SnsClientTypes.Endpoint]? = nil
                if let endpointsContainer = endpointsContainer {
                    endpointsBuffer = [SnsClientTypes.Endpoint]()
                    for structureContainer0 in endpointsContainer {
                        endpointsBuffer?.append(structureContainer0)
                    }
                }
                endpoints = endpointsBuffer
            } else {
                endpoints = []
            }
        } else {
            endpoints = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOriginationNumbersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOriginationNumbersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOriginationNumbersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOriginationNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOriginationNumbersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOriginationNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOriginationNumbersOutputError>
}

extension ListOriginationNumbersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOriginationNumbersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListOriginationNumbersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: ClientRuntime.Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        try container.encode("ListOriginationNumbers", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ListOriginationNumbersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOriginationNumbersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOriginationNumbersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOriginationNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOriginationNumbersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOriginationNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOriginationNumbersOutputError>
}

public struct ListOriginationNumbersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOriginationNumbersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOriginationNumbersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOriginationNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOriginationNumbersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOriginationNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOriginationNumbersOutputError>
}

public struct ListOriginationNumbersInput: Swift.Equatable {
    /// <p>The maximum number of origination numbers to return.</p>
    public let maxResults: Swift.Int?
    /// <p>Token that the previous <code>ListOriginationNumbers</code> request returns.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListOriginationNumbersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListOriginationNumbersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOriginationNumbersOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOriginationNumbersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOriginationNumbersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), phoneNumbers: \(Swift.String(describing: phoneNumbers)))"}
}

extension ListOriginationNumbersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOriginationNumbersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

public struct ListOriginationNumbersOutputResponse: Swift.Equatable {
    /// <p>A <code>NextToken</code> string is returned when you call the
    ///                 <code>ListOriginationNumbers</code> operation if additional pages of records are
    ///             available.</p>
    public let nextToken: Swift.String?
    /// <p>A list of the calling account's verified and pending origination numbers.</p>
    public let phoneNumbers: [SnsClientTypes.PhoneNumberInformation]?

    public init (
        nextToken: Swift.String? = nil,
        phoneNumbers: [SnsClientTypes.PhoneNumberInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct ListOriginationNumbersOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let phoneNumbers: [SnsClientTypes.PhoneNumberInformation]?
}

extension ListOriginationNumbersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumbers = "PhoneNumbers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListOriginationNumbersResult"))
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        if containerValues.contains(.phoneNumbers) {
            struct KeyVal0{struct member{}}
            let phoneNumbersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .phoneNumbers)
            if let phoneNumbersWrappedContainer = phoneNumbersWrappedContainer {
                let phoneNumbersContainer = try phoneNumbersWrappedContainer.decodeIfPresent([SnsClientTypes.PhoneNumberInformation].self, forKey: .member)
                var phoneNumbersBuffer:[SnsClientTypes.PhoneNumberInformation]? = nil
                if let phoneNumbersContainer = phoneNumbersContainer {
                    phoneNumbersBuffer = [SnsClientTypes.PhoneNumberInformation]()
                    for structureContainer0 in phoneNumbersContainer {
                        phoneNumbersBuffer?.append(structureContainer0)
                    }
                }
                phoneNumbers = phoneNumbersBuffer
            } else {
                phoneNumbers = []
            }
        } else {
            phoneNumbers = nil
        }
    }
}

public struct ListPhoneNumbersOptedOutInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPhoneNumbersOptedOutInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPhoneNumbersOptedOutInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPhoneNumbersOptedOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPhoneNumbersOptedOutInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPhoneNumbersOptedOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPhoneNumbersOptedOutOutputError>
}

extension ListPhoneNumbersOptedOutInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPhoneNumbersOptedOutInput(nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPhoneNumbersOptedOutInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("nextToken"))
        }
        try container.encode("ListPhoneNumbersOptedOut", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ListPhoneNumbersOptedOutInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPhoneNumbersOptedOutInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPhoneNumbersOptedOutInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPhoneNumbersOptedOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPhoneNumbersOptedOutInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPhoneNumbersOptedOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPhoneNumbersOptedOutOutputError>
}

public struct ListPhoneNumbersOptedOutInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPhoneNumbersOptedOutInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPhoneNumbersOptedOutInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPhoneNumbersOptedOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPhoneNumbersOptedOutInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPhoneNumbersOptedOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPhoneNumbersOptedOutOutputError>
}

/// <p>The input for the <code>ListPhoneNumbersOptedOut</code> action.</p>
public struct ListPhoneNumbersOptedOutInput: Swift.Equatable {
    /// <p>A <code>NextToken</code> string is used when you call the
    ///                 <code>ListPhoneNumbersOptedOut</code> action to retrieve additional records that are
    ///             available after the first page of results.</p>
    public let nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListPhoneNumbersOptedOutOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPhoneNumbersOptedOutOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPhoneNumbersOptedOutOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPhoneNumbersOptedOutOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPhoneNumbersOptedOutOutputResponse(nextToken: \(Swift.String(describing: nextToken)), phoneNumbers: \(Swift.String(describing: phoneNumbers)))"}
}

extension ListPhoneNumbersOptedOutOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPhoneNumbersOptedOutOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

/// <p>The response from the <code>ListPhoneNumbersOptedOut</code> action.</p>
public struct ListPhoneNumbersOptedOutOutputResponse: Swift.Equatable {
    /// <p>A <code>NextToken</code> string is returned when you call the
    ///                 <code>ListPhoneNumbersOptedOut</code> action if additional records are available
    ///             after the first page of results.</p>
    public let nextToken: Swift.String?
    /// <p>A list of phone numbers that are opted out of receiving SMS messages. The list is
    ///             paginated, and each page can contain up to 100 phone numbers.</p>
    public let phoneNumbers: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        phoneNumbers: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct ListPhoneNumbersOptedOutOutputResponseBody: Swift.Equatable {
    public let phoneNumbers: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListPhoneNumbersOptedOutOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case phoneNumbers
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListPhoneNumbersOptedOutResult"))
        if containerValues.contains(.phoneNumbers) {
            struct KeyVal0{struct member{}}
            let phoneNumbersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .phoneNumbers)
            if let phoneNumbersWrappedContainer = phoneNumbersWrappedContainer {
                let phoneNumbersContainer = try phoneNumbersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var phoneNumbersBuffer:[Swift.String]? = nil
                if let phoneNumbersContainer = phoneNumbersContainer {
                    phoneNumbersBuffer = [Swift.String]()
                    for stringContainer0 in phoneNumbersContainer {
                        phoneNumbersBuffer?.append(stringContainer0)
                    }
                }
                phoneNumbers = phoneNumbersBuffer
            } else {
                phoneNumbers = []
            }
        } else {
            phoneNumbers = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPlatformApplicationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlatformApplicationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPlatformApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlatformApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPlatformApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlatformApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlatformApplicationsOutputError>
}

extension ListPlatformApplicationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPlatformApplicationsInput(nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPlatformApplicationsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        try container.encode("ListPlatformApplications", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ListPlatformApplicationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlatformApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPlatformApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlatformApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPlatformApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlatformApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlatformApplicationsOutputError>
}

public struct ListPlatformApplicationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlatformApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPlatformApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlatformApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPlatformApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlatformApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlatformApplicationsOutputError>
}

/// <p>Input for ListPlatformApplications action.</p>
public struct ListPlatformApplicationsInput: Swift.Equatable {
    /// <p>NextToken string is used when calling ListPlatformApplications action to retrieve
    ///             additional records that are available after the first page results.</p>
    public let nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListPlatformApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPlatformApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPlatformApplicationsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPlatformApplicationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPlatformApplicationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), platformApplications: \(Swift.String(describing: platformApplications)))"}
}

extension ListPlatformApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPlatformApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.platformApplications = output.platformApplications
        } else {
            self.nextToken = nil
            self.platformApplications = nil
        }
    }
}

/// <p>Response for ListPlatformApplications action.</p>
public struct ListPlatformApplicationsOutputResponse: Swift.Equatable {
    /// <p>NextToken string is returned when calling ListPlatformApplications action if
    ///             additional records are available after the first page results.</p>
    public let nextToken: Swift.String?
    /// <p>Platform applications returned when calling ListPlatformApplications action.</p>
    public let platformApplications: [SnsClientTypes.PlatformApplication]?

    public init (
        nextToken: Swift.String? = nil,
        platformApplications: [SnsClientTypes.PlatformApplication]? = nil
    )
    {
        self.nextToken = nextToken
        self.platformApplications = platformApplications
    }
}

struct ListPlatformApplicationsOutputResponseBody: Swift.Equatable {
    public let platformApplications: [SnsClientTypes.PlatformApplication]?
    public let nextToken: Swift.String?
}

extension ListPlatformApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case platformApplications = "PlatformApplications"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListPlatformApplicationsResult"))
        if containerValues.contains(.platformApplications) {
            struct KeyVal0{struct member{}}
            let platformApplicationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .platformApplications)
            if let platformApplicationsWrappedContainer = platformApplicationsWrappedContainer {
                let platformApplicationsContainer = try platformApplicationsWrappedContainer.decodeIfPresent([SnsClientTypes.PlatformApplication].self, forKey: .member)
                var platformApplicationsBuffer:[SnsClientTypes.PlatformApplication]? = nil
                if let platformApplicationsContainer = platformApplicationsContainer {
                    platformApplicationsBuffer = [SnsClientTypes.PlatformApplication]()
                    for structureContainer0 in platformApplicationsContainer {
                        platformApplicationsBuffer?.append(structureContainer0)
                    }
                }
                platformApplications = platformApplicationsBuffer
            } else {
                platformApplications = []
            }
        } else {
            platformApplications = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSMSSandboxPhoneNumbersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSMSSandboxPhoneNumbersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSMSSandboxPhoneNumbersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSMSSandboxPhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSMSSandboxPhoneNumbersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSMSSandboxPhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSMSSandboxPhoneNumbersOutputError>
}

extension ListSMSSandboxPhoneNumbersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSMSSandboxPhoneNumbersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSMSSandboxPhoneNumbersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: ClientRuntime.Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        try container.encode("ListSMSSandboxPhoneNumbers", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ListSMSSandboxPhoneNumbersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSMSSandboxPhoneNumbersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSMSSandboxPhoneNumbersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSMSSandboxPhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSMSSandboxPhoneNumbersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSMSSandboxPhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSMSSandboxPhoneNumbersOutputError>
}

public struct ListSMSSandboxPhoneNumbersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSMSSandboxPhoneNumbersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSMSSandboxPhoneNumbersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSMSSandboxPhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSMSSandboxPhoneNumbersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSMSSandboxPhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSMSSandboxPhoneNumbersOutputError>
}

public struct ListSMSSandboxPhoneNumbersInput: Swift.Equatable {
    /// <p>The maximum number of phone numbers to return.</p>
    public let maxResults: Swift.Int?
    /// <p>Token that the previous <code>ListSMSSandboxPhoneNumbersInput</code> request
    ///             returns.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListSMSSandboxPhoneNumbersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSMSSandboxPhoneNumbersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSMSSandboxPhoneNumbersOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSMSSandboxPhoneNumbersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSMSSandboxPhoneNumbersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), phoneNumbers: \(Swift.String(describing: phoneNumbers)))"}
}

extension ListSMSSandboxPhoneNumbersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSMSSandboxPhoneNumbersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

public struct ListSMSSandboxPhoneNumbersOutputResponse: Swift.Equatable {
    /// <p>A <code>NextToken</code> string is returned when you call the
    ///             <code>ListSMSSandboxPhoneNumbersInput</code> operation if additional pages of
    ///             records are available.</p>
    public let nextToken: Swift.String?
    /// <p>A list of the calling account's pending and verified phone numbers.</p>
    public let phoneNumbers: [SnsClientTypes.SMSSandboxPhoneNumber]?

    public init (
        nextToken: Swift.String? = nil,
        phoneNumbers: [SnsClientTypes.SMSSandboxPhoneNumber]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct ListSMSSandboxPhoneNumbersOutputResponseBody: Swift.Equatable {
    public let phoneNumbers: [SnsClientTypes.SMSSandboxPhoneNumber]?
    public let nextToken: Swift.String?
}

extension ListSMSSandboxPhoneNumbersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumbers = "PhoneNumbers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListSMSSandboxPhoneNumbersResult"))
        if containerValues.contains(.phoneNumbers) {
            struct KeyVal0{struct member{}}
            let phoneNumbersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .phoneNumbers)
            if let phoneNumbersWrappedContainer = phoneNumbersWrappedContainer {
                let phoneNumbersContainer = try phoneNumbersWrappedContainer.decodeIfPresent([SnsClientTypes.SMSSandboxPhoneNumber].self, forKey: .member)
                var phoneNumbersBuffer:[SnsClientTypes.SMSSandboxPhoneNumber]? = nil
                if let phoneNumbersContainer = phoneNumbersContainer {
                    phoneNumbersBuffer = [SnsClientTypes.SMSSandboxPhoneNumber]()
                    for structureContainer0 in phoneNumbersContainer {
                        phoneNumbersBuffer?.append(structureContainer0)
                    }
                }
                phoneNumbers = phoneNumbersBuffer
            } else {
                phoneNumbers = []
            }
        } else {
            phoneNumbers = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSubscriptionsByTopicInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSubscriptionsByTopicInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSubscriptionsByTopicInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSubscriptionsByTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSubscriptionsByTopicInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSubscriptionsByTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSubscriptionsByTopicOutputError>
}

extension ListSubscriptionsByTopicInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSubscriptionsByTopicInput(nextToken: \(Swift.String(describing: nextToken)), topicArn: \(Swift.String(describing: topicArn)))"}
}

extension ListSubscriptionsByTopicInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("ListSubscriptionsByTopic", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ListSubscriptionsByTopicInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSubscriptionsByTopicInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSubscriptionsByTopicInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSubscriptionsByTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSubscriptionsByTopicInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSubscriptionsByTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSubscriptionsByTopicOutputError>
}

public struct ListSubscriptionsByTopicInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSubscriptionsByTopicInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSubscriptionsByTopicInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSubscriptionsByTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSubscriptionsByTopicInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSubscriptionsByTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSubscriptionsByTopicOutputError>
}

/// <p>Input for ListSubscriptionsByTopic action.</p>
public struct ListSubscriptionsByTopicInput: Swift.Equatable {
    /// <p>Token returned by the previous <code>ListSubscriptionsByTopic</code> request.</p>
    public let nextToken: Swift.String?
    /// <p>The ARN of the topic for which you wish to find subscriptions.</p>
    public let topicArn: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.topicArn = topicArn
    }
}

extension ListSubscriptionsByTopicOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSubscriptionsByTopicOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSubscriptionsByTopicOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSubscriptionsByTopicOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSubscriptionsByTopicOutputResponse(nextToken: \(Swift.String(describing: nextToken)), subscriptions: \(Swift.String(describing: subscriptions)))"}
}

extension ListSubscriptionsByTopicOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSubscriptionsByTopicOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subscriptions = output.subscriptions
        } else {
            self.nextToken = nil
            self.subscriptions = nil
        }
    }
}

/// <p>Response for ListSubscriptionsByTopic action.</p>
public struct ListSubscriptionsByTopicOutputResponse: Swift.Equatable {
    /// <p>Token to pass along to the next <code>ListSubscriptionsByTopic</code> request. This
    ///             element is returned if there are more subscriptions to retrieve.</p>
    public let nextToken: Swift.String?
    /// <p>A list of subscriptions.</p>
    public let subscriptions: [SnsClientTypes.Subscription]?

    public init (
        nextToken: Swift.String? = nil,
        subscriptions: [SnsClientTypes.Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

struct ListSubscriptionsByTopicOutputResponseBody: Swift.Equatable {
    public let subscriptions: [SnsClientTypes.Subscription]?
    public let nextToken: Swift.String?
}

extension ListSubscriptionsByTopicOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case subscriptions = "Subscriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListSubscriptionsByTopicResult"))
        if containerValues.contains(.subscriptions) {
            struct KeyVal0{struct member{}}
            let subscriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subscriptions)
            if let subscriptionsWrappedContainer = subscriptionsWrappedContainer {
                let subscriptionsContainer = try subscriptionsWrappedContainer.decodeIfPresent([SnsClientTypes.Subscription].self, forKey: .member)
                var subscriptionsBuffer:[SnsClientTypes.Subscription]? = nil
                if let subscriptionsContainer = subscriptionsContainer {
                    subscriptionsBuffer = [SnsClientTypes.Subscription]()
                    for structureContainer0 in subscriptionsContainer {
                        subscriptionsBuffer?.append(structureContainer0)
                    }
                }
                subscriptions = subscriptionsBuffer
            } else {
                subscriptions = []
            }
        } else {
            subscriptions = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSubscriptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSubscriptionsOutputError>
}

extension ListSubscriptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSubscriptionsInput(nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSubscriptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        try container.encode("ListSubscriptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ListSubscriptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSubscriptionsOutputError>
}

public struct ListSubscriptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSubscriptionsOutputError>
}

/// <p>Input for ListSubscriptions action.</p>
public struct ListSubscriptionsInput: Swift.Equatable {
    /// <p>Token returned by the previous <code>ListSubscriptions</code> request.</p>
    public let nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListSubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListSubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSubscriptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSubscriptionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), subscriptions: \(Swift.String(describing: subscriptions)))"}
}

extension ListSubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subscriptions = output.subscriptions
        } else {
            self.nextToken = nil
            self.subscriptions = nil
        }
    }
}

/// <p>Response for ListSubscriptions action</p>
public struct ListSubscriptionsOutputResponse: Swift.Equatable {
    /// <p>Token to pass along to the next <code>ListSubscriptions</code> request. This element
    ///             is returned if there are more subscriptions to retrieve.</p>
    public let nextToken: Swift.String?
    /// <p>A list of subscriptions.</p>
    public let subscriptions: [SnsClientTypes.Subscription]?

    public init (
        nextToken: Swift.String? = nil,
        subscriptions: [SnsClientTypes.Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

struct ListSubscriptionsOutputResponseBody: Swift.Equatable {
    public let subscriptions: [SnsClientTypes.Subscription]?
    public let nextToken: Swift.String?
}

extension ListSubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case subscriptions = "Subscriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListSubscriptionsResult"))
        if containerValues.contains(.subscriptions) {
            struct KeyVal0{struct member{}}
            let subscriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subscriptions)
            if let subscriptionsWrappedContainer = subscriptionsWrappedContainer {
                let subscriptionsContainer = try subscriptionsWrappedContainer.decodeIfPresent([SnsClientTypes.Subscription].self, forKey: .member)
                var subscriptionsBuffer:[SnsClientTypes.Subscription]? = nil
                if let subscriptionsContainer = subscriptionsContainer {
                    subscriptionsBuffer = [SnsClientTypes.Subscription]()
                    for structureContainer0 in subscriptionsContainer {
                        subscriptionsBuffer?.append(structureContainer0)
                    }
                }
                subscriptions = subscriptionsBuffer
            } else {
                subscriptions = []
            }
        } else {
            subscriptions = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        try container.encode("ListTagsForResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>The ARN of the topic for which to list tags.</p>
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccessException" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case concurrentAccessException(ConcurrentAccessException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagPolicyException(TagPolicyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>The tags associated with the specified topic.</p>
    public let tags: [SnsClientTypes.Tag]?

    public init (
        tags: [SnsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [SnsClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListTagsForResourceResult"))
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([SnsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[SnsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [SnsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

public struct ListTopicsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTopicsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTopicsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTopicsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTopicsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTopicsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTopicsOutputError>
}

extension ListTopicsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTopicsInput(nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTopicsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        try container.encode("ListTopics", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ListTopicsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTopicsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTopicsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTopicsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTopicsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTopicsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTopicsOutputError>
}

public struct ListTopicsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTopicsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTopicsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTopicsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTopicsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTopicsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTopicsOutputError>
}

public struct ListTopicsInput: Swift.Equatable {
    /// <p>Token returned by the previous <code>ListTopics</code> request.</p>
    public let nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListTopicsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTopicsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTopicsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTopicsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTopicsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), topics: \(Swift.String(describing: topics)))"}
}

extension ListTopicsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTopicsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.topics = output.topics
        } else {
            self.nextToken = nil
            self.topics = nil
        }
    }
}

/// <p>Response for ListTopics action.</p>
public struct ListTopicsOutputResponse: Swift.Equatable {
    /// <p>Token to pass along to the next <code>ListTopics</code> request. This element is
    ///             returned if there are additional topics to retrieve.</p>
    public let nextToken: Swift.String?
    /// <p>A list of topic ARNs.</p>
    public let topics: [SnsClientTypes.Topic]?

    public init (
        nextToken: Swift.String? = nil,
        topics: [SnsClientTypes.Topic]? = nil
    )
    {
        self.nextToken = nextToken
        self.topics = topics
    }
}

struct ListTopicsOutputResponseBody: Swift.Equatable {
    public let topics: [SnsClientTypes.Topic]?
    public let nextToken: Swift.String?
}

extension ListTopicsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case topics = "Topics"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListTopicsResult"))
        if containerValues.contains(.topics) {
            struct KeyVal0{struct member{}}
            let topicsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .topics)
            if let topicsWrappedContainer = topicsWrappedContainer {
                let topicsContainer = try topicsWrappedContainer.decodeIfPresent([SnsClientTypes.Topic].self, forKey: .member)
                var topicsBuffer:[SnsClientTypes.Topic]? = nil
                if let topicsContainer = topicsContainer {
                    topicsBuffer = [SnsClientTypes.Topic]()
                    for structureContainer0 in topicsContainer {
                        topicsBuffer?.append(structureContainer0)
                    }
                }
                topics = topicsBuffer
            } else {
                topics = []
            }
        } else {
            topics = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SnsClientTypes.MessageAttributeValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binaryValue = "BinaryValue"
        case dataType = "DataType"
        case stringValue = "StringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let binaryValue = binaryValue {
            try container.encode(binaryValue.base64EncodedString(), forKey: ClientRuntime.Key("BinaryValue"))
        }
        if let dataType = dataType {
            try container.encode(dataType, forKey: ClientRuntime.Key("DataType"))
        }
        if let stringValue = stringValue {
            try container.encode(stringValue, forKey: ClientRuntime.Key("StringValue"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let stringValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        if containerValues.contains(.binaryValue) {
            do {
                let binaryValueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .binaryValue)
                binaryValue = binaryValueDecoded
            } catch {
                binaryValue = "".data(using: .utf8)
            }
        } else {
            binaryValue = nil
        }
    }
}

extension SnsClientTypes.MessageAttributeValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MessageAttributeValue(binaryValue: \(Swift.String(describing: binaryValue)), dataType: \(Swift.String(describing: dataType)), stringValue: \(Swift.String(describing: stringValue)))"}
}

extension SnsClientTypes {
    /// <p>The user-specified message attribute value. For string data types, the value attribute
    ///             has the same restrictions on the content as the message body. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/sns/latest/api/API_Publish.html">Publish</a>.</p>
    ///         <p>Name, type, and value must not be empty or null. In addition, the message body should
    ///             not be empty or null. All parts of the message attribute, including name, type, and
    ///             value, are included in the message size restriction, which is currently 256 KB (262,144
    ///             bytes). For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/SNSMessageAttributes.html">Amazon SNS message attributes</a> and
    ///                 <a href="https://docs.aws.amazon.com/sns/latest/dg/sms_publish-to-phone.html">Publishing
    ///                 to a mobile phone</a> in the <i>Amazon SNS Developer Guide.</i>
    ///          </p>
    public struct MessageAttributeValue: Swift.Equatable {
        /// <p>Binary type attributes can store any binary data, for example, compressed data,
        ///             encrypted data, or images.</p>
        public let binaryValue: ClientRuntime.Data?
        /// <p>Amazon SNS supports the following logical data types: String, String.Array, Number, and
        ///             Binary. For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/SNSMessageAttributes.html#SNSMessageAttributes.DataTypes">Message
        ///                 Attribute Data Types</a>.</p>
        public let dataType: Swift.String?
        /// <p>Strings are Unicode with UTF8 binary encoding. For a list of code values, see <a href="https://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters">ASCII Printable
        ///                 Characters</a>.</p>
        public let stringValue: Swift.String?

        public init (
            binaryValue: ClientRuntime.Data? = nil,
            dataType: Swift.String? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.binaryValue = binaryValue
            self.dataType = dataType
            self.stringValue = stringValue
        }
    }

}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(message: \(Swift.String(describing: message)))"}
}

extension NotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the requested resource does not exist.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsClientTypes {
    /// Enum listing out all supported number capabilities.
    public enum NumberCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mms
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberCapability] {
            return [
                .mms,
                .sms,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mms: return "MMS"
            case .sms: return "SMS"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumberCapability(rawValue: rawValue) ?? NumberCapability.sdkUnknown(rawValue)
        }
    }
}

public struct OptInPhoneNumberInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "OptInPhoneNumberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<OptInPhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<OptInPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<OptInPhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<OptInPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<OptInPhoneNumberOutputError>
}

extension OptInPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptInPhoneNumberInput(phoneNumber: \(Swift.String(describing: phoneNumber)))"}
}

extension OptInPhoneNumberInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("phoneNumber"))
        }
        try container.encode("OptInPhoneNumber", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct OptInPhoneNumberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "OptInPhoneNumberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<OptInPhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<OptInPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<OptInPhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<OptInPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<OptInPhoneNumberOutputError>
}

public struct OptInPhoneNumberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "OptInPhoneNumberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<OptInPhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<OptInPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<OptInPhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<OptInPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<OptInPhoneNumberOutputError>
}

/// <p>Input for the OptInPhoneNumber action.</p>
public struct OptInPhoneNumberInput: Swift.Equatable {
    /// <p>The phone number to opt in. Use E.164 format.</p>
    public let phoneNumber: Swift.String?

    public init (
        phoneNumber: Swift.String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

extension OptInPhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension OptInPhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum OptInPhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension OptInPhoneNumberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptInPhoneNumberOutputResponse()"}
}

extension OptInPhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p>The response for the OptInPhoneNumber action.</p>
public struct OptInPhoneNumberOutputResponse: Swift.Equatable {

    public init() {}
}

struct OptInPhoneNumberOutputResponseBody: Swift.Equatable {
}

extension OptInPhoneNumberOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension OptedOutException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptedOutException(message: \(Swift.String(describing: message)))"}
}

extension OptedOutException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<OptedOutExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the specified phone number opted out of receiving SMS messages from
///             your AWS account. You can't send SMS messages to phone numbers that opt out.</p>
public struct OptedOutException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OptedOutExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OptedOutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsClientTypes.PhoneNumberInformation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case iso2CountryCode = "Iso2CountryCode"
        case numberCapabilities = "NumberCapabilities"
        case phoneNumber = "PhoneNumber"
        case routeType = "RouteType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createdAt = createdAt {
            try container.encode(ClientRuntime.TimestampWrapper(createdAt, format: .dateTime), forKey: ClientRuntime.Key("createdAt"))
        }
        if let iso2CountryCode = iso2CountryCode {
            try container.encode(iso2CountryCode, forKey: ClientRuntime.Key("Iso2CountryCode"))
        }
        if let numberCapabilities = numberCapabilities {
            var numberCapabilitiesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NumberCapabilities"))
            for (index0, numbercapability0) in numberCapabilities.enumerated() {
                try numberCapabilitiesContainer.encode(numbercapability0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        if let routeType = routeType {
            try container.encode(routeType, forKey: ClientRuntime.Key("RouteType"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        var createdAtBuffer:ClientRuntime.Date? = nil
        if let createdAtDecoded = createdAtDecoded {
            createdAtBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdAtDecoded, format: .dateTime)
        }
        createdAt = createdAtBuffer
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let iso2CountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iso2CountryCode)
        iso2CountryCode = iso2CountryCodeDecoded
        let routeTypeDecoded = try containerValues.decodeIfPresent(SnsClientTypes.RouteType.self, forKey: .routeType)
        routeType = routeTypeDecoded
        if containerValues.contains(.numberCapabilities) {
            struct KeyVal0{struct member{}}
            let numberCapabilitiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .numberCapabilities)
            if let numberCapabilitiesWrappedContainer = numberCapabilitiesWrappedContainer {
                let numberCapabilitiesContainer = try numberCapabilitiesWrappedContainer.decodeIfPresent([SnsClientTypes.NumberCapability].self, forKey: .member)
                var numberCapabilitiesBuffer:[SnsClientTypes.NumberCapability]? = nil
                if let numberCapabilitiesContainer = numberCapabilitiesContainer {
                    numberCapabilitiesBuffer = [SnsClientTypes.NumberCapability]()
                    for stringContainer0 in numberCapabilitiesContainer {
                        numberCapabilitiesBuffer?.append(stringContainer0)
                    }
                }
                numberCapabilities = numberCapabilitiesBuffer
            } else {
                numberCapabilities = []
            }
        } else {
            numberCapabilities = nil
        }
    }
}

extension SnsClientTypes.PhoneNumberInformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumberInformation(createdAt: \(Swift.String(describing: createdAt)), iso2CountryCode: \(Swift.String(describing: iso2CountryCode)), numberCapabilities: \(Swift.String(describing: numberCapabilities)), phoneNumber: \(Swift.String(describing: phoneNumber)), routeType: \(Swift.String(describing: routeType)), status: \(Swift.String(describing: status)))"}
}

extension SnsClientTypes {
    /// <p>A list of phone numbers and their metadata.</p>
    public struct PhoneNumberInformation: Swift.Equatable {
        /// <p>The date and time when the phone number was created.</p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The two-character code for the country or region, in ISO 3166-1 alpha-2 format.</p>
        public let iso2CountryCode: Swift.String?
        /// <p>The capabilities of each phone number.</p>
        public let numberCapabilities: [SnsClientTypes.NumberCapability]?
        /// <p>The phone number.</p>
        public let phoneNumber: Swift.String?
        /// <p>The list of supported routes.</p>
        public let routeType: SnsClientTypes.RouteType?
        /// <p>The status of the phone number.</p>
        public let status: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            iso2CountryCode: Swift.String? = nil,
            numberCapabilities: [SnsClientTypes.NumberCapability]? = nil,
            phoneNumber: Swift.String? = nil,
            routeType: SnsClientTypes.RouteType? = nil,
            status: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.iso2CountryCode = iso2CountryCode
            self.numberCapabilities = numberCapabilities
            self.phoneNumber = phoneNumber
            self.routeType = routeType
            self.status = status
        }
    }

}

extension SnsClientTypes.PlatformApplication: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case platformApplicationArn = "PlatformApplicationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformApplicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformApplicationArn)
        platformApplicationArn = platformApplicationArnDecoded
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var attributesBuffer: [Swift.String:Swift.String]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in attributesContainer {
                        attributesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = [:]
            }
        } else {
            attributes = nil
        }
    }
}

extension SnsClientTypes.PlatformApplication: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlatformApplication(attributes: \(Swift.String(describing: attributes)), platformApplicationArn: \(Swift.String(describing: platformApplicationArn)))"}
}

extension SnsClientTypes {
    /// <p>Platform application object.</p>
    public struct PlatformApplication: Swift.Equatable {
        /// <p>Attributes for platform application object.</p>
        public let attributes: [Swift.String:Swift.String]?
        /// <p>PlatformApplicationArn for platform application object.</p>
        public let platformApplicationArn: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            platformApplicationArn: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.platformApplicationArn = platformApplicationArn
        }
    }

}

extension PlatformApplicationDisabledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlatformApplicationDisabledException(message: \(Swift.String(describing: message)))"}
}

extension PlatformApplicationDisabledException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<PlatformApplicationDisabledExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception error indicating platform application disabled.</p>
public struct PlatformApplicationDisabledException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>Message for platform application disabled.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PlatformApplicationDisabledExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PlatformApplicationDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PublishInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishOutputError>
}

extension PublishInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishInput(message: \(Swift.String(describing: message)), messageAttributes: \(Swift.String(describing: messageAttributes)), messageDeduplicationId: \(Swift.String(describing: messageDeduplicationId)), messageGroupId: \(Swift.String(describing: messageGroupId)), messageStructure: \(Swift.String(describing: messageStructure)), phoneNumber: \(Swift.String(describing: phoneNumber)), subject: \(Swift.String(describing: subject)), targetArn: \(Swift.String(describing: targetArn)), topicArn: \(Swift.String(describing: topicArn)))"}
}

extension PublishInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if let messageAttributes = messageAttributes {
            var messageAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MessageAttributes"))
            for (index0, element0) in messageAttributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let messageattributevalueValue0 = element0.value
                var entryContainer0 = messageAttributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Name"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Value"))
                try valueContainer0.encode(messageattributevalueValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let messageDeduplicationId = messageDeduplicationId {
            try container.encode(messageDeduplicationId, forKey: ClientRuntime.Key("MessageDeduplicationId"))
        }
        if let messageGroupId = messageGroupId {
            try container.encode(messageGroupId, forKey: ClientRuntime.Key("MessageGroupId"))
        }
        if let messageStructure = messageStructure {
            try container.encode(messageStructure, forKey: ClientRuntime.Key("MessageStructure"))
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        if let subject = subject {
            try container.encode(subject, forKey: ClientRuntime.Key("Subject"))
        }
        if let targetArn = targetArn {
            try container.encode(targetArn, forKey: ClientRuntime.Key("TargetArn"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("Publish", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct PublishInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishOutputError>
}

public struct PublishInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishOutputError>
}

/// <p>Input for Publish action.</p>
public struct PublishInput: Swift.Equatable {
    /// <p>The message you want to send.</p>
    ///         <p>If you are publishing to a topic and you want to send the same message to all
    ///             transport protocols, include the text of the message as a String value. If you want to
    ///             send different messages for each transport protocol, set the value of the
    ///                 <code>MessageStructure</code> parameter to <code>json</code> and use a JSON object
    ///             for the <code>Message</code> parameter.
    ///         </p>
    ///         <p></p>
    ///         <p>Constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>With the exception of SMS, messages must be UTF-8 encoded strings and at most
    ///                     256 KB in size (262,144 bytes, not 262,144 characters).</p>
    ///             </li>
    ///             <li>
    ///                 <p>For SMS, each message can contain up to 140 characters. This character limit
    ///                     depends on the encoding schema. For example, an SMS message can contain 160 GSM
    ///                     characters, 140 ASCII characters, or 70 UCS-2 characters.</p>
    ///                 <p>If you publish a message that exceeds this size limit, Amazon SNS sends the message
    ///                     as multiple messages, each fitting within the size limit. Messages aren't
    ///                     truncated mid-word but are cut off at whole-word boundaries.</p>
    ///                 <p>The total size limit for a single SMS <code>Publish</code> action is 1,600
    ///                     characters.</p>
    ///             </li>
    ///          </ul>
    ///         <p>JSON-specific constraints:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Keys in the JSON object that correspond to supported transport protocols must
    ///                     have simple JSON string values.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The values will be parsed (unescaped) before they are used in outgoing
    ///                     messages.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Outbound notifications are JSON encoded (meaning that the characters will be
    ///                     reescaped for sending).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Values have a minimum length of 0 (the empty string, "", is allowed).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Values have a maximum length bounded by the overall message size (so,
    ///                     including multiple protocols may limit message sizes).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Non-string values will cause the key to be ignored.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Keys that do not correspond to supported transport protocols are
    ///                     ignored.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Duplicate keys are not allowed.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Failure to parse or validate any key or value in the message will cause the
    ///                         <code>Publish</code> call to return an error (no partial delivery).</p>
    ///             </li>
    ///          </ul>
    public let message: Swift.String?
    /// <p>Message attributes for Publish action.</p>
    public let messageAttributes: [Swift.String:SnsClientTypes.MessageAttributeValue]?
    /// <p>This parameter applies only to FIFO (first-in-first-out) topics. The
    ///                 <code>MessageDeduplicationId</code> can contain up to 128 alphanumeric characters
    ///             (a-z, A-Z, 0-9) and punctuation
    ///             <code>(!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~)</code>.</p>
    ///         <p>Every message must have a unique <code>MessageDeduplicationId</code>, which is a token
    ///             used for deduplication of sent messages. If a message with a particular
    ///                 <code>MessageDeduplicationId</code> is sent successfully, any message sent with the
    ///             same <code>MessageDeduplicationId</code> during the 5-minute deduplication interval is
    ///             treated as a duplicate. </p>
    ///         <p>If the topic has <code>ContentBasedDeduplication</code> set, the system generates a
    ///                 <code>MessageDeduplicationId</code> based on the contents of the message. Your
    ///                 <code>MessageDeduplicationId</code> overrides the generated one.</p>
    public let messageDeduplicationId: Swift.String?
    /// <p>This parameter applies only to FIFO (first-in-first-out) topics. The
    ///                 <code>MessageGroupId</code> can contain up to 128 alphanumeric characters (a-z, A-Z,
    ///             0-9) and punctuation <code>(!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~)</code>.</p>
    ///         <p>The <code>MessageGroupId</code> is a tag that specifies that a message belongs to a
    ///             specific message group. Messages that belong to the same message group are processed in
    ///             a FIFO manner (however, messages in different message groups might be processed out of
    ///             order). Every message must include a <code>MessageGroupId</code>.</p>
    public let messageGroupId: Swift.String?
    /// <p>Set <code>MessageStructure</code> to <code>json</code> if you want to send a different
    ///             message for each protocol. For example, using one publish action, you can send a short
    ///             message to your SMS subscribers and a longer message to your email subscribers. If you
    ///             set <code>MessageStructure</code> to <code>json</code>, the value of the
    ///                 <code>Message</code> parameter must: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>be a syntactically valid JSON object; and</p>
    ///             </li>
    ///             <li>
    ///                 <p>contain at least a top-level JSON key of "default" with a value that is a
    ///                     string.</p>
    ///             </li>
    ///          </ul>
    ///         <p>You can define other top-level keys that define the message you want to send to a
    ///             specific transport protocol (e.g., "http").</p>
    ///         <p>Valid value: <code>json</code>
    ///         </p>
    public let messageStructure: Swift.String?
    /// <p>The phone number to which you want to deliver an SMS message. Use E.164 format.</p>
    ///         <p>If you don't specify a value for the <code>PhoneNumber</code> parameter, you must
    ///             specify a value for the <code>TargetArn</code> or <code>TopicArn</code>
    ///             parameters.</p>
    public let phoneNumber: Swift.String?
    /// <p>Optional parameter to be used as the "Subject" line when the message is delivered to
    ///             email endpoints. This field will also be included, if present, in the standard JSON
    ///             messages delivered to other endpoints.</p>
    ///         <p>Constraints: Subjects must be ASCII text that begins with a letter, number, or
    ///             punctuation mark; must not include line breaks or control characters; and must be less
    ///             than 100 characters long.</p>
    public let subject: Swift.String?
    /// <p>If you don't specify a value for the <code>TargetArn</code> parameter, you must
    ///             specify a value for the <code>PhoneNumber</code> or <code>TopicArn</code>
    ///             parameters.</p>
    public let targetArn: Swift.String?
    /// <p>The topic you want to publish to.</p>
    ///         <p>If you don't specify a value for the <code>TopicArn</code> parameter, you must specify
    ///             a value for the <code>PhoneNumber</code> or <code>TargetArn</code> parameters.</p>
    public let topicArn: Swift.String?

    public init (
        message: Swift.String? = nil,
        messageAttributes: [Swift.String:SnsClientTypes.MessageAttributeValue]? = nil,
        messageDeduplicationId: Swift.String? = nil,
        messageGroupId: Swift.String? = nil,
        messageStructure: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        subject: Swift.String? = nil,
        targetArn: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.message = message
        self.messageAttributes = messageAttributes
        self.messageDeduplicationId = messageDeduplicationId
        self.messageGroupId = messageGroupId
        self.messageStructure = messageStructure
        self.phoneNumber = phoneNumber
        self.subject = subject
        self.targetArn = targetArn
        self.topicArn = topicArn
    }
}

extension PublishOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PublishOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointDisabledException" : self = .endpointDisabledException(try EndpointDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityException" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedException" : self = .kMSAccessDeniedException(try KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledException" : self = .kMSDisabledException(try KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundException" : self = .kMSNotFoundException(try KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSOptInRequired" : self = .kMSOptInRequired(try KMSOptInRequired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingException" : self = .kMSThrottlingException(try KMSThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PlatformApplicationDisabledException" : self = .platformApplicationDisabledException(try PlatformApplicationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case endpointDisabledException(EndpointDisabledException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidSecurityException(InvalidSecurityException)
    case kMSAccessDeniedException(KMSAccessDeniedException)
    case kMSDisabledException(KMSDisabledException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case kMSNotFoundException(KMSNotFoundException)
    case kMSOptInRequired(KMSOptInRequired)
    case kMSThrottlingException(KMSThrottlingException)
    case notFoundException(NotFoundException)
    case platformApplicationDisabledException(PlatformApplicationDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishOutputResponse(messageId: \(Swift.String(describing: messageId)), sequenceNumber: \(Swift.String(describing: sequenceNumber)))"}
}

extension PublishOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PublishOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
            self.sequenceNumber = output.sequenceNumber
        } else {
            self.messageId = nil
            self.sequenceNumber = nil
        }
    }
}

/// <p>Response for Publish action.</p>
public struct PublishOutputResponse: Swift.Equatable {
    /// <p>Unique identifier assigned to the published message.</p>
    ///         <p>Length Constraint: Maximum 100 characters</p>
    public let messageId: Swift.String?
    /// <p>This response element applies only to FIFO (first-in-first-out) topics. </p>
    ///         <p>The sequence number is a large, non-consecutive number that Amazon SNS assigns to each
    ///             message. The length of <code>SequenceNumber</code> is 128 bits.
    ///                 <code>SequenceNumber</code> continues to increase for each
    ///                 <code>MessageGroupId</code>.</p>
    public let sequenceNumber: Swift.String?

    public init (
        messageId: Swift.String? = nil,
        sequenceNumber: Swift.String? = nil
    )
    {
        self.messageId = messageId
        self.sequenceNumber = sequenceNumber
    }
}

struct PublishOutputResponseBody: Swift.Equatable {
    public let messageId: Swift.String?
    public let sequenceNumber: Swift.String?
}

extension PublishOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
        case sequenceNumber = "SequenceNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("PublishResult"))
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
    }
}

public struct RemovePermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemovePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemovePermissionOutputError>
}

extension RemovePermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemovePermissionInput(label: \(Swift.String(describing: label)), topicArn: \(Swift.String(describing: topicArn)))"}
}

extension RemovePermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let label = label {
            try container.encode(label, forKey: ClientRuntime.Key("Label"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("RemovePermission", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RemovePermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemovePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemovePermissionOutputError>
}

public struct RemovePermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemovePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemovePermissionOutputError>
}

/// <p>Input for RemovePermission action.</p>
public struct RemovePermissionInput: Swift.Equatable {
    /// <p>The unique label of the statement you want to remove.</p>
    public let label: Swift.String?
    /// <p>The ARN of the topic whose access control policy you wish to modify.</p>
    public let topicArn: Swift.String?

    public init (
        label: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.label = label
        self.topicArn = topicArn
    }
}

extension RemovePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemovePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemovePermissionOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemovePermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemovePermissionOutputResponse()"}
}

extension RemovePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemovePermissionOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemovePermissionOutputResponseBody: Swift.Equatable {
}

extension RemovePermissionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ResourceNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Can’t perform the action on the specified resource. Make sure that the resource
///             exists.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsClientTypes {
    /// Enum listing out all supported route types. The following enum values are supported.
    ///         1. Transactional : Non-marketing traffic
    ///         2. Promotional : Marketing
    ///         3. Premium : Premium routes for OTP delivery to the carriers
    public enum RouteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case premium
        case promotional
        case transactional
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteType] {
            return [
                .premium,
                .promotional,
                .transactional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .premium: return "Premium"
            case .promotional: return "Promotional"
            case .transactional: return "Transactional"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteType(rawValue: rawValue) ?? RouteType.sdkUnknown(rawValue)
        }
    }
}

extension SnsClientTypes.SMSSandboxPhoneNumber: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SnsClientTypes.SMSSandboxPhoneNumberVerificationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SnsClientTypes.SMSSandboxPhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SMSSandboxPhoneNumber(phoneNumber: \(Swift.String(describing: phoneNumber)), status: \(Swift.String(describing: status)))"}
}

extension SnsClientTypes {
    /// <p>A verified or pending destination phone number in the SMS sandbox.</p>
    ///         <p>When you start using Amazon SNS to send SMS messages, your AWS account is in the
    ///                 <i>SMS sandbox</i>. The SMS sandbox provides a safe environment for
    ///                 you to try Amazon SNS features without risking your reputation as an SMS sender. While your
    ///                 account is in the SMS sandbox, you can use all of the features of Amazon SNS. However, you can send
    ///                 SMS messages only to verified destination phone numbers. For more information, including how to
    ///                 move out of the sandbox to send messages without restrictions,
    ///                 see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">SMS sandbox</a> in
    ///                 the <i>Amazon SNS Developer Guide</i>.</p>
    public struct SMSSandboxPhoneNumber: Swift.Equatable {
        /// <p>The destination phone number.</p>
        public let phoneNumber: Swift.String?
        /// <p>The destination phone number's verification status.</p>
        public let status: SnsClientTypes.SMSSandboxPhoneNumberVerificationStatus?

        public init (
            phoneNumber: Swift.String? = nil,
            status: SnsClientTypes.SMSSandboxPhoneNumberVerificationStatus? = nil
        )
        {
            self.phoneNumber = phoneNumber
            self.status = status
        }
    }

}

extension SnsClientTypes {
    /// Enum listing out all supported destination phone number verification statuses. The following enum values are
    ///         supported.
    ///         1. PENDING : The destination phone number is pending verification.
    ///         2. VERIFIED : The destination phone number is verified.
    public enum SMSSandboxPhoneNumberVerificationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pending
        case verified
        case sdkUnknown(Swift.String)

        public static var allCases: [SMSSandboxPhoneNumberVerificationStatus] {
            return [
                .pending,
                .verified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pending: return "Pending"
            case .verified: return "Verified"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SMSSandboxPhoneNumberVerificationStatus(rawValue: rawValue) ?? SMSSandboxPhoneNumberVerificationStatus.sdkUnknown(rawValue)
        }
    }
}

public struct SetEndpointAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetEndpointAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetEndpointAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetEndpointAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetEndpointAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetEndpointAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetEndpointAttributesOutputError>
}

extension SetEndpointAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetEndpointAttributesInput(attributes: \(Swift.String(describing: attributes)), endpointArn: \(Swift.String(describing: endpointArn)))"}
}

extension SetEndpointAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: ClientRuntime.Key("EndpointArn"))
        }
        try container.encode("SetEndpointAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct SetEndpointAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetEndpointAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetEndpointAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetEndpointAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetEndpointAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetEndpointAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetEndpointAttributesOutputError>
}

public struct SetEndpointAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetEndpointAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetEndpointAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetEndpointAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetEndpointAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetEndpointAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetEndpointAttributesOutputError>
}

/// <p>Input for SetEndpointAttributes action.</p>
public struct SetEndpointAttributesInput: Swift.Equatable {
    /// <p>A map of the endpoint attributes. Attributes in this map include the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>CustomUserData</code> – arbitrary user data to associate with the
    ///                     endpoint. Amazon SNS does not use this data. The data must be in UTF-8 format and
    ///                     less than 2KB.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>Enabled</code> – flag that enables/disables delivery to the
    ///                     endpoint. Amazon SNS will set this to false when a notification service indicates to
    ///                     Amazon SNS that the endpoint is invalid. Users can set it back to true, typically
    ///                     after updating Token.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>Token</code> – device token, also referred to as a registration id,
    ///                     for an app and mobile device. This is returned from the notification service
    ///                     when an app and mobile device are registered with the notification
    ///                     service.</p>
    ///             </li>
    ///          </ul>
    public let attributes: [Swift.String:Swift.String]?
    /// <p>EndpointArn used for SetEndpointAttributes action.</p>
    public let endpointArn: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        endpointArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.endpointArn = endpointArn
    }
}

extension SetEndpointAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetEndpointAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetEndpointAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetEndpointAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetEndpointAttributesOutputResponse()"}
}

extension SetEndpointAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetEndpointAttributesOutputResponse: Swift.Equatable {

    public init() {}
}

struct SetEndpointAttributesOutputResponseBody: Swift.Equatable {
}

extension SetEndpointAttributesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct SetPlatformApplicationAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetPlatformApplicationAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetPlatformApplicationAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetPlatformApplicationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetPlatformApplicationAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetPlatformApplicationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetPlatformApplicationAttributesOutputError>
}

extension SetPlatformApplicationAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetPlatformApplicationAttributesInput(attributes: \(Swift.String(describing: attributes)), platformApplicationArn: \(Swift.String(describing: platformApplicationArn)))"}
}

extension SetPlatformApplicationAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
        try container.encode("SetPlatformApplicationAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct SetPlatformApplicationAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetPlatformApplicationAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetPlatformApplicationAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetPlatformApplicationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetPlatformApplicationAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetPlatformApplicationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetPlatformApplicationAttributesOutputError>
}

public struct SetPlatformApplicationAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetPlatformApplicationAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetPlatformApplicationAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetPlatformApplicationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetPlatformApplicationAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetPlatformApplicationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetPlatformApplicationAttributesOutputError>
}

/// <p>Input for SetPlatformApplicationAttributes action.</p>
public struct SetPlatformApplicationAttributesInput: Swift.Equatable {
    /// <p>A map of the platform application attributes. Attributes in this map include the
    ///             following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>PlatformCredential</code> – The credential received from the
    ///                     notification service. For <code>APNS</code> and <code>APNS_SANDBOX</code>,
    ///                         <code>PlatformCredential</code> is <code>private key</code>. For
    ///                         <code>GCM</code> (Firebase Cloud Messaging), <code>PlatformCredential</code>
    ///                     is <code>API key</code>. For <code>ADM</code>, <code>PlatformCredential</code>
    ///                     is <code>client secret</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>PlatformPrincipal</code> – The principal received from the
    ///                     notification service. For <code>APNS</code> and <code>APNS_SANDBOX</code>,
    ///                         <code>PlatformPrincipal</code> is <code>SSL certificate</code>. For
    ///                         <code>GCM</code> (Firebase Cloud Messaging), there is no
    ///                         <code>PlatformPrincipal</code>. For <code>ADM</code>,
    ///                         <code>PlatformPrincipal</code> is <code>client id</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EventEndpointCreated</code> – Topic ARN to which
    ///                         <code>EndpointCreated</code> event notifications are sent.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EventEndpointDeleted</code> – Topic ARN to which
    ///                         <code>EndpointDeleted</code> event notifications are sent.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EventEndpointUpdated</code> – Topic ARN to which
    ///                         <code>EndpointUpdate</code> event notifications are sent.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>EventDeliveryFailure</code> – Topic ARN to which
    ///                         <code>DeliveryFailure</code> event notifications are sent upon Direct
    ///                     Publish delivery failure (permanent) to one of the application's
    ///                     endpoints.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>SuccessFeedbackRoleArn</code> – IAM role ARN used to give Amazon SNS
    ///                     write access to use CloudWatch Logs on your behalf.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>FailureFeedbackRoleArn</code> – IAM role ARN used to give Amazon SNS
    ///                     write access to use CloudWatch Logs on your behalf.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>SuccessFeedbackSampleRate</code> – Sample rate percentage (0-100)
    ///                     of successfully delivered messages.</p>
    ///             </li>
    ///          </ul>
    public let attributes: [Swift.String:Swift.String]?
    /// <p>PlatformApplicationArn for SetPlatformApplicationAttributes action.</p>
    public let platformApplicationArn: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.platformApplicationArn = platformApplicationArn
    }
}

extension SetPlatformApplicationAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetPlatformApplicationAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetPlatformApplicationAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetPlatformApplicationAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetPlatformApplicationAttributesOutputResponse()"}
}

extension SetPlatformApplicationAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetPlatformApplicationAttributesOutputResponse: Swift.Equatable {

    public init() {}
}

struct SetPlatformApplicationAttributesOutputResponseBody: Swift.Equatable {
}

extension SetPlatformApplicationAttributesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct SetSMSAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSMSAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetSMSAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSMSAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetSMSAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetSMSAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSMSAttributesOutputError>
}

extension SetSMSAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetSMSAttributesInput(attributes: \(Swift.String(describing: attributes)))"}
}

extension SetSMSAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("SetSMSAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct SetSMSAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSMSAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetSMSAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSMSAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetSMSAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetSMSAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSMSAttributesOutputError>
}

public struct SetSMSAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSMSAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetSMSAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSMSAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetSMSAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetSMSAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSMSAttributesOutputError>
}

/// <p>The input for the SetSMSAttributes action.</p>
public struct SetSMSAttributesInput: Swift.Equatable {
    /// <p>The default settings for sending SMS messages from your account. You can set values
    ///             for the following attribute names:</p>
    ///         <p>
    ///             <code>MonthlySpendLimit</code> – The maximum amount in USD that you are willing to spend
    ///             each month to send SMS messages. When Amazon SNS determines that sending an SMS message would
    ///             incur a cost that exceeds this limit, it stops sending SMS messages within
    ///             minutes.</p>
    ///         <important>
    ///             <p>Amazon SNS stops sending SMS messages within minutes of the limit being crossed. During
    ///                 that interval, if you continue to send SMS messages, you will incur costs that
    ///                 exceed your limit.</p>
    ///         </important>
    ///         <p>By default, the spend limit is set to the maximum allowed by Amazon SNS. If you want to
    ///             raise the limit, submit an <a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-sns">SNS Limit Increase case</a>. For <b>New limit
    ///                 value</b>, enter your desired monthly spend limit. In the <b>Use Case Description</b> field, explain that you are requesting
    ///             an SMS monthly spend limit increase.</p>
    ///         <p>
    ///             <code>DeliveryStatusIAMRole</code> – The ARN of the IAM role that allows Amazon SNS to write
    ///             logs about SMS deliveries in CloudWatch Logs. For each SMS message that you send, Amazon SNS
    ///             writes a log that includes the message price, the success or failure status, the reason
    ///             for failure (if the message failed), the message dwell time, and other
    ///             information.</p>
    ///         <p>
    ///             <code>DeliveryStatusSuccessSamplingRate</code> – The percentage of successful SMS
    ///             deliveries for which Amazon SNS will write logs in CloudWatch Logs. The value can be an
    ///             integer from 0 - 100. For example, to write logs only for failed deliveries, set this
    ///             value to <code>0</code>. To write logs for 10% of your successful deliveries, set it to
    ///                 <code>10</code>.</p>
    ///         <p>
    ///             <code>DefaultSenderID</code> – A string, such as your business brand, that is displayed
    ///             as the sender on the receiving device. Support for sender IDs varies by country. The
    ///             sender ID can be 1 - 11 alphanumeric characters, and it must contain at least one
    ///             letter.</p>
    ///         <p>
    ///             <code>DefaultSMSType</code> – The type of SMS message that you will send by default. You
    ///             can assign the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>Promotional</code> – (Default) Noncritical messages, such as marketing
    ///                     messages. Amazon SNS optimizes the message delivery to incur the lowest cost.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>Transactional</code> – Critical messages that support customer
    ///                     transactions, such as one-time passcodes for multi-factor authentication. Amazon
    ///                     SNS optimizes the message delivery to achieve the highest reliability.</p>
    ///             </li>
    ///          </ul>
    ///         <p>
    ///             <code>UsageReportS3Bucket</code> – The name of the Amazon S3 bucket to receive daily SMS
    ///             usage reports from Amazon SNS. Each day, Amazon SNS will deliver a usage report as a CSV file to
    ///             the bucket. The report includes the following information for each SMS message that was
    ///             successfully delivered by your account:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Time that the message was published (in UTC)</p>
    ///             </li>
    ///             <li>
    ///                 <p>Message ID</p>
    ///             </li>
    ///             <li>
    ///                 <p>Destination phone number</p>
    ///             </li>
    ///             <li>
    ///                 <p>Message type</p>
    ///             </li>
    ///             <li>
    ///                 <p>Delivery status</p>
    ///             </li>
    ///             <li>
    ///                 <p>Message price (in USD)</p>
    ///             </li>
    ///             <li>
    ///                 <p>Part number (a message is split into multiple parts if it is too long for a
    ///                     single message)</p>
    ///             </li>
    ///             <li>
    ///                 <p>Total number of parts</p>
    ///             </li>
    ///          </ul>
    ///         <p>To receive the report, the bucket must have a policy that allows the Amazon SNS service
    ///             principle to perform the <code>s3:PutObject</code> and <code>s3:GetBucketLocation</code>
    ///             actions.</p>
    ///         <p>For an example bucket policy and usage report, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sms_stats.html">Monitoring SMS Activity</a> in the
    ///                 <i>Amazon SNS Developer Guide</i>.</p>
    public let attributes: [Swift.String:Swift.String]?

    public init (
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

extension SetSMSAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetSMSAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetSMSAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetSMSAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetSMSAttributesOutputResponse()"}
}

extension SetSMSAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p>The response for the SetSMSAttributes action.</p>
public struct SetSMSAttributesOutputResponse: Swift.Equatable {

    public init() {}
}

struct SetSMSAttributesOutputResponseBody: Swift.Equatable {
}

extension SetSMSAttributesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct SetSubscriptionAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSubscriptionAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetSubscriptionAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSubscriptionAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetSubscriptionAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetSubscriptionAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSubscriptionAttributesOutputError>
}

extension SetSubscriptionAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetSubscriptionAttributesInput(attributeName: \(Swift.String(describing: attributeName)), attributeValue: \(Swift.String(describing: attributeValue)), subscriptionArn: \(Swift.String(describing: subscriptionArn)))"}
}

extension SetSubscriptionAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: ClientRuntime.Key("AttributeValue"))
        }
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: ClientRuntime.Key("SubscriptionArn"))
        }
        try container.encode("SetSubscriptionAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct SetSubscriptionAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSubscriptionAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetSubscriptionAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSubscriptionAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetSubscriptionAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetSubscriptionAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSubscriptionAttributesOutputError>
}

public struct SetSubscriptionAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSubscriptionAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetSubscriptionAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSubscriptionAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetSubscriptionAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetSubscriptionAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSubscriptionAttributesOutputError>
}

/// <p>Input for SetSubscriptionAttributes action.</p>
public struct SetSubscriptionAttributesInput: Swift.Equatable {
    /// <p>A map of attributes with their corresponding values.</p>
    ///         <p>The following lists the names, descriptions, and values of the special request
    ///             parameters that this action uses:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>DeliveryPolicy</code> – The policy that defines how Amazon SNS retries
    ///                     failed deliveries to HTTP/S endpoints.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FilterPolicy</code> – The simple JSON object that lets your
    ///                     subscriber receive only a subset of messages, rather than receiving every
    ///                     message published to the topic.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>RawMessageDelivery</code> – When set to <code>true</code>,
    ///                     enables raw message delivery to Amazon SQS or HTTP/S endpoints. This eliminates the
    ///                     need for the endpoints to process JSON formatting, which is otherwise created
    ///                     for Amazon SNS metadata.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>RedrivePolicy</code> – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue.
    ///     Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable)
    ///     or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held
    ///     in the dead-letter queue for further analysis or reprocessing.</p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///         <p>The following attribute applies only to Amazon Kinesis Data Firehose delivery stream subscriptions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SubscriptionRoleArn</code> – The ARN of the IAM role that has the following:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>Permission to write to the Kinesis Data Firehose delivery stream</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>Amazon SNS listed as a trusted entity</p>
    ///                     </li>
    ///                </ul>
    ///                 <p>Specifying a valid ARN for this attribute is required for Kinesis Data Firehose delivery stream subscriptions.
    ///                 For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html">Fanout
    ///                     to Kinesis Data Firehose delivery streams</a> in the <i>Amazon SNS Developer Guide</i>.</p>
    ///                     </li>
    ///          </ul>
    public let attributeName: Swift.String?
    /// <p>The new value for the attribute in JSON format.</p>
    public let attributeValue: Swift.String?
    /// <p>The ARN of the subscription to modify.</p>
    public let subscriptionArn: Swift.String?

    public init (
        attributeName: Swift.String? = nil,
        attributeValue: Swift.String? = nil,
        subscriptionArn: Swift.String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.subscriptionArn = subscriptionArn
    }
}

extension SetSubscriptionAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetSubscriptionAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterPolicyLimitExceededException" : self = .filterPolicyLimitExceededException(try FilterPolicyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetSubscriptionAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case filterPolicyLimitExceededException(FilterPolicyLimitExceededException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetSubscriptionAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetSubscriptionAttributesOutputResponse()"}
}

extension SetSubscriptionAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetSubscriptionAttributesOutputResponse: Swift.Equatable {

    public init() {}
}

struct SetSubscriptionAttributesOutputResponseBody: Swift.Equatable {
}

extension SetSubscriptionAttributesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct SetTopicAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetTopicAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetTopicAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetTopicAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetTopicAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetTopicAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetTopicAttributesOutputError>
}

extension SetTopicAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetTopicAttributesInput(attributeName: \(Swift.String(describing: attributeName)), attributeValue: \(Swift.String(describing: attributeValue)), topicArn: \(Swift.String(describing: topicArn)))"}
}

extension SetTopicAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: ClientRuntime.Key("AttributeValue"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("SetTopicAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct SetTopicAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetTopicAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetTopicAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetTopicAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetTopicAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetTopicAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetTopicAttributesOutputError>
}

public struct SetTopicAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetTopicAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetTopicAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetTopicAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetTopicAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetTopicAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetTopicAttributesOutputError>
}

/// <p>Input for SetTopicAttributes action.</p>
public struct SetTopicAttributesInput: Swift.Equatable {
    /// <p>A map of attributes with their corresponding values.</p>
    ///         <p>The following lists the names, descriptions, and values of the special request
    ///             parameters that the <code>SetTopicAttributes</code> action uses:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>DeliveryPolicy</code> – The policy that defines how Amazon SNS retries
    ///                     failed deliveries to HTTP/S endpoints.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DisplayName</code> – The display name to use for a topic with SMS
    ///                     subscriptions.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Policy</code> – The policy that defines who can access your
    ///                     topic. By default, only the topic owner can publish or subscribe to the
    ///                     topic.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>The following attribute applies only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html">server-side-encryption</a>:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>KmsMasterKeyId</code> – The ID of an AWS-managed customer master
    ///                     key (CMK) for Amazon SNS or a custom CMK. For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms">Key
    ///                         Terms</a>. For more examples, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters">KeyId</a> in the <i>AWS Key Management Service API
    ///                         Reference</i>. </p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///         <p>The following attribute applies only to <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html">FIFO topics</a>:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                     <code>ContentBasedDeduplication</code> –  Enables content-based deduplication for
    ///                     FIFO topics.</p>
    ///
    ///                 <ul>
    ///                   <li>
    ///                         <p>By default, <code>ContentBasedDeduplication</code> is set to <code>false</code>.
    ///                             If you create a FIFO topic and this attribute is <code>false</code>, you must
    ///                             specify a value for the <code>MessageDeduplicationId</code> parameter for the
    ///                             <a href="https://docs.aws.amazon.com/sns/latest/api/API_Publish.html">Publish</a> action. </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>When you set <code>ContentBasedDeduplication</code> to <code>true</code>,
    ///                             Amazon SNS uses a SHA-256 hash to generate the <code>MessageDeduplicationId</code> using
    ///                             the body of the message (but not the attributes of the message).</p>
    ///                         <p>(Optional) To override the generated value, you can specify a value
    ///                             for the <code>MessageDeduplicationId</code> parameter for the <code>Publish</code>
    ///                             action.</p>
    ///                      </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let attributeName: Swift.String?
    /// <p>The new value for the attribute.</p>
    public let attributeValue: Swift.String?
    /// <p>The ARN of the topic to modify.</p>
    public let topicArn: Swift.String?

    public init (
        attributeName: Swift.String? = nil,
        attributeValue: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.topicArn = topicArn
    }
}

extension SetTopicAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetTopicAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityException" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetTopicAttributesOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSecurityException(InvalidSecurityException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetTopicAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetTopicAttributesOutputResponse()"}
}

extension SetTopicAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetTopicAttributesOutputResponse: Swift.Equatable {

    public init() {}
}

struct SetTopicAttributesOutputResponseBody: Swift.Equatable {
}

extension SetTopicAttributesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StaleTagException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StaleTagException(message: \(Swift.String(describing: message)))"}
}

extension StaleTagException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<StaleTagExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A tag has been added to a resource with the same ARN as a deleted resource. Wait a
///             short while and then retry the operation.</p>
public struct StaleTagException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StaleTagExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension StaleTagExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SubscribeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubscribeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubscribeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubscribeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubscribeOutputError>
}

extension SubscribeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscribeInput(attributes: \(Swift.String(describing: attributes)), endpoint: \(Swift.String(describing: endpoint)), protocol: \(Swift.String(describing: `protocol`)), returnSubscriptionArn: \(Swift.String(describing: returnSubscriptionArn)), topicArn: \(Swift.String(describing: topicArn)))"}
}

extension SubscribeInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let attributenameKey0 = element0.key
                let attributevalueValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(attributenameKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(attributevalueValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
        if returnSubscriptionArn != false {
            try container.encode(returnSubscriptionArn, forKey: ClientRuntime.Key("ReturnSubscriptionArn"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("Subscribe", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct SubscribeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubscribeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubscribeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubscribeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubscribeOutputError>
}

public struct SubscribeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubscribeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubscribeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubscribeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubscribeOutputError>
}

/// <p>Input for Subscribe action.</p>
public struct SubscribeInput: Swift.Equatable {
    /// <p>The protocol that you want to use. Supported protocols include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>http</code> – delivery of JSON-encoded message via HTTP
    ///                     POST</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>https</code> – delivery of JSON-encoded message via HTTPS
    ///                     POST</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>email</code> – delivery of message via SMTP</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>email-json</code> – delivery of JSON-encoded message via
    ///                     SMTP</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>sms</code> – delivery of message via SMS</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>sqs</code> – delivery of JSON-encoded message to an Amazon SQS
    ///                     queue</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>application</code> – delivery of JSON-encoded message to an
    ///                     EndpointArn for a mobile app and device</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>lambda</code> – delivery of JSON-encoded message to an AWS Lambda
    ///                     function</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>firehose</code> – delivery of JSON-encoded message to an Amazon
    ///                     Kinesis Data Firehose delivery stream.</p>
    ///             </li>
    ///          </ul>
    public let `protocol`: Swift.String?
    /// <p>A map of attributes with their corresponding values.</p>
    ///         <p>The following lists the names, descriptions, and values of the special request
    ///             parameters that the <code>SetTopicAttributes</code> action uses:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>DeliveryPolicy</code> – The policy that defines how Amazon SNS retries
    ///                     failed deliveries to HTTP/S endpoints.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>FilterPolicy</code> – The simple JSON object that lets your
    ///                     subscriber receive only a subset of messages, rather than receiving every
    ///                     message published to the topic.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>RawMessageDelivery</code> – When set to <code>true</code>,
    ///                     enables raw message delivery to Amazon SQS or HTTP/S endpoints. This eliminates the
    ///                     need for the endpoints to process JSON formatting, which is otherwise created
    ///                     for Amazon SNS metadata.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>RedrivePolicy</code> – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue.
    ///     Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable)
    ///     or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held
    ///     in the dead-letter queue for further analysis or reprocessing.</p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///         <p>The following attribute applies only to Amazon Kinesis Data Firehose delivery stream subscriptions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SubscriptionRoleArn</code> – The ARN of the IAM role that has the following:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>Permission to write to the Kinesis Data Firehose delivery stream</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>Amazon SNS listed as a trusted entity</p>
    ///                     </li>
    ///                </ul>
    ///                 <p>Specifying a valid ARN for this attribute is required for Kinesis Data Firehose delivery stream subscriptions.
    ///                 For more information, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html">Fanout
    ///                     to Kinesis Data Firehose delivery streams</a> in the <i>Amazon SNS Developer Guide</i>.</p>
    ///                     </li>
    ///          </ul>
    public let attributes: [Swift.String:Swift.String]?
    /// <p>The endpoint that you want to receive notifications. Endpoints vary by
    ///             protocol:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>For the <code>http</code> protocol, the (public) endpoint is a URL beginning
    ///                     with <code>http://</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>https</code> protocol, the (public) endpoint is a URL beginning
    ///                     with <code>https://</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>email</code> protocol, the endpoint is an email address.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>email-json</code> protocol, the endpoint is an email
    ///                     address.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>sms</code> protocol, the endpoint is a phone number of an
    ///                     SMS-enabled device.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>sqs</code> protocol, the endpoint is the ARN of an Amazon SQS
    ///                     queue.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>application</code> protocol, the endpoint is the EndpointArn of
    ///                     a mobile app and device.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>lambda</code> protocol, the endpoint is the ARN of an AWS Lambda
    ///                     function.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>firehose</code> protocol, the endpoint is the ARN of an Amazon
    ///                     Kinesis Data Firehose delivery stream.</p>
    ///             </li>
    ///          </ul>
    public let endpoint: Swift.String?
    /// <p>Sets whether the response from the <code>Subscribe</code> request includes the
    ///             subscription ARN, even if the subscription is not yet confirmed.</p>
    ///         <p>If you set this parameter to <code>true</code>, the response includes the ARN in all
    ///             cases, even if the subscription is not yet confirmed. In addition to the ARN for
    ///             confirmed subscriptions, the response also includes the <code>pending
    ///                 subscription</code> ARN value for subscriptions that aren't yet confirmed. A
    ///             subscription becomes confirmed when the subscriber calls the
    ///                 <code>ConfirmSubscription</code> action with a confirmation token.</p>
    ///         <p></p>
    ///         <p>The default value is <code>false</code>.</p>
    public let returnSubscriptionArn: Swift.Bool
    /// <p>The ARN of the topic you want to subscribe to.</p>
    public let topicArn: Swift.String?

    public init (
        `protocol`: Swift.String? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        endpoint: Swift.String? = nil,
        returnSubscriptionArn: Swift.Bool = false,
        topicArn: Swift.String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.attributes = attributes
        self.endpoint = endpoint
        self.returnSubscriptionArn = returnSubscriptionArn
        self.topicArn = topicArn
    }
}

extension SubscribeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SubscribeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterPolicyLimitExceededException" : self = .filterPolicyLimitExceededException(try FilterPolicyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityException" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionLimitExceededException" : self = .subscriptionLimitExceededException(try SubscriptionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SubscribeOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case filterPolicyLimitExceededException(FilterPolicyLimitExceededException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSecurityException(InvalidSecurityException)
    case notFoundException(NotFoundException)
    case subscriptionLimitExceededException(SubscriptionLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SubscribeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscribeOutputResponse(subscriptionArn: \(Swift.String(describing: subscriptionArn)))"}
}

extension SubscribeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubscribeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subscriptionArn = output.subscriptionArn
        } else {
            self.subscriptionArn = nil
        }
    }
}

/// <p>Response for Subscribe action.</p>
public struct SubscribeOutputResponse: Swift.Equatable {
    /// <p>The ARN of the subscription if it is confirmed, or the string "pending confirmation"
    ///             if the subscription requires confirmation. However, if the API request parameter
    ///                 <code>ReturnSubscriptionArn</code> is true, then the value is always the
    ///             subscription ARN, even if the subscription requires confirmation.</p>
    public let subscriptionArn: Swift.String?

    public init (
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct SubscribeOutputResponseBody: Swift.Equatable {
    public let subscriptionArn: Swift.String?
}

extension SubscribeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("SubscribeResult"))
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

extension SnsClientTypes.Subscription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
        case owner = "Owner"
        case `protocol` = "Protocol"
        case subscriptionArn = "SubscriptionArn"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: ClientRuntime.Key("Owner"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: ClientRuntime.Key("SubscriptionArn"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension SnsClientTypes.Subscription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Subscription(endpoint: \(Swift.String(describing: endpoint)), owner: \(Swift.String(describing: owner)), protocol: \(Swift.String(describing: `protocol`)), subscriptionArn: \(Swift.String(describing: subscriptionArn)), topicArn: \(Swift.String(describing: topicArn)))"}
}

extension SnsClientTypes {
    /// <p>A wrapper type for the attributes of an Amazon SNS subscription.</p>
    public struct Subscription: Swift.Equatable {
        /// <p>The subscription's protocol.</p>
        public let `protocol`: Swift.String?
        /// <p>The subscription's endpoint (format depends on the protocol).</p>
        public let endpoint: Swift.String?
        /// <p>The subscription's owner.</p>
        public let owner: Swift.String?
        /// <p>The subscription's ARN.</p>
        public let subscriptionArn: Swift.String?
        /// <p>The ARN of the subscription's topic.</p>
        public let topicArn: Swift.String?

        public init (
            `protocol`: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            owner: Swift.String? = nil,
            subscriptionArn: Swift.String? = nil,
            topicArn: Swift.String? = nil
        )
        {
            self.`protocol` = `protocol`
            self.endpoint = endpoint
            self.owner = owner
            self.subscriptionArn = subscriptionArn
            self.topicArn = topicArn
        }
    }

}

extension SubscriptionLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension SubscriptionLimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SubscriptionLimitExceededExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the customer already owns the maximum allowed number of
///             subscriptions.</p>
public struct SubscriptionLimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubscriptionLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SnsClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension SnsClientTypes {
    /// <p>The list of tags to be added to the specified topic.</p>
    public struct Tag: Swift.Equatable {
        /// <p>The required key portion of the tag.</p>
        public let key: Swift.String?
        /// <p>The optional value portion of the tag.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension TagLimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TagLimitExceededExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Can't add more than 50 tags to a topic.</p>
public struct TagLimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TagLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagPolicyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagPolicyException(message: \(Swift.String(describing: message)))"}
}

extension TagPolicyException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TagPolicyExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request doesn't comply with the IAM tag policy. Correct your request and then
///             retry it.</p>
public struct TagPolicyException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagPolicyExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TagPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("TagResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The ARN of the topic to which to add tags.</p>
    public let resourceArn: Swift.String?
    /// <p>The tags to be added to the specified topic. A tag consists of a required key and an
    ///             optional value.</p>
    public let tags: [SnsClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [SnsClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccessException" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleTagException" : self = .staleTagException(try StaleTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededException" : self = .tagLimitExceededException(try TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case concurrentAccessException(ConcurrentAccessException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case staleTagException(StaleTagException)
    case tagLimitExceededException(TagLimitExceededException)
    case tagPolicyException(TagPolicyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottledException(message: \(Swift.String(describing: message)))"}
}

extension ThrottledException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ThrottledExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the rate at which requests have been submitted for this action exceeds
///             the limit for your account.</p>
public struct ThrottledException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>Throttled request.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottledExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnsClientTypes.Topic: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension SnsClientTypes.Topic: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Topic(topicArn: \(Swift.String(describing: topicArn)))"}
}

extension SnsClientTypes {
    /// <p>A wrapper type for the topic's Amazon Resource Name (ARN). To retrieve a topic's
    ///             attributes, use <code>GetTopicAttributes</code>.</p>
    public struct Topic: Swift.Equatable {
        /// <p>The topic's ARN.</p>
        public let topicArn: Swift.String?

        public init (
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }

}

extension TopicLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TopicLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension TopicLimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TopicLimitExceededExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the customer already owns the maximum allowed number of topics.</p>
public struct TopicLimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TopicLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TopicLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UnsubscribeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnsubscribeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnsubscribeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnsubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnsubscribeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnsubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnsubscribeOutputError>
}

extension UnsubscribeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsubscribeInput(subscriptionArn: \(Swift.String(describing: subscriptionArn)))"}
}

extension UnsubscribeInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: ClientRuntime.Key("SubscriptionArn"))
        }
        try container.encode("Unsubscribe", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct UnsubscribeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnsubscribeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnsubscribeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnsubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnsubscribeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnsubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnsubscribeOutputError>
}

public struct UnsubscribeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnsubscribeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnsubscribeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnsubscribeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnsubscribeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnsubscribeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnsubscribeOutputError>
}

/// <p>Input for Unsubscribe action.</p>
public struct UnsubscribeInput: Swift.Equatable {
    /// <p>The ARN of the subscription to be deleted.</p>
    public let subscriptionArn: Swift.String?

    public init (
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

extension UnsubscribeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UnsubscribeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityException" : self = .invalidSecurityException(try InvalidSecurityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnsubscribeOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSecurityException(InvalidSecurityException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnsubscribeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsubscribeOutputResponse()"}
}

extension UnsubscribeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UnsubscribeOutputResponse: Swift.Equatable {

    public init() {}
}

struct UnsubscribeOutputResponseBody: Swift.Equatable {
}

extension UnsubscribeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, tagkey0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(tagkey0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("UntagResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The ARN of the topic from which to remove tags.</p>
    public let resourceArn: Swift.String?
    /// <p>The list of tag keys to remove from the specified topic.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentAccessException" : self = .concurrentAccessException(try ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StaleTagException" : self = .staleTagException(try StaleTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededException" : self = .tagLimitExceededException(try TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case concurrentAccessException(ConcurrentAccessException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case staleTagException(StaleTagException)
    case tagLimitExceededException(TagLimitExceededException)
    case tagPolicyException(TagPolicyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UserErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserErrorException(message: \(Swift.String(describing: message)))"}
}

extension UserErrorException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<UserErrorExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a request parameter does not comply with the associated
///             constraints.</p>
public struct UserErrorException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UserErrorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UserErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ValidationExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a parameter in the request is invalid.</p>
public struct ValidationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VerificationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VerificationException(message: \(Swift.String(describing: message)), status: \(Swift.String(describing: status)))"}
}

extension VerificationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<VerificationExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
            self.status = output.error.status
        } else {
            self.message = nil
            self.status = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the one-time password (OTP) used for verification is invalid.</p>
public struct VerificationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// <p>The status of the verification error.</p>
    public var status: Swift.String?

    public init (
        message: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.message = message
        self.status = status
    }
}

struct VerificationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let status: Swift.String?
}

extension VerificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct VerifySMSSandboxPhoneNumberInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "VerifySMSSandboxPhoneNumberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<VerifySMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<VerifySMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<VerifySMSSandboxPhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<VerifySMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<VerifySMSSandboxPhoneNumberOutputError>
}

extension VerifySMSSandboxPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VerifySMSSandboxPhoneNumberInput(oneTimePassword: \(Swift.String(describing: oneTimePassword)), phoneNumber: \(Swift.String(describing: phoneNumber)))"}
}

extension VerifySMSSandboxPhoneNumberInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let oneTimePassword = oneTimePassword {
            try container.encode(oneTimePassword, forKey: ClientRuntime.Key("OneTimePassword"))
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        try container.encode("VerifySMSSandboxPhoneNumber", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct VerifySMSSandboxPhoneNumberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "VerifySMSSandboxPhoneNumberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<VerifySMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<VerifySMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<VerifySMSSandboxPhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<VerifySMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<VerifySMSSandboxPhoneNumberOutputError>
}

public struct VerifySMSSandboxPhoneNumberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "VerifySMSSandboxPhoneNumberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<VerifySMSSandboxPhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<VerifySMSSandboxPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<VerifySMSSandboxPhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<VerifySMSSandboxPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<VerifySMSSandboxPhoneNumberOutputError>
}

public struct VerifySMSSandboxPhoneNumberInput: Swift.Equatable {
    /// <p>The OTP sent to the destination number from the
    ///                 <code>CreateSMSSandBoxPhoneNumber</code> call.</p>
    public let oneTimePassword: Swift.String?
    /// <p>The destination phone number to verify.</p>
    public let phoneNumber: Swift.String?

    public init (
        oneTimePassword: Swift.String? = nil,
        phoneNumber: Swift.String? = nil
    )
    {
        self.oneTimePassword = oneTimePassword
        self.phoneNumber = phoneNumber
    }
}

extension VerifySMSSandboxPhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension VerifySMSSandboxPhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VerificationException" : self = .verificationException(try VerificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum VerifySMSSandboxPhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttledException(ThrottledException)
    case verificationException(VerificationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension VerifySMSSandboxPhoneNumberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VerifySMSSandboxPhoneNumberOutputResponse()"}
}

extension VerifySMSSandboxPhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p>The destination phone number's verification status.</p>
public struct VerifySMSSandboxPhoneNumberOutputResponse: Swift.Equatable {

    public init() {}
}

struct VerifySMSSandboxPhoneNumberOutputResponseBody: Swift.Equatable {
}

extension VerifySMSSandboxPhoneNumberOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}
