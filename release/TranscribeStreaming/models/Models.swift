// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension TranscribeStreamingClientTypes.Alternative: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case transcript = "Transcript"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for itemlist0 in items {
                try itemsContainer.encode(itemlist0)
            }
        }
        if let transcript = transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcript)
        transcript = transcriptDecoded
        let itemsContainer = try containerValues.decodeIfPresent([TranscribeStreamingClientTypes.Item?].self, forKey: .items)
        var itemsDecoded0:[TranscribeStreamingClientTypes.Item]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [TranscribeStreamingClientTypes.Item]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension TranscribeStreamingClientTypes.Alternative: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Alternative(items: \(Swift.String(describing: items)), transcript: \(Swift.String(describing: transcript)))"}
}

extension TranscribeStreamingClientTypes {
    /// <p>A list of possible transcriptions for the audio.</p>
    public struct Alternative: Swift.Equatable {
        /// <p>One or more alternative interpretations of the input audio. </p>
        public let items: [TranscribeStreamingClientTypes.Item]?
        /// <p>The text that was transcribed from the audio.</p>
        public let transcript: Swift.String?

        public init (
            items: [TranscribeStreamingClientTypes.Item]? = nil,
            transcript: Swift.String? = nil
        )
        {
            self.items = items
            self.transcript = transcript
        }
    }

}

extension TranscribeStreamingClientTypes.AudioEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioChunk = "AudioChunk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioChunk = audioChunk {
            try encodeContainer.encode(audioChunk.base64EncodedString(), forKey: .audioChunk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioChunkDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .audioChunk)
        audioChunk = audioChunkDecoded
    }
}

extension TranscribeStreamingClientTypes.AudioEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AudioEvent(audioChunk: \(Swift.String(describing: audioChunk)))"}
}

extension TranscribeStreamingClientTypes {
    /// <p>Provides a wrapper for the audio chunks that you are sending.</p>
    ///          <p>For information on audio encoding in Amazon Transcribe, see <a>input</a>. For information
    ///       on audio encoding formats in Amazon Transcribe Medical, see <a>input-med</a>.</p>
    public struct AudioEvent: Swift.Equatable {
        /// <p>An audio blob that contains the next part of the audio that you want to transcribe. The
        ///       maximum audio chunk size is 32 KB.</p>
        public let audioChunk: ClientRuntime.Data?

        public init (
            audioChunk: ClientRuntime.Data? = nil
        )
        {
            self.audioChunk = audioChunk
        }
    }

}

extension TranscribeStreamingClientTypes.AudioStream: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioevent = "AudioEvent"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .audioevent(audioevent):
                try container.encode(audioevent, forKey: .audioevent)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let audioeventDecoded = try values.decodeIfPresent(TranscribeStreamingClientTypes.AudioEvent.self, forKey: .audioevent)
        if let audioevent = audioeventDecoded {
            self = .audioevent(audioevent)
            return
        }
        self = .sdkUnknown("")
    }
}

extension TranscribeStreamingClientTypes {
    /// <p>Represents the audio stream from your application to Amazon Transcribe.</p>
    public enum AudioStream: Swift.Equatable {
        /// <p>A blob of audio from your application. You audio stream consists of one or more audio
        ///       events.</p>
        ///          <p>For information on audio encoding formats in Amazon Transcribe, see <a>input</a>. For
        ///       information on audio encoding formats in Amazon Transcribe Medical, see <a>input-med</a>.</p>
        ///          <p>For more information on stream encoding in Amazon Transcribe, see <a>event-stream</a>. For
        ///       information on stream encoding in Amazon Transcribe Medical, see <a>event-stream-med</a>.</p>
        case audioevent(TranscribeStreamingClientTypes.AudioEvent)
        case sdkUnknown(Swift.String)
    }

}

extension BadRequestException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequestException(message: \(Swift.String(describing: message)))"}
}

extension BadRequestException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more arguments to the <code>StartStreamTranscription</code> or
///         <code>StartMedicalStreamTranscription</code> operation was invalid. For example,
///         <code>MediaEncoding</code> was not set to a valid encoding, or <code>LanguageCode</code> was
///       not set to a valid code. Check the parameters and try your request again.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A new stream started with the same session ID. The current stream has been
///       terminated.</p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalFailureException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalFailureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalFailureException(message: \(Swift.String(describing: message)))"}
}

extension InternalFailureException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A problem occurred while processing the audio. Amazon Transcribe or Amazon Transcribe Medical terminated processing. Try
///       your request again.</p>
public struct InternalFailureException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TranscribeStreamingClientTypes.Item: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confidence = "Confidence"
        case content = "Content"
        case endTime = "EndTime"
        case speaker = "Speaker"
        case stable = "Stable"
        case startTime = "StartTime"
        case type = "Type"
        case vocabularyFilterMatch = "VocabularyFilterMatch"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confidence = confidence {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if endTime != 0.0 {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let speaker = speaker {
            try encodeContainer.encode(speaker, forKey: .speaker)
        }
        if let stable = stable {
            try encodeContainer.encode(stable, forKey: .stable)
        }
        if startTime != 0.0 {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if vocabularyFilterMatch != false {
            try encodeContainer.encode(vocabularyFilterMatch, forKey: .vocabularyFilterMatch)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decode(Swift.Double.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decode(Swift.Double.self, forKey: .endTime)
        endTime = endTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TranscribeStreamingClientTypes.ItemType.self, forKey: .type)
        type = typeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let vocabularyFilterMatchDecoded = try containerValues.decode(Swift.Bool.self, forKey: .vocabularyFilterMatch)
        vocabularyFilterMatch = vocabularyFilterMatchDecoded
        let speakerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speaker)
        speaker = speakerDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .confidence)
        confidence = confidenceDecoded
        let stableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .stable)
        stable = stableDecoded
    }
}

extension TranscribeStreamingClientTypes.Item: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Item(confidence: \(Swift.String(describing: confidence)), content: \(Swift.String(describing: content)), endTime: \(Swift.String(describing: endTime)), speaker: \(Swift.String(describing: speaker)), stable: \(Swift.String(describing: stable)), startTime: \(Swift.String(describing: startTime)), type: \(Swift.String(describing: type)), vocabularyFilterMatch: \(Swift.String(describing: vocabularyFilterMatch)))"}
}

extension TranscribeStreamingClientTypes {
    /// <p>A word, phrase, or punctuation mark that is transcribed from the input audio.</p>
    public struct Item: Swift.Equatable {
        /// <p>A value between 0 and 1 for an item that is a confidence score that Amazon Transcribe assigns to each
        ///       word or phrase that it transcribes.</p>
        public let confidence: Swift.Double?
        /// <p>The word or punctuation that was recognized in the input audio.</p>
        public let content: Swift.String?
        /// <p>The offset from the beginning of the audio stream to the end of the audio that resulted in
        ///       the item.</p>
        public let endTime: Swift.Double
        /// <p>If speaker identification is enabled, shows the speakers identified in the real-time
        ///       stream.</p>
        public let speaker: Swift.String?
        /// <p>If partial result stabilization has been enabled, indicates whether the word or phrase in
        ///       the item is stable. If <code>Stable</code> is <code>true</code>, the result is stable.</p>
        public let stable: Swift.Bool?
        /// <p>The offset from the beginning of the audio stream to the beginning of the audio that
        ///       resulted in the item.</p>
        public let startTime: Swift.Double
        /// <p>The type of the item. <code>PRONUNCIATION</code> indicates that the item is a word that
        ///       was recognized in the input audio. <code>PUNCTUATION</code> indicates that the item was
        ///       interpreted as a pause in the input audio.</p>
        public let type: TranscribeStreamingClientTypes.ItemType?
        /// <p>Indicates whether a word in the item matches a word in the vocabulary filter you've chosen
        ///       for your real-time stream. If <code>true</code> then a word in the item matches your
        ///       vocabulary filter.</p>
        public let vocabularyFilterMatch: Swift.Bool

        public init (
            confidence: Swift.Double? = nil,
            content: Swift.String? = nil,
            endTime: Swift.Double = 0.0,
            speaker: Swift.String? = nil,
            stable: Swift.Bool? = nil,
            startTime: Swift.Double = 0.0,
            type: TranscribeStreamingClientTypes.ItemType? = nil,
            vocabularyFilterMatch: Swift.Bool = false
        )
        {
            self.confidence = confidence
            self.content = content
            self.endTime = endTime
            self.speaker = speaker
            self.stable = stable
            self.startTime = startTime
            self.type = type
            self.vocabularyFilterMatch = vocabularyFilterMatch
        }
    }

}

extension TranscribeStreamingClientTypes {
    public enum ItemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pronunciation
        case punctuation
        case sdkUnknown(Swift.String)

        public static var allCases: [ItemType] {
            return [
                .pronunciation,
                .punctuation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pronunciation: return "pronunciation"
            case .punctuation: return "punctuation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ItemType(rawValue: rawValue) ?? ItemType.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeStreamingClientTypes {
    public enum LanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deDe
        case enAu
        case enGb
        case enUs
        case esUs
        case frCa
        case frFr
        case itIt
        case jaJp
        case koKr
        case ptBr
        case zhCn
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCode] {
            return [
                .deDe,
                .enAu,
                .enGb,
                .enUs,
                .esUs,
                .frCa,
                .frFr,
                .itIt,
                .jaJp,
                .koKr,
                .ptBr,
                .zhCn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .esUs: return "es-US"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .itIt: return "it-IT"
            case .jaJp: return "ja-JP"
            case .koKr: return "ko-KR"
            case .ptBr: return "pt-BR"
            case .zhCn: return "zh-CN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LanguageCode(rawValue: rawValue) ?? LanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the maximum number of concurrent transcription streams, are starting
///       transcription streams too quickly, or the maximum audio length of 4 hours. Wait until a stream
///       has finished processing, or break your audio stream into smaller chunks and try your request
///       again.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TranscribeStreamingClientTypes {
    public enum MediaEncoding: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case flac
        case oggOpus
        case pcm
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaEncoding] {
            return [
                .flac,
                .oggOpus,
                .pcm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .flac: return "flac"
            case .oggOpus: return "ogg-opus"
            case .pcm: return "pcm"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaEncoding(rawValue: rawValue) ?? MediaEncoding.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeStreamingClientTypes.MedicalAlternative: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case items = "Items"
        case transcript = "Transcript"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entities = entities {
            var entitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entities)
            for medicalentitylist0 in entities {
                try entitiesContainer.encode(medicalentitylist0)
            }
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for medicalitemlist0 in items {
                try itemsContainer.encode(medicalitemlist0)
            }
        }
        if let transcript = transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcript)
        transcript = transcriptDecoded
        let itemsContainer = try containerValues.decodeIfPresent([TranscribeStreamingClientTypes.MedicalItem?].self, forKey: .items)
        var itemsDecoded0:[TranscribeStreamingClientTypes.MedicalItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [TranscribeStreamingClientTypes.MedicalItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let entitiesContainer = try containerValues.decodeIfPresent([TranscribeStreamingClientTypes.MedicalEntity?].self, forKey: .entities)
        var entitiesDecoded0:[TranscribeStreamingClientTypes.MedicalEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [TranscribeStreamingClientTypes.MedicalEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
    }
}

extension TranscribeStreamingClientTypes.MedicalAlternative: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MedicalAlternative(entities: \(Swift.String(describing: entities)), items: \(Swift.String(describing: items)), transcript: \(Swift.String(describing: transcript)))"}
}

extension TranscribeStreamingClientTypes {
    /// <p>A list of possible transcriptions for the audio.</p>
    public struct MedicalAlternative: Swift.Equatable {
        /// <p>Contains the medical entities identified as personal health information in the transcription output.</p>
        public let entities: [TranscribeStreamingClientTypes.MedicalEntity]?
        /// <p>A list of objects that contains words and punctuation marks that represents one or
        ///             more interpretations of the input audio.</p>
        public let items: [TranscribeStreamingClientTypes.MedicalItem]?
        /// <p>The text that was transcribed from the audio.</p>
        public let transcript: Swift.String?

        public init (
            entities: [TranscribeStreamingClientTypes.MedicalEntity]? = nil,
            items: [TranscribeStreamingClientTypes.MedicalItem]? = nil,
            transcript: Swift.String? = nil
        )
        {
            self.entities = entities
            self.items = items
            self.transcript = transcript
        }
    }

}

extension TranscribeStreamingClientTypes {
    public enum MedicalContentIdentificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case phi
        case sdkUnknown(Swift.String)

        public static var allCases: [MedicalContentIdentificationType] {
            return [
                .phi,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .phi: return "PHI"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MedicalContentIdentificationType(rawValue: rawValue) ?? MedicalContentIdentificationType.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeStreamingClientTypes.MedicalEntity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case confidence = "Confidence"
        case content = "Content"
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let confidence = confidence {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if endTime != 0.0 {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if startTime != 0.0 {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decode(Swift.Double.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decode(Swift.Double.self, forKey: .endTime)
        endTime = endTimeDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .confidence)
        confidence = confidenceDecoded
    }
}

extension TranscribeStreamingClientTypes.MedicalEntity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MedicalEntity(category: \(Swift.String(describing: category)), confidence: \(Swift.String(describing: confidence)), content: \(Swift.String(describing: content)), endTime: \(Swift.String(describing: endTime)), startTime: \(Swift.String(describing: startTime)))"}
}

extension TranscribeStreamingClientTypes {
    /// <p>The medical entity identified as personal health information.</p>
    public struct MedicalEntity: Swift.Equatable {
        /// <p>The type of personal health information of the medical entity.</p>
        public let category: Swift.String?
        /// <p>A value between zero and one that Amazon Transcribe Medical assigned to the personal health information
        ///             that it identified in the source audio. Larger values indicate that Amazon Transcribe Medical has higher
        ///             confidence in the personal health information that it identified.</p>
        public let confidence: Swift.Double?
        /// <p>The word or words in the transcription output that have been identified as a
        ///             medical entity.</p>
        public let content: Swift.String?
        /// <p>The end time of the speech that was identified as a medical entity.</p>
        public let endTime: Swift.Double
        /// <p>The start time of the speech that was identified as a medical entity.</p>
        public let startTime: Swift.Double

        public init (
            category: Swift.String? = nil,
            confidence: Swift.Double? = nil,
            content: Swift.String? = nil,
            endTime: Swift.Double = 0.0,
            startTime: Swift.Double = 0.0
        )
        {
            self.category = category
            self.confidence = confidence
            self.content = content
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension TranscribeStreamingClientTypes.MedicalItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confidence = "Confidence"
        case content = "Content"
        case endTime = "EndTime"
        case speaker = "Speaker"
        case startTime = "StartTime"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confidence = confidence {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if endTime != 0.0 {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let speaker = speaker {
            try encodeContainer.encode(speaker, forKey: .speaker)
        }
        if startTime != 0.0 {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decode(Swift.Double.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decode(Swift.Double.self, forKey: .endTime)
        endTime = endTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TranscribeStreamingClientTypes.ItemType.self, forKey: .type)
        type = typeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .confidence)
        confidence = confidenceDecoded
        let speakerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speaker)
        speaker = speakerDecoded
    }
}

extension TranscribeStreamingClientTypes.MedicalItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MedicalItem(confidence: \(Swift.String(describing: confidence)), content: \(Swift.String(describing: content)), endTime: \(Swift.String(describing: endTime)), speaker: \(Swift.String(describing: speaker)), startTime: \(Swift.String(describing: startTime)), type: \(Swift.String(describing: type)))"}
}

extension TranscribeStreamingClientTypes {
    /// <p>A word, phrase, or punctuation mark that is transcribed from the input audio.</p>
    public struct MedicalItem: Swift.Equatable {
        /// <p>A value between 0 and 1 for an item that is a confidence score that Amazon Transcribe Medical assigns to
        ///             each word that it transcribes.</p>
        public let confidence: Swift.Double?
        /// <p>The word or punctuation mark that was recognized in the input audio.</p>
        public let content: Swift.String?
        /// <p>The number of seconds into an audio stream that indicates the creation time of an
        ///             item.</p>
        public let endTime: Swift.Double
        /// <p>If speaker identification is enabled, shows the integer values that correspond to the
        ///             different speakers identified in the stream. For example, if the value of
        ///                 <code>Speaker</code> in the stream is either a <code>0</code> or a <code>1</code>,
        ///             that indicates that Amazon Transcribe Medical has identified two speakers in the stream. The value of
        ///                 <code>0</code> corresponds to one speaker and the value of <code>1</code>
        ///             corresponds to the other speaker.</p>
        public let speaker: Swift.String?
        /// <p>The number of seconds into an audio stream that indicates the creation time of an
        ///             item.</p>
        public let startTime: Swift.Double
        /// <p>The type of the item. <code>PRONUNCIATION</code> indicates that the item is a word
        ///             that was recognized in the input audio. <code>PUNCTUATION</code> indicates that the item
        ///             was interpreted as a pause in the input audio, such as a period to indicate the end of a
        ///             sentence.</p>
        public let type: TranscribeStreamingClientTypes.ItemType?

        public init (
            confidence: Swift.Double? = nil,
            content: Swift.String? = nil,
            endTime: Swift.Double = 0.0,
            speaker: Swift.String? = nil,
            startTime: Swift.Double = 0.0,
            type: TranscribeStreamingClientTypes.ItemType? = nil
        )
        {
            self.confidence = confidence
            self.content = content
            self.endTime = endTime
            self.speaker = speaker
            self.startTime = startTime
            self.type = type
        }
    }

}

extension TranscribeStreamingClientTypes.MedicalResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternatives = "Alternatives"
        case channelId = "ChannelId"
        case endTime = "EndTime"
        case isPartial = "IsPartial"
        case resultId = "ResultId"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternatives = alternatives {
            var alternativesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alternatives)
            for medicalalternativelist0 in alternatives {
                try alternativesContainer.encode(medicalalternativelist0)
            }
        }
        if let channelId = channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if endTime != 0.0 {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if isPartial != false {
            try encodeContainer.encode(isPartial, forKey: .isPartial)
        }
        if let resultId = resultId {
            try encodeContainer.encode(resultId, forKey: .resultId)
        }
        if startTime != 0.0 {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultId)
        resultId = resultIdDecoded
        let startTimeDecoded = try containerValues.decode(Swift.Double.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decode(Swift.Double.self, forKey: .endTime)
        endTime = endTimeDecoded
        let isPartialDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isPartial)
        isPartial = isPartialDecoded
        let alternativesContainer = try containerValues.decodeIfPresent([TranscribeStreamingClientTypes.MedicalAlternative?].self, forKey: .alternatives)
        var alternativesDecoded0:[TranscribeStreamingClientTypes.MedicalAlternative]? = nil
        if let alternativesContainer = alternativesContainer {
            alternativesDecoded0 = [TranscribeStreamingClientTypes.MedicalAlternative]()
            for structure0 in alternativesContainer {
                if let structure0 = structure0 {
                    alternativesDecoded0?.append(structure0)
                }
            }
        }
        alternatives = alternativesDecoded0
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
    }
}

extension TranscribeStreamingClientTypes.MedicalResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MedicalResult(alternatives: \(Swift.String(describing: alternatives)), channelId: \(Swift.String(describing: channelId)), endTime: \(Swift.String(describing: endTime)), isPartial: \(Swift.String(describing: isPartial)), resultId: \(Swift.String(describing: resultId)), startTime: \(Swift.String(describing: startTime)))"}
}

extension TranscribeStreamingClientTypes {
    /// <p>The results of transcribing a portion of the input audio stream.</p>
    public struct MedicalResult: Swift.Equatable {
        /// <p>A list of possible transcriptions of the audio. Each alternative typically contains
        ///             one <code>Item</code> that contains the result of the transcription.</p>
        public let alternatives: [TranscribeStreamingClientTypes.MedicalAlternative]?
        /// <p>When channel identification is enabled, Amazon Transcribe Medical transcribes the speech from each audio
        ///             channel separately.</p>
        ///         <p>You can use <code>ChannelId</code> to retrieve the transcription results for a single
        ///             channel in your audio stream.</p>
        public let channelId: Swift.String?
        /// <p>The time, in seconds, from the beginning of the audio stream to the end of the
        ///             result.</p>
        public let endTime: Swift.Double
        /// <p>Amazon Transcribe Medical divides the incoming audio stream into segments at natural points in the audio.
        ///             Transcription results are returned based on these segments.</p>
        ///         <p>The <code>IsPartial</code> field is <code>true</code> to indicate that Amazon Transcribe Medical has
        ///             additional transcription data to send. The <code>IsPartial</code> field is
        ///                 <code>false</code> to indicate that this is the last transcription result for the
        ///             segment.</p>
        public let isPartial: Swift.Bool
        /// <p>A unique identifier for the result.</p>
        public let resultId: Swift.String?
        /// <p>The time, in seconds, from the beginning of the audio stream to the beginning of the
        ///             result.</p>
        public let startTime: Swift.Double

        public init (
            alternatives: [TranscribeStreamingClientTypes.MedicalAlternative]? = nil,
            channelId: Swift.String? = nil,
            endTime: Swift.Double = 0.0,
            isPartial: Swift.Bool = false,
            resultId: Swift.String? = nil,
            startTime: Swift.Double = 0.0
        )
        {
            self.alternatives = alternatives
            self.channelId = channelId
            self.endTime = endTime
            self.isPartial = isPartial
            self.resultId = resultId
            self.startTime = startTime
        }
    }

}

extension TranscribeStreamingClientTypes.MedicalTranscript: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let results = results {
            var resultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .results)
            for medicalresultlist0 in results {
                try resultsContainer.encode(medicalresultlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([TranscribeStreamingClientTypes.MedicalResult?].self, forKey: .results)
        var resultsDecoded0:[TranscribeStreamingClientTypes.MedicalResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [TranscribeStreamingClientTypes.MedicalResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

extension TranscribeStreamingClientTypes.MedicalTranscript: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MedicalTranscript(results: \(Swift.String(describing: results)))"}
}

extension TranscribeStreamingClientTypes {
    /// <p>The medical transcript in a <a>MedicalTranscriptEvent</a>.</p>
    public struct MedicalTranscript: Swift.Equatable {
        /// <p>
        ///             <a>MedicalResult</a> objects that contain the results of transcribing a
        ///             portion of the input audio stream. The array can be empty.</p>
        public let results: [TranscribeStreamingClientTypes.MedicalResult]?

        public init (
            results: [TranscribeStreamingClientTypes.MedicalResult]? = nil
        )
        {
            self.results = results
        }
    }

}

extension TranscribeStreamingClientTypes.MedicalTranscriptEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcript = "Transcript"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transcript = transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptDecoded = try containerValues.decodeIfPresent(TranscribeStreamingClientTypes.MedicalTranscript.self, forKey: .transcript)
        transcript = transcriptDecoded
    }
}

extension TranscribeStreamingClientTypes.MedicalTranscriptEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MedicalTranscriptEvent(transcript: \(Swift.String(describing: transcript)))"}
}

extension TranscribeStreamingClientTypes {
    /// <p>Represents a set of transcription results from the server to the client. It contains
    ///             one or more segments of the transcription.</p>
    public struct MedicalTranscriptEvent: Swift.Equatable {
        /// <p>The transcription of the audio stream. The transcription is composed of all of the
        ///             items in the results list.</p>
        public let transcript: TranscribeStreamingClientTypes.MedicalTranscript?

        public init (
            transcript: TranscribeStreamingClientTypes.MedicalTranscript? = nil
        )
        {
            self.transcript = transcript
        }
    }

}

extension TranscribeStreamingClientTypes.MedicalTranscriptResultStream: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case badrequestexception = "BadRequestException"
        case conflictexception = "ConflictException"
        case internalfailureexception = "InternalFailureException"
        case limitexceededexception = "LimitExceededException"
        case serviceunavailableexception = "ServiceUnavailableException"
        case transcriptevent = "TranscriptEvent"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .badrequestexception(badrequestexception):
                try container.encode(badrequestexception, forKey: .badrequestexception)
            case let .conflictexception(conflictexception):
                try container.encode(conflictexception, forKey: .conflictexception)
            case let .internalfailureexception(internalfailureexception):
                try container.encode(internalfailureexception, forKey: .internalfailureexception)
            case let .limitexceededexception(limitexceededexception):
                try container.encode(limitexceededexception, forKey: .limitexceededexception)
            case let .serviceunavailableexception(serviceunavailableexception):
                try container.encode(serviceunavailableexception, forKey: .serviceunavailableexception)
            case let .transcriptevent(transcriptevent):
                try container.encode(transcriptevent, forKey: .transcriptevent)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let transcripteventDecoded = try values.decodeIfPresent(TranscribeStreamingClientTypes.MedicalTranscriptEvent.self, forKey: .transcriptevent)
        if let transcriptevent = transcripteventDecoded {
            self = .transcriptevent(transcriptevent)
            return
        }
        let badrequestexceptionDecoded = try values.decodeIfPresent(BadRequestException.self, forKey: .badrequestexception)
        if let badrequestexception = badrequestexceptionDecoded {
            self = .badrequestexception(badrequestexception)
            return
        }
        let limitexceededexceptionDecoded = try values.decodeIfPresent(LimitExceededException.self, forKey: .limitexceededexception)
        if let limitexceededexception = limitexceededexceptionDecoded {
            self = .limitexceededexception(limitexceededexception)
            return
        }
        let internalfailureexceptionDecoded = try values.decodeIfPresent(InternalFailureException.self, forKey: .internalfailureexception)
        if let internalfailureexception = internalfailureexceptionDecoded {
            self = .internalfailureexception(internalfailureexception)
            return
        }
        let conflictexceptionDecoded = try values.decodeIfPresent(ConflictException.self, forKey: .conflictexception)
        if let conflictexception = conflictexceptionDecoded {
            self = .conflictexception(conflictexception)
            return
        }
        let serviceunavailableexceptionDecoded = try values.decodeIfPresent(ServiceUnavailableException.self, forKey: .serviceunavailableexception)
        if let serviceunavailableexception = serviceunavailableexceptionDecoded {
            self = .serviceunavailableexception(serviceunavailableexception)
            return
        }
        self = .sdkUnknown("")
    }
}

extension TranscribeStreamingClientTypes {
    /// <p>Represents the transcription result stream from Amazon Transcribe Medical to your application.</p>
    public enum MedicalTranscriptResultStream: Swift.Equatable {
        /// <p>A portion of the transcription of the audio stream. Events are sent periodically from
        ///             Amazon Transcribe Medical to your application. The event can be a partial transcription of a section of the
        ///             audio stream, or it can be the entire transcription of that portion of the audio
        ///             stream.</p>
        case transcriptevent(TranscribeStreamingClientTypes.MedicalTranscriptEvent)
        /// <p>One or more arguments to the <code>StartStreamTranscription</code> or
        ///         <code>StartMedicalStreamTranscription</code> operation was invalid. For example,
        ///         <code>MediaEncoding</code> was not set to a valid encoding, or <code>LanguageCode</code> was
        ///       not set to a valid code. Check the parameters and try your request again.</p>
        case badrequestexception(BadRequestException)
        /// <p>You have exceeded the maximum number of concurrent transcription streams, are starting
        ///       transcription streams too quickly, or the maximum audio length of 4 hours. Wait until a stream
        ///       has finished processing, or break your audio stream into smaller chunks and try your request
        ///       again.</p>
        case limitexceededexception(LimitExceededException)
        /// <p>A problem occurred while processing the audio. Amazon Transcribe or Amazon Transcribe Medical terminated processing. Try
        ///       your request again.</p>
        case internalfailureexception(InternalFailureException)
        /// <p>A new stream started with the same session ID. The current stream has been
        ///       terminated.</p>
        case conflictexception(ConflictException)
        /// <p>Service is currently unavailable. Try your request later.</p>
        case serviceunavailableexception(ServiceUnavailableException)
        case sdkUnknown(Swift.String)
    }

}

extension TranscribeStreamingClientTypes {
    public enum PartialResultsStability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [PartialResultsStability] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .low: return "low"
            case .medium: return "medium"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PartialResultsStability(rawValue: rawValue) ?? PartialResultsStability.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeStreamingClientTypes.Result: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternatives = "Alternatives"
        case channelId = "ChannelId"
        case endTime = "EndTime"
        case isPartial = "IsPartial"
        case resultId = "ResultId"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternatives = alternatives {
            var alternativesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alternatives)
            for alternativelist0 in alternatives {
                try alternativesContainer.encode(alternativelist0)
            }
        }
        if let channelId = channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if endTime != 0.0 {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if isPartial != false {
            try encodeContainer.encode(isPartial, forKey: .isPartial)
        }
        if let resultId = resultId {
            try encodeContainer.encode(resultId, forKey: .resultId)
        }
        if startTime != 0.0 {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultId)
        resultId = resultIdDecoded
        let startTimeDecoded = try containerValues.decode(Swift.Double.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decode(Swift.Double.self, forKey: .endTime)
        endTime = endTimeDecoded
        let isPartialDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isPartial)
        isPartial = isPartialDecoded
        let alternativesContainer = try containerValues.decodeIfPresent([TranscribeStreamingClientTypes.Alternative?].self, forKey: .alternatives)
        var alternativesDecoded0:[TranscribeStreamingClientTypes.Alternative]? = nil
        if let alternativesContainer = alternativesContainer {
            alternativesDecoded0 = [TranscribeStreamingClientTypes.Alternative]()
            for structure0 in alternativesContainer {
                if let structure0 = structure0 {
                    alternativesDecoded0?.append(structure0)
                }
            }
        }
        alternatives = alternativesDecoded0
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
    }
}

extension TranscribeStreamingClientTypes.Result: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Result(alternatives: \(Swift.String(describing: alternatives)), channelId: \(Swift.String(describing: channelId)), endTime: \(Swift.String(describing: endTime)), isPartial: \(Swift.String(describing: isPartial)), resultId: \(Swift.String(describing: resultId)), startTime: \(Swift.String(describing: startTime)))"}
}

extension TranscribeStreamingClientTypes {
    /// <p>The result of transcribing a portion of the input audio stream. </p>
    public struct Result: Swift.Equatable {
        /// <p>A list of possible transcriptions for the audio. Each alternative typically contains one
        ///         <code>item</code> that contains the result of the transcription.</p>
        public let alternatives: [TranscribeStreamingClientTypes.Alternative]?
        /// <p>When channel identification is enabled, Amazon Transcribe transcribes the speech from each audio
        ///       channel separately.</p>
        ///          <p>You can use <code>ChannelId</code> to retrieve the transcription results for a single
        ///       channel in your audio stream.</p>
        public let channelId: Swift.String?
        /// <p>The offset in seconds from the beginning of the audio stream to the end of the
        ///       result.</p>
        public let endTime: Swift.Double
        /// <p>Amazon Transcribe divides the incoming audio stream into segments at natural points in the audio.
        ///       Transcription results are returned based on these segments. </p>
        ///          <p>The <code>IsPartial</code> field is <code>true</code> to indicate that Amazon Transcribe has
        ///       additional transcription data to send, <code>false</code> to indicate that this is the last
        ///       transcription result for the segment.</p>
        public let isPartial: Swift.Bool
        /// <p>A unique identifier for the result. </p>
        public let resultId: Swift.String?
        /// <p>The offset in seconds from the beginning of the audio stream to the beginning of the
        ///       result.</p>
        public let startTime: Swift.Double

        public init (
            alternatives: [TranscribeStreamingClientTypes.Alternative]? = nil,
            channelId: Swift.String? = nil,
            endTime: Swift.Double = 0.0,
            isPartial: Swift.Bool = false,
            resultId: Swift.String? = nil,
            startTime: Swift.Double = 0.0
        )
        {
            self.alternatives = alternatives
            self.channelId = channelId
            self.endTime = endTime
            self.isPartial = isPartial
            self.resultId = resultId
            self.startTime = startTime
        }
    }

}

extension ServiceUnavailableException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Service is currently unavailable. Try your request later.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TranscribeStreamingClientTypes {
    public enum Specialty: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cardiology
        case neurology
        case oncology
        case primarycare
        case radiology
        case urology
        case sdkUnknown(Swift.String)

        public static var allCases: [Specialty] {
            return [
                .cardiology,
                .neurology,
                .oncology,
                .primarycare,
                .radiology,
                .urology,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cardiology: return "CARDIOLOGY"
            case .neurology: return "NEUROLOGY"
            case .oncology: return "ONCOLOGY"
            case .primarycare: return "PRIMARYCARE"
            case .radiology: return "RADIOLOGY"
            case .urology: return "UROLOGY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Specialty(rawValue: rawValue) ?? Specialty.sdkUnknown(rawValue)
        }
    }
}

public struct StartMedicalStreamTranscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMedicalStreamTranscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartMedicalStreamTranscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMedicalStreamTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let audioStream = input.operationInput.audioStream {
            do {
                let encoder = context.getEncoder()
                let audioStreamdata = try encoder.encode(audioStream)
                let audioStreambody = ClientRuntime.HttpBody.data(audioStreamdata)
                input.builder.withBody(audioStreambody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartMedicalStreamTranscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartMedicalStreamTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMedicalStreamTranscriptionOutputError>
}

extension StartMedicalStreamTranscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartMedicalStreamTranscriptionInput(audioStream: \(Swift.String(describing: audioStream)), contentIdentificationType: \(Swift.String(describing: contentIdentificationType)), enableChannelIdentification: \(Swift.String(describing: enableChannelIdentification)), languageCode: \(Swift.String(describing: languageCode)), mediaEncoding: \(Swift.String(describing: mediaEncoding)), mediaSampleRateHertz: \(Swift.String(describing: mediaSampleRateHertz)), numberOfChannels: \(Swift.String(describing: numberOfChannels)), sessionId: \(Swift.String(describing: sessionId)), showSpeakerLabel: \(Swift.String(describing: showSpeakerLabel)), specialty: \(Swift.String(describing: specialty)), type: \(Swift.String(describing: type)), vocabularyName: \(Swift.String(describing: vocabularyName)))"}
}

extension StartMedicalStreamTranscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioStream = "AudioStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioStream = audioStream {
            try encodeContainer.encode(audioStream, forKey: .audioStream)
        }
    }
}

public struct StartMedicalStreamTranscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMedicalStreamTranscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartMedicalStreamTranscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMedicalStreamTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentIdentificationType = input.operationInput.contentIdentificationType {
            input.builder.withHeader(name: "x-amzn-transcribe-content-identification-type", value: Swift.String(contentIdentificationType.rawValue))
        }
        if input.operationInput.enableChannelIdentification != false {
            input.builder.withHeader(name: "x-amzn-transcribe-enable-channel-identification", value: Swift.String(input.operationInput.enableChannelIdentification))
        }
        if let languageCode = input.operationInput.languageCode {
            input.builder.withHeader(name: "x-amzn-transcribe-language-code", value: Swift.String(languageCode.rawValue))
        }
        if let mediaEncoding = input.operationInput.mediaEncoding {
            input.builder.withHeader(name: "x-amzn-transcribe-media-encoding", value: Swift.String(mediaEncoding.rawValue))
        }
        if let mediaSampleRateHertz = input.operationInput.mediaSampleRateHertz {
            input.builder.withHeader(name: "x-amzn-transcribe-sample-rate", value: Swift.String(mediaSampleRateHertz))
        }
        if let numberOfChannels = input.operationInput.numberOfChannels {
            input.builder.withHeader(name: "x-amzn-transcribe-number-of-channels", value: Swift.String(numberOfChannels))
        }
        if let sessionId = input.operationInput.sessionId {
            input.builder.withHeader(name: "x-amzn-transcribe-session-id", value: Swift.String(sessionId))
        }
        if input.operationInput.showSpeakerLabel != false {
            input.builder.withHeader(name: "x-amzn-transcribe-show-speaker-label", value: Swift.String(input.operationInput.showSpeakerLabel))
        }
        if let specialty = input.operationInput.specialty {
            input.builder.withHeader(name: "x-amzn-transcribe-specialty", value: Swift.String(specialty.rawValue))
        }
        if let type = input.operationInput.type {
            input.builder.withHeader(name: "x-amzn-transcribe-type", value: Swift.String(type.rawValue))
        }
        if let vocabularyName = input.operationInput.vocabularyName {
            input.builder.withHeader(name: "x-amzn-transcribe-vocabulary-name", value: Swift.String(vocabularyName))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartMedicalStreamTranscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartMedicalStreamTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMedicalStreamTranscriptionOutputError>
}

public struct StartMedicalStreamTranscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMedicalStreamTranscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartMedicalStreamTranscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMedicalStreamTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartMedicalStreamTranscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartMedicalStreamTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMedicalStreamTranscriptionOutputError>
}

public struct StartMedicalStreamTranscriptionInput: Swift.Equatable {
    /// <p>Represents the audio stream from your application to Amazon Transcribe.</p>
    public let audioStream: TranscribeStreamingClientTypes.AudioStream?
    /// <p>Set this field to <code>PHI</code> to identify personal health information in the
    ///             transcription output.</p>
    public let contentIdentificationType: TranscribeStreamingClientTypes.MedicalContentIdentificationType?
    /// <p>When <code>true</code>, instructs Amazon Transcribe Medical to process each audio channel separately and
    ///             then merge the transcription output of each channel into a single transcription.</p>
    ///         <p>Amazon Transcribe Medical also produces a transcription of each item. An item includes the start time,
    ///             end time, and any alternative transcriptions.</p>
    ///         <p>You can't set both <code>ShowSpeakerLabel</code> and
    ///                 <code>EnableChannelIdentification</code> in the same request. If you set both, your
    ///             request returns a <code>BadRequestException</code>.</p>
    public let enableChannelIdentification: Swift.Bool
    /// <p> Indicates the source language used in the input audio stream. For Amazon Transcribe Medical, this is US
    ///             English (en-US). </p>
    public let languageCode: TranscribeStreamingClientTypes.LanguageCode?
    /// <p>The encoding used for the input audio.</p>
    public let mediaEncoding: TranscribeStreamingClientTypes.MediaEncoding?
    /// <p>The sample rate of the input audio in Hertz. Sample rates of 16000 Hz or higher are
    ///             accepted.</p>
    public let mediaSampleRateHertz: Swift.Int?
    /// <p>The number of channels that are in your audio stream.</p>
    public let numberOfChannels: Swift.Int?
    /// <p> Optional. An identifier for the transcription session. If you don't provide a session
    ///             ID, Amazon Transcribe generates one for you and returns it in the response. </p>
    public let sessionId: Swift.String?
    /// <p>When <code>true</code>, enables speaker identification in your real-time
    ///             stream.</p>
    public let showSpeakerLabel: Swift.Bool
    /// <p>The medical specialty of the clinician or provider.</p>
    public let specialty: TranscribeStreamingClientTypes.Specialty?
    /// <p>The type of input audio. Choose <code>DICTATION</code> for a provider dictating
    ///             patient notes. Choose <code>CONVERSATION</code> for a dialogue between a patient and one
    ///             or more medical professionanls.</p>
    public let type: TranscribeStreamingClientTypes.ModelType?
    /// <p>The name of the medical custom vocabulary to use when processing the real-time
    ///             stream.</p>
    public let vocabularyName: Swift.String?

    public init (
        audioStream: TranscribeStreamingClientTypes.AudioStream? = nil,
        contentIdentificationType: TranscribeStreamingClientTypes.MedicalContentIdentificationType? = nil,
        enableChannelIdentification: Swift.Bool = false,
        languageCode: TranscribeStreamingClientTypes.LanguageCode? = nil,
        mediaEncoding: TranscribeStreamingClientTypes.MediaEncoding? = nil,
        mediaSampleRateHertz: Swift.Int? = nil,
        numberOfChannels: Swift.Int? = nil,
        sessionId: Swift.String? = nil,
        showSpeakerLabel: Swift.Bool = false,
        specialty: TranscribeStreamingClientTypes.Specialty? = nil,
        type: TranscribeStreamingClientTypes.ModelType? = nil,
        vocabularyName: Swift.String? = nil
    )
    {
        self.audioStream = audioStream
        self.contentIdentificationType = contentIdentificationType
        self.enableChannelIdentification = enableChannelIdentification
        self.languageCode = languageCode
        self.mediaEncoding = mediaEncoding
        self.mediaSampleRateHertz = mediaSampleRateHertz
        self.numberOfChannels = numberOfChannels
        self.sessionId = sessionId
        self.showSpeakerLabel = showSpeakerLabel
        self.specialty = specialty
        self.type = type
        self.vocabularyName = vocabularyName
    }
}

struct StartMedicalStreamTranscriptionInputBody: Swift.Equatable {
    public let audioStream: TranscribeStreamingClientTypes.AudioStream?
}

extension StartMedicalStreamTranscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioStream = "AudioStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(TranscribeStreamingClientTypes.AudioStream.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

extension StartMedicalStreamTranscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMedicalStreamTranscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartMedicalStreamTranscriptionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMedicalStreamTranscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartMedicalStreamTranscriptionOutputResponse(contentIdentificationType: \(Swift.String(describing: contentIdentificationType)), enableChannelIdentification: \(Swift.String(describing: enableChannelIdentification)), languageCode: \(Swift.String(describing: languageCode)), mediaEncoding: \(Swift.String(describing: mediaEncoding)), mediaSampleRateHertz: \(Swift.String(describing: mediaSampleRateHertz)), numberOfChannels: \(Swift.String(describing: numberOfChannels)), requestId: \(Swift.String(describing: requestId)), sessionId: \(Swift.String(describing: sessionId)), showSpeakerLabel: \(Swift.String(describing: showSpeakerLabel)), specialty: \(Swift.String(describing: specialty)), transcriptResultStream: \(Swift.String(describing: transcriptResultStream)), type: \(Swift.String(describing: type)), vocabularyName: \(Swift.String(describing: vocabularyName)))"}
}

extension StartMedicalStreamTranscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentIdentificationTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-content-identification-type") {
            self.contentIdentificationType = TranscribeStreamingClientTypes.MedicalContentIdentificationType(rawValue: contentIdentificationTypeHeaderValue)
        } else {
            self.contentIdentificationType = nil
        }
        if let enableChannelIdentificationHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-enable-channel-identification") {
            self.enableChannelIdentification = Swift.Bool(enableChannelIdentificationHeaderValue) ?? false
        } else {
            self.enableChannelIdentification = false
        }
        if let languageCodeHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-language-code") {
            self.languageCode = TranscribeStreamingClientTypes.LanguageCode(rawValue: languageCodeHeaderValue)
        } else {
            self.languageCode = nil
        }
        if let mediaEncodingHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-media-encoding") {
            self.mediaEncoding = TranscribeStreamingClientTypes.MediaEncoding(rawValue: mediaEncodingHeaderValue)
        } else {
            self.mediaEncoding = nil
        }
        if let mediaSampleRateHertzHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-sample-rate") {
            self.mediaSampleRateHertz = Swift.Int(mediaSampleRateHertzHeaderValue) ?? 0
        } else {
            self.mediaSampleRateHertz = nil
        }
        if let numberOfChannelsHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-number-of-channels") {
            self.numberOfChannels = Swift.Int(numberOfChannelsHeaderValue) ?? 0
        } else {
            self.numberOfChannels = nil
        }
        if let requestIdHeaderValue = httpResponse.headers.value(for: "x-amzn-request-id") {
            self.requestId = requestIdHeaderValue
        } else {
            self.requestId = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if let showSpeakerLabelHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-show-speaker-label") {
            self.showSpeakerLabel = Swift.Bool(showSpeakerLabelHeaderValue) ?? false
        } else {
            self.showSpeakerLabel = false
        }
        if let specialtyHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-specialty") {
            self.specialty = TranscribeStreamingClientTypes.Specialty(rawValue: specialtyHeaderValue)
        } else {
            self.specialty = nil
        }
        if let typeHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-type") {
            self.type = TranscribeStreamingClientTypes.ModelType(rawValue: typeHeaderValue)
        } else {
            self.type = nil
        }
        if let vocabularyNameHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-vocabulary-name") {
            self.vocabularyName = vocabularyNameHeaderValue
        } else {
            self.vocabularyName = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: TranscribeStreamingClientTypes.MedicalTranscriptResultStream = try responseDecoder.decode(responseBody: data)
                self.transcriptResultStream = output
            } else {
                self.transcriptResultStream = nil
            }
        } else {
            self.transcriptResultStream = nil
        }
    }
}

public struct StartMedicalStreamTranscriptionOutputResponse: Swift.Equatable {
    /// <p>If the value is <code>PHI</code>, indicates that you've configured your stream to
    ///             identify personal health information.</p>
    public let contentIdentificationType: TranscribeStreamingClientTypes.MedicalContentIdentificationType?
    /// <p>Shows whether channel identification has been enabled in the stream.</p>
    public let enableChannelIdentification: Swift.Bool
    /// <p>The language code for the response transcript. For Amazon Transcribe Medical, this is US English
    ///             (en-US).</p>
    public let languageCode: TranscribeStreamingClientTypes.LanguageCode?
    /// <p>The encoding used for the input audio stream.</p>
    public let mediaEncoding: TranscribeStreamingClientTypes.MediaEncoding?
    /// <p>The sample rate of the input audio in Hertz. Valid value: 16000 Hz.</p>
    public let mediaSampleRateHertz: Swift.Int?
    /// <p>The number of channels identified in the stream.</p>
    public let numberOfChannels: Swift.Int?
    /// <p>An identifier for the streaming transcription.</p>
    public let requestId: Swift.String?
    /// <p>Optional. An identifier for the transcription session. If you don't provide a session
    ///             ID, Amazon Transcribe generates one for you and returns it in the response.</p>
    public let sessionId: Swift.String?
    /// <p>Shows whether speaker identification was enabled in the stream.</p>
    public let showSpeakerLabel: Swift.Bool
    /// <p>The specialty in the medical domain.</p>
    public let specialty: TranscribeStreamingClientTypes.Specialty?
    /// <p>Represents the stream of transcription events from Amazon Transcribe Medical to your application. </p>
    public let transcriptResultStream: TranscribeStreamingClientTypes.MedicalTranscriptResultStream?
    /// <p>The type of audio that was transcribed. </p>
    public let type: TranscribeStreamingClientTypes.ModelType?
    /// <p>The name of the vocabulary used when processing the stream.</p>
    public let vocabularyName: Swift.String?

    public init (
        contentIdentificationType: TranscribeStreamingClientTypes.MedicalContentIdentificationType? = nil,
        enableChannelIdentification: Swift.Bool = false,
        languageCode: TranscribeStreamingClientTypes.LanguageCode? = nil,
        mediaEncoding: TranscribeStreamingClientTypes.MediaEncoding? = nil,
        mediaSampleRateHertz: Swift.Int? = nil,
        numberOfChannels: Swift.Int? = nil,
        requestId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        showSpeakerLabel: Swift.Bool = false,
        specialty: TranscribeStreamingClientTypes.Specialty? = nil,
        transcriptResultStream: TranscribeStreamingClientTypes.MedicalTranscriptResultStream? = nil,
        type: TranscribeStreamingClientTypes.ModelType? = nil,
        vocabularyName: Swift.String? = nil
    )
    {
        self.contentIdentificationType = contentIdentificationType
        self.enableChannelIdentification = enableChannelIdentification
        self.languageCode = languageCode
        self.mediaEncoding = mediaEncoding
        self.mediaSampleRateHertz = mediaSampleRateHertz
        self.numberOfChannels = numberOfChannels
        self.requestId = requestId
        self.sessionId = sessionId
        self.showSpeakerLabel = showSpeakerLabel
        self.specialty = specialty
        self.transcriptResultStream = transcriptResultStream
        self.type = type
        self.vocabularyName = vocabularyName
    }
}

struct StartMedicalStreamTranscriptionOutputResponseBody: Swift.Equatable {
    public let transcriptResultStream: TranscribeStreamingClientTypes.MedicalTranscriptResultStream?
}

extension StartMedicalStreamTranscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcriptResultStream = "TranscriptResultStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptResultStreamDecoded = try containerValues.decodeIfPresent(TranscribeStreamingClientTypes.MedicalTranscriptResultStream.self, forKey: .transcriptResultStream)
        transcriptResultStream = transcriptResultStreamDecoded
    }
}

public struct StartStreamTranscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStreamTranscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartStreamTranscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartStreamTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let audioStream = input.operationInput.audioStream {
            do {
                let encoder = context.getEncoder()
                let audioStreamdata = try encoder.encode(audioStream)
                let audioStreambody = ClientRuntime.HttpBody.data(audioStreamdata)
                input.builder.withBody(audioStreambody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartStreamTranscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartStreamTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartStreamTranscriptionOutputError>
}

extension StartStreamTranscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartStreamTranscriptionInput(audioStream: \(Swift.String(describing: audioStream)), enableChannelIdentification: \(Swift.String(describing: enableChannelIdentification)), enablePartialResultsStabilization: \(Swift.String(describing: enablePartialResultsStabilization)), languageCode: \(Swift.String(describing: languageCode)), mediaEncoding: \(Swift.String(describing: mediaEncoding)), mediaSampleRateHertz: \(Swift.String(describing: mediaSampleRateHertz)), numberOfChannels: \(Swift.String(describing: numberOfChannels)), partialResultsStability: \(Swift.String(describing: partialResultsStability)), sessionId: \(Swift.String(describing: sessionId)), showSpeakerLabel: \(Swift.String(describing: showSpeakerLabel)), vocabularyFilterMethod: \(Swift.String(describing: vocabularyFilterMethod)), vocabularyFilterName: \(Swift.String(describing: vocabularyFilterName)), vocabularyName: \(Swift.String(describing: vocabularyName)))"}
}

extension StartStreamTranscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioStream = "AudioStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioStream = audioStream {
            try encodeContainer.encode(audioStream, forKey: .audioStream)
        }
    }
}

public struct StartStreamTranscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStreamTranscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartStreamTranscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartStreamTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.enableChannelIdentification != false {
            input.builder.withHeader(name: "x-amzn-transcribe-enable-channel-identification", value: Swift.String(input.operationInput.enableChannelIdentification))
        }
        if input.operationInput.enablePartialResultsStabilization != false {
            input.builder.withHeader(name: "x-amzn-transcribe-enable-partial-results-stabilization", value: Swift.String(input.operationInput.enablePartialResultsStabilization))
        }
        if let languageCode = input.operationInput.languageCode {
            input.builder.withHeader(name: "x-amzn-transcribe-language-code", value: Swift.String(languageCode.rawValue))
        }
        if let mediaEncoding = input.operationInput.mediaEncoding {
            input.builder.withHeader(name: "x-amzn-transcribe-media-encoding", value: Swift.String(mediaEncoding.rawValue))
        }
        if let mediaSampleRateHertz = input.operationInput.mediaSampleRateHertz {
            input.builder.withHeader(name: "x-amzn-transcribe-sample-rate", value: Swift.String(mediaSampleRateHertz))
        }
        if let numberOfChannels = input.operationInput.numberOfChannels {
            input.builder.withHeader(name: "x-amzn-transcribe-number-of-channels", value: Swift.String(numberOfChannels))
        }
        if let partialResultsStability = input.operationInput.partialResultsStability {
            input.builder.withHeader(name: "x-amzn-transcribe-partial-results-stability", value: Swift.String(partialResultsStability.rawValue))
        }
        if let sessionId = input.operationInput.sessionId {
            input.builder.withHeader(name: "x-amzn-transcribe-session-id", value: Swift.String(sessionId))
        }
        if input.operationInput.showSpeakerLabel != false {
            input.builder.withHeader(name: "x-amzn-transcribe-show-speaker-label", value: Swift.String(input.operationInput.showSpeakerLabel))
        }
        if let vocabularyFilterMethod = input.operationInput.vocabularyFilterMethod {
            input.builder.withHeader(name: "x-amzn-transcribe-vocabulary-filter-method", value: Swift.String(vocabularyFilterMethod.rawValue))
        }
        if let vocabularyFilterName = input.operationInput.vocabularyFilterName {
            input.builder.withHeader(name: "x-amzn-transcribe-vocabulary-filter-name", value: Swift.String(vocabularyFilterName))
        }
        if let vocabularyName = input.operationInput.vocabularyName {
            input.builder.withHeader(name: "x-amzn-transcribe-vocabulary-name", value: Swift.String(vocabularyName))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartStreamTranscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartStreamTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartStreamTranscriptionOutputError>
}

public struct StartStreamTranscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStreamTranscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartStreamTranscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartStreamTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartStreamTranscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartStreamTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartStreamTranscriptionOutputError>
}

public struct StartStreamTranscriptionInput: Swift.Equatable {
    /// <p>PCM-encoded stream of audio blobs. The audio stream is encoded as an HTTP2 data
    ///       frame.</p>
    public let audioStream: TranscribeStreamingClientTypes.AudioStream?
    /// <p>When <code>true</code>, instructs Amazon Transcribe to process each audio channel separately and then
    ///       merge the transcription output of each channel into a single transcription.</p>
    ///          <p>Amazon Transcribe also produces a transcription of each item. An item includes the start time, end
    ///       time, and any alternative transcriptions.</p>
    ///          <p>You can't set both <code>ShowSpeakerLabel</code> and
    ///         <code>EnableChannelIdentification</code> in the same request. If you set both, your request
    ///       returns a <code>BadRequestException</code>.</p>
    public let enableChannelIdentification: Swift.Bool
    /// <p>When <code>true</code>, instructs Amazon Transcribe to present transcription results that have the
    ///       partial results stabilized. Normally, any word or phrase from one partial result can change in
    ///       a subsequent partial result. With partial results stabilization enabled, only the last few
    ///       words of one partial result can change in another partial result.</p>
    public let enablePartialResultsStabilization: Swift.Bool
    /// <p>Indicates the source language used in the input audio stream.</p>
    public let languageCode: TranscribeStreamingClientTypes.LanguageCode?
    /// <p>The encoding used for the input audio.</p>
    public let mediaEncoding: TranscribeStreamingClientTypes.MediaEncoding?
    /// <p>The sample rate, in Hertz, of the input audio. We suggest that you use 8000 Hz for low
    ///       quality audio and 16000 Hz for high quality audio.</p>
    public let mediaSampleRateHertz: Swift.Int?
    /// <p>The number of channels that are in your audio stream.</p>
    public let numberOfChannels: Swift.Int?
    /// <p>You can use this field to set the stability level of the transcription results. A higher
    ///       stability level means that the transcription results are less likely to change. Higher
    ///       stability levels can come with lower overall transcription accuracy.</p>
    public let partialResultsStability: TranscribeStreamingClientTypes.PartialResultsStability?
    /// <p>A identifier for the transcription session. Use this parameter when you want to retry a
    ///       session. If you don't provide a session ID, Amazon Transcribe will generate one for you and return it in
    ///       the response.</p>
    public let sessionId: Swift.String?
    /// <p>When <code>true</code>, enables speaker identification in your real-time stream.</p>
    public let showSpeakerLabel: Swift.Bool
    /// <p>The manner in which you use your vocabulary filter to filter words in your transcript.
    ///         <code>Remove</code> removes filtered words from your transcription results.
    ///         <code>Mask</code> masks those words with a <code>***</code> in your transcription results.
    ///         <code>Tag</code> keeps the filtered words in your transcription results and tags them. The
    ///       tag appears as <code>VocabularyFilterMatch</code> equal to <code>True</code>
    ///          </p>
    public let vocabularyFilterMethod: TranscribeStreamingClientTypes.VocabularyFilterMethod?
    /// <p>The name of the vocabulary filter you've created that is unique to your AWS account.
    ///       Provide the name in this field to successfully use it in a stream.</p>
    public let vocabularyFilterName: Swift.String?
    /// <p>The name of the vocabulary to use when processing the transcription job.</p>
    public let vocabularyName: Swift.String?

    public init (
        audioStream: TranscribeStreamingClientTypes.AudioStream? = nil,
        enableChannelIdentification: Swift.Bool = false,
        enablePartialResultsStabilization: Swift.Bool = false,
        languageCode: TranscribeStreamingClientTypes.LanguageCode? = nil,
        mediaEncoding: TranscribeStreamingClientTypes.MediaEncoding? = nil,
        mediaSampleRateHertz: Swift.Int? = nil,
        numberOfChannels: Swift.Int? = nil,
        partialResultsStability: TranscribeStreamingClientTypes.PartialResultsStability? = nil,
        sessionId: Swift.String? = nil,
        showSpeakerLabel: Swift.Bool = false,
        vocabularyFilterMethod: TranscribeStreamingClientTypes.VocabularyFilterMethod? = nil,
        vocabularyFilterName: Swift.String? = nil,
        vocabularyName: Swift.String? = nil
    )
    {
        self.audioStream = audioStream
        self.enableChannelIdentification = enableChannelIdentification
        self.enablePartialResultsStabilization = enablePartialResultsStabilization
        self.languageCode = languageCode
        self.mediaEncoding = mediaEncoding
        self.mediaSampleRateHertz = mediaSampleRateHertz
        self.numberOfChannels = numberOfChannels
        self.partialResultsStability = partialResultsStability
        self.sessionId = sessionId
        self.showSpeakerLabel = showSpeakerLabel
        self.vocabularyFilterMethod = vocabularyFilterMethod
        self.vocabularyFilterName = vocabularyFilterName
        self.vocabularyName = vocabularyName
    }
}

struct StartStreamTranscriptionInputBody: Swift.Equatable {
    public let audioStream: TranscribeStreamingClientTypes.AudioStream?
}

extension StartStreamTranscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioStream = "AudioStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(TranscribeStreamingClientTypes.AudioStream.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

extension StartStreamTranscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartStreamTranscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartStreamTranscriptionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartStreamTranscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartStreamTranscriptionOutputResponse(enableChannelIdentification: \(Swift.String(describing: enableChannelIdentification)), enablePartialResultsStabilization: \(Swift.String(describing: enablePartialResultsStabilization)), languageCode: \(Swift.String(describing: languageCode)), mediaEncoding: \(Swift.String(describing: mediaEncoding)), mediaSampleRateHertz: \(Swift.String(describing: mediaSampleRateHertz)), numberOfChannels: \(Swift.String(describing: numberOfChannels)), partialResultsStability: \(Swift.String(describing: partialResultsStability)), requestId: \(Swift.String(describing: requestId)), sessionId: \(Swift.String(describing: sessionId)), showSpeakerLabel: \(Swift.String(describing: showSpeakerLabel)), transcriptResultStream: \(Swift.String(describing: transcriptResultStream)), vocabularyFilterMethod: \(Swift.String(describing: vocabularyFilterMethod)), vocabularyFilterName: \(Swift.String(describing: vocabularyFilterName)), vocabularyName: \(Swift.String(describing: vocabularyName)))"}
}

extension StartStreamTranscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let enableChannelIdentificationHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-enable-channel-identification") {
            self.enableChannelIdentification = Swift.Bool(enableChannelIdentificationHeaderValue) ?? false
        } else {
            self.enableChannelIdentification = false
        }
        if let enablePartialResultsStabilizationHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-enable-partial-results-stabilization") {
            self.enablePartialResultsStabilization = Swift.Bool(enablePartialResultsStabilizationHeaderValue) ?? false
        } else {
            self.enablePartialResultsStabilization = false
        }
        if let languageCodeHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-language-code") {
            self.languageCode = TranscribeStreamingClientTypes.LanguageCode(rawValue: languageCodeHeaderValue)
        } else {
            self.languageCode = nil
        }
        if let mediaEncodingHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-media-encoding") {
            self.mediaEncoding = TranscribeStreamingClientTypes.MediaEncoding(rawValue: mediaEncodingHeaderValue)
        } else {
            self.mediaEncoding = nil
        }
        if let mediaSampleRateHertzHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-sample-rate") {
            self.mediaSampleRateHertz = Swift.Int(mediaSampleRateHertzHeaderValue) ?? 0
        } else {
            self.mediaSampleRateHertz = nil
        }
        if let numberOfChannelsHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-number-of-channels") {
            self.numberOfChannels = Swift.Int(numberOfChannelsHeaderValue) ?? 0
        } else {
            self.numberOfChannels = nil
        }
        if let partialResultsStabilityHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-partial-results-stability") {
            self.partialResultsStability = TranscribeStreamingClientTypes.PartialResultsStability(rawValue: partialResultsStabilityHeaderValue)
        } else {
            self.partialResultsStability = nil
        }
        if let requestIdHeaderValue = httpResponse.headers.value(for: "x-amzn-request-id") {
            self.requestId = requestIdHeaderValue
        } else {
            self.requestId = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if let showSpeakerLabelHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-show-speaker-label") {
            self.showSpeakerLabel = Swift.Bool(showSpeakerLabelHeaderValue) ?? false
        } else {
            self.showSpeakerLabel = false
        }
        if let vocabularyFilterMethodHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-vocabulary-filter-method") {
            self.vocabularyFilterMethod = TranscribeStreamingClientTypes.VocabularyFilterMethod(rawValue: vocabularyFilterMethodHeaderValue)
        } else {
            self.vocabularyFilterMethod = nil
        }
        if let vocabularyFilterNameHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-vocabulary-filter-name") {
            self.vocabularyFilterName = vocabularyFilterNameHeaderValue
        } else {
            self.vocabularyFilterName = nil
        }
        if let vocabularyNameHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-vocabulary-name") {
            self.vocabularyName = vocabularyNameHeaderValue
        } else {
            self.vocabularyName = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: TranscribeStreamingClientTypes.TranscriptResultStream = try responseDecoder.decode(responseBody: data)
                self.transcriptResultStream = output
            } else {
                self.transcriptResultStream = nil
            }
        } else {
            self.transcriptResultStream = nil
        }
    }
}

public struct StartStreamTranscriptionOutputResponse: Swift.Equatable {
    /// <p>Shows whether channel identification has been enabled in the stream.</p>
    public let enableChannelIdentification: Swift.Bool
    /// <p>Shows whether partial results stabilization has been enabled in the stream.</p>
    public let enablePartialResultsStabilization: Swift.Bool
    /// <p>The language code for the input audio stream.</p>
    public let languageCode: TranscribeStreamingClientTypes.LanguageCode?
    /// <p>The encoding used for the input audio stream.</p>
    public let mediaEncoding: TranscribeStreamingClientTypes.MediaEncoding?
    /// <p>The sample rate for the input audio stream. Use 8000 Hz for low quality audio and 16000 Hz
    ///       for high quality audio.</p>
    public let mediaSampleRateHertz: Swift.Int?
    /// <p>The number of channels identified in the stream.</p>
    public let numberOfChannels: Swift.Int?
    /// <p>If partial results stabilization has been enabled in the stream, shows the stability
    ///       level.</p>
    public let partialResultsStability: TranscribeStreamingClientTypes.PartialResultsStability?
    /// <p>An identifier for the streaming transcription.</p>
    public let requestId: Swift.String?
    /// <p>An identifier for a specific transcription session.</p>
    public let sessionId: Swift.String?
    /// <p>Shows whether speaker identification was enabled in the stream.</p>
    public let showSpeakerLabel: Swift.Bool
    /// <p>Represents the stream of transcription events from Amazon Transcribe to your application.</p>
    public let transcriptResultStream: TranscribeStreamingClientTypes.TranscriptResultStream?
    /// <p>The vocabulary filtering method used in the real-time stream.</p>
    public let vocabularyFilterMethod: TranscribeStreamingClientTypes.VocabularyFilterMethod?
    /// <p>The name of the vocabulary filter used in your real-time stream.</p>
    public let vocabularyFilterName: Swift.String?
    /// <p>The name of the vocabulary used when processing the stream.</p>
    public let vocabularyName: Swift.String?

    public init (
        enableChannelIdentification: Swift.Bool = false,
        enablePartialResultsStabilization: Swift.Bool = false,
        languageCode: TranscribeStreamingClientTypes.LanguageCode? = nil,
        mediaEncoding: TranscribeStreamingClientTypes.MediaEncoding? = nil,
        mediaSampleRateHertz: Swift.Int? = nil,
        numberOfChannels: Swift.Int? = nil,
        partialResultsStability: TranscribeStreamingClientTypes.PartialResultsStability? = nil,
        requestId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        showSpeakerLabel: Swift.Bool = false,
        transcriptResultStream: TranscribeStreamingClientTypes.TranscriptResultStream? = nil,
        vocabularyFilterMethod: TranscribeStreamingClientTypes.VocabularyFilterMethod? = nil,
        vocabularyFilterName: Swift.String? = nil,
        vocabularyName: Swift.String? = nil
    )
    {
        self.enableChannelIdentification = enableChannelIdentification
        self.enablePartialResultsStabilization = enablePartialResultsStabilization
        self.languageCode = languageCode
        self.mediaEncoding = mediaEncoding
        self.mediaSampleRateHertz = mediaSampleRateHertz
        self.numberOfChannels = numberOfChannels
        self.partialResultsStability = partialResultsStability
        self.requestId = requestId
        self.sessionId = sessionId
        self.showSpeakerLabel = showSpeakerLabel
        self.transcriptResultStream = transcriptResultStream
        self.vocabularyFilterMethod = vocabularyFilterMethod
        self.vocabularyFilterName = vocabularyFilterName
        self.vocabularyName = vocabularyName
    }
}

struct StartStreamTranscriptionOutputResponseBody: Swift.Equatable {
    public let transcriptResultStream: TranscribeStreamingClientTypes.TranscriptResultStream?
}

extension StartStreamTranscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcriptResultStream = "TranscriptResultStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptResultStreamDecoded = try containerValues.decodeIfPresent(TranscribeStreamingClientTypes.TranscriptResultStream.self, forKey: .transcriptResultStream)
        transcriptResultStream = transcriptResultStreamDecoded
    }
}

extension TranscribeStreamingClientTypes.Transcript: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let results = results {
            var resultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .results)
            for resultlist0 in results {
                try resultsContainer.encode(resultlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([TranscribeStreamingClientTypes.Result?].self, forKey: .results)
        var resultsDecoded0:[TranscribeStreamingClientTypes.Result]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [TranscribeStreamingClientTypes.Result]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

extension TranscribeStreamingClientTypes.Transcript: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Transcript(results: \(Swift.String(describing: results)))"}
}

extension TranscribeStreamingClientTypes {
    /// <p>The transcription in a <a>TranscriptEvent</a>.</p>
    public struct Transcript: Swift.Equatable {
        /// <p>
        ///             <a>Result</a> objects that contain the results of transcribing a portion of the
        ///       input audio stream. The array can be empty.</p>
        public let results: [TranscribeStreamingClientTypes.Result]?

        public init (
            results: [TranscribeStreamingClientTypes.Result]? = nil
        )
        {
            self.results = results
        }
    }

}

extension TranscribeStreamingClientTypes.TranscriptEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcript = "Transcript"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transcript = transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptDecoded = try containerValues.decodeIfPresent(TranscribeStreamingClientTypes.Transcript.self, forKey: .transcript)
        transcript = transcriptDecoded
    }
}

extension TranscribeStreamingClientTypes.TranscriptEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TranscriptEvent(transcript: \(Swift.String(describing: transcript)))"}
}

extension TranscribeStreamingClientTypes {
    /// <p>Represents a set of transcription results from the server to the client. It contains one
    ///       or more segments of the transcription.</p>
    public struct TranscriptEvent: Swift.Equatable {
        /// <p>The transcription of the audio stream. The transcription is composed of all of the items
        ///       in the results list.</p>
        public let transcript: TranscribeStreamingClientTypes.Transcript?

        public init (
            transcript: TranscribeStreamingClientTypes.Transcript? = nil
        )
        {
            self.transcript = transcript
        }
    }

}

extension TranscribeStreamingClientTypes.TranscriptResultStream: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case badrequestexception = "BadRequestException"
        case conflictexception = "ConflictException"
        case internalfailureexception = "InternalFailureException"
        case limitexceededexception = "LimitExceededException"
        case serviceunavailableexception = "ServiceUnavailableException"
        case transcriptevent = "TranscriptEvent"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .badrequestexception(badrequestexception):
                try container.encode(badrequestexception, forKey: .badrequestexception)
            case let .conflictexception(conflictexception):
                try container.encode(conflictexception, forKey: .conflictexception)
            case let .internalfailureexception(internalfailureexception):
                try container.encode(internalfailureexception, forKey: .internalfailureexception)
            case let .limitexceededexception(limitexceededexception):
                try container.encode(limitexceededexception, forKey: .limitexceededexception)
            case let .serviceunavailableexception(serviceunavailableexception):
                try container.encode(serviceunavailableexception, forKey: .serviceunavailableexception)
            case let .transcriptevent(transcriptevent):
                try container.encode(transcriptevent, forKey: .transcriptevent)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let transcripteventDecoded = try values.decodeIfPresent(TranscribeStreamingClientTypes.TranscriptEvent.self, forKey: .transcriptevent)
        if let transcriptevent = transcripteventDecoded {
            self = .transcriptevent(transcriptevent)
            return
        }
        let badrequestexceptionDecoded = try values.decodeIfPresent(BadRequestException.self, forKey: .badrequestexception)
        if let badrequestexception = badrequestexceptionDecoded {
            self = .badrequestexception(badrequestexception)
            return
        }
        let limitexceededexceptionDecoded = try values.decodeIfPresent(LimitExceededException.self, forKey: .limitexceededexception)
        if let limitexceededexception = limitexceededexceptionDecoded {
            self = .limitexceededexception(limitexceededexception)
            return
        }
        let internalfailureexceptionDecoded = try values.decodeIfPresent(InternalFailureException.self, forKey: .internalfailureexception)
        if let internalfailureexception = internalfailureexceptionDecoded {
            self = .internalfailureexception(internalfailureexception)
            return
        }
        let conflictexceptionDecoded = try values.decodeIfPresent(ConflictException.self, forKey: .conflictexception)
        if let conflictexception = conflictexceptionDecoded {
            self = .conflictexception(conflictexception)
            return
        }
        let serviceunavailableexceptionDecoded = try values.decodeIfPresent(ServiceUnavailableException.self, forKey: .serviceunavailableexception)
        if let serviceunavailableexception = serviceunavailableexceptionDecoded {
            self = .serviceunavailableexception(serviceunavailableexception)
            return
        }
        self = .sdkUnknown("")
    }
}

extension TranscribeStreamingClientTypes {
    /// <p>Represents the transcription result stream from Amazon Transcribe to your application.</p>
    public enum TranscriptResultStream: Swift.Equatable {
        /// <p>A portion of the transcription of the audio stream. Events are sent periodically from
        ///       Amazon Transcribe to your application. The event can be a partial transcription of a section of the audio
        ///       stream, or it can be the entire transcription of that portion of the audio stream.
        ///       </p>
        case transcriptevent(TranscribeStreamingClientTypes.TranscriptEvent)
        /// <p>A client error occurred when the stream was created. Check the parameters of the request
        ///       and try your request again.</p>
        case badrequestexception(BadRequestException)
        /// <p>Your client has exceeded one of the Amazon Transcribe limits, typically the limit on audio length.
        ///       Break your audio stream into smaller chunks and try your request again.</p>
        case limitexceededexception(LimitExceededException)
        /// <p>A problem occurred while processing the audio. Amazon Transcribe terminated processing.</p>
        case internalfailureexception(InternalFailureException)
        /// <p>A new stream started with the same session ID. The current stream has been
        ///       terminated.</p>
        case conflictexception(ConflictException)
        /// <p>Service is currently unavailable. Try your request later.</p>
        case serviceunavailableexception(ServiceUnavailableException)
        case sdkUnknown(Swift.String)
    }

}

extension TranscribeStreamingClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conversation
        case dictation
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .conversation,
                .dictation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conversation: return "CONVERSATION"
            case .dictation: return "DICTATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension TranscribeStreamingClientTypes {
    public enum VocabularyFilterMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mask
        case remove
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [VocabularyFilterMethod] {
            return [
                .mask,
                .remove,
                .tag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mask: return "mask"
            case .remove: return "remove"
            case .tag: return "tag"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VocabularyFilterMethod(rawValue: rawValue) ?? VocabularyFilterMethod.sdkUnknown(rawValue)
        }
    }
}
