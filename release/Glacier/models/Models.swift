// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AbortMultipartUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AbortMultipartUploadInput(accountId: \(Swift.String(describing: accountId)), uploadId: \(Swift.String(describing: uploadId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension AbortMultipartUploadInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct AbortMultipartUploadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AbortMultipartUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AbortMultipartUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AbortMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AbortMultipartUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AbortMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AbortMultipartUploadOutputError>
}

public struct AbortMultipartUploadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AbortMultipartUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AbortMultipartUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AbortMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AbortMultipartUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AbortMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AbortMultipartUploadOutputError>
}

/// <p>Provides options to abort a multipart upload identified by the upload ID.</p>
///
///          <p>For information about the underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-abort-upload.html">Abort Multipart
///             Upload</a>. For conceptual information, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html">Working with Archives in
///             Amazon S3 Glacier</a>.</p>
public struct AbortMultipartUploadInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The upload ID of the multipart upload to delete.</p>
    public let uploadId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        uploadId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.uploadId = uploadId
        self.vaultName = vaultName
    }
}

struct AbortMultipartUploadInputBody: Swift.Equatable {
}

extension AbortMultipartUploadInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AbortMultipartUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AbortMultipartUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AbortMultipartUploadOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AbortMultipartUploadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AbortMultipartUploadOutputResponse()"}
}

extension AbortMultipartUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AbortMultipartUploadOutputResponse: Swift.Equatable {

    public init() {}
}

struct AbortMultipartUploadOutputResponseBody: Swift.Equatable {
}

extension AbortMultipartUploadOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AbortVaultLockInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AbortVaultLockInput(accountId: \(Swift.String(describing: accountId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension AbortVaultLockInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct AbortVaultLockInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AbortVaultLockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AbortVaultLockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AbortVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AbortVaultLockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AbortVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AbortVaultLockOutputError>
}

public struct AbortVaultLockInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AbortVaultLockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AbortVaultLockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AbortVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AbortVaultLockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AbortVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AbortVaultLockOutputError>
}

/// <p>The input values for <code>AbortVaultLock</code>.</p>
public struct AbortVaultLockInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID. This value must match the AWS
    ///          account ID associated with the credentials used to sign the request. You can either specify
    ///          an AWS account ID or optionally a single '<code>-</code>' (hyphen), in which case Amazon
    ///          Glacier uses the AWS account ID associated with the credentials used to sign the request.
    ///          If you specify your account ID, do not include any hyphens ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct AbortVaultLockInputBody: Swift.Equatable {
}

extension AbortVaultLockInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AbortVaultLockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AbortVaultLockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AbortVaultLockOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AbortVaultLockOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AbortVaultLockOutputResponse()"}
}

extension AbortVaultLockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AbortVaultLockOutputResponse: Swift.Equatable {

    public init() {}
}

struct AbortVaultLockOutputResponseBody: Swift.Equatable {
}

extension AbortVaultLockOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GlacierClientTypes {
    public enum ActionCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archiveretrieval
        case inventoryretrieval
        case select
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionCode] {
            return [
                .archiveretrieval,
                .inventoryretrieval,
                .select,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archiveretrieval: return "ArchiveRetrieval"
            case .inventoryretrieval: return "InventoryRetrieval"
            case .select: return "Select"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionCode(rawValue: rawValue) ?? ActionCode.sdkUnknown(rawValue)
        }
    }
}

public struct AddTagsToVaultInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToVaultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToVaultOutputError>
}

extension AddTagsToVaultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToVaultInput(tags: \(Swift.String(describing: tags)), accountId: \(Swift.String(describing: accountId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension AddTagsToVaultInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct AddTagsToVaultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToVaultOutputError>
}

public struct AddTagsToVaultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "add"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToVaultOutputError>
}

/// <p>The input values for <code>AddTagsToVault</code>.</p>
public struct AddTagsToVaultInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The tags to add to the vault. Each tag is composed of a key and a value. The value
    ///          can be an empty string.</p>
    public let tags: [Swift.String:Swift.String]?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.tags = tags
        self.vaultName = vaultName
    }
}

struct AddTagsToVaultInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension AddTagsToVaultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToVaultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToVaultOutputResponse()"}
}

extension AddTagsToVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsToVaultOutputResponse: Swift.Equatable {

    public init() {}
}

struct AddTagsToVaultOutputResponseBody: Swift.Equatable {
}

extension AddTagsToVaultOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GlacierClientTypes.CSVInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comments = "Comments"
        case fieldDelimiter = "FieldDelimiter"
        case fileHeaderInfo = "FileHeaderInfo"
        case quoteCharacter = "QuoteCharacter"
        case quoteEscapeCharacter = "QuoteEscapeCharacter"
        case recordDelimiter = "RecordDelimiter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comments = comments {
            try encodeContainer.encode(comments, forKey: .comments)
        }
        if let fieldDelimiter = fieldDelimiter {
            try encodeContainer.encode(fieldDelimiter, forKey: .fieldDelimiter)
        }
        if let fileHeaderInfo = fileHeaderInfo {
            try encodeContainer.encode(fileHeaderInfo.rawValue, forKey: .fileHeaderInfo)
        }
        if let quoteCharacter = quoteCharacter {
            try encodeContainer.encode(quoteCharacter, forKey: .quoteCharacter)
        }
        if let quoteEscapeCharacter = quoteEscapeCharacter {
            try encodeContainer.encode(quoteEscapeCharacter, forKey: .quoteEscapeCharacter)
        }
        if let recordDelimiter = recordDelimiter {
            try encodeContainer.encode(recordDelimiter, forKey: .recordDelimiter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileHeaderInfoDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.FileHeaderInfo.self, forKey: .fileHeaderInfo)
        fileHeaderInfo = fileHeaderInfoDecoded
        let commentsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comments)
        comments = commentsDecoded
        let quoteEscapeCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quoteEscapeCharacter)
        quoteEscapeCharacter = quoteEscapeCharacterDecoded
        let recordDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordDelimiter)
        recordDelimiter = recordDelimiterDecoded
        let fieldDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldDelimiter)
        fieldDelimiter = fieldDelimiterDecoded
        let quoteCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quoteCharacter)
        quoteCharacter = quoteCharacterDecoded
    }
}

extension GlacierClientTypes.CSVInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CSVInput(comments: \(Swift.String(describing: comments)), fieldDelimiter: \(Swift.String(describing: fieldDelimiter)), fileHeaderInfo: \(Swift.String(describing: fileHeaderInfo)), quoteCharacter: \(Swift.String(describing: quoteCharacter)), quoteEscapeCharacter: \(Swift.String(describing: quoteEscapeCharacter)), recordDelimiter: \(Swift.String(describing: recordDelimiter)))"}
}

extension GlacierClientTypes {
    /// <p>Contains information about the comma-separated value (CSV) file to select from.</p>
    public struct CSVInput: Swift.Equatable {
        /// <p>A single character used to indicate that a row should be ignored when the character is
        ///             present at the start of that row.</p>
        public let comments: Swift.String?
        /// <p>A value used to separate individual fields from each other within a record.</p>
        public let fieldDelimiter: Swift.String?
        /// <p>Describes the first line of input. Valid values are <code>None</code>,
        ///                 <code>Ignore</code>, and <code>Use</code>.</p>
        public let fileHeaderInfo: GlacierClientTypes.FileHeaderInfo?
        /// <p>A value used as an escape character where the field delimiter is part of the
        ///             value.</p>
        public let quoteCharacter: Swift.String?
        /// <p>A single character used for escaping the quotation-mark character inside an already
        ///             escaped value.</p>
        public let quoteEscapeCharacter: Swift.String?
        /// <p>A value used to separate individual records from each other.</p>
        public let recordDelimiter: Swift.String?

        public init (
            comments: Swift.String? = nil,
            fieldDelimiter: Swift.String? = nil,
            fileHeaderInfo: GlacierClientTypes.FileHeaderInfo? = nil,
            quoteCharacter: Swift.String? = nil,
            quoteEscapeCharacter: Swift.String? = nil,
            recordDelimiter: Swift.String? = nil
        )
        {
            self.comments = comments
            self.fieldDelimiter = fieldDelimiter
            self.fileHeaderInfo = fileHeaderInfo
            self.quoteCharacter = quoteCharacter
            self.quoteEscapeCharacter = quoteEscapeCharacter
            self.recordDelimiter = recordDelimiter
        }
    }

}

extension GlacierClientTypes.CSVOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldDelimiter = "FieldDelimiter"
        case quoteCharacter = "QuoteCharacter"
        case quoteEscapeCharacter = "QuoteEscapeCharacter"
        case quoteFields = "QuoteFields"
        case recordDelimiter = "RecordDelimiter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldDelimiter = fieldDelimiter {
            try encodeContainer.encode(fieldDelimiter, forKey: .fieldDelimiter)
        }
        if let quoteCharacter = quoteCharacter {
            try encodeContainer.encode(quoteCharacter, forKey: .quoteCharacter)
        }
        if let quoteEscapeCharacter = quoteEscapeCharacter {
            try encodeContainer.encode(quoteEscapeCharacter, forKey: .quoteEscapeCharacter)
        }
        if let quoteFields = quoteFields {
            try encodeContainer.encode(quoteFields.rawValue, forKey: .quoteFields)
        }
        if let recordDelimiter = recordDelimiter {
            try encodeContainer.encode(recordDelimiter, forKey: .recordDelimiter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quoteFieldsDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.QuoteFields.self, forKey: .quoteFields)
        quoteFields = quoteFieldsDecoded
        let quoteEscapeCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quoteEscapeCharacter)
        quoteEscapeCharacter = quoteEscapeCharacterDecoded
        let recordDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordDelimiter)
        recordDelimiter = recordDelimiterDecoded
        let fieldDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldDelimiter)
        fieldDelimiter = fieldDelimiterDecoded
        let quoteCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quoteCharacter)
        quoteCharacter = quoteCharacterDecoded
    }
}

extension GlacierClientTypes.CSVOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CSVOutput(fieldDelimiter: \(Swift.String(describing: fieldDelimiter)), quoteCharacter: \(Swift.String(describing: quoteCharacter)), quoteEscapeCharacter: \(Swift.String(describing: quoteEscapeCharacter)), quoteFields: \(Swift.String(describing: quoteFields)), recordDelimiter: \(Swift.String(describing: recordDelimiter)))"}
}

extension GlacierClientTypes {
    /// <p>Contains information about the comma-separated value (CSV) file that the job results
    ///             are stored in.</p>
    public struct CSVOutput: Swift.Equatable {
        /// <p>A value used to separate individual fields from each other within a record.</p>
        public let fieldDelimiter: Swift.String?
        /// <p>A value used as an escape character where the field delimiter is part of the
        ///             value.</p>
        public let quoteCharacter: Swift.String?
        /// <p>A single character used for escaping the quotation-mark character inside an already
        ///             escaped value.</p>
        public let quoteEscapeCharacter: Swift.String?
        /// <p>A value that indicates whether all output fields should be contained within quotation
        ///             marks.</p>
        public let quoteFields: GlacierClientTypes.QuoteFields?
        /// <p>A value used to separate individual records from each other.</p>
        public let recordDelimiter: Swift.String?

        public init (
            fieldDelimiter: Swift.String? = nil,
            quoteCharacter: Swift.String? = nil,
            quoteEscapeCharacter: Swift.String? = nil,
            quoteFields: GlacierClientTypes.QuoteFields? = nil,
            recordDelimiter: Swift.String? = nil
        )
        {
            self.fieldDelimiter = fieldDelimiter
            self.quoteCharacter = quoteCharacter
            self.quoteEscapeCharacter = quoteEscapeCharacter
            self.quoteFields = quoteFields
            self.recordDelimiter = recordDelimiter
        }
    }

}

extension GlacierClientTypes {
    public enum CannedACL: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedread
        case awsexecread
        case bucketownerfullcontrol
        case bucketownerread
        case `private`
        case publicread
        case publicreadwrite
        case sdkUnknown(Swift.String)

        public static var allCases: [CannedACL] {
            return [
                .authenticatedread,
                .awsexecread,
                .bucketownerfullcontrol,
                .bucketownerread,
                .private,
                .publicread,
                .publicreadwrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedread: return "authenticated-read"
            case .awsexecread: return "aws-exec-read"
            case .bucketownerfullcontrol: return "bucket-owner-full-control"
            case .bucketownerread: return "bucket-owner-read"
            case .private: return "private"
            case .publicread: return "public-read"
            case .publicreadwrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CannedACL(rawValue: rawValue) ?? CannedACL.sdkUnknown(rawValue)
        }
    }
}

extension CompleteMultipartUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompleteMultipartUploadInput(accountId: \(Swift.String(describing: accountId)), archiveSize: \(Swift.String(describing: archiveSize)), checksum: \(Swift.String(describing: checksum)), uploadId: \(Swift.String(describing: uploadId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension CompleteMultipartUploadInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct CompleteMultipartUploadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteMultipartUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteMultipartUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let archiveSize = input.operationInput.archiveSize {
            input.builder.withHeader(name: "x-amz-archive-size", value: Swift.String(archiveSize))
        }
        if let checksum = input.operationInput.checksum {
            input.builder.withHeader(name: "x-amz-sha256-tree-hash", value: Swift.String(checksum))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteMultipartUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteMultipartUploadOutputError>
}

public struct CompleteMultipartUploadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteMultipartUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteMultipartUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteMultipartUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteMultipartUploadOutputError>
}

/// <p>Provides options to complete a multipart upload operation. This informs Amazon
///          Glacier that all the archive parts have been uploaded and Amazon S3 Glacier (Glacier) can now assemble
///          the archive from the uploaded parts. After assembling and saving the archive to the vault,
///          Glacier returns the URI path of the newly created archive resource.</p>
public struct CompleteMultipartUploadInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The total size, in bytes, of the entire archive. This value should be the sum of all
    ///          the sizes of the individual parts that you uploaded.</p>
    public let archiveSize: Swift.String?
    /// <p>The SHA256 tree hash of the entire archive. It is the tree hash of SHA256 tree hash
    ///          of the individual parts. If the value you specify in the request does not match the SHA256
    ///          tree hash of the final assembled archive as computed by Amazon S3 Glacier (Glacier),
    ///          Glacier returns an error and the request fails.</p>
    public let checksum: Swift.String?
    /// <p>The upload ID of the multipart upload.</p>
    public let uploadId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        archiveSize: Swift.String? = nil,
        checksum: Swift.String? = nil,
        uploadId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.archiveSize = archiveSize
        self.checksum = checksum
        self.uploadId = uploadId
        self.vaultName = vaultName
    }
}

struct CompleteMultipartUploadInputBody: Swift.Equatable {
}

extension CompleteMultipartUploadInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CompleteMultipartUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteMultipartUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CompleteMultipartUploadOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteMultipartUploadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompleteMultipartUploadOutputResponse(archiveId: \(Swift.String(describing: archiveId)), checksum: \(Swift.String(describing: checksum)), location: \(Swift.String(describing: location)))"}
}

extension CompleteMultipartUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let archiveIdHeaderValue = httpResponse.headers.value(for: "x-amz-archive-id") {
            self.archiveId = archiveIdHeaderValue
        } else {
            self.archiveId = nil
        }
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-sha256-tree-hash") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
///          <p>For information about the underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-post.html">Upload Archive</a>. For
///          conceptual information, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html">Working with Archives in
///             Amazon S3 Glacier</a>.</p>
public struct CompleteMultipartUploadOutputResponse: Swift.Equatable {
    /// <p>The ID of the archive. This value is also included as part of the location.</p>
    public let archiveId: Swift.String?
    /// <p>The checksum of the archive computed by Amazon S3 Glacier.</p>
    public let checksum: Swift.String?
    /// <p>The relative URI path of the newly added archive resource.</p>
    public let location: Swift.String?

    public init (
        archiveId: Swift.String? = nil,
        checksum: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.archiveId = archiveId
        self.checksum = checksum
        self.location = location
    }
}

struct CompleteMultipartUploadOutputResponseBody: Swift.Equatable {
}

extension CompleteMultipartUploadOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CompleteVaultLockInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompleteVaultLockInput(accountId: \(Swift.String(describing: accountId)), lockId: \(Swift.String(describing: lockId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension CompleteVaultLockInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct CompleteVaultLockInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteVaultLockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteVaultLockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteVaultLockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteVaultLockOutputError>
}

public struct CompleteVaultLockInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteVaultLockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteVaultLockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteVaultLockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteVaultLockOutputError>
}

/// <p>The input values for <code>CompleteVaultLock</code>.</p>
public struct CompleteVaultLockInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID. This value must match the AWS
    ///          account ID associated with the credentials used to sign the request. You can either specify
    ///          an AWS account ID or optionally a single '<code>-</code>' (hyphen), in which case Amazon
    ///          Glacier uses the AWS account ID associated with the credentials used to sign the request.
    ///          If you specify your account ID, do not include any hyphens ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The <code>lockId</code> value is the lock ID obtained from a <a>InitiateVaultLock</a> request.</p>
    public let lockId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        lockId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.lockId = lockId
        self.vaultName = vaultName
    }
}

struct CompleteVaultLockInputBody: Swift.Equatable {
}

extension CompleteVaultLockInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CompleteVaultLockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteVaultLockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CompleteVaultLockOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteVaultLockOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompleteVaultLockOutputResponse()"}
}

extension CompleteVaultLockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CompleteVaultLockOutputResponse: Swift.Equatable {

    public init() {}
}

struct CompleteVaultLockOutputResponseBody: Swift.Equatable {
}

extension CompleteVaultLockOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CreateVaultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVaultInput(accountId: \(Swift.String(describing: accountId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension CreateVaultInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct CreateVaultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVaultOutputError>
}

public struct CreateVaultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVaultOutputError>
}

/// <p>Provides options to create a vault.</p>
public struct CreateVaultInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID. This value must match the AWS
    ///          account ID associated with the credentials used to sign the request. You can either specify
    ///          an AWS account ID or optionally a single '<code>-</code>' (hyphen), in which case Amazon S3
    ///          Glacier uses the AWS account ID associated with the credentials used to sign the request.
    ///          If you specify your account ID, do not include any hyphens ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct CreateVaultInputBody: Swift.Equatable {
}

extension CreateVaultInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CreateVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVaultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVaultOutputResponse(location: \(Swift.String(describing: location)))"}
}

extension CreateVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct CreateVaultOutputResponse: Swift.Equatable {
    /// <p>The URI of the vault that was created.</p>
    public let location: Swift.String?

    public init (
        location: Swift.String? = nil
    )
    {
        self.location = location
    }
}

struct CreateVaultOutputResponseBody: Swift.Equatable {
}

extension CreateVaultOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GlacierClientTypes.DataRetrievalPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for dataretrievalruleslist0 in rules {
                try rulesContainer.encode(dataretrievalruleslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([GlacierClientTypes.DataRetrievalRule?].self, forKey: .rules)
        var rulesDecoded0:[GlacierClientTypes.DataRetrievalRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [GlacierClientTypes.DataRetrievalRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension GlacierClientTypes.DataRetrievalPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataRetrievalPolicy(rules: \(Swift.String(describing: rules)))"}
}

extension GlacierClientTypes {
    /// <p>Data retrieval policy.</p>
    public struct DataRetrievalPolicy: Swift.Equatable {
        /// <p>The policy rule. Although this is a list type, currently there must be only one rule,
        ///          which contains a Strategy field and optionally a BytesPerHour field.</p>
        public let rules: [GlacierClientTypes.DataRetrievalRule]?

        public init (
            rules: [GlacierClientTypes.DataRetrievalRule]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension GlacierClientTypes.DataRetrievalRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesPerHour = "BytesPerHour"
        case strategy = "Strategy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesPerHour = bytesPerHour {
            try encodeContainer.encode(bytesPerHour, forKey: .bytesPerHour)
        }
        if let strategy = strategy {
            try encodeContainer.encode(strategy, forKey: .strategy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let strategyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .strategy)
        strategy = strategyDecoded
        let bytesPerHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesPerHour)
        bytesPerHour = bytesPerHourDecoded
    }
}

extension GlacierClientTypes.DataRetrievalRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataRetrievalRule(bytesPerHour: \(Swift.String(describing: bytesPerHour)), strategy: \(Swift.String(describing: strategy)))"}
}

extension GlacierClientTypes {
    /// <p>Data retrieval policy rule.</p>
    public struct DataRetrievalRule: Swift.Equatable {
        /// <p>The maximum number of bytes that can be retrieved in an hour.</p>
        ///          <p>This field is required only if the value of the Strategy field is
        ///             <code>BytesPerHour</code>. Your PUT operation will be rejected if the Strategy field is
        ///          not set to <code>BytesPerHour</code> and you set this field.</p>
        public let bytesPerHour: Swift.Int?
        /// <p>The type of data retrieval policy to set.</p>
        ///          <p>Valid values: BytesPerHour|FreeTier|None</p>
        public let strategy: Swift.String?

        public init (
            bytesPerHour: Swift.Int? = nil,
            strategy: Swift.String? = nil
        )
        {
            self.bytesPerHour = bytesPerHour
            self.strategy = strategy
        }
    }

}

extension DeleteArchiveInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteArchiveInput(accountId: \(Swift.String(describing: accountId)), archiveId: \(Swift.String(describing: archiveId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension DeleteArchiveInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteArchiveInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteArchiveOutputError>
}

public struct DeleteArchiveInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteArchiveOutputError>
}

/// <p>Provides options for deleting an archive from an Amazon S3 Glacier vault.</p>
public struct DeleteArchiveInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The ID of the archive to delete.</p>
    public let archiveId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        archiveId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.archiveId = archiveId
        self.vaultName = vaultName
    }
}

struct DeleteArchiveInputBody: Swift.Equatable {
}

extension DeleteArchiveInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteArchiveOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteArchiveOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteArchiveOutputResponse()"}
}

extension DeleteArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteArchiveOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteArchiveOutputResponseBody: Swift.Equatable {
}

extension DeleteArchiveOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVaultAccessPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVaultAccessPolicyInput(accountId: \(Swift.String(describing: accountId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension DeleteVaultAccessPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteVaultAccessPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVaultAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVaultAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVaultAccessPolicyOutputError>
}

public struct DeleteVaultAccessPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVaultAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVaultAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVaultAccessPolicyOutputError>
}

/// <p>DeleteVaultAccessPolicy input.</p>
public struct DeleteVaultAccessPolicyInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct DeleteVaultAccessPolicyInputBody: Swift.Equatable {
}

extension DeleteVaultAccessPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVaultAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVaultAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVaultAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVaultAccessPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVaultAccessPolicyOutputResponse()"}
}

extension DeleteVaultAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVaultAccessPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteVaultAccessPolicyOutputResponseBody: Swift.Equatable {
}

extension DeleteVaultAccessPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVaultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVaultInput(accountId: \(Swift.String(describing: accountId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension DeleteVaultInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteVaultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVaultOutputError>
}

public struct DeleteVaultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVaultOutputError>
}

/// <p>Provides options for deleting a vault from Amazon S3 Glacier.</p>
public struct DeleteVaultInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct DeleteVaultInputBody: Swift.Equatable {
}

extension DeleteVaultInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVaultNotificationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVaultNotificationsInput(accountId: \(Swift.String(describing: accountId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension DeleteVaultNotificationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteVaultNotificationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVaultNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVaultNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVaultNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVaultNotificationsOutputError>
}

public struct DeleteVaultNotificationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVaultNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVaultNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVaultNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVaultNotificationsOutputError>
}

/// <p>Provides options for deleting a vault notification configuration from an Amazon
///          Glacier vault.</p>
public struct DeleteVaultNotificationsInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct DeleteVaultNotificationsInputBody: Swift.Equatable {
}

extension DeleteVaultNotificationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVaultNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVaultNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVaultNotificationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVaultNotificationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVaultNotificationsOutputResponse()"}
}

extension DeleteVaultNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVaultNotificationsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteVaultNotificationsOutputResponseBody: Swift.Equatable {
}

extension DeleteVaultNotificationsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVaultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVaultOutputResponse()"}
}

extension DeleteVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVaultOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteVaultOutputResponseBody: Swift.Equatable {
}

extension DeleteVaultOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeJobInput(accountId: \(Swift.String(describing: accountId)), jobId: \(Swift.String(describing: jobId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension DescribeJobInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeJobOutputError>
}

public struct DescribeJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeJobOutputError>
}

/// <p>Provides options for retrieving a job description.</p>
public struct DescribeJobInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: Swift.String?
    /// <p>The ID of the job to describe.</p>
    public let jobId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.vaultName = vaultName
    }
}

struct DescribeJobInputBody: Swift.Equatable {
}

extension DescribeJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeJobOutputResponse(action: \(Swift.String(describing: action)), archiveId: \(Swift.String(describing: archiveId)), archiveSHA256TreeHash: \(Swift.String(describing: archiveSHA256TreeHash)), archiveSizeInBytes: \(Swift.String(describing: archiveSizeInBytes)), completed: \(Swift.String(describing: completed)), completionDate: \(Swift.String(describing: completionDate)), creationDate: \(Swift.String(describing: creationDate)), inventoryRetrievalParameters: \(Swift.String(describing: inventoryRetrievalParameters)), inventorySizeInBytes: \(Swift.String(describing: inventorySizeInBytes)), jobDescription: \(Swift.String(describing: jobDescription)), jobId: \(Swift.String(describing: jobId)), jobOutputPath: \(Swift.String(describing: jobOutputPath)), outputLocation: \(Swift.String(describing: outputLocation)), retrievalByteRange: \(Swift.String(describing: retrievalByteRange)), sHA256TreeHash: \(Swift.String(describing: sHA256TreeHash)), sNSTopic: \(Swift.String(describing: sNSTopic)), selectParameters: \(Swift.String(describing: selectParameters)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), tier: \(Swift.String(describing: tier)), vaultARN: \(Swift.String(describing: vaultARN)))"}
}

extension DescribeJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.archiveId = output.archiveId
            self.archiveSHA256TreeHash = output.archiveSHA256TreeHash
            self.archiveSizeInBytes = output.archiveSizeInBytes
            self.completed = output.completed
            self.completionDate = output.completionDate
            self.creationDate = output.creationDate
            self.inventoryRetrievalParameters = output.inventoryRetrievalParameters
            self.inventorySizeInBytes = output.inventorySizeInBytes
            self.jobDescription = output.jobDescription
            self.jobId = output.jobId
            self.jobOutputPath = output.jobOutputPath
            self.outputLocation = output.outputLocation
            self.retrievalByteRange = output.retrievalByteRange
            self.sHA256TreeHash = output.sHA256TreeHash
            self.sNSTopic = output.sNSTopic
            self.selectParameters = output.selectParameters
            self.statusCode = output.statusCode
            self.statusMessage = output.statusMessage
            self.tier = output.tier
            self.vaultARN = output.vaultARN
        } else {
            self.action = nil
            self.archiveId = nil
            self.archiveSHA256TreeHash = nil
            self.archiveSizeInBytes = nil
            self.completed = false
            self.completionDate = nil
            self.creationDate = nil
            self.inventoryRetrievalParameters = nil
            self.inventorySizeInBytes = nil
            self.jobDescription = nil
            self.jobId = nil
            self.jobOutputPath = nil
            self.outputLocation = nil
            self.retrievalByteRange = nil
            self.sHA256TreeHash = nil
            self.sNSTopic = nil
            self.selectParameters = nil
            self.statusCode = nil
            self.statusMessage = nil
            self.tier = nil
            self.vaultARN = nil
        }
    }
}

/// <p>Contains the description of an Amazon S3 Glacier job.</p>
public struct DescribeJobOutputResponse: Swift.Equatable {
    /// <p>The job type. This value is either <code>ArchiveRetrieval</code>,
    ///                 <code>InventoryRetrieval</code>, or
    ///             <code>Select</code>. </p>
    public let action: GlacierClientTypes.ActionCode?
    /// <p>The archive ID requested for a select job or archive retrieval. Otherwise, this
    ///             field is null.</p>
    public let archiveId: Swift.String?
    /// <p>The SHA256 tree hash of the entire archive for an archive retrieval. For inventory
    ///             retrieval or select jobs, this field is null.</p>
    public let archiveSHA256TreeHash: Swift.String?
    /// <p>For an archive retrieval job, this value is the size in bytes of the archive being
    ///             requested for download. For an inventory retrieval or select job, this value is
    ///             null.</p>
    public let archiveSizeInBytes: Swift.Int?
    /// <p>The job status. When a job is completed, you get the job's output using Get Job
    ///             Output (GET output).</p>
    public let completed: Swift.Bool
    /// <p>The UTC time that the job request completed. While the job is in progress, the
    ///             value is null.</p>
    public let completionDate: Swift.String?
    /// <p>The UTC date when the job was created. This value is a string representation of ISO
    ///             8601 date format, for example <code>"2012-03-20T17:03:43.221Z"</code>.</p>
    public let creationDate: Swift.String?
    /// <p>Parameters used for range inventory retrieval.</p>
    public let inventoryRetrievalParameters: GlacierClientTypes.InventoryRetrievalJobDescription?
    /// <p>For an inventory retrieval job, this value is the size in bytes of the inventory
    ///             requested for download. For an archive retrieval or select job, this value is
    ///             null.</p>
    public let inventorySizeInBytes: Swift.Int?
    /// <p>The job description provided when initiating the job.</p>
    public let jobDescription: Swift.String?
    /// <p>An opaque string that identifies an Amazon S3 Glacier job.</p>
    public let jobId: Swift.String?
    /// <p>Contains the job output location.</p>
    public let jobOutputPath: Swift.String?
    /// <p>Contains the location where the data from the select job is stored.</p>
    public let outputLocation: GlacierClientTypes.OutputLocation?
    /// <p>The retrieved byte range for archive retrieval jobs in the form
    ///                 <i>StartByteValue</i>-<i>EndByteValue</i>. If no range
    ///             was specified in the archive retrieval, then the whole archive is retrieved. In this
    ///             case, <i>StartByteValue</i> equals 0 and <i>EndByteValue</i>
    ///             equals the size of the archive minus 1. For inventory retrieval or select jobs, this
    ///             field is null. </p>
    public let retrievalByteRange: Swift.String?
    /// <p>For an archive retrieval job, this value is the checksum of the archive. Otherwise,
    ///             this value is null.</p>
    ///         <p>The SHA256 tree hash value for the requested range of an archive. If the <b>InitiateJob</b> request for an archive specified a tree-hash
    ///             aligned range, then this field returns a value.</p>
    ///         <p>If the whole archive is retrieved, this value is the same as the
    ///             ArchiveSHA256TreeHash value.</p>
    ///         <p>This field is null for the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Archive retrieval jobs that specify a range that is not tree-hash
    ///                     aligned</p>
    ///             </li>
    ///          </ul>
    ///         <ul>
    ///             <li>
    ///                 <p>Archival jobs that specify a range that is equal to the whole archive, when
    ///                     the job status is <code>InProgress</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///         <ul>
    ///             <li>
    ///                 <p>Inventory jobs</p>
    ///             </li>
    ///             <li>
    ///                 <p>Select jobs</p>
    ///             </li>
    ///          </ul>
    public let sHA256TreeHash: Swift.String?
    /// <p>An Amazon SNS topic that receives notification.</p>
    public let sNSTopic: Swift.String?
    /// <p>Contains the parameters used for a select.</p>
    public let selectParameters: GlacierClientTypes.SelectParameters?
    /// <p>The status code can be <code>InProgress</code>, <code>Succeeded</code>, or
    ///                 <code>Failed</code>, and indicates the status of the job.</p>
    public let statusCode: GlacierClientTypes.StatusCode?
    /// <p>A friendly message that describes the job status.</p>
    public let statusMessage: Swift.String?
    /// <p>The tier to use for a select or an archive retrieval. Valid values are
    ///                 <code>Expedited</code>, <code>Standard</code>, or <code>Bulk</code>.
    ///                 <code>Standard</code> is the default.</p>
    public let tier: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the vault from which an archive retrieval was
    ///             requested.</p>
    public let vaultARN: Swift.String?

    public init (
        action: GlacierClientTypes.ActionCode? = nil,
        archiveId: Swift.String? = nil,
        archiveSHA256TreeHash: Swift.String? = nil,
        archiveSizeInBytes: Swift.Int? = nil,
        completed: Swift.Bool = false,
        completionDate: Swift.String? = nil,
        creationDate: Swift.String? = nil,
        inventoryRetrievalParameters: GlacierClientTypes.InventoryRetrievalJobDescription? = nil,
        inventorySizeInBytes: Swift.Int? = nil,
        jobDescription: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobOutputPath: Swift.String? = nil,
        outputLocation: GlacierClientTypes.OutputLocation? = nil,
        retrievalByteRange: Swift.String? = nil,
        sHA256TreeHash: Swift.String? = nil,
        sNSTopic: Swift.String? = nil,
        selectParameters: GlacierClientTypes.SelectParameters? = nil,
        statusCode: GlacierClientTypes.StatusCode? = nil,
        statusMessage: Swift.String? = nil,
        tier: Swift.String? = nil,
        vaultARN: Swift.String? = nil
    )
    {
        self.action = action
        self.archiveId = archiveId
        self.archiveSHA256TreeHash = archiveSHA256TreeHash
        self.archiveSizeInBytes = archiveSizeInBytes
        self.completed = completed
        self.completionDate = completionDate
        self.creationDate = creationDate
        self.inventoryRetrievalParameters = inventoryRetrievalParameters
        self.inventorySizeInBytes = inventorySizeInBytes
        self.jobDescription = jobDescription
        self.jobId = jobId
        self.jobOutputPath = jobOutputPath
        self.outputLocation = outputLocation
        self.retrievalByteRange = retrievalByteRange
        self.sHA256TreeHash = sHA256TreeHash
        self.sNSTopic = sNSTopic
        self.selectParameters = selectParameters
        self.statusCode = statusCode
        self.statusMessage = statusMessage
        self.tier = tier
        self.vaultARN = vaultARN
    }
}

struct DescribeJobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let jobDescription: Swift.String?
    public let action: GlacierClientTypes.ActionCode?
    public let archiveId: Swift.String?
    public let vaultARN: Swift.String?
    public let creationDate: Swift.String?
    public let completed: Swift.Bool
    public let statusCode: GlacierClientTypes.StatusCode?
    public let statusMessage: Swift.String?
    public let archiveSizeInBytes: Swift.Int?
    public let inventorySizeInBytes: Swift.Int?
    public let sNSTopic: Swift.String?
    public let completionDate: Swift.String?
    public let sHA256TreeHash: Swift.String?
    public let archiveSHA256TreeHash: Swift.String?
    public let retrievalByteRange: Swift.String?
    public let tier: Swift.String?
    public let inventoryRetrievalParameters: GlacierClientTypes.InventoryRetrievalJobDescription?
    public let jobOutputPath: Swift.String?
    public let selectParameters: GlacierClientTypes.SelectParameters?
    public let outputLocation: GlacierClientTypes.OutputLocation?
}

extension DescribeJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case archiveId = "ArchiveId"
        case archiveSHA256TreeHash = "ArchiveSHA256TreeHash"
        case archiveSizeInBytes = "ArchiveSizeInBytes"
        case completed = "Completed"
        case completionDate = "CompletionDate"
        case creationDate = "CreationDate"
        case inventoryRetrievalParameters = "InventoryRetrievalParameters"
        case inventorySizeInBytes = "InventorySizeInBytes"
        case jobDescription = "JobDescription"
        case jobId = "JobId"
        case jobOutputPath = "JobOutputPath"
        case outputLocation = "OutputLocation"
        case retrievalByteRange = "RetrievalByteRange"
        case sHA256TreeHash = "SHA256TreeHash"
        case sNSTopic = "SNSTopic"
        case selectParameters = "SelectParameters"
        case statusCode = "StatusCode"
        case statusMessage = "StatusMessage"
        case tier = "Tier"
        case vaultARN = "VaultARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobDescription)
        jobDescription = jobDescriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.ActionCode.self, forKey: .action)
        action = actionDecoded
        let archiveIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveId)
        archiveId = archiveIdDecoded
        let vaultARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .completed)
        completed = completedDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.StatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let archiveSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .archiveSizeInBytes)
        archiveSizeInBytes = archiveSizeInBytesDecoded
        let inventorySizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inventorySizeInBytes)
        inventorySizeInBytes = inventorySizeInBytesDecoded
        let sNSTopicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sNSTopic)
        sNSTopic = sNSTopicDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let sHA256TreeHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sHA256TreeHash)
        sHA256TreeHash = sHA256TreeHashDecoded
        let archiveSHA256TreeHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveSHA256TreeHash)
        archiveSHA256TreeHash = archiveSHA256TreeHashDecoded
        let retrievalByteRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalByteRange)
        retrievalByteRange = retrievalByteRangeDecoded
        let tierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tier)
        tier = tierDecoded
        let inventoryRetrievalParametersDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.InventoryRetrievalJobDescription.self, forKey: .inventoryRetrievalParameters)
        inventoryRetrievalParameters = inventoryRetrievalParametersDecoded
        let jobOutputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobOutputPath)
        jobOutputPath = jobOutputPathDecoded
        let selectParametersDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.SelectParameters.self, forKey: .selectParameters)
        selectParameters = selectParametersDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
    }
}

extension DescribeVaultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeVaultInput(accountId: \(Swift.String(describing: accountId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension DescribeVaultInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeVaultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVaultOutputError>
}

public struct DescribeVaultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVaultOutputError>
}

/// <p>Provides options for retrieving metadata for a specific vault in Amazon
///          Glacier.</p>
public struct DescribeVaultInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct DescribeVaultInputBody: Swift.Equatable {
}

extension DescribeVaultInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GlacierClientTypes.DescribeVaultOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case lastInventoryDate = "LastInventoryDate"
        case numberOfArchives = "NumberOfArchives"
        case sizeInBytes = "SizeInBytes"
        case vaultARN = "VaultARN"
        case vaultName = "VaultName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let lastInventoryDate = lastInventoryDate {
            try encodeContainer.encode(lastInventoryDate, forKey: .lastInventoryDate)
        }
        if numberOfArchives != 0 {
            try encodeContainer.encode(numberOfArchives, forKey: .numberOfArchives)
        }
        if sizeInBytes != 0 {
            try encodeContainer.encode(sizeInBytes, forKey: .sizeInBytes)
        }
        if let vaultARN = vaultARN {
            try encodeContainer.encode(vaultARN, forKey: .vaultARN)
        }
        if let vaultName = vaultName {
            try encodeContainer.encode(vaultName, forKey: .vaultName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let vaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultName)
        vaultName = vaultNameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastInventoryDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastInventoryDate)
        lastInventoryDate = lastInventoryDateDecoded
        let numberOfArchivesDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfArchives)
        numberOfArchives = numberOfArchivesDecoded
        let sizeInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
    }
}

extension GlacierClientTypes.DescribeVaultOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeVaultOutput(creationDate: \(Swift.String(describing: creationDate)), lastInventoryDate: \(Swift.String(describing: lastInventoryDate)), numberOfArchives: \(Swift.String(describing: numberOfArchives)), sizeInBytes: \(Swift.String(describing: sizeInBytes)), vaultARN: \(Swift.String(describing: vaultARN)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension GlacierClientTypes {
    /// <p>Contains the Amazon S3 Glacier response to your request.</p>
    public struct DescribeVaultOutput: Swift.Equatable {
        /// <p>The Universal Coordinated Time (UTC) date when the vault was created. This value
        ///          should be a string in the ISO 8601 date format, for example
        ///             <code>2012-03-20T17:03:43.221Z</code>.</p>
        public let creationDate: Swift.String?
        /// <p>The Universal Coordinated Time (UTC) date when Amazon S3 Glacier completed the last
        ///          vault inventory.  This value should be a string in the ISO 8601 date format, for example
        ///             <code>2012-03-20T17:03:43.221Z</code>.</p>
        public let lastInventoryDate: Swift.String?
        /// <p>The number of archives in the vault as of the last inventory date. This field will
        ///          return <code>null</code> if an inventory has not yet run on the vault, for example if you
        ///          just created the vault.</p>
        public let numberOfArchives: Swift.Int
        /// <p>Total size, in bytes, of the archives in the vault as of the last inventory date.
        ///          This field will return null if an inventory has not yet run on the vault, for example if
        ///          you just created the vault.</p>
        public let sizeInBytes: Swift.Int
        /// <p>The Amazon Resource Name (ARN) of the vault.</p>
        public let vaultARN: Swift.String?
        /// <p>The name of the vault.</p>
        public let vaultName: Swift.String?

        public init (
            creationDate: Swift.String? = nil,
            lastInventoryDate: Swift.String? = nil,
            numberOfArchives: Swift.Int = 0,
            sizeInBytes: Swift.Int = 0,
            vaultARN: Swift.String? = nil,
            vaultName: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.lastInventoryDate = lastInventoryDate
            self.numberOfArchives = numberOfArchives
            self.sizeInBytes = sizeInBytes
            self.vaultARN = vaultARN
            self.vaultName = vaultName
        }
    }

}

extension DescribeVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVaultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeVaultOutputResponse(creationDate: \(Swift.String(describing: creationDate)), lastInventoryDate: \(Swift.String(describing: lastInventoryDate)), numberOfArchives: \(Swift.String(describing: numberOfArchives)), sizeInBytes: \(Swift.String(describing: sizeInBytes)), vaultARN: \(Swift.String(describing: vaultARN)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension DescribeVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeVaultOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.lastInventoryDate = output.lastInventoryDate
            self.numberOfArchives = output.numberOfArchives
            self.sizeInBytes = output.sizeInBytes
            self.vaultARN = output.vaultARN
            self.vaultName = output.vaultName
        } else {
            self.creationDate = nil
            self.lastInventoryDate = nil
            self.numberOfArchives = 0
            self.sizeInBytes = 0
            self.vaultARN = nil
            self.vaultName = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct DescribeVaultOutputResponse: Swift.Equatable {
    /// <p>The Universal Coordinated Time (UTC) date when the vault was created. This value
    ///          should be a string in the ISO 8601 date format, for example
    ///             <code>2012-03-20T17:03:43.221Z</code>.</p>
    public let creationDate: Swift.String?
    /// <p>The Universal Coordinated Time (UTC) date when Amazon S3 Glacier completed the last
    ///          vault inventory.  This value should be a string in the ISO 8601 date format, for example
    ///             <code>2012-03-20T17:03:43.221Z</code>.</p>
    public let lastInventoryDate: Swift.String?
    /// <p>The number of archives in the vault as of the last inventory date. This field will
    ///          return <code>null</code> if an inventory has not yet run on the vault, for example if you
    ///          just created the vault.</p>
    public let numberOfArchives: Swift.Int
    /// <p>Total size, in bytes, of the archives in the vault as of the last inventory date.
    ///          This field will return null if an inventory has not yet run on the vault, for example if
    ///          you just created the vault.</p>
    public let sizeInBytes: Swift.Int
    /// <p>The Amazon Resource Name (ARN) of the vault.</p>
    public let vaultARN: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        creationDate: Swift.String? = nil,
        lastInventoryDate: Swift.String? = nil,
        numberOfArchives: Swift.Int = 0,
        sizeInBytes: Swift.Int = 0,
        vaultARN: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.lastInventoryDate = lastInventoryDate
        self.numberOfArchives = numberOfArchives
        self.sizeInBytes = sizeInBytes
        self.vaultARN = vaultARN
        self.vaultName = vaultName
    }
}

struct DescribeVaultOutputResponseBody: Swift.Equatable {
    public let vaultARN: Swift.String?
    public let vaultName: Swift.String?
    public let creationDate: Swift.String?
    public let lastInventoryDate: Swift.String?
    public let numberOfArchives: Swift.Int
    public let sizeInBytes: Swift.Int
}

extension DescribeVaultOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case lastInventoryDate = "LastInventoryDate"
        case numberOfArchives = "NumberOfArchives"
        case sizeInBytes = "SizeInBytes"
        case vaultARN = "VaultARN"
        case vaultName = "VaultName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let vaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultName)
        vaultName = vaultNameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastInventoryDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastInventoryDate)
        lastInventoryDate = lastInventoryDateDecoded
        let numberOfArchivesDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfArchives)
        numberOfArchives = numberOfArchivesDecoded
        let sizeInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
    }
}

extension GlacierClientTypes.Encryption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "EncryptionType"
        case kMSContext = "KMSContext"
        case kMSKeyId = "KMSKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let kMSContext = kMSContext {
            try encodeContainer.encode(kMSContext, forKey: .kMSContext)
        }
        if let kMSKeyId = kMSKeyId {
            try encodeContainer.encode(kMSKeyId, forKey: .kMSKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
        let kMSContextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSContext)
        kMSContext = kMSContextDecoded
    }
}

extension GlacierClientTypes.Encryption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Encryption(encryptionType: \(Swift.String(describing: encryptionType)), kMSContext: \(Swift.String(describing: kMSContext)), kMSKeyId: \(Swift.String(describing: kMSKeyId)))"}
}

extension GlacierClientTypes {
    /// <p>Contains information about the encryption used to store the job results in Amazon S3. </p>
    public struct Encryption: Swift.Equatable {
        /// <p>The server-side encryption algorithm used when storing job results in Amazon S3, for
        ///             example <code>AES256</code> or <code>aws:kms</code>.</p>
        public let encryptionType: GlacierClientTypes.EncryptionType?
        /// <p>Optional. If the encryption type is <code>aws:kms</code>, you can use this value to
        ///             specify the encryption context for the job results.</p>
        public let kMSContext: Swift.String?
        /// <p>The AWS KMS key ID to use for object encryption. All GET and PUT requests for an
        ///             object protected by AWS KMS fail if not made by using Secure Sockets Layer (SSL) or
        ///             Signature Version 4. </p>
        public let kMSKeyId: Swift.String?

        public init (
            encryptionType: GlacierClientTypes.EncryptionType? = nil,
            kMSContext: Swift.String? = nil,
            kMSKeyId: Swift.String? = nil
        )
        {
            self.encryptionType = encryptionType
            self.kMSContext = kMSContext
            self.kMSKeyId = kMSKeyId
        }
    }

}

extension GlacierClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kms
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kms,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kms: return "aws:kms"
            case .s3: return "AES256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension GlacierClientTypes {
    public enum ExpressionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sql
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpressionType] {
            return [
                .sql,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sql: return "SQL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExpressionType(rawValue: rawValue) ?? ExpressionType.sdkUnknown(rawValue)
        }
    }
}

extension GlacierClientTypes {
    public enum FileHeaderInfo: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ignore
        case `none`
        case use
        case sdkUnknown(Swift.String)

        public static var allCases: [FileHeaderInfo] {
            return [
                .ignore,
                .none,
                .use,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ignore: return "IGNORE"
            case .none: return "NONE"
            case .use: return "USE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileHeaderInfo(rawValue: rawValue) ?? FileHeaderInfo.sdkUnknown(rawValue)
        }
    }
}

extension GetDataRetrievalPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataRetrievalPolicyInput(accountId: \(Swift.String(describing: accountId)))"}
}

extension GetDataRetrievalPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDataRetrievalPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDataRetrievalPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDataRetrievalPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDataRetrievalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDataRetrievalPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDataRetrievalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDataRetrievalPolicyOutputError>
}

public struct GetDataRetrievalPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDataRetrievalPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDataRetrievalPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDataRetrievalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDataRetrievalPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDataRetrievalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDataRetrievalPolicyOutputError>
}

/// <p>Input for GetDataRetrievalPolicy.</p>
public struct GetDataRetrievalPolicyInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID. This value must match the AWS
    ///          account ID associated with the credentials used to sign the request. You can either specify
    ///          an AWS account ID or optionally a single '<code>-</code>' (hyphen), in which case Amazon
    ///          Glacier uses the AWS account ID associated with the credentials used to sign the request.
    ///          If you specify your account ID, do not include any hyphens ('-') in the ID. </p>
    public let accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetDataRetrievalPolicyInputBody: Swift.Equatable {
}

extension GetDataRetrievalPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDataRetrievalPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataRetrievalPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataRetrievalPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataRetrievalPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataRetrievalPolicyOutputResponse(policy: \(Swift.String(describing: policy)))"}
}

extension GetDataRetrievalPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDataRetrievalPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to the <code>GetDataRetrievalPolicy</code>
///          request.</p>
public struct GetDataRetrievalPolicyOutputResponse: Swift.Equatable {
    /// <p>Contains the returned data retrieval policy in JSON format.</p>
    public let policy: GlacierClientTypes.DataRetrievalPolicy?

    public init (
        policy: GlacierClientTypes.DataRetrievalPolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetDataRetrievalPolicyOutputResponseBody: Swift.Equatable {
    public let policy: GlacierClientTypes.DataRetrievalPolicy?
}

extension GetDataRetrievalPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.DataRetrievalPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetJobOutputInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetJobOutputInput(accountId: \(Swift.String(describing: accountId)), jobId: \(Swift.String(describing: jobId)), range: \(Swift.String(describing: range)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension GetJobOutputInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetJobOutputInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobOutputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobOutputInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let range = input.operationInput.range {
            input.builder.withHeader(name: "Range", value: Swift.String(range))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobOutputInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobOutputOutputError>
}

public struct GetJobOutputInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobOutputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobOutputInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobOutputInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobOutputOutputError>
}

/// <p>Provides options for downloading output of an Amazon S3 Glacier job.</p>
public struct GetJobOutputInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The job ID whose data is downloaded.</p>
    public let jobId: Swift.String?
    /// <p>The range of bytes to retrieve from the output. For example, if you want to download
    ///          the first 1,048,576 bytes, specify the range as <code>bytes=0-1048575</code>. By default, this operation
    ///          downloads the entire output.</p>
    ///
    ///          <p>If the job output is large, then you can use a range to
    ///          retrieve a portion of the output. This allows you to download the entire output in smaller
    ///          chunks of bytes. For example, suppose you have 1 GB of job output you want to download and
    ///          you decide to download 128 MB chunks of data at a time, which is a total of eight Get Job
    ///          Output requests. You use the following process to download the job output:</p>
    ///
    ///          <ol>
    ///             <li>
    ///                <p>Download a 128 MB chunk of output by specifying the appropriate byte range.
    ///                   Verify that all 128 MB of data was received.</p>
    ///             </li>
    ///             <li>
    ///                <p>Along with the data, the response includes a SHA256 tree hash of the payload.
    ///                   You compute the checksum of the payload on the client and compare it with the
    ///                   checksum you received in the response to ensure you received all the expected
    ///                   data.</p>
    ///             </li>
    ///             <li>
    ///                <p>Repeat steps 1 and 2 for all the eight 128 MB chunks of output data, each time
    ///                   specifying the appropriate byte range.</p>
    ///             </li>
    ///             <li>
    ///                <p>After downloading all the parts of the job output, you have a list of eight
    ///                   checksum values. Compute the tree hash of these values to find the checksum of the
    ///                   entire output. Using the <a>DescribeJob</a> API, obtain job information of
    ///                   the job that provided you the output. The response includes the checksum of the
    ///                   entire archive stored in Amazon S3 Glacier. You compare this value with the checksum you
    ///                   computed to ensure you have downloaded the entire archive content with no
    ///                   errors.</p>
    ///                <p></p>
    ///             </li>
    ///          </ol>
    public let range: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        range: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.range = range
        self.vaultName = vaultName
    }
}

struct GetJobOutputInputBody: Swift.Equatable {
}

extension GetJobOutputInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetJobOutputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobOutputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobOutputOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobOutputOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetJobOutputOutputResponse(acceptRanges: \(Swift.String(describing: acceptRanges)), archiveDescription: \(Swift.String(describing: archiveDescription)), body: \(Swift.String(describing: body)), checksum: \(Swift.String(describing: checksum)), contentRange: \(Swift.String(describing: contentRange)), contentType: \(Swift.String(describing: contentType)), status: \(Swift.String(describing: status)))"}
}

extension GetJobOutputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let acceptRangesHeaderValue = httpResponse.headers.value(for: "Accept-Ranges") {
            self.acceptRanges = acceptRangesHeaderValue
        } else {
            self.acceptRanges = nil
        }
        if let archiveDescriptionHeaderValue = httpResponse.headers.value(for: "x-amz-archive-description") {
            self.archiveDescription = archiveDescriptionHeaderValue
        } else {
            self.archiveDescription = nil
        }
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-sha256-tree-hash") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let contentRangeHeaderValue = httpResponse.headers.value(for: "Content-Range") {
            self.contentRange = contentRangeHeaderValue
        } else {
            self.contentRange = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader
            self.body = data
        } else {
            self.body = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct GetJobOutputOutputResponse: Swift.Equatable {
    /// <p>Indicates the range units accepted. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">RFC2616</a>. </p>
    public let acceptRanges: Swift.String?
    /// <p>The description of an archive.</p>
    public let archiveDescription: Swift.String?
    /// <p>The job data, either archive data or inventory data.</p>
    public let body: ClientRuntime.ByteStream?
    /// <p>The checksum of the data in the response. This header is returned only when
    ///          retrieving the output for an archive retrieval job. Furthermore, this header appears only
    ///          under the following conditions:</p>
    ///          <ul>
    ///             <li>
    ///                 <p>You get the entire range of the archive.</p>
    ///             </li>
    ///             <li>
    ///                <p>You request a range to return of the archive that starts and ends on a multiple
    ///                of 1 MB. For example, if you have an 3.1 MB archive and you specify a range to return
    ///                that starts at 1 MB and ends at 2 MB, then the x-amz-sha256-tree-hash is returned as
    ///                a response header.</p>
    ///             </li>
    ///             <li>
    ///                <p>You request a range of the archive to return that starts on a multiple of 1 MB
    ///                and goes to the end of the archive. For example, if you have a 3.1 MB archive and you
    ///                specify a range that starts at 2 MB and ends at 3.1 MB (the end of the archive), then
    ///                the x-amz-sha256-tree-hash is returned as a response header.</p>
    ///             </li>
    ///          </ul>
    public let checksum: Swift.String?
    /// <p>The range of bytes returned by Amazon S3 Glacier. If only partial output is downloaded,
    ///          the response provides the range of bytes Amazon S3 Glacier returned. For example, bytes
    ///          0-1048575/8388608 returns the first 1 MB from 8 MB.</p>
    public let contentRange: Swift.String?
    /// <p>The Content-Type depends on whether the job output is an archive or a vault
    ///          inventory. For archive data, the Content-Type is application/octet-stream. For vault
    ///          inventory, if you requested CSV format when you initiated the job, the Content-Type is
    ///          text/csv. Otherwise, by default, vault inventory is returned as JSON, and the Content-Type
    ///          is application/json.</p>
    public let contentType: Swift.String?
    /// <p>The HTTP response code for a job output request. The value depends on whether a range
    ///          was specified in the request.</p>
    public let status: Swift.Int

    public init (
        acceptRanges: Swift.String? = nil,
        archiveDescription: Swift.String? = nil,
        body: ClientRuntime.ByteStream? = nil,
        checksum: Swift.String? = nil,
        contentRange: Swift.String? = nil,
        contentType: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.acceptRanges = acceptRanges
        self.archiveDescription = archiveDescription
        self.body = body
        self.checksum = checksum
        self.contentRange = contentRange
        self.contentType = contentType
        self.status = status
    }
}

struct GetJobOutputOutputResponseBody: Swift.Equatable {
    public let body: ClientRuntime.ByteStream?
    public let status: Swift.Int
}

extension GetJobOutputOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
        body = bodyDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetVaultAccessPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVaultAccessPolicyInput(accountId: \(Swift.String(describing: accountId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension GetVaultAccessPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetVaultAccessPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVaultAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVaultAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVaultAccessPolicyOutputError>
}

public struct GetVaultAccessPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVaultAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVaultAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVaultAccessPolicyOutputError>
}

/// <p>Input for GetVaultAccessPolicy.</p>
public struct GetVaultAccessPolicyInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct GetVaultAccessPolicyInputBody: Swift.Equatable {
}

extension GetVaultAccessPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVaultAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVaultAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVaultAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVaultAccessPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVaultAccessPolicyOutputResponse(policy: \(Swift.String(describing: policy)))"}
}

extension GetVaultAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: GlacierClientTypes.VaultAccessPolicy = try responseDecoder.decode(responseBody: data)
                self.policy = output
            } else {
                self.policy = nil
            }
        } else {
            self.policy = nil
        }
    }
}

/// <p>Output for GetVaultAccessPolicy.</p>
public struct GetVaultAccessPolicyOutputResponse: Swift.Equatable {
    /// <p>Contains the returned vault access policy as a JSON string.</p>
    public let policy: GlacierClientTypes.VaultAccessPolicy?

    public init (
        policy: GlacierClientTypes.VaultAccessPolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetVaultAccessPolicyOutputResponseBody: Swift.Equatable {
    public let policy: GlacierClientTypes.VaultAccessPolicy?
}

extension GetVaultAccessPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.VaultAccessPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetVaultLockInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVaultLockInput(accountId: \(Swift.String(describing: accountId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension GetVaultLockInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetVaultLockInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVaultLockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVaultLockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVaultLockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVaultLockOutputError>
}

public struct GetVaultLockInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVaultLockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVaultLockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVaultLockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVaultLockOutputError>
}

/// <p>The input values for <code>GetVaultLock</code>.</p>
public struct GetVaultLockInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct GetVaultLockInputBody: Swift.Equatable {
}

extension GetVaultLockInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVaultLockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVaultLockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVaultLockOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVaultLockOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVaultLockOutputResponse(creationDate: \(Swift.String(describing: creationDate)), expirationDate: \(Swift.String(describing: expirationDate)), policy: \(Swift.String(describing: policy)), state: \(Swift.String(describing: state)))"}
}

extension GetVaultLockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVaultLockOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.expirationDate = output.expirationDate
            self.policy = output.policy
            self.state = output.state
        } else {
            self.creationDate = nil
            self.expirationDate = nil
            self.policy = nil
            self.state = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct GetVaultLockOutputResponse: Swift.Equatable {
    /// <p>The UTC date and time at which the vault lock was put into the
    ///             <code>InProgress</code> state.</p>
    public let creationDate: Swift.String?
    /// <p>The UTC date and time at which the lock ID expires. This value can be
    ///             <code>null</code> if the vault lock is in a <code>Locked</code> state.</p>
    public let expirationDate: Swift.String?
    /// <p>The vault lock policy as a JSON string, which uses "\" as an escape
    ///          character.</p>
    public let policy: Swift.String?
    /// <p>The state of the vault lock. <code>InProgress</code> or
    ///          <code>Locked</code>.</p>
    public let state: Swift.String?

    public init (
        creationDate: Swift.String? = nil,
        expirationDate: Swift.String? = nil,
        policy: Swift.String? = nil,
        state: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.expirationDate = expirationDate
        self.policy = policy
        self.state = state
    }
}

struct GetVaultLockOutputResponseBody: Swift.Equatable {
    public let policy: Swift.String?
    public let state: Swift.String?
    public let expirationDate: Swift.String?
    public let creationDate: Swift.String?
}

extension GetVaultLockOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case expirationDate = "ExpirationDate"
        case policy = "Policy"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension GetVaultNotificationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVaultNotificationsInput(accountId: \(Swift.String(describing: accountId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension GetVaultNotificationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetVaultNotificationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVaultNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVaultNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVaultNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVaultNotificationsOutputError>
}

public struct GetVaultNotificationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVaultNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVaultNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVaultNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVaultNotificationsOutputError>
}

/// <p>Provides options for retrieving the notification configuration set on an Amazon
///          Glacier vault.</p>
public struct GetVaultNotificationsInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct GetVaultNotificationsInputBody: Swift.Equatable {
}

extension GetVaultNotificationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVaultNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVaultNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVaultNotificationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVaultNotificationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVaultNotificationsOutputResponse(vaultNotificationConfig: \(Swift.String(describing: vaultNotificationConfig)))"}
}

extension GetVaultNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: GlacierClientTypes.VaultNotificationConfig = try responseDecoder.decode(responseBody: data)
                self.vaultNotificationConfig = output
            } else {
                self.vaultNotificationConfig = nil
            }
        } else {
            self.vaultNotificationConfig = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct GetVaultNotificationsOutputResponse: Swift.Equatable {
    /// <p>Returns the notification configuration set on the vault.</p>
    public let vaultNotificationConfig: GlacierClientTypes.VaultNotificationConfig?

    public init (
        vaultNotificationConfig: GlacierClientTypes.VaultNotificationConfig? = nil
    )
    {
        self.vaultNotificationConfig = vaultNotificationConfig
    }
}

struct GetVaultNotificationsOutputResponseBody: Swift.Equatable {
    public let vaultNotificationConfig: GlacierClientTypes.VaultNotificationConfig?
}

extension GetVaultNotificationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vaultNotificationConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultNotificationConfigDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.VaultNotificationConfig.self, forKey: .vaultNotificationConfig)
        vaultNotificationConfig = vaultNotificationConfigDecoded
    }
}

extension GlacierClientTypes.GlacierJobDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case archiveId = "ArchiveId"
        case archiveSHA256TreeHash = "ArchiveSHA256TreeHash"
        case archiveSizeInBytes = "ArchiveSizeInBytes"
        case completed = "Completed"
        case completionDate = "CompletionDate"
        case creationDate = "CreationDate"
        case inventoryRetrievalParameters = "InventoryRetrievalParameters"
        case inventorySizeInBytes = "InventorySizeInBytes"
        case jobDescription = "JobDescription"
        case jobId = "JobId"
        case jobOutputPath = "JobOutputPath"
        case outputLocation = "OutputLocation"
        case retrievalByteRange = "RetrievalByteRange"
        case sHA256TreeHash = "SHA256TreeHash"
        case sNSTopic = "SNSTopic"
        case selectParameters = "SelectParameters"
        case statusCode = "StatusCode"
        case statusMessage = "StatusMessage"
        case tier = "Tier"
        case vaultARN = "VaultARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let archiveId = archiveId {
            try encodeContainer.encode(archiveId, forKey: .archiveId)
        }
        if let archiveSHA256TreeHash = archiveSHA256TreeHash {
            try encodeContainer.encode(archiveSHA256TreeHash, forKey: .archiveSHA256TreeHash)
        }
        if let archiveSizeInBytes = archiveSizeInBytes {
            try encodeContainer.encode(archiveSizeInBytes, forKey: .archiveSizeInBytes)
        }
        if completed != false {
            try encodeContainer.encode(completed, forKey: .completed)
        }
        if let completionDate = completionDate {
            try encodeContainer.encode(completionDate, forKey: .completionDate)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let inventoryRetrievalParameters = inventoryRetrievalParameters {
            try encodeContainer.encode(inventoryRetrievalParameters, forKey: .inventoryRetrievalParameters)
        }
        if let inventorySizeInBytes = inventorySizeInBytes {
            try encodeContainer.encode(inventorySizeInBytes, forKey: .inventorySizeInBytes)
        }
        if let jobDescription = jobDescription {
            try encodeContainer.encode(jobDescription, forKey: .jobDescription)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobOutputPath = jobOutputPath {
            try encodeContainer.encode(jobOutputPath, forKey: .jobOutputPath)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let retrievalByteRange = retrievalByteRange {
            try encodeContainer.encode(retrievalByteRange, forKey: .retrievalByteRange)
        }
        if let sHA256TreeHash = sHA256TreeHash {
            try encodeContainer.encode(sHA256TreeHash, forKey: .sHA256TreeHash)
        }
        if let sNSTopic = sNSTopic {
            try encodeContainer.encode(sNSTopic, forKey: .sNSTopic)
        }
        if let selectParameters = selectParameters {
            try encodeContainer.encode(selectParameters, forKey: .selectParameters)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tier = tier {
            try encodeContainer.encode(tier, forKey: .tier)
        }
        if let vaultARN = vaultARN {
            try encodeContainer.encode(vaultARN, forKey: .vaultARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobDescription)
        jobDescription = jobDescriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.ActionCode.self, forKey: .action)
        action = actionDecoded
        let archiveIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveId)
        archiveId = archiveIdDecoded
        let vaultARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .completed)
        completed = completedDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.StatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let archiveSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .archiveSizeInBytes)
        archiveSizeInBytes = archiveSizeInBytesDecoded
        let inventorySizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inventorySizeInBytes)
        inventorySizeInBytes = inventorySizeInBytesDecoded
        let sNSTopicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sNSTopic)
        sNSTopic = sNSTopicDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let sHA256TreeHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sHA256TreeHash)
        sHA256TreeHash = sHA256TreeHashDecoded
        let archiveSHA256TreeHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveSHA256TreeHash)
        archiveSHA256TreeHash = archiveSHA256TreeHashDecoded
        let retrievalByteRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalByteRange)
        retrievalByteRange = retrievalByteRangeDecoded
        let tierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tier)
        tier = tierDecoded
        let inventoryRetrievalParametersDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.InventoryRetrievalJobDescription.self, forKey: .inventoryRetrievalParameters)
        inventoryRetrievalParameters = inventoryRetrievalParametersDecoded
        let jobOutputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobOutputPath)
        jobOutputPath = jobOutputPathDecoded
        let selectParametersDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.SelectParameters.self, forKey: .selectParameters)
        selectParameters = selectParametersDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
    }
}

extension GlacierClientTypes.GlacierJobDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GlacierJobDescription(action: \(Swift.String(describing: action)), archiveId: \(Swift.String(describing: archiveId)), archiveSHA256TreeHash: \(Swift.String(describing: archiveSHA256TreeHash)), archiveSizeInBytes: \(Swift.String(describing: archiveSizeInBytes)), completed: \(Swift.String(describing: completed)), completionDate: \(Swift.String(describing: completionDate)), creationDate: \(Swift.String(describing: creationDate)), inventoryRetrievalParameters: \(Swift.String(describing: inventoryRetrievalParameters)), inventorySizeInBytes: \(Swift.String(describing: inventorySizeInBytes)), jobDescription: \(Swift.String(describing: jobDescription)), jobId: \(Swift.String(describing: jobId)), jobOutputPath: \(Swift.String(describing: jobOutputPath)), outputLocation: \(Swift.String(describing: outputLocation)), retrievalByteRange: \(Swift.String(describing: retrievalByteRange)), sHA256TreeHash: \(Swift.String(describing: sHA256TreeHash)), sNSTopic: \(Swift.String(describing: sNSTopic)), selectParameters: \(Swift.String(describing: selectParameters)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), tier: \(Swift.String(describing: tier)), vaultARN: \(Swift.String(describing: vaultARN)))"}
}

extension GlacierClientTypes {
    /// <p>Contains the description of an Amazon S3 Glacier job.</p>
    public struct GlacierJobDescription: Swift.Equatable {
        /// <p>The job type. This value is either <code>ArchiveRetrieval</code>,
        ///                 <code>InventoryRetrieval</code>, or
        ///             <code>Select</code>. </p>
        public let action: GlacierClientTypes.ActionCode?
        /// <p>The archive ID requested for a select job or archive retrieval. Otherwise, this
        ///             field is null.</p>
        public let archiveId: Swift.String?
        /// <p>The SHA256 tree hash of the entire archive for an archive retrieval. For inventory
        ///             retrieval or select jobs, this field is null.</p>
        public let archiveSHA256TreeHash: Swift.String?
        /// <p>For an archive retrieval job, this value is the size in bytes of the archive being
        ///             requested for download. For an inventory retrieval or select job, this value is
        ///             null.</p>
        public let archiveSizeInBytes: Swift.Int?
        /// <p>The job status. When a job is completed, you get the job's output using Get Job
        ///             Output (GET output).</p>
        public let completed: Swift.Bool
        /// <p>The UTC time that the job request completed. While the job is in progress, the
        ///             value is null.</p>
        public let completionDate: Swift.String?
        /// <p>The UTC date when the job was created. This value is a string representation of ISO
        ///             8601 date format, for example <code>"2012-03-20T17:03:43.221Z"</code>.</p>
        public let creationDate: Swift.String?
        /// <p>Parameters used for range inventory retrieval.</p>
        public let inventoryRetrievalParameters: GlacierClientTypes.InventoryRetrievalJobDescription?
        /// <p>For an inventory retrieval job, this value is the size in bytes of the inventory
        ///             requested for download. For an archive retrieval or select job, this value is
        ///             null.</p>
        public let inventorySizeInBytes: Swift.Int?
        /// <p>The job description provided when initiating the job.</p>
        public let jobDescription: Swift.String?
        /// <p>An opaque string that identifies an Amazon S3 Glacier job.</p>
        public let jobId: Swift.String?
        /// <p>Contains the job output location.</p>
        public let jobOutputPath: Swift.String?
        /// <p>Contains the location where the data from the select job is stored.</p>
        public let outputLocation: GlacierClientTypes.OutputLocation?
        /// <p>The retrieved byte range for archive retrieval jobs in the form
        ///                 <i>StartByteValue</i>-<i>EndByteValue</i>. If no range
        ///             was specified in the archive retrieval, then the whole archive is retrieved. In this
        ///             case, <i>StartByteValue</i> equals 0 and <i>EndByteValue</i>
        ///             equals the size of the archive minus 1. For inventory retrieval or select jobs, this
        ///             field is null. </p>
        public let retrievalByteRange: Swift.String?
        /// <p>For an archive retrieval job, this value is the checksum of the archive. Otherwise,
        ///             this value is null.</p>
        ///         <p>The SHA256 tree hash value for the requested range of an archive. If the <b>InitiateJob</b> request for an archive specified a tree-hash
        ///             aligned range, then this field returns a value.</p>
        ///         <p>If the whole archive is retrieved, this value is the same as the
        ///             ArchiveSHA256TreeHash value.</p>
        ///         <p>This field is null for the following:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>Archive retrieval jobs that specify a range that is not tree-hash
        ///                     aligned</p>
        ///             </li>
        ///          </ul>
        ///         <ul>
        ///             <li>
        ///                 <p>Archival jobs that specify a range that is equal to the whole archive, when
        ///                     the job status is <code>InProgress</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        ///         <ul>
        ///             <li>
        ///                 <p>Inventory jobs</p>
        ///             </li>
        ///             <li>
        ///                 <p>Select jobs</p>
        ///             </li>
        ///          </ul>
        public let sHA256TreeHash: Swift.String?
        /// <p>An Amazon SNS topic that receives notification.</p>
        public let sNSTopic: Swift.String?
        /// <p>Contains the parameters used for a select.</p>
        public let selectParameters: GlacierClientTypes.SelectParameters?
        /// <p>The status code can be <code>InProgress</code>, <code>Succeeded</code>, or
        ///                 <code>Failed</code>, and indicates the status of the job.</p>
        public let statusCode: GlacierClientTypes.StatusCode?
        /// <p>A friendly message that describes the job status.</p>
        public let statusMessage: Swift.String?
        /// <p>The tier to use for a select or an archive retrieval. Valid values are
        ///                 <code>Expedited</code>, <code>Standard</code>, or <code>Bulk</code>.
        ///                 <code>Standard</code> is the default.</p>
        public let tier: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the vault from which an archive retrieval was
        ///             requested.</p>
        public let vaultARN: Swift.String?

        public init (
            action: GlacierClientTypes.ActionCode? = nil,
            archiveId: Swift.String? = nil,
            archiveSHA256TreeHash: Swift.String? = nil,
            archiveSizeInBytes: Swift.Int? = nil,
            completed: Swift.Bool = false,
            completionDate: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            inventoryRetrievalParameters: GlacierClientTypes.InventoryRetrievalJobDescription? = nil,
            inventorySizeInBytes: Swift.Int? = nil,
            jobDescription: Swift.String? = nil,
            jobId: Swift.String? = nil,
            jobOutputPath: Swift.String? = nil,
            outputLocation: GlacierClientTypes.OutputLocation? = nil,
            retrievalByteRange: Swift.String? = nil,
            sHA256TreeHash: Swift.String? = nil,
            sNSTopic: Swift.String? = nil,
            selectParameters: GlacierClientTypes.SelectParameters? = nil,
            statusCode: GlacierClientTypes.StatusCode? = nil,
            statusMessage: Swift.String? = nil,
            tier: Swift.String? = nil,
            vaultARN: Swift.String? = nil
        )
        {
            self.action = action
            self.archiveId = archiveId
            self.archiveSHA256TreeHash = archiveSHA256TreeHash
            self.archiveSizeInBytes = archiveSizeInBytes
            self.completed = completed
            self.completionDate = completionDate
            self.creationDate = creationDate
            self.inventoryRetrievalParameters = inventoryRetrievalParameters
            self.inventorySizeInBytes = inventorySizeInBytes
            self.jobDescription = jobDescription
            self.jobId = jobId
            self.jobOutputPath = jobOutputPath
            self.outputLocation = outputLocation
            self.retrievalByteRange = retrievalByteRange
            self.sHA256TreeHash = sHA256TreeHash
            self.sNSTopic = sNSTopic
            self.selectParameters = selectParameters
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.tier = tier
            self.vaultARN = vaultARN
        }
    }

}

extension GlacierClientTypes.Grant: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantee = "Grantee"
        case permission = "Permission"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantee = grantee {
            try encodeContainer.encode(grantee, forKey: .grantee)
        }
        if let permission = permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.Grantee.self, forKey: .grantee)
        grantee = granteeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.Permission.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension GlacierClientTypes.Grant: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Grant(grantee: \(Swift.String(describing: grantee)), permission: \(Swift.String(describing: permission)))"}
}

extension GlacierClientTypes {
    /// <p>Contains information about a grant.</p>
    public struct Grant: Swift.Equatable {
        /// <p>The grantee.</p>
        public let grantee: GlacierClientTypes.Grantee?
        /// <p>Specifies the permission given to the grantee. </p>
        public let permission: GlacierClientTypes.Permission?

        public init (
            grantee: GlacierClientTypes.Grantee? = nil,
            permission: GlacierClientTypes.Permission? = nil
        )
        {
            self.grantee = grantee
            self.permission = permission
        }
    }

}

extension GlacierClientTypes.Grantee: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case emailAddress = "EmailAddress"
        case iD = "ID"
        case type = "Type"
        case uRI = "URI"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let iD = iD {
            try encodeContainer.encode(iD, forKey: .iD)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uRI = uRI {
            try encodeContainer.encode(uRI, forKey: .uRI)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let uRIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uRI)
        uRI = uRIDecoded
        let iDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iD)
        iD = iDDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
    }
}

extension GlacierClientTypes.Grantee: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Grantee(displayName: \(Swift.String(describing: displayName)), emailAddress: \(Swift.String(describing: emailAddress)), iD: \(Swift.String(describing: iD)), type: \(Swift.String(describing: type)), uRI: \(Swift.String(describing: uRI)))"}
}

extension GlacierClientTypes {
    /// <p>Contains information about the grantee.</p>
    public struct Grantee: Swift.Equatable {
        /// <p>Screen name of the grantee.</p>
        public let displayName: Swift.String?
        /// <p>Email address of the grantee.</p>
        public let emailAddress: Swift.String?
        /// <p>The canonical user ID of the grantee.</p>
        public let iD: Swift.String?
        /// <p>Type of grantee</p>
        public let type: GlacierClientTypes.ModelType?
        /// <p>URI of the grantee group.</p>
        public let uRI: Swift.String?

        public init (
            displayName: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            iD: Swift.String? = nil,
            type: GlacierClientTypes.ModelType? = nil,
            uRI: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.emailAddress = emailAddress
            self.iD = iD
            self.type = type
            self.uRI = uRI
        }
    }

}

public struct InitiateJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let jobParameters = input.operationInput.jobParameters {
            do {
                let encoder = context.getEncoder()
                let jobParametersdata = try encoder.encode(jobParameters)
                let jobParametersbody = ClientRuntime.HttpBody.data(jobParametersdata)
                input.builder.withBody(jobParametersbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateJobOutputError>
}

extension InitiateJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InitiateJobInput(accountId: \(Swift.String(describing: accountId)), jobParameters: \(Swift.String(describing: jobParameters)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension InitiateJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobParameters = jobParameters {
            try encodeContainer.encode(jobParameters, forKey: .jobParameters)
        }
    }
}

public struct InitiateJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateJobOutputError>
}

public struct InitiateJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateJobOutputError>
}

/// <p>Provides options for initiating an Amazon S3 Glacier job.</p>
public struct InitiateJobInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>Provides options for specifying job information.</p>
    public let jobParameters: GlacierClientTypes.JobParameters?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        jobParameters: GlacierClientTypes.JobParameters? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.jobParameters = jobParameters
        self.vaultName = vaultName
    }
}

struct InitiateJobInputBody: Swift.Equatable {
    public let jobParameters: GlacierClientTypes.JobParameters?
}

extension InitiateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobParameters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobParametersDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.JobParameters.self, forKey: .jobParameters)
        jobParameters = jobParametersDecoded
    }
}

extension InitiateJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsufficientCapacityException" : self = .insufficientCapacityException(try InsufficientCapacityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyEnforcedException" : self = .policyEnforcedException(try PolicyEnforcedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitiateJobOutputError: Swift.Error, Swift.Equatable {
    case insufficientCapacityException(InsufficientCapacityException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case policyEnforcedException(PolicyEnforcedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InitiateJobOutputResponse(jobId: \(Swift.String(describing: jobId)), jobOutputPath: \(Swift.String(describing: jobOutputPath)), location: \(Swift.String(describing: location)))"}
}

extension InitiateJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let jobIdHeaderValue = httpResponse.headers.value(for: "x-amz-job-id") {
            self.jobId = jobIdHeaderValue
        } else {
            self.jobId = nil
        }
        if let jobOutputPathHeaderValue = httpResponse.headers.value(for: "x-amz-job-output-path") {
            self.jobOutputPath = jobOutputPathHeaderValue
        } else {
            self.jobOutputPath = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct InitiateJobOutputResponse: Swift.Equatable {
    /// <p>The ID of the job.</p>
    public let jobId: Swift.String?
    /// <p>The path to the location of where the select results are stored.</p>
    public let jobOutputPath: Swift.String?
    /// <p>The relative URI path of the job.</p>
    public let location: Swift.String?

    public init (
        jobId: Swift.String? = nil,
        jobOutputPath: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.jobOutputPath = jobOutputPath
        self.location = location
    }
}

struct InitiateJobOutputResponseBody: Swift.Equatable {
}

extension InitiateJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension InitiateMultipartUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InitiateMultipartUploadInput(accountId: \(Swift.String(describing: accountId)), archiveDescription: \(Swift.String(describing: archiveDescription)), partSize: \(Swift.String(describing: partSize)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension InitiateMultipartUploadInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct InitiateMultipartUploadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateMultipartUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateMultipartUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let archiveDescription = input.operationInput.archiveDescription {
            input.builder.withHeader(name: "x-amz-archive-description", value: Swift.String(archiveDescription))
        }
        if let partSize = input.operationInput.partSize {
            input.builder.withHeader(name: "x-amz-part-size", value: Swift.String(partSize))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateMultipartUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateMultipartUploadOutputError>
}

public struct InitiateMultipartUploadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateMultipartUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateMultipartUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateMultipartUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateMultipartUploadOutputError>
}

/// <p>Provides options for initiating a multipart upload to an Amazon S3 Glacier
///          vault.</p>
public struct InitiateMultipartUploadInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: Swift.String?
    /// <p>The archive description that you are uploading in parts.</p>
    ///          <p>The part size must be a megabyte (1024 KB) multiplied by a power of 2, for example
    ///          1048576 (1 MB), 2097152 (2 MB), 4194304 (4 MB), 8388608 (8 MB), and so on. The minimum
    ///          allowable part size is 1 MB, and the maximum is 4 GB (4096 MB).</p>
    public let archiveDescription: Swift.String?
    /// <p>The size of each part except the last, in bytes. The last part can be smaller than
    ///          this part size.</p>
    public let partSize: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        archiveDescription: Swift.String? = nil,
        partSize: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.archiveDescription = archiveDescription
        self.partSize = partSize
        self.vaultName = vaultName
    }
}

struct InitiateMultipartUploadInputBody: Swift.Equatable {
}

extension InitiateMultipartUploadInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension InitiateMultipartUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateMultipartUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitiateMultipartUploadOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateMultipartUploadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InitiateMultipartUploadOutputResponse(location: \(Swift.String(describing: location)), uploadId: \(Swift.String(describing: uploadId)))"}
}

extension InitiateMultipartUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let uploadIdHeaderValue = httpResponse.headers.value(for: "x-amz-multipart-upload-id") {
            self.uploadId = uploadIdHeaderValue
        } else {
            self.uploadId = nil
        }
    }
}

/// <p>The Amazon S3 Glacier response to your request.</p>
public struct InitiateMultipartUploadOutputResponse: Swift.Equatable {
    /// <p>The relative URI path of the multipart upload ID Amazon S3 Glacier created.</p>
    public let location: Swift.String?
    /// <p>The ID of the multipart upload. This value is also included as part of the
    ///          location.</p>
    public let uploadId: Swift.String?

    public init (
        location: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.location = location
        self.uploadId = uploadId
    }
}

struct InitiateMultipartUploadOutputResponseBody: Swift.Equatable {
}

extension InitiateMultipartUploadOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct InitiateVaultLockInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateVaultLockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateVaultLockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let policy = input.operationInput.policy {
            do {
                let encoder = context.getEncoder()
                let policydata = try encoder.encode(policy)
                let policybody = ClientRuntime.HttpBody.data(policydata)
                input.builder.withBody(policybody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateVaultLockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateVaultLockOutputError>
}

extension InitiateVaultLockInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InitiateVaultLockInput(accountId: \(Swift.String(describing: accountId)), policy: \(Swift.String(describing: policy)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension InitiateVaultLockInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct InitiateVaultLockInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateVaultLockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateVaultLockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateVaultLockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateVaultLockOutputError>
}

public struct InitiateVaultLockInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateVaultLockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateVaultLockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateVaultLockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateVaultLockOutputError>
}

/// <p>The input values for <code>InitiateVaultLock</code>.</p>
public struct InitiateVaultLockInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID. This value must match the AWS
    ///          account ID associated with the credentials used to sign the request. You can either specify
    ///          an AWS account ID or optionally a single '<code>-</code>' (hyphen), in which case Amazon
    ///          Glacier uses the AWS account ID associated with the credentials used to sign the request.
    ///          If you specify your account ID, do not include any hyphens ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The vault lock policy as a JSON string, which uses "\" as an escape
    ///          character.</p>
    public let policy: GlacierClientTypes.VaultLockPolicy?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        policy: GlacierClientTypes.VaultLockPolicy? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.policy = policy
        self.vaultName = vaultName
    }
}

struct InitiateVaultLockInputBody: Swift.Equatable {
    public let policy: GlacierClientTypes.VaultLockPolicy?
}

extension InitiateVaultLockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.VaultLockPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension InitiateVaultLockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateVaultLockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitiateVaultLockOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateVaultLockOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InitiateVaultLockOutputResponse(lockId: \(Swift.String(describing: lockId)))"}
}

extension InitiateVaultLockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let lockIdHeaderValue = httpResponse.headers.value(for: "x-amz-lock-id") {
            self.lockId = lockIdHeaderValue
        } else {
            self.lockId = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct InitiateVaultLockOutputResponse: Swift.Equatable {
    /// <p>The lock ID, which is used to complete the vault locking process.</p>
    public let lockId: Swift.String?

    public init (
        lockId: Swift.String? = nil
    )
    {
        self.lockId = lockId
    }
}

struct InitiateVaultLockOutputResponseBody: Swift.Equatable {
}

extension InitiateVaultLockOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GlacierClientTypes.InputSerialization: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csv
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csv = csv {
            try encodeContainer.encode(csv, forKey: .csv)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csvDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.CSVInput.self, forKey: .csv)
        csv = csvDecoded
    }
}

extension GlacierClientTypes.InputSerialization: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InputSerialization(csv: \(Swift.String(describing: csv)))"}
}

extension GlacierClientTypes {
    /// <p>Describes how the archive is serialized.</p>
    public struct InputSerialization: Swift.Equatable {
        /// <p>Describes the serialization of a CSV-encoded object.</p>
        public let csv: GlacierClientTypes.CSVInput?

        public init (
            csv: GlacierClientTypes.CSVInput? = nil
        )
        {
            self.csv = csv
        }
    }

}

extension InsufficientCapacityException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InsufficientCapacityException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension InsufficientCapacityException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InsufficientCapacityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if there is insufficient capacity to process this expedited request. This
///          error only applies to expedited retrievals and not to standard or bulk
///          retrievals.</p>
public struct InsufficientCapacityException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct InsufficientCapacityExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let code: Swift.String?
    public let message: Swift.String?
}

extension InsufficientCapacityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterValueException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if a parameter of the request is incorrectly specified.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>400 Bad Request</p>
    public var code: Swift.String?
    /// <p>Returned if a parameter of the request is incorrectly specified.</p>
    public var message: Swift.String?
    /// <p>Client</p>
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let code: Swift.String?
    public let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlacierClientTypes.InventoryRetrievalJobDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDate = "EndDate"
        case format = "Format"
        case limit = "Limit"
        case marker = "Marker"
        case startDate = "StartDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension GlacierClientTypes.InventoryRetrievalJobDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InventoryRetrievalJobDescription(endDate: \(Swift.String(describing: endDate)), format: \(Swift.String(describing: format)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), startDate: \(Swift.String(describing: startDate)))"}
}

extension GlacierClientTypes {
    /// <p>Describes the options for a range inventory retrieval job.</p>
    public struct InventoryRetrievalJobDescription: Swift.Equatable {
        /// <p>The end of the date range in UTC for vault inventory retrieval that includes
        ///             archives created before this date. This value should be a string in the ISO 8601 date
        ///             format, for example <code>2013-03-20T17:03:43Z</code>.</p>
        public let endDate: Swift.String?
        /// <p>The output format for the vault inventory list, which is set by the <b>InitiateJob</b> request when initiating a job to retrieve a vault
        ///             inventory. Valid values are <code>CSV</code> and <code>JSON</code>.</p>
        public let format: Swift.String?
        /// <p>The maximum number of inventory items returned per vault inventory retrieval
        ///             request. This limit is set when initiating the job with the a <b>InitiateJob</b> request. </p>
        public let limit: Swift.String?
        /// <p>An opaque string that represents where to continue pagination of the vault
        ///             inventory retrieval results. You use the marker in a new <b>InitiateJob</b> request to obtain additional inventory items. If there are
        ///             no more inventory items, this value is <code>null</code>. For more information, see
        ///                 <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html#api-initiate-job-post-vault-inventory-list-filtering"> Range Inventory Retrieval</a>.</p>
        public let marker: Swift.String?
        /// <p>The start of the date range in Universal Coordinated Time (UTC) for vault inventory
        ///             retrieval that includes archives created on or after this date. This value should be a
        ///             string in the ISO 8601 date format, for example
        ///             <code>2013-03-20T17:03:43Z</code>.</p>
        public let startDate: Swift.String?

        public init (
            endDate: Swift.String? = nil,
            format: Swift.String? = nil,
            limit: Swift.String? = nil,
            marker: Swift.String? = nil,
            startDate: Swift.String? = nil
        )
        {
            self.endDate = endDate
            self.format = format
            self.limit = limit
            self.marker = marker
            self.startDate = startDate
        }
    }

}

extension GlacierClientTypes.InventoryRetrievalJobInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDate = "EndDate"
        case limit = "Limit"
        case marker = "Marker"
        case startDate = "StartDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension GlacierClientTypes.InventoryRetrievalJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InventoryRetrievalJobInput(endDate: \(Swift.String(describing: endDate)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), startDate: \(Swift.String(describing: startDate)))"}
}

extension GlacierClientTypes {
    /// <p>Provides options for specifying a range inventory retrieval job.</p>
    public struct InventoryRetrievalJobInput: Swift.Equatable {
        /// <p>The end of the date range in UTC for vault inventory retrieval that includes archives
        ///          created before this date. This value should be a string in the ISO 8601 date format, for
        ///          example <code>2013-03-20T17:03:43Z</code>.</p>
        public let endDate: Swift.String?
        /// <p>Specifies the maximum number of inventory items returned per vault inventory
        ///          retrieval request. Valid values are greater than or equal to 1.</p>
        public let limit: Swift.String?
        /// <p>An opaque string that represents where to continue pagination of the vault inventory
        ///          retrieval results. You use the marker in a new <b>InitiateJob</b>
        ///          request to obtain additional inventory items. If there are no more inventory items, this
        ///          value is <code>null</code>.</p>
        public let marker: Swift.String?
        /// <p>The start of the date range in UTC for vault inventory retrieval that includes
        ///          archives created on or after this date. This value should be a string in the ISO 8601 date
        ///          format, for example <code>2013-03-20T17:03:43Z</code>.</p>
        public let startDate: Swift.String?

        public init (
            endDate: Swift.String? = nil,
            limit: Swift.String? = nil,
            marker: Swift.String? = nil,
            startDate: Swift.String? = nil
        )
        {
            self.endDate = endDate
            self.limit = limit
            self.marker = marker
            self.startDate = startDate
        }
    }

}

extension GlacierClientTypes.JobParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveId = "ArchiveId"
        case description = "Description"
        case format = "Format"
        case inventoryRetrievalParameters = "InventoryRetrievalParameters"
        case outputLocation = "OutputLocation"
        case retrievalByteRange = "RetrievalByteRange"
        case sNSTopic = "SNSTopic"
        case selectParameters = "SelectParameters"
        case tier = "Tier"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveId = archiveId {
            try encodeContainer.encode(archiveId, forKey: .archiveId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let inventoryRetrievalParameters = inventoryRetrievalParameters {
            try encodeContainer.encode(inventoryRetrievalParameters, forKey: .inventoryRetrievalParameters)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let retrievalByteRange = retrievalByteRange {
            try encodeContainer.encode(retrievalByteRange, forKey: .retrievalByteRange)
        }
        if let sNSTopic = sNSTopic {
            try encodeContainer.encode(sNSTopic, forKey: .sNSTopic)
        }
        if let selectParameters = selectParameters {
            try encodeContainer.encode(selectParameters, forKey: .selectParameters)
        }
        if let tier = tier {
            try encodeContainer.encode(tier, forKey: .tier)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let archiveIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveId)
        archiveId = archiveIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sNSTopicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sNSTopic)
        sNSTopic = sNSTopicDecoded
        let retrievalByteRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalByteRange)
        retrievalByteRange = retrievalByteRangeDecoded
        let tierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tier)
        tier = tierDecoded
        let inventoryRetrievalParametersDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.InventoryRetrievalJobInput.self, forKey: .inventoryRetrievalParameters)
        inventoryRetrievalParameters = inventoryRetrievalParametersDecoded
        let selectParametersDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.SelectParameters.self, forKey: .selectParameters)
        selectParameters = selectParametersDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
    }
}

extension GlacierClientTypes.JobParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobParameters(archiveId: \(Swift.String(describing: archiveId)), description: \(Swift.String(describing: description)), format: \(Swift.String(describing: format)), inventoryRetrievalParameters: \(Swift.String(describing: inventoryRetrievalParameters)), outputLocation: \(Swift.String(describing: outputLocation)), retrievalByteRange: \(Swift.String(describing: retrievalByteRange)), sNSTopic: \(Swift.String(describing: sNSTopic)), selectParameters: \(Swift.String(describing: selectParameters)), tier: \(Swift.String(describing: tier)), type: \(Swift.String(describing: type)))"}
}

extension GlacierClientTypes {
    /// <p>Provides options for defining a job.</p>
    public struct JobParameters: Swift.Equatable {
        /// <p>The ID of the archive that you want to retrieve. This field is required only if
        ///             <code>Type</code> is set to <code>select</code> or <code>archive-retrieval</code>code>.
        ///          An error occurs if you specify this
        ///          request parameter for an inventory retrieval job request. </p>
        public let archiveId: Swift.String?
        /// <p>The optional description for the job. The description must be less than or equal to
        ///          1,024 bytes. The allowable characters are 7-bit ASCII without control codes-specifically,
        ///          ASCII values 32-126 decimal or 0x20-0x7E hexadecimal.</p>
        public let description: Swift.String?
        /// <p>When initiating a job to retrieve a vault inventory, you can optionally add this
        ///          parameter to your request to specify the output format. If you are initiating an inventory
        ///          job and do not specify a Format field, JSON is the default format. Valid values are "CSV"
        ///          and "JSON".</p>
        public let format: Swift.String?
        /// <p>Input parameters used for range inventory retrieval.</p>
        public let inventoryRetrievalParameters: GlacierClientTypes.InventoryRetrievalJobInput?
        /// <p>Contains information about the location where the select job results are stored.</p>
        public let outputLocation: GlacierClientTypes.OutputLocation?
        /// <p>The byte range to retrieve for an archive retrieval. in the form
        ///             "<i>StartByteValue</i>-<i>EndByteValue</i>" If not
        ///          specified, the whole archive is retrieved. If specified, the byte range must be megabyte
        ///          (1024*1024) aligned which means that <i>StartByteValue</i> must be divisible
        ///          by 1 MB and <i>EndByteValue</i> plus 1 must be divisible by 1 MB or be the
        ///          end of the archive specified as the archive byte size value minus 1. If RetrievalByteRange
        ///          is not megabyte aligned, this operation returns a 400 response. </p>
        ///          <p>An error occurs if you specify this field for an inventory retrieval job
        ///          request.</p>
        public let retrievalByteRange: Swift.String?
        /// <p>The Amazon SNS topic ARN to which Amazon S3 Glacier sends a notification when the job is
        ///          completed and the output is ready for you to download. The specified topic publishes the
        ///          notification to its subscribers. The SNS topic must exist.</p>
        public let sNSTopic: Swift.String?
        /// <p>Contains the parameters that define a job.</p>
        public let selectParameters: GlacierClientTypes.SelectParameters?
        /// <p>The tier to use for a select or an archive retrieval job. Valid values are
        ///             <code>Expedited</code>, <code>Standard</code>, or <code>Bulk</code>.
        ///             <code>Standard</code> is the default.</p>
        public let tier: Swift.String?
        /// <p>The job type. You can initiate a job to perform a select query on an archive,
        ///          retrieve an archive, or get an inventory of a vault.
        ///          Valid values are "select", "archive-retrieval" and "inventory-retrieval".</p>
        public let type: Swift.String?

        public init (
            archiveId: Swift.String? = nil,
            description: Swift.String? = nil,
            format: Swift.String? = nil,
            inventoryRetrievalParameters: GlacierClientTypes.InventoryRetrievalJobInput? = nil,
            outputLocation: GlacierClientTypes.OutputLocation? = nil,
            retrievalByteRange: Swift.String? = nil,
            sNSTopic: Swift.String? = nil,
            selectParameters: GlacierClientTypes.SelectParameters? = nil,
            tier: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.archiveId = archiveId
            self.description = description
            self.format = format
            self.inventoryRetrievalParameters = inventoryRetrievalParameters
            self.outputLocation = outputLocation
            self.retrievalByteRange = retrievalByteRange
            self.sNSTopic = sNSTopic
            self.selectParameters = selectParameters
            self.tier = tier
            self.type = type
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension LimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the request results in a vault or account limit being exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>400 Bad Request</p>
    public var code: Swift.String?
    /// <p>Returned if the request results in a vault limit or tags limit being exceeded.</p>
    public var message: Swift.String?
    /// <p>Client</p>
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let code: Swift.String?
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListJobsInput(accountId: \(Swift.String(describing: accountId)), completed: \(Swift.String(describing: completed)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), statuscode: \(Swift.String(describing: statuscode)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension ListJobsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsOutputError>
}

public struct ListJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let statuscode = input.operationInput.statuscode {
            let statuscodeQueryItem = ClientRuntime.URLQueryItem(name: "statuscode".urlPercentEncoding(), value: Swift.String(statuscode).urlPercentEncoding())
            input.builder.withQueryItem(statuscodeQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let completed = input.operationInput.completed {
            let completedQueryItem = ClientRuntime.URLQueryItem(name: "completed".urlPercentEncoding(), value: Swift.String(completed).urlPercentEncoding())
            input.builder.withQueryItem(completedQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsOutputError>
}

/// <p>Provides options for retrieving a job list for an Amazon S3 Glacier vault.</p>
public struct ListJobsInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: Swift.String?
    /// <p>The state of the jobs to return. You can specify <code>true</code> or
    ///             <code>false</code>.</p>
    public let completed: Swift.String?
    /// <p>The maximum number of jobs to be returned. The default limit is 50. The number of
    ///          jobs returned might be fewer than the specified limit, but the number of returned jobs
    ///          never exceeds the limit.</p>
    public let limit: Swift.Int?
    /// <p>An opaque string used for pagination. This value specifies the job at which the
    ///          listing of jobs should begin. Get the marker value from a previous List Jobs response. You
    ///          only need to include the marker if you are continuing the pagination of results started in
    ///          a previous List Jobs request.</p>
    public let marker: Swift.String?
    /// <p>The type of job status to return. You can specify the following values:
    ///             <code>InProgress</code>, <code>Succeeded</code>, or <code>Failed</code>.</p>
    public let statuscode: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        completed: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        statuscode: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.completed = completed
        self.limit = limit
        self.marker = marker
        self.statuscode = statuscode
        self.vaultName = vaultName
    }
}

struct ListJobsInputBody: Swift.Equatable {
}

extension ListJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListJobsOutputResponse(jobList: \(Swift.String(describing: jobList)), marker: \(Swift.String(describing: marker)))"}
}

extension ListJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobList = output.jobList
            self.marker = output.marker
        } else {
            self.jobList = nil
            self.marker = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct ListJobsOutputResponse: Swift.Equatable {
    /// <p>A list of job objects. Each job object contains metadata describing the
    ///          job.</p>
    public let jobList: [GlacierClientTypes.GlacierJobDescription]?
    /// <p>	
    ///          An opaque string used for pagination that specifies the job at which the listing of jobs should begin.
    ///          You get the <code>marker</code> value from a previous List Jobs response.
    ///          You only need to include the marker if you are continuing the pagination of the results started in a
    ///          previous List Jobs request. </p>
    public let marker: Swift.String?

    public init (
        jobList: [GlacierClientTypes.GlacierJobDescription]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.jobList = jobList
        self.marker = marker
    }
}

struct ListJobsOutputResponseBody: Swift.Equatable {
    public let jobList: [GlacierClientTypes.GlacierJobDescription]?
    public let marker: Swift.String?
}

extension ListJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobList = "JobList"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobListContainer = try containerValues.decodeIfPresent([GlacierClientTypes.GlacierJobDescription?].self, forKey: .jobList)
        var jobListDecoded0:[GlacierClientTypes.GlacierJobDescription]? = nil
        if let jobListContainer = jobListContainer {
            jobListDecoded0 = [GlacierClientTypes.GlacierJobDescription]()
            for structure0 in jobListContainer {
                if let structure0 = structure0 {
                    jobListDecoded0?.append(structure0)
                }
            }
        }
        jobList = jobListDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListMultipartUploadsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMultipartUploadsInput(accountId: \(Swift.String(describing: accountId)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension ListMultipartUploadsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListMultipartUploadsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMultipartUploadsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMultipartUploadsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMultipartUploadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMultipartUploadsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMultipartUploadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMultipartUploadsOutputError>
}

public struct ListMultipartUploadsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMultipartUploadsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMultipartUploadsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMultipartUploadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMultipartUploadsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMultipartUploadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMultipartUploadsOutputError>
}

/// <p>Provides options for retrieving list of in-progress multipart uploads for an Amazon
///          Glacier vault.</p>
public struct ListMultipartUploadsInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: Swift.String?
    /// <p>Specifies the maximum number of uploads returned in the response body. If this value
    ///          is not specified, the List Uploads operation returns up to 50 uploads.</p>
    public let limit: Swift.Int?
    /// <p>An opaque string used for pagination. This value specifies the upload at which the
    ///          listing of uploads should begin. Get the marker value from a previous List Uploads
    ///          response. You need only include the marker if you are continuing the pagination of results
    ///          started in a previous List Uploads request.</p>
    public let marker: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.limit = limit
        self.marker = marker
        self.vaultName = vaultName
    }
}

struct ListMultipartUploadsInputBody: Swift.Equatable {
}

extension ListMultipartUploadsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMultipartUploadsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMultipartUploadsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMultipartUploadsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMultipartUploadsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMultipartUploadsOutputResponse(marker: \(Swift.String(describing: marker)), uploadsList: \(Swift.String(describing: uploadsList)))"}
}

extension ListMultipartUploadsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMultipartUploadsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.uploadsList = output.uploadsList
        } else {
            self.marker = nil
            self.uploadsList = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct ListMultipartUploadsOutputResponse: Swift.Equatable {
    /// <p>An opaque string that represents where to continue pagination of the results. You use
    ///          the marker in a new List Multipart Uploads request to obtain more uploads in the list. If
    ///          there are no more uploads, this value is <code>null</code>.</p>
    public let marker: Swift.String?
    /// <p>A list of in-progress multipart uploads.</p>
    public let uploadsList: [GlacierClientTypes.UploadListElement]?

    public init (
        marker: Swift.String? = nil,
        uploadsList: [GlacierClientTypes.UploadListElement]? = nil
    )
    {
        self.marker = marker
        self.uploadsList = uploadsList
    }
}

struct ListMultipartUploadsOutputResponseBody: Swift.Equatable {
    public let uploadsList: [GlacierClientTypes.UploadListElement]?
    public let marker: Swift.String?
}

extension ListMultipartUploadsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case uploadsList = "UploadsList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadsListContainer = try containerValues.decodeIfPresent([GlacierClientTypes.UploadListElement?].self, forKey: .uploadsList)
        var uploadsListDecoded0:[GlacierClientTypes.UploadListElement]? = nil
        if let uploadsListContainer = uploadsListContainer {
            uploadsListDecoded0 = [GlacierClientTypes.UploadListElement]()
            for structure0 in uploadsListContainer {
                if let structure0 = structure0 {
                    uploadsListDecoded0?.append(structure0)
                }
            }
        }
        uploadsList = uploadsListDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListPartsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPartsInput(accountId: \(Swift.String(describing: accountId)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), uploadId: \(Swift.String(describing: uploadId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension ListPartsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPartsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPartsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPartsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPartsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPartsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPartsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPartsOutputError>
}

public struct ListPartsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPartsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPartsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPartsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPartsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPartsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPartsOutputError>
}

/// <p>Provides options for retrieving a list of parts of an archive that have been uploaded
///          in a specific multipart upload.</p>
public struct ListPartsInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: Swift.String?
    /// <p>The maximum number of parts to be returned. The default limit is 50. The number of
    ///          parts returned might be fewer than the specified limit, but the number of returned parts
    ///          never exceeds the limit.</p>
    public let limit: Swift.Int?
    /// <p>An opaque string used for pagination. This value specifies the part at which the
    ///          listing of parts should begin. Get the marker value from the response of a previous List
    ///          Parts response. You need only include the marker if you are continuing the pagination of
    ///          results started in a previous List Parts request.</p>
    public let marker: Swift.String?
    /// <p>The upload ID of the multipart upload.</p>
    public let uploadId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        uploadId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.limit = limit
        self.marker = marker
        self.uploadId = uploadId
        self.vaultName = vaultName
    }
}

struct ListPartsInputBody: Swift.Equatable {
}

extension ListPartsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPartsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPartsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPartsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPartsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPartsOutputResponse(archiveDescription: \(Swift.String(describing: archiveDescription)), creationDate: \(Swift.String(describing: creationDate)), marker: \(Swift.String(describing: marker)), multipartUploadId: \(Swift.String(describing: multipartUploadId)), partSizeInBytes: \(Swift.String(describing: partSizeInBytes)), parts: \(Swift.String(describing: parts)), vaultARN: \(Swift.String(describing: vaultARN)))"}
}

extension ListPartsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPartsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.archiveDescription = output.archiveDescription
            self.creationDate = output.creationDate
            self.marker = output.marker
            self.multipartUploadId = output.multipartUploadId
            self.partSizeInBytes = output.partSizeInBytes
            self.parts = output.parts
            self.vaultARN = output.vaultARN
        } else {
            self.archiveDescription = nil
            self.creationDate = nil
            self.marker = nil
            self.multipartUploadId = nil
            self.partSizeInBytes = 0
            self.parts = nil
            self.vaultARN = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct ListPartsOutputResponse: Swift.Equatable {
    /// <p>The description of the archive that was specified in the Initiate Multipart Upload
    ///          request.</p>
    public let archiveDescription: Swift.String?
    /// <p>The UTC time at which the multipart upload was initiated.</p>
    public let creationDate: Swift.String?
    /// <p>An opaque string that represents where to continue pagination of the results. You use
    ///          the marker in a new List Parts request to obtain more jobs in the list. If there are no
    ///          more parts, this value is <code>null</code>.</p>
    public let marker: Swift.String?
    /// <p>The ID of the upload to which the parts are associated.</p>
    public let multipartUploadId: Swift.String?
    /// <p>The part size in bytes. This is the same value that you specified in the Initiate
    ///          Multipart Upload request.</p>
    public let partSizeInBytes: Swift.Int
    /// <p>A list of the part sizes of the multipart upload. Each object in the array contains a
    ///          <code>RangeBytes</code> and <code>sha256-tree-hash</code> name/value
    ///          pair.</p>
    public let parts: [GlacierClientTypes.PartListElement]?
    /// <p>The Amazon Resource Name (ARN) of the vault to which the multipart upload was
    ///          initiated.</p>
    public let vaultARN: Swift.String?

    public init (
        archiveDescription: Swift.String? = nil,
        creationDate: Swift.String? = nil,
        marker: Swift.String? = nil,
        multipartUploadId: Swift.String? = nil,
        partSizeInBytes: Swift.Int = 0,
        parts: [GlacierClientTypes.PartListElement]? = nil,
        vaultARN: Swift.String? = nil
    )
    {
        self.archiveDescription = archiveDescription
        self.creationDate = creationDate
        self.marker = marker
        self.multipartUploadId = multipartUploadId
        self.partSizeInBytes = partSizeInBytes
        self.parts = parts
        self.vaultARN = vaultARN
    }
}

struct ListPartsOutputResponseBody: Swift.Equatable {
    public let multipartUploadId: Swift.String?
    public let vaultARN: Swift.String?
    public let archiveDescription: Swift.String?
    public let partSizeInBytes: Swift.Int
    public let creationDate: Swift.String?
    public let parts: [GlacierClientTypes.PartListElement]?
    public let marker: Swift.String?
}

extension ListPartsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveDescription = "ArchiveDescription"
        case creationDate = "CreationDate"
        case marker = "Marker"
        case multipartUploadId = "MultipartUploadId"
        case partSizeInBytes = "PartSizeInBytes"
        case parts = "Parts"
        case vaultARN = "VaultARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multipartUploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multipartUploadId)
        multipartUploadId = multipartUploadIdDecoded
        let vaultARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let archiveDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveDescription)
        archiveDescription = archiveDescriptionDecoded
        let partSizeInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .partSizeInBytes)
        partSizeInBytes = partSizeInBytesDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let partsContainer = try containerValues.decodeIfPresent([GlacierClientTypes.PartListElement?].self, forKey: .parts)
        var partsDecoded0:[GlacierClientTypes.PartListElement]? = nil
        if let partsContainer = partsContainer {
            partsDecoded0 = [GlacierClientTypes.PartListElement]()
            for structure0 in partsContainer {
                if let structure0 = structure0 {
                    partsDecoded0?.append(structure0)
                }
            }
        }
        parts = partsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListProvisionedCapacityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProvisionedCapacityInput(accountId: \(Swift.String(describing: accountId)))"}
}

extension ListProvisionedCapacityInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListProvisionedCapacityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisionedCapacityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProvisionedCapacityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisionedCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProvisionedCapacityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisionedCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisionedCapacityOutputError>
}

public struct ListProvisionedCapacityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisionedCapacityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProvisionedCapacityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisionedCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProvisionedCapacityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisionedCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisionedCapacityOutputError>
}

public struct ListProvisionedCapacityInput: Swift.Equatable {
    /// <p>The AWS account ID of the account that owns the vault. You can either specify an AWS
    ///          account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS
    ///          account ID associated with the credentials used to sign the request. If you use an account
    ///          ID, don't include any hyphens ('-') in the ID. </p>
    public let accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct ListProvisionedCapacityInputBody: Swift.Equatable {
}

extension ListProvisionedCapacityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProvisionedCapacityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProvisionedCapacityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProvisionedCapacityOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProvisionedCapacityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProvisionedCapacityOutputResponse(provisionedCapacityList: \(Swift.String(describing: provisionedCapacityList)))"}
}

extension ListProvisionedCapacityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProvisionedCapacityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.provisionedCapacityList = output.provisionedCapacityList
        } else {
            self.provisionedCapacityList = nil
        }
    }
}

public struct ListProvisionedCapacityOutputResponse: Swift.Equatable {
    /// <p>The response body contains the following JSON fields.</p>
    public let provisionedCapacityList: [GlacierClientTypes.ProvisionedCapacityDescription]?

    public init (
        provisionedCapacityList: [GlacierClientTypes.ProvisionedCapacityDescription]? = nil
    )
    {
        self.provisionedCapacityList = provisionedCapacityList
    }
}

struct ListProvisionedCapacityOutputResponseBody: Swift.Equatable {
    public let provisionedCapacityList: [GlacierClientTypes.ProvisionedCapacityDescription]?
}

extension ListProvisionedCapacityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedCapacityList = "ProvisionedCapacityList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedCapacityListContainer = try containerValues.decodeIfPresent([GlacierClientTypes.ProvisionedCapacityDescription?].self, forKey: .provisionedCapacityList)
        var provisionedCapacityListDecoded0:[GlacierClientTypes.ProvisionedCapacityDescription]? = nil
        if let provisionedCapacityListContainer = provisionedCapacityListContainer {
            provisionedCapacityListDecoded0 = [GlacierClientTypes.ProvisionedCapacityDescription]()
            for structure0 in provisionedCapacityListContainer {
                if let structure0 = structure0 {
                    provisionedCapacityListDecoded0?.append(structure0)
                }
            }
        }
        provisionedCapacityList = provisionedCapacityListDecoded0
    }
}

extension ListTagsForVaultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForVaultInput(accountId: \(Swift.String(describing: accountId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension ListTagsForVaultInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForVaultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForVaultOutputError>
}

public struct ListTagsForVaultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForVaultOutputError>
}

/// <p>The input value for <code>ListTagsForVaultInput</code>.</p>
public struct ListTagsForVaultInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct ListTagsForVaultInputBody: Swift.Equatable {
}

extension ListTagsForVaultInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForVaultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForVaultOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForVaultOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct ListTagsForVaultOutputResponse: Swift.Equatable {
    /// <p>The tags attached to the vault. Each tag is composed of a key and a value.</p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForVaultOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForVaultOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVaultsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVaultsInput(accountId: \(Swift.String(describing: accountId)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)))"}
}

extension ListVaultsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListVaultsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVaultsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVaultsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVaultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVaultsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVaultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVaultsOutputError>
}

public struct ListVaultsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVaultsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVaultsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVaultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVaultsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVaultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVaultsOutputError>
}

/// <p>Provides options to retrieve the vault list owned by the calling user's account. The
///          list provides metadata information for each vault.</p>
public struct ListVaultsInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID. This value must match the AWS
    ///          account ID associated with the credentials used to sign the request. You can either specify
    ///          an AWS account ID or optionally a single '<code>-</code>' (hyphen), in which case Amazon
    ///          Glacier uses the AWS account ID associated with the credentials used to sign the request.
    ///          If you specify your account ID, do not include any hyphens ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The maximum number of vaults to be returned. The default limit is 10. The number of
    ///          vaults returned might be fewer than the specified limit, but the number of returned vaults
    ///          never exceeds the limit.</p>
    public let limit: Swift.Int?
    /// <p>A string used for pagination. The marker specifies the vault ARN after which the
    ///          listing of vaults should begin.</p>
    public let marker: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.limit = limit
        self.marker = marker
    }
}

struct ListVaultsInputBody: Swift.Equatable {
}

extension ListVaultsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVaultsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVaultsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVaultsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVaultsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVaultsOutputResponse(marker: \(Swift.String(describing: marker)), vaultList: \(Swift.String(describing: vaultList)))"}
}

extension ListVaultsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListVaultsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.vaultList = output.vaultList
        } else {
            self.marker = nil
            self.vaultList = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct ListVaultsOutputResponse: Swift.Equatable {
    /// <p>The vault ARN at which to continue pagination of the results. You use the marker in
    ///          another List Vaults request to obtain more vaults in the list.</p>
    public let marker: Swift.String?
    /// <p>List of vaults.</p>
    public let vaultList: [GlacierClientTypes.DescribeVaultOutput]?

    public init (
        marker: Swift.String? = nil,
        vaultList: [GlacierClientTypes.DescribeVaultOutput]? = nil
    )
    {
        self.marker = marker
        self.vaultList = vaultList
    }
}

struct ListVaultsOutputResponseBody: Swift.Equatable {
    public let vaultList: [GlacierClientTypes.DescribeVaultOutput]?
    public let marker: Swift.String?
}

extension ListVaultsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case vaultList = "VaultList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultListContainer = try containerValues.decodeIfPresent([GlacierClientTypes.DescribeVaultOutput?].self, forKey: .vaultList)
        var vaultListDecoded0:[GlacierClientTypes.DescribeVaultOutput]? = nil
        if let vaultListContainer = vaultListContainer {
            vaultListDecoded0 = [GlacierClientTypes.DescribeVaultOutput]()
            for structure0 in vaultListContainer {
                if let structure0 = structure0 {
                    vaultListDecoded0?.append(structure0)
                }
            }
        }
        vaultList = vaultListDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension MissingParameterValueException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MissingParameterValueException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension MissingParameterValueException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MissingParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if a required header or parameter is missing from the request.</p>
public struct MissingParameterValueException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>400 Bad Request</p>
    public var code: Swift.String?
    /// <p>Returned if no authentication data is found for the request.</p>
    public var message: Swift.String?
    /// <p>Client.</p>
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct MissingParameterValueExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let code: Swift.String?
    public let message: Swift.String?
}

extension MissingParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlacierClientTypes.OutputLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3 = "S3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(GlacierClientTypes.S3Location.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension GlacierClientTypes.OutputLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OutputLocation(s3: \(Swift.String(describing: s3)))"}
}

extension GlacierClientTypes {
    /// <p>Contains information about the location where the select job results are stored.</p>
    public struct OutputLocation: Swift.Equatable {
        /// <p>Describes an S3 location that will receive the results of the job request.</p>
        public let s3: GlacierClientTypes.S3Location?

        public init (
            s3: GlacierClientTypes.S3Location? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension GlacierClientTypes.OutputSerialization: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csv
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csv = csv {
            try encodeContainer.encode(csv, forKey: .csv)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csvDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.CSVOutput.self, forKey: .csv)
        csv = csvDecoded
    }
}

extension GlacierClientTypes.OutputSerialization: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OutputSerialization(csv: \(Swift.String(describing: csv)))"}
}

extension GlacierClientTypes {
    /// <p>Describes how the select output is serialized.</p>
    public struct OutputSerialization: Swift.Equatable {
        /// <p>Describes the serialization of CSV-encoded query results.</p>
        public let csv: GlacierClientTypes.CSVOutput?

        public init (
            csv: GlacierClientTypes.CSVOutput? = nil
        )
        {
            self.csv = csv
        }
    }

}

extension GlacierClientTypes.PartListElement: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rangeInBytes = "RangeInBytes"
        case sHA256TreeHash = "SHA256TreeHash"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rangeInBytes = rangeInBytes {
            try encodeContainer.encode(rangeInBytes, forKey: .rangeInBytes)
        }
        if let sHA256TreeHash = sHA256TreeHash {
            try encodeContainer.encode(sHA256TreeHash, forKey: .sHA256TreeHash)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rangeInBytesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rangeInBytes)
        rangeInBytes = rangeInBytesDecoded
        let sHA256TreeHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sHA256TreeHash)
        sHA256TreeHash = sHA256TreeHashDecoded
    }
}

extension GlacierClientTypes.PartListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PartListElement(rangeInBytes: \(Swift.String(describing: rangeInBytes)), sHA256TreeHash: \(Swift.String(describing: sHA256TreeHash)))"}
}

extension GlacierClientTypes {
    /// <p>A list of the part sizes of the multipart upload.</p>
    public struct PartListElement: Swift.Equatable {
        /// <p>The byte range of a part, inclusive of the upper value of the range.</p>
        public let rangeInBytes: Swift.String?
        /// <p>The SHA256 tree hash value that Amazon S3 Glacier calculated for the part. This field is
        ///          never <code>null</code>.</p>
        public let sHA256TreeHash: Swift.String?

        public init (
            rangeInBytes: Swift.String? = nil,
            sHA256TreeHash: Swift.String? = nil
        )
        {
            self.rangeInBytes = rangeInBytes
            self.sHA256TreeHash = sHA256TreeHash
        }
    }

}

extension GlacierClientTypes {
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullControl
        case read
        case readAcp
        case write
        case writeAcp
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .fullControl,
                .read,
                .readAcp,
                .write,
                .writeAcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullControl: return "FULL_CONTROL"
            case .read: return "READ"
            case .readAcp: return "READ_ACP"
            case .write: return "WRITE"
            case .writeAcp: return "WRITE_ACP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
        }
    }
}

extension PolicyEnforcedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyEnforcedException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension PolicyEnforcedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PolicyEnforcedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if a retrieval job would exceed the current data policy's retrieval rate
///          limit. For more information about data retrieval policies,</p>
public struct PolicyEnforcedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>PolicyEnforcedException</p>
    public var code: Swift.String?
    /// <p>InitiateJob request denied by current data retrieval policy.</p>
    public var message: Swift.String?
    /// <p>Client</p>
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct PolicyEnforcedExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let code: Swift.String?
    public let message: Swift.String?
}

extension PolicyEnforcedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlacierClientTypes.ProvisionedCapacityDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityId = "CapacityId"
        case expirationDate = "ExpirationDate"
        case startDate = "StartDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityId = capacityId {
            try encodeContainer.encode(capacityId, forKey: .capacityId)
        }
        if let expirationDate = expirationDate {
            try encodeContainer.encode(expirationDate, forKey: .expirationDate)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityId)
        capacityId = capacityIdDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
    }
}

extension GlacierClientTypes.ProvisionedCapacityDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionedCapacityDescription(capacityId: \(Swift.String(describing: capacityId)), expirationDate: \(Swift.String(describing: expirationDate)), startDate: \(Swift.String(describing: startDate)))"}
}

extension GlacierClientTypes {
    /// <p>The definition for a provisioned capacity unit.</p>
    public struct ProvisionedCapacityDescription: Swift.Equatable {
        /// <p>The ID that identifies the provisioned capacity unit.</p>
        public let capacityId: Swift.String?
        /// <p>The date that the provisioned capacity unit expires, in Universal Coordinated Time (UTC).</p>
        public let expirationDate: Swift.String?
        /// <p>The date that the provisioned capacity unit was purchased, in Universal Coordinated Time (UTC).</p>
        public let startDate: Swift.String?

        public init (
            capacityId: Swift.String? = nil,
            expirationDate: Swift.String? = nil,
            startDate: Swift.String? = nil
        )
        {
            self.capacityId = capacityId
            self.expirationDate = expirationDate
            self.startDate = startDate
        }
    }

}

extension PurchaseProvisionedCapacityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PurchaseProvisionedCapacityInput(accountId: \(Swift.String(describing: accountId)))"}
}

extension PurchaseProvisionedCapacityInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct PurchaseProvisionedCapacityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PurchaseProvisionedCapacityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PurchaseProvisionedCapacityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PurchaseProvisionedCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PurchaseProvisionedCapacityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PurchaseProvisionedCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PurchaseProvisionedCapacityOutputError>
}

public struct PurchaseProvisionedCapacityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PurchaseProvisionedCapacityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PurchaseProvisionedCapacityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PurchaseProvisionedCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PurchaseProvisionedCapacityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PurchaseProvisionedCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PurchaseProvisionedCapacityOutputError>
}

public struct PurchaseProvisionedCapacityInput: Swift.Equatable {
    /// <p>The AWS account ID of the account that owns the vault. You can either specify an AWS
    ///          account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS
    ///          account ID associated with the credentials used to sign the request. If you use an account
    ///          ID, don't include any hyphens ('-') in the ID. </p>
    public let accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct PurchaseProvisionedCapacityInputBody: Swift.Equatable {
}

extension PurchaseProvisionedCapacityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PurchaseProvisionedCapacityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PurchaseProvisionedCapacityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PurchaseProvisionedCapacityOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PurchaseProvisionedCapacityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PurchaseProvisionedCapacityOutputResponse(capacityId: \(Swift.String(describing: capacityId)))"}
}

extension PurchaseProvisionedCapacityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let capacityIdHeaderValue = httpResponse.headers.value(for: "x-amz-capacity-id") {
            self.capacityId = capacityIdHeaderValue
        } else {
            self.capacityId = nil
        }
    }
}

public struct PurchaseProvisionedCapacityOutputResponse: Swift.Equatable {
    /// <p>The ID that identifies the provisioned capacity unit.</p>
    public let capacityId: Swift.String?

    public init (
        capacityId: Swift.String? = nil
    )
    {
        self.capacityId = capacityId
    }
}

struct PurchaseProvisionedCapacityOutputResponseBody: Swift.Equatable {
}

extension PurchaseProvisionedCapacityOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GlacierClientTypes {
    public enum QuoteFields: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case always
        case asneeded
        case sdkUnknown(Swift.String)

        public static var allCases: [QuoteFields] {
            return [
                .always,
                .asneeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .always: return "ALWAYS"
            case .asneeded: return "ASNEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuoteFields(rawValue: rawValue) ?? QuoteFields.sdkUnknown(rawValue)
        }
    }
}

public struct RemoveTagsFromVaultInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromVaultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromVaultOutputError>
}

extension RemoveTagsFromVaultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromVaultInput(tagKeys: \(Swift.String(describing: tagKeys)), accountId: \(Swift.String(describing: accountId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension RemoveTagsFromVaultInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct RemoveTagsFromVaultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromVaultOutputError>
}

public struct RemoveTagsFromVaultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "remove"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromVaultOutputError>
}

/// <p>The input value for <code>RemoveTagsFromVaultInput</code>.</p>
public struct RemoveTagsFromVaultInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>A list of tag keys. Each corresponding tag is removed from the vault.</p>
    public let tagKeys: [Swift.String]?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.tagKeys = tagKeys
        self.vaultName = vaultName
    }
}

struct RemoveTagsFromVaultInputBody: Swift.Equatable {
    public let tagKeys: [Swift.String]?
}

extension RemoveTagsFromVaultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromVaultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromVaultOutputResponse()"}
}

extension RemoveTagsFromVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsFromVaultOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemoveTagsFromVaultOutputResponseBody: Swift.Equatable {
}

extension RemoveTagsFromVaultOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RequestTimeoutException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestTimeoutException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension RequestTimeoutException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if, when uploading an archive, Amazon S3 Glacier times out while receiving the
///          upload.</p>
public struct RequestTimeoutException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>408 Request Timeout</p>
    public var code: Swift.String?
    /// <p>Returned if, when uploading an archive, Amazon S3 Glacier times out while receiving the
    ///          upload.</p>
    public var message: Swift.String?
    /// <p>Client</p>
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct RequestTimeoutExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let code: Swift.String?
    public let message: Swift.String?
}

extension RequestTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the specified resource (such as a vault, upload ID, or job ID) doesn't
///          exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>404 Not Found</p>
    public var code: Swift.String?
    /// <p>Returned if the specified resource (such as a vault, upload ID, or job ID) doesn't
    ///          exist.</p>
    public var message: Swift.String?
    /// <p>Client</p>
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let code: Swift.String?
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlacierClientTypes.S3Location: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlList = "AccessControlList"
        case bucketName = "BucketName"
        case cannedACL = "CannedACL"
        case encryption = "Encryption"
        case prefix = "Prefix"
        case storageClass = "StorageClass"
        case tagging = "Tagging"
        case userMetadata = "UserMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlList = accessControlList {
            var accessControlListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessControlList)
            for accesscontrolpolicylist0 in accessControlList {
                try accessControlListContainer.encode(accesscontrolpolicylist0)
            }
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let cannedACL = cannedACL {
            try encodeContainer.encode(cannedACL.rawValue, forKey: .cannedACL)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
        if let storageClass = storageClass {
            try encodeContainer.encode(storageClass.rawValue, forKey: .storageClass)
        }
        if let tagging = tagging {
            var taggingContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tagging)
            for (dictKey0, hashmap0) in tagging {
                try taggingContainer.encode(hashmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userMetadata = userMetadata {
            var userMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .userMetadata)
            for (dictKey0, hashmap0) in userMetadata {
                try userMetadataContainer.encode(hashmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        prefix = prefixDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let cannedACLDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.CannedACL.self, forKey: .cannedACL)
        cannedACL = cannedACLDecoded
        let accessControlListContainer = try containerValues.decodeIfPresent([GlacierClientTypes.Grant?].self, forKey: .accessControlList)
        var accessControlListDecoded0:[GlacierClientTypes.Grant]? = nil
        if let accessControlListContainer = accessControlListContainer {
            accessControlListDecoded0 = [GlacierClientTypes.Grant]()
            for structure0 in accessControlListContainer {
                if let structure0 = structure0 {
                    accessControlListDecoded0?.append(structure0)
                }
            }
        }
        accessControlList = accessControlListDecoded0
        let taggingContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tagging)
        var taggingDecoded0: [Swift.String:Swift.String]? = nil
        if let taggingContainer = taggingContainer {
            taggingDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in taggingContainer {
                if let string0 = string0 {
                    taggingDecoded0?[key0] = string0
                }
            }
        }
        tagging = taggingDecoded0
        let userMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .userMetadata)
        var userMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let userMetadataContainer = userMetadataContainer {
            userMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in userMetadataContainer {
                if let string0 = string0 {
                    userMetadataDecoded0?[key0] = string0
                }
            }
        }
        userMetadata = userMetadataDecoded0
        let storageClassDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension GlacierClientTypes.S3Location: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Location(accessControlList: \(Swift.String(describing: accessControlList)), bucketName: \(Swift.String(describing: bucketName)), cannedACL: \(Swift.String(describing: cannedACL)), encryption: \(Swift.String(describing: encryption)), prefix: \(Swift.String(describing: prefix)), storageClass: \(Swift.String(describing: storageClass)), tagging: \(Swift.String(describing: tagging)), userMetadata: \(Swift.String(describing: userMetadata)))"}
}

extension GlacierClientTypes {
    /// <p>Contains information about the location in Amazon S3 where the select job results are stored.</p>
    public struct S3Location: Swift.Equatable {
        /// <p>A list of grants that control access to the staged results.</p>
        public let accessControlList: [GlacierClientTypes.Grant]?
        /// <p>The name of the Amazon S3 bucket where the job results are stored.</p>
        public let bucketName: Swift.String?
        /// <p>The canned access control list (ACL) to apply to the job results.</p>
        public let cannedACL: GlacierClientTypes.CannedACL?
        /// <p>Contains information about the encryption used to store the job results in Amazon S3.</p>
        public let encryption: GlacierClientTypes.Encryption?
        /// <p>The prefix that is prepended to the results for this request.</p>
        public let prefix: Swift.String?
        /// <p>The storage class used to store the job results.</p>
        public let storageClass: GlacierClientTypes.StorageClass?
        /// <p>The tag-set that is applied to the job results.</p>
        public let tagging: [Swift.String:Swift.String]?
        /// <p>A map of metadata to store with the job results in Amazon S3.</p>
        public let userMetadata: [Swift.String:Swift.String]?

        public init (
            accessControlList: [GlacierClientTypes.Grant]? = nil,
            bucketName: Swift.String? = nil,
            cannedACL: GlacierClientTypes.CannedACL? = nil,
            encryption: GlacierClientTypes.Encryption? = nil,
            prefix: Swift.String? = nil,
            storageClass: GlacierClientTypes.StorageClass? = nil,
            tagging: [Swift.String:Swift.String]? = nil,
            userMetadata: [Swift.String:Swift.String]? = nil
        )
        {
            self.accessControlList = accessControlList
            self.bucketName = bucketName
            self.cannedACL = cannedACL
            self.encryption = encryption
            self.prefix = prefix
            self.storageClass = storageClass
            self.tagging = tagging
            self.userMetadata = userMetadata
        }
    }

}

extension GlacierClientTypes.SelectParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case inputSerialization = "InputSerialization"
        case outputSerialization = "OutputSerialization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let inputSerialization = inputSerialization {
            try encodeContainer.encode(inputSerialization, forKey: .inputSerialization)
        }
        if let outputSerialization = outputSerialization {
            try encodeContainer.encode(outputSerialization, forKey: .outputSerialization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSerializationDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.InputSerialization.self, forKey: .inputSerialization)
        inputSerialization = inputSerializationDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let outputSerializationDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.OutputSerialization.self, forKey: .outputSerialization)
        outputSerialization = outputSerializationDecoded
    }
}

extension GlacierClientTypes.SelectParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SelectParameters(expression: \(Swift.String(describing: expression)), expressionType: \(Swift.String(describing: expressionType)), inputSerialization: \(Swift.String(describing: inputSerialization)), outputSerialization: \(Swift.String(describing: outputSerialization)))"}
}

extension GlacierClientTypes {
    /// <p>Contains information about the parameters used for a select.</p>
    public struct SelectParameters: Swift.Equatable {
        /// <p>The expression that is used to select the object.</p>
        public let expression: Swift.String?
        /// <p>The type of the provided expression, for example <code>SQL</code>.</p>
        public let expressionType: GlacierClientTypes.ExpressionType?
        /// <p>Describes the serialization format of the object.</p>
        public let inputSerialization: GlacierClientTypes.InputSerialization?
        /// <p>Describes how the results of the select job are serialized.</p>
        public let outputSerialization: GlacierClientTypes.OutputSerialization?

        public init (
            expression: Swift.String? = nil,
            expressionType: GlacierClientTypes.ExpressionType? = nil,
            inputSerialization: GlacierClientTypes.InputSerialization? = nil,
            outputSerialization: GlacierClientTypes.OutputSerialization? = nil
        )
        {
            self.expression = expression
            self.expressionType = expressionType
            self.inputSerialization = inputSerialization
            self.outputSerialization = outputSerialization
        }
    }

}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the service cannot complete the request.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// <p>500 Internal Server Error</p>
    public var code: Swift.String?
    /// <p>Returned if the service cannot complete the request.</p>
    public var message: Swift.String?
    /// <p>Server</p>
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let type: Swift.String?
    public let code: Swift.String?
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SetDataRetrievalPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetDataRetrievalPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetDataRetrievalPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetDataRetrievalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetDataRetrievalPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetDataRetrievalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetDataRetrievalPolicyOutputError>
}

extension SetDataRetrievalPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetDataRetrievalPolicyInput(policy: \(Swift.String(describing: policy)), accountId: \(Swift.String(describing: accountId)))"}
}

extension SetDataRetrievalPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct SetDataRetrievalPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetDataRetrievalPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetDataRetrievalPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetDataRetrievalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetDataRetrievalPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetDataRetrievalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetDataRetrievalPolicyOutputError>
}

public struct SetDataRetrievalPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetDataRetrievalPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetDataRetrievalPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetDataRetrievalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetDataRetrievalPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetDataRetrievalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetDataRetrievalPolicyOutputError>
}

/// <p>SetDataRetrievalPolicy input.</p>
public struct SetDataRetrievalPolicyInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID. This value must match the AWS
    ///          account ID associated with the credentials used to sign the request. You can either specify
    ///          an AWS account ID or optionally a single '<code>-</code>' (hyphen), in which case Amazon
    ///          Glacier uses the AWS account ID associated with the credentials used to sign the request.
    ///          If you specify your account ID, do not include any hyphens ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The data retrieval policy in JSON format.</p>
    public let policy: GlacierClientTypes.DataRetrievalPolicy?

    public init (
        accountId: Swift.String? = nil,
        policy: GlacierClientTypes.DataRetrievalPolicy? = nil
    )
    {
        self.accountId = accountId
        self.policy = policy
    }
}

struct SetDataRetrievalPolicyInputBody: Swift.Equatable {
    public let policy: GlacierClientTypes.DataRetrievalPolicy?
}

extension SetDataRetrievalPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.DataRetrievalPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension SetDataRetrievalPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetDataRetrievalPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetDataRetrievalPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetDataRetrievalPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetDataRetrievalPolicyOutputResponse()"}
}

extension SetDataRetrievalPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetDataRetrievalPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct SetDataRetrievalPolicyOutputResponseBody: Swift.Equatable {
}

extension SetDataRetrievalPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct SetVaultAccessPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetVaultAccessPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let policy = input.operationInput.policy {
            do {
                let encoder = context.getEncoder()
                let policydata = try encoder.encode(policy)
                let policybody = ClientRuntime.HttpBody.data(policydata)
                input.builder.withBody(policybody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetVaultAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetVaultAccessPolicyOutputError>
}

extension SetVaultAccessPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetVaultAccessPolicyInput(accountId: \(Swift.String(describing: accountId)), policy: \(Swift.String(describing: policy)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension SetVaultAccessPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct SetVaultAccessPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetVaultAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetVaultAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetVaultAccessPolicyOutputError>
}

public struct SetVaultAccessPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetVaultAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetVaultAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetVaultAccessPolicyOutputError>
}

/// <p>SetVaultAccessPolicy input.</p>
public struct SetVaultAccessPolicyInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The vault access policy as a JSON string.</p>
    public let policy: GlacierClientTypes.VaultAccessPolicy?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        policy: GlacierClientTypes.VaultAccessPolicy? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.policy = policy
        self.vaultName = vaultName
    }
}

struct SetVaultAccessPolicyInputBody: Swift.Equatable {
    public let policy: GlacierClientTypes.VaultAccessPolicy?
}

extension SetVaultAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.VaultAccessPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension SetVaultAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetVaultAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetVaultAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetVaultAccessPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetVaultAccessPolicyOutputResponse()"}
}

extension SetVaultAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetVaultAccessPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct SetVaultAccessPolicyOutputResponseBody: Swift.Equatable {
}

extension SetVaultAccessPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct SetVaultNotificationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetVaultNotificationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetVaultNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let vaultNotificationConfig = input.operationInput.vaultNotificationConfig {
            do {
                let encoder = context.getEncoder()
                let vaultNotificationConfigdata = try encoder.encode(vaultNotificationConfig)
                let vaultNotificationConfigbody = ClientRuntime.HttpBody.data(vaultNotificationConfigdata)
                input.builder.withBody(vaultNotificationConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetVaultNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetVaultNotificationsOutputError>
}

extension SetVaultNotificationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetVaultNotificationsInput(accountId: \(Swift.String(describing: accountId)), vaultName: \(Swift.String(describing: vaultName)), vaultNotificationConfig: \(Swift.String(describing: vaultNotificationConfig)))"}
}

extension SetVaultNotificationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vaultNotificationConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vaultNotificationConfig = vaultNotificationConfig {
            try encodeContainer.encode(vaultNotificationConfig, forKey: .vaultNotificationConfig)
        }
    }
}

public struct SetVaultNotificationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetVaultNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetVaultNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetVaultNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetVaultNotificationsOutputError>
}

public struct SetVaultNotificationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetVaultNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetVaultNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetVaultNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetVaultNotificationsOutputError>
}

/// <p>Provides options to configure notifications that will be sent when specific events
///          happen to a vault.</p>
public struct SetVaultNotificationsInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?
    /// <p>Provides options for specifying notification configuration.</p>
    public let vaultNotificationConfig: GlacierClientTypes.VaultNotificationConfig?

    public init (
        accountId: Swift.String? = nil,
        vaultName: Swift.String? = nil,
        vaultNotificationConfig: GlacierClientTypes.VaultNotificationConfig? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
        self.vaultNotificationConfig = vaultNotificationConfig
    }
}

struct SetVaultNotificationsInputBody: Swift.Equatable {
    public let vaultNotificationConfig: GlacierClientTypes.VaultNotificationConfig?
}

extension SetVaultNotificationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vaultNotificationConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultNotificationConfigDecoded = try containerValues.decodeIfPresent(GlacierClientTypes.VaultNotificationConfig.self, forKey: .vaultNotificationConfig)
        vaultNotificationConfig = vaultNotificationConfigDecoded
    }
}

extension SetVaultNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetVaultNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetVaultNotificationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetVaultNotificationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetVaultNotificationsOutputResponse()"}
}

extension SetVaultNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetVaultNotificationsOutputResponse: Swift.Equatable {

    public init() {}
}

struct SetVaultNotificationsOutputResponseBody: Swift.Equatable {
}

extension SetVaultNotificationsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GlacierClientTypes {
    public enum StatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusCode] {
            return [
                .failed,
                .inprogress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .succeeded: return "Succeeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusCode(rawValue: rawValue) ?? StatusCode.sdkUnknown(rawValue)
        }
    }
}

extension GlacierClientTypes {
    public enum StorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case reducedredundancy
        case standard
        case standardinfrequentaccess
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageClass] {
            return [
                .reducedredundancy,
                .standard,
                .standardinfrequentaccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .reducedredundancy: return "REDUCED_REDUNDANCY"
            case .standard: return "STANDARD"
            case .standardinfrequentaccess: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageClass(rawValue: rawValue) ?? StorageClass.sdkUnknown(rawValue)
        }
    }
}

extension GlacierClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazoncustomerbyemail
        case canonicaluser
        case group
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .amazoncustomerbyemail,
                .canonicaluser,
                .group,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazoncustomerbyemail: return "AmazonCustomerByEmail"
            case .canonicaluser: return "CanonicalUser"
            case .group: return "Group"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

public struct UploadArchiveInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadArchiveInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UploadArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let bodydata = body
            let bodybody = ClientRuntime.HttpBody.stream(bodydata)
            input.builder.withBody(bodybody)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UploadArchiveOutputError>
}

extension UploadArchiveInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadArchiveInput(accountId: \(Swift.String(describing: accountId)), archiveDescription: \(Swift.String(describing: archiveDescription)), body: \(Swift.String(describing: body)), checksum: \(Swift.String(describing: checksum)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension UploadArchiveInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.toBytes().toData(), forKey: .body)
        }
    }
}

public struct UploadArchiveInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UploadArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let archiveDescription = input.operationInput.archiveDescription {
            input.builder.withHeader(name: "x-amz-archive-description", value: Swift.String(archiveDescription))
        }
        if let checksum = input.operationInput.checksum {
            input.builder.withHeader(name: "x-amz-sha256-tree-hash", value: Swift.String(checksum))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UploadArchiveOutputError>
}

public struct UploadArchiveInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadArchiveInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UploadArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadArchiveInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UploadArchiveOutputError>
}

/// <p>Provides options to add an archive to a vault.</p>
public struct UploadArchiveInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: Swift.String?
    /// <p>The optional description of the archive you are uploading.</p>
    public let archiveDescription: Swift.String?
    /// <p>The data to upload.</p>
    public let body: ClientRuntime.ByteStream?
    /// <p>The SHA256 tree hash of the data being uploaded.</p>
    public let checksum: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        archiveDescription: Swift.String? = nil,
        body: ClientRuntime.ByteStream? = nil,
        checksum: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.archiveDescription = archiveDescription
        self.body = body
        self.checksum = checksum
        self.vaultName = vaultName
    }
}

struct UploadArchiveInputBody: Swift.Equatable {
    public let body: ClientRuntime.ByteStream?
}

extension UploadArchiveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
        body = bodyDecoded
    }
}

extension UploadArchiveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UploadArchiveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UploadArchiveOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadArchiveOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadArchiveOutputResponse(archiveId: \(Swift.String(describing: archiveId)), checksum: \(Swift.String(describing: checksum)), location: \(Swift.String(describing: location)))"}
}

extension UploadArchiveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let archiveIdHeaderValue = httpResponse.headers.value(for: "x-amz-archive-id") {
            self.archiveId = archiveIdHeaderValue
        } else {
            self.archiveId = nil
        }
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-sha256-tree-hash") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
///          <p>For information about the underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-post.html">Upload Archive</a>. For
///          conceptual information, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html">Working with Archives in
///             Amazon S3 Glacier</a>.</p>
public struct UploadArchiveOutputResponse: Swift.Equatable {
    /// <p>The ID of the archive. This value is also included as part of the location.</p>
    public let archiveId: Swift.String?
    /// <p>The checksum of the archive computed by Amazon S3 Glacier.</p>
    public let checksum: Swift.String?
    /// <p>The relative URI path of the newly added archive resource.</p>
    public let location: Swift.String?

    public init (
        archiveId: Swift.String? = nil,
        checksum: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.archiveId = archiveId
        self.checksum = checksum
        self.location = location
    }
}

struct UploadArchiveOutputResponseBody: Swift.Equatable {
}

extension UploadArchiveOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GlacierClientTypes.UploadListElement: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveDescription = "ArchiveDescription"
        case creationDate = "CreationDate"
        case multipartUploadId = "MultipartUploadId"
        case partSizeInBytes = "PartSizeInBytes"
        case vaultARN = "VaultARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveDescription = archiveDescription {
            try encodeContainer.encode(archiveDescription, forKey: .archiveDescription)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let multipartUploadId = multipartUploadId {
            try encodeContainer.encode(multipartUploadId, forKey: .multipartUploadId)
        }
        if partSizeInBytes != 0 {
            try encodeContainer.encode(partSizeInBytes, forKey: .partSizeInBytes)
        }
        if let vaultARN = vaultARN {
            try encodeContainer.encode(vaultARN, forKey: .vaultARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multipartUploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multipartUploadId)
        multipartUploadId = multipartUploadIdDecoded
        let vaultARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let archiveDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .archiveDescription)
        archiveDescription = archiveDescriptionDecoded
        let partSizeInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .partSizeInBytes)
        partSizeInBytes = partSizeInBytesDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension GlacierClientTypes.UploadListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadListElement(archiveDescription: \(Swift.String(describing: archiveDescription)), creationDate: \(Swift.String(describing: creationDate)), multipartUploadId: \(Swift.String(describing: multipartUploadId)), partSizeInBytes: \(Swift.String(describing: partSizeInBytes)), vaultARN: \(Swift.String(describing: vaultARN)))"}
}

extension GlacierClientTypes {
    /// <p>A list of in-progress multipart uploads for a vault.</p>
    public struct UploadListElement: Swift.Equatable {
        /// <p>The description of the archive that was specified in the Initiate Multipart Upload
        ///          request.</p>
        public let archiveDescription: Swift.String?
        /// <p>The UTC time at which the multipart upload was initiated.</p>
        public let creationDate: Swift.String?
        /// <p>The ID of a multipart upload.</p>
        public let multipartUploadId: Swift.String?
        /// <p>The part size, in bytes, specified in the Initiate Multipart Upload request. This is
        ///          the size of all the parts in the upload except the last part, which may be smaller than
        ///          this size.</p>
        public let partSizeInBytes: Swift.Int
        /// <p>The Amazon Resource Name (ARN) of the vault that contains the archive.</p>
        public let vaultARN: Swift.String?

        public init (
            archiveDescription: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            multipartUploadId: Swift.String? = nil,
            partSizeInBytes: Swift.Int = 0,
            vaultARN: Swift.String? = nil
        )
        {
            self.archiveDescription = archiveDescription
            self.creationDate = creationDate
            self.multipartUploadId = multipartUploadId
            self.partSizeInBytes = partSizeInBytes
            self.vaultARN = vaultARN
        }
    }

}

public struct UploadMultipartPartInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadMultipartPartInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadMultipartPartInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UploadMultipartPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let bodydata = body
            let bodybody = ClientRuntime.HttpBody.stream(bodydata)
            input.builder.withBody(bodybody)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadMultipartPartInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadMultipartPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UploadMultipartPartOutputError>
}

extension UploadMultipartPartInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadMultipartPartInput(accountId: \(Swift.String(describing: accountId)), body: \(Swift.String(describing: body)), checksum: \(Swift.String(describing: checksum)), range: \(Swift.String(describing: range)), uploadId: \(Swift.String(describing: uploadId)), vaultName: \(Swift.String(describing: vaultName)))"}
}

extension UploadMultipartPartInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.toBytes().toData(), forKey: .body)
        }
    }
}

public struct UploadMultipartPartInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadMultipartPartInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadMultipartPartInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UploadMultipartPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let checksum = input.operationInput.checksum {
            input.builder.withHeader(name: "x-amz-sha256-tree-hash", value: Swift.String(checksum))
        }
        if let range = input.operationInput.range {
            input.builder.withHeader(name: "Content-Range", value: Swift.String(range))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadMultipartPartInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadMultipartPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UploadMultipartPartOutputError>
}

public struct UploadMultipartPartInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadMultipartPartInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadMultipartPartInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UploadMultipartPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadMultipartPartInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadMultipartPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UploadMultipartPartOutputError>
}

/// <p>Provides options to upload a part of an archive in a multipart upload
///          operation.</p>
public struct UploadMultipartPartInput: Swift.Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: Swift.String?
    /// <p>The data to upload.</p>
    public let body: ClientRuntime.ByteStream?
    /// <p>The SHA256 tree hash of the data being uploaded.</p>
    public let checksum: Swift.String?
    /// <p>Identifies the range of bytes in the assembled archive that will be uploaded in this
    ///          part. Amazon S3 Glacier uses this information to assemble the archive in the proper sequence.
    ///          The format of this header follows RFC 2616. An example header is Content-Range:bytes
    ///          0-4194303/*.</p>
    public let range: Swift.String?
    /// <p>The upload ID of the multipart upload.</p>
    public let uploadId: Swift.String?
    /// <p>The name of the vault.</p>
    public let vaultName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        body: ClientRuntime.ByteStream? = nil,
        checksum: Swift.String? = nil,
        range: Swift.String? = nil,
        uploadId: Swift.String? = nil,
        vaultName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.body = body
        self.checksum = checksum
        self.range = range
        self.uploadId = uploadId
        self.vaultName = vaultName
    }
}

struct UploadMultipartPartInputBody: Swift.Equatable {
    public let body: ClientRuntime.ByteStream?
}

extension UploadMultipartPartInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
        body = bodyDecoded
    }
}

extension UploadMultipartPartOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UploadMultipartPartOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UploadMultipartPartOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadMultipartPartOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadMultipartPartOutputResponse(checksum: \(Swift.String(describing: checksum)))"}
}

extension UploadMultipartPartOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-sha256-tree-hash") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct UploadMultipartPartOutputResponse: Swift.Equatable {
    /// <p>The SHA256 tree hash that Amazon S3 Glacier computed for the uploaded part.</p>
    public let checksum: Swift.String?

    public init (
        checksum: Swift.String? = nil
    )
    {
        self.checksum = checksum
    }
}

struct UploadMultipartPartOutputResponseBody: Swift.Equatable {
}

extension UploadMultipartPartOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GlacierClientTypes.VaultAccessPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GlacierClientTypes.VaultAccessPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VaultAccessPolicy(policy: \(Swift.String(describing: policy)))"}
}

extension GlacierClientTypes {
    /// <p>Contains the vault access policy.</p>
    public struct VaultAccessPolicy: Swift.Equatable {
        /// <p>The vault access policy.</p>
        public let policy: Swift.String?

        public init (
            policy: Swift.String? = nil
        )
        {
            self.policy = policy
        }
    }

}

extension GlacierClientTypes.VaultLockPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GlacierClientTypes.VaultLockPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VaultLockPolicy(policy: \(Swift.String(describing: policy)))"}
}

extension GlacierClientTypes {
    /// <p>Contains the vault lock policy.</p>
    public struct VaultLockPolicy: Swift.Equatable {
        /// <p>The vault lock policy.</p>
        public let policy: Swift.String?

        public init (
            policy: Swift.String? = nil
        )
        {
            self.policy = policy
        }
    }

}

extension GlacierClientTypes.VaultNotificationConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case sNSTopic = "SNSTopic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for notificationeventlist0 in events {
                try eventsContainer.encode(notificationeventlist0)
            }
        }
        if let sNSTopic = sNSTopic {
            try encodeContainer.encode(sNSTopic, forKey: .sNSTopic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sNSTopicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sNSTopic)
        sNSTopic = sNSTopicDecoded
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .events)
        var eventsDecoded0:[Swift.String]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String]()
            for string0 in eventsContainer {
                if let string0 = string0 {
                    eventsDecoded0?.append(string0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension GlacierClientTypes.VaultNotificationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VaultNotificationConfig(events: \(Swift.String(describing: events)), sNSTopic: \(Swift.String(describing: sNSTopic)))"}
}

extension GlacierClientTypes {
    /// <p>Represents a vault's notification configuration.</p>
    public struct VaultNotificationConfig: Swift.Equatable {
        /// <p>A list of one or more events for which Amazon S3 Glacier will send a notification to the
        ///          specified Amazon SNS topic.</p>
        public let events: [Swift.String]?
        /// <p>The Amazon Simple Notification Service (Amazon SNS) topic Amazon Resource Name
        ///          (ARN).</p>
        public let sNSTopic: Swift.String?

        public init (
            events: [Swift.String]? = nil,
            sNSTopic: Swift.String? = nil
        )
        {
            self.events = events
            self.sNSTopic = sNSTopic
        }
    }

}
