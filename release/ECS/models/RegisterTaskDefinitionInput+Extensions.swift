// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

public struct RegisterTaskDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterTaskDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTaskDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTaskDefinitionInput>
    public typealias MOutput = OperationOutput<RegisterTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTaskDefinitionOutputError>
}

public struct RegisterTaskDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterTaskDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTaskDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTaskDefinitionInput>
    public typealias MOutput = OperationOutput<RegisterTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTaskDefinitionOutputError>
}

public struct RegisterTaskDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "RegisterTaskDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTaskDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTaskDefinitionInput>
    public typealias MOutput = OperationOutput<RegisterTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTaskDefinitionOutputError>
}

extension RegisterTaskDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerDefinitions
        case cpu
        case ephemeralStorage
        case executionRoleArn
        case family
        case inferenceAccelerators
        case ipcMode
        case memory
        case networkMode
        case pidMode
        case placementConstraints
        case proxyConfiguration
        case requiresCompatibilities
        case tags
        case taskRoleArn
        case volumes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerDefinitions = containerDefinitions {
            var containerDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containerDefinitions)
            for containerdefinitions0 in containerDefinitions {
                try containerDefinitionsContainer.encode(containerdefinitions0)
            }
        }
        if let cpu = cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let ephemeralStorage = ephemeralStorage {
            try encodeContainer.encode(ephemeralStorage, forKey: .ephemeralStorage)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let family = family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let inferenceAccelerators = inferenceAccelerators {
            var inferenceAcceleratorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inferenceAccelerators)
            for inferenceaccelerators0 in inferenceAccelerators {
                try inferenceAcceleratorsContainer.encode(inferenceaccelerators0)
            }
        }
        if let ipcMode = ipcMode {
            try encodeContainer.encode(ipcMode.rawValue, forKey: .ipcMode)
        }
        if let memory = memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
        if let networkMode = networkMode {
            try encodeContainer.encode(networkMode.rawValue, forKey: .networkMode)
        }
        if let pidMode = pidMode {
            try encodeContainer.encode(pidMode.rawValue, forKey: .pidMode)
        }
        if let placementConstraints = placementConstraints {
            var placementConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .placementConstraints)
            for taskdefinitionplacementconstraints0 in placementConstraints {
                try placementConstraintsContainer.encode(taskdefinitionplacementconstraints0)
            }
        }
        if let proxyConfiguration = proxyConfiguration {
            try encodeContainer.encode(proxyConfiguration, forKey: .proxyConfiguration)
        }
        if let requiresCompatibilities = requiresCompatibilities {
            var requiresCompatibilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiresCompatibilities)
            for compatibilitylist0 in requiresCompatibilities {
                try requiresCompatibilitiesContainer.encode(compatibilitylist0.rawValue)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let taskRoleArn = taskRoleArn {
            try encodeContainer.encode(taskRoleArn, forKey: .taskRoleArn)
        }
        if let volumes = volumes {
            var volumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumes)
            for volumelist0 in volumes {
                try volumesContainer.encode(volumelist0)
            }
        }
    }
}
