// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Access to the resource is denied.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Access to the resource is denied.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataExchangeClientTypes.Action: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportRevisionToS3 = "ExportRevisionToS3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportRevisionToS3 = exportRevisionToS3 {
            try encodeContainer.encode(exportRevisionToS3, forKey: .exportRevisionToS3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportRevisionToS3Decoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AutoExportRevisionToS3RequestDetails.self, forKey: .exportRevisionToS3)
        exportRevisionToS3 = exportRevisionToS3Decoded
    }
}

extension DataExchangeClientTypes.Action: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Action(exportRevisionToS3: \(Swift.String(describing: exportRevisionToS3)))"}
}

extension DataExchangeClientTypes {
    /// What occurs after a certain event.
    public struct Action: Swift.Equatable {
        /// Details for the export revision to Amazon S3 action.
        public var exportRevisionToS3: DataExchangeClientTypes.AutoExportRevisionToS3RequestDetails?

        public init (
            exportRevisionToS3: DataExchangeClientTypes.AutoExportRevisionToS3RequestDetails? = nil
        )
        {
            self.exportRevisionToS3 = exportRevisionToS3
        }
    }

}

extension DataExchangeClientTypes.ApiGatewayApiAsset: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDescription = "ApiDescription"
        case apiEndpoint = "ApiEndpoint"
        case apiId = "ApiId"
        case apiKey = "ApiKey"
        case apiName = "ApiName"
        case apiSpecificationDownloadUrl = "ApiSpecificationDownloadUrl"
        case apiSpecificationDownloadUrlExpiresAt = "ApiSpecificationDownloadUrlExpiresAt"
        case protocolType = "ProtocolType"
        case stage = "Stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiDescription = apiDescription {
            try encodeContainer.encode(apiDescription, forKey: .apiDescription)
        }
        if let apiEndpoint = apiEndpoint {
            try encodeContainer.encode(apiEndpoint, forKey: .apiEndpoint)
        }
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiKey = apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let apiName = apiName {
            try encodeContainer.encode(apiName, forKey: .apiName)
        }
        if let apiSpecificationDownloadUrl = apiSpecificationDownloadUrl {
            try encodeContainer.encode(apiSpecificationDownloadUrl, forKey: .apiSpecificationDownloadUrl)
        }
        if let apiSpecificationDownloadUrlExpiresAt = apiSpecificationDownloadUrlExpiresAt {
            try encodeContainer.encode(apiSpecificationDownloadUrlExpiresAt.timeIntervalSince1970, forKey: .apiSpecificationDownloadUrlExpiresAt)
        }
        if let protocolType = protocolType {
            try encodeContainer.encode(protocolType.rawValue, forKey: .protocolType)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiDescription)
        apiDescription = apiDescriptionDecoded
        let apiEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let apiNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiName)
        apiName = apiNameDecoded
        let apiSpecificationDownloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiSpecificationDownloadUrl)
        apiSpecificationDownloadUrl = apiSpecificationDownloadUrlDecoded
        let apiSpecificationDownloadUrlExpiresAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .apiSpecificationDownloadUrlExpiresAt)
        apiSpecificationDownloadUrlExpiresAt = apiSpecificationDownloadUrlExpiresAtDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension DataExchangeClientTypes.ApiGatewayApiAsset: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiGatewayApiAsset(apiDescription: \(Swift.String(describing: apiDescription)), apiEndpoint: \(Swift.String(describing: apiEndpoint)), apiId: \(Swift.String(describing: apiId)), apiKey: \(Swift.String(describing: apiKey)), apiName: \(Swift.String(describing: apiName)), apiSpecificationDownloadUrl: \(Swift.String(describing: apiSpecificationDownloadUrl)), apiSpecificationDownloadUrlExpiresAt: \(Swift.String(describing: apiSpecificationDownloadUrlExpiresAt)), protocolType: \(Swift.String(describing: protocolType)), stage: \(Swift.String(describing: stage)))"}
}

extension DataExchangeClientTypes {
    /// The API Gateway API that is the asset.
    public struct ApiGatewayApiAsset: Swift.Equatable {
        /// The API description of the API asset.
        public var apiDescription: Swift.String?
        /// The API endpoint of the API asset.
        public var apiEndpoint: Swift.String?
        /// The unique identifier of the API asset.
        public var apiId: Swift.String?
        /// The API key of the API asset.
        public var apiKey: Swift.String?
        /// The API name of the API asset.
        public var apiName: Swift.String?
        /// The download URL of the API specification of the API asset.
        public var apiSpecificationDownloadUrl: Swift.String?
        /// The date and time that the upload URL expires, in ISO 8601 format.
        public var apiSpecificationDownloadUrlExpiresAt: ClientRuntime.Date?
        /// The protocol type of the API asset.
        public var protocolType: DataExchangeClientTypes.ProtocolType?
        /// The stage of the API asset.
        public var stage: Swift.String?

        public init (
            apiDescription: Swift.String? = nil,
            apiEndpoint: Swift.String? = nil,
            apiId: Swift.String? = nil,
            apiKey: Swift.String? = nil,
            apiName: Swift.String? = nil,
            apiSpecificationDownloadUrl: Swift.String? = nil,
            apiSpecificationDownloadUrlExpiresAt: ClientRuntime.Date? = nil,
            protocolType: DataExchangeClientTypes.ProtocolType? = nil,
            stage: Swift.String? = nil
        )
        {
            self.apiDescription = apiDescription
            self.apiEndpoint = apiEndpoint
            self.apiId = apiId
            self.apiKey = apiKey
            self.apiName = apiName
            self.apiSpecificationDownloadUrl = apiSpecificationDownloadUrl
            self.apiSpecificationDownloadUrlExpiresAt = apiSpecificationDownloadUrlExpiresAt
            self.protocolType = protocolType
            self.stage = stage
        }
    }

}

extension DataExchangeClientTypes.AssetDestinationEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId = "AssetId"
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension DataExchangeClientTypes.AssetDestinationEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetDestinationEntry(assetId: \(Swift.String(describing: assetId)), bucket: \(Swift.String(describing: bucket)), key: \(Swift.String(describing: key)))"}
}

extension DataExchangeClientTypes {
    /// The destination for the asset.
    public struct AssetDestinationEntry: Swift.Equatable {
        /// The unique identifier for the asset.
        /// This member is required.
        public var assetId: Swift.String?
        /// The S3 bucket that is the destination for the asset.
        /// This member is required.
        public var bucket: Swift.String?
        /// The name of the object in Amazon S3 for the asset.
        public var key: Swift.String?

        public init (
            assetId: Swift.String? = nil,
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.bucket = bucket
            self.key = key
        }
    }

}

extension DataExchangeClientTypes.AssetDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayApiAsset = "ApiGatewayApiAsset"
        case redshiftDataShareAsset = "RedshiftDataShareAsset"
        case s3SnapshotAsset = "S3SnapshotAsset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayApiAsset = apiGatewayApiAsset {
            try encodeContainer.encode(apiGatewayApiAsset, forKey: .apiGatewayApiAsset)
        }
        if let redshiftDataShareAsset = redshiftDataShareAsset {
            try encodeContainer.encode(redshiftDataShareAsset, forKey: .redshiftDataShareAsset)
        }
        if let s3SnapshotAsset = s3SnapshotAsset {
            try encodeContainer.encode(s3SnapshotAsset, forKey: .s3SnapshotAsset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3SnapshotAssetDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.S3SnapshotAsset.self, forKey: .s3SnapshotAsset)
        s3SnapshotAsset = s3SnapshotAssetDecoded
        let redshiftDataShareAssetDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.RedshiftDataShareAsset.self, forKey: .redshiftDataShareAsset)
        redshiftDataShareAsset = redshiftDataShareAssetDecoded
        let apiGatewayApiAssetDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ApiGatewayApiAsset.self, forKey: .apiGatewayApiAsset)
        apiGatewayApiAsset = apiGatewayApiAssetDecoded
    }
}

extension DataExchangeClientTypes.AssetDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetDetails(apiGatewayApiAsset: \(Swift.String(describing: apiGatewayApiAsset)), redshiftDataShareAsset: \(Swift.String(describing: redshiftDataShareAsset)), s3SnapshotAsset: \(Swift.String(describing: s3SnapshotAsset)))"}
}

extension DataExchangeClientTypes {
    /// Information about the asset.
    public struct AssetDetails: Swift.Equatable {
        /// Information about the API Gateway API asset.
        public var apiGatewayApiAsset: DataExchangeClientTypes.ApiGatewayApiAsset?
        /// The Amazon Redshift datashare that is the asset.
        public var redshiftDataShareAsset: DataExchangeClientTypes.RedshiftDataShareAsset?
        /// The S3 object that is the asset.
        public var s3SnapshotAsset: DataExchangeClientTypes.S3SnapshotAsset?

        public init (
            apiGatewayApiAsset: DataExchangeClientTypes.ApiGatewayApiAsset? = nil,
            redshiftDataShareAsset: DataExchangeClientTypes.RedshiftDataShareAsset? = nil,
            s3SnapshotAsset: DataExchangeClientTypes.S3SnapshotAsset? = nil
        )
        {
            self.apiGatewayApiAsset = apiGatewayApiAsset
            self.redshiftDataShareAsset = redshiftDataShareAsset
            self.s3SnapshotAsset = s3SnapshotAsset
        }
    }

}

extension DataExchangeClientTypes.AssetEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assetDetails = "AssetDetails"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case id = "Id"
        case name = "Name"
        case revisionId = "RevisionId"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetDetails = assetDetails {
            try encodeContainer.encode(assetDetails, forKey: .assetDetails)
        }
        if let assetType = assetType {
            try encodeContainer.encode(assetType.rawValue, forKey: .assetType)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let sourceId = sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let assetDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetDetails.self, forKey: .assetDetails)
        assetDetails = assetDetailsDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataExchangeClientTypes.AssetEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetEntry(arn: \(Swift.String(describing: arn)), assetDetails: \(Swift.String(describing: assetDetails)), assetType: \(Swift.String(describing: assetType)), createdAt: \(Swift.String(describing: createdAt)), dataSetId: \(Swift.String(describing: dataSetId)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), sourceId: \(Swift.String(describing: sourceId)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension DataExchangeClientTypes {
    /// An asset in AWS Data Exchange is a piece of data (S3 object) or a means of fulfilling data (Amazon Redshift datashare or Amazon API Gateway API). The asset can be a structured data file, an image file, or some other data file that can be stored as an S3 object, an Amazon API Gateway API, or an Amazon Redshift datashare (Preview). When you create an import job for your files, API Gateway APIs, or Amazon Redshift datashares, you create an asset in AWS Data Exchange.
    public struct AssetEntry: Swift.Equatable {
        /// The ARN for the asset.
        /// This member is required.
        public var arn: Swift.String?
        /// Information about the asset.
        /// This member is required.
        public var assetDetails: DataExchangeClientTypes.AssetDetails?
        /// The type of asset that is added to a data set.
        /// This member is required.
        public var assetType: DataExchangeClientTypes.AssetType?
        /// The date and time that the asset was created, in ISO 8601 format.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The unique identifier for the data set associated with this asset.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for the asset.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the asset. When importing from Amazon S3, the S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target S3 object key. When importing from Amazon API Gateway API, the API name is used as the asset name. When importing from Amazon Redshift, the datashare name is used as the asset name.
        /// This member is required.
        public var name: Swift.String?
        /// The unique identifier for the revision associated with this asset.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The asset ID of the owned asset corresponding to the entitled asset being viewed. This parameter is returned when an asset owner is viewing the entitled copy of its owned asset.
        public var sourceId: Swift.String?
        /// The date and time that the asset was last updated, in ISO 8601 format.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            assetDetails: DataExchangeClientTypes.AssetDetails? = nil,
            assetType: DataExchangeClientTypes.AssetType? = nil,
            createdAt: ClientRuntime.Date? = nil,
            dataSetId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            sourceId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.assetDetails = assetDetails
            self.assetType = assetType
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.id = id
            self.name = name
            self.revisionId = revisionId
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }
    }

}

extension DataExchangeClientTypes.AssetSourceEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension DataExchangeClientTypes.AssetSourceEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetSourceEntry(bucket: \(Swift.String(describing: bucket)), key: \(Swift.String(describing: key)))"}
}

extension DataExchangeClientTypes {
    /// The source of the assets.
    public struct AssetSourceEntry: Swift.Equatable {
        /// The S3 bucket that's part of the source of the asset.
        /// This member is required.
        public var bucket: Swift.String?
        /// The name of the object in Amazon S3 for the asset.
        /// This member is required.
        public var key: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension DataExchangeClientTypes {
    /// The type of asset that is added to a data set.
    public enum AssetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apiGatewayApi
        case redshiftDataShare
        case s3Snapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetType] {
            return [
                .apiGatewayApi,
                .redshiftDataShare,
                .s3Snapshot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apiGatewayApi: return "API_GATEWAY_API"
            case .redshiftDataShare: return "REDSHIFT_DATA_SHARE"
            case .s3Snapshot: return "S3_SNAPSHOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetType(rawValue: rawValue) ?? AssetType.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.AutoExportRevisionDestinationEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case keyPattern = "KeyPattern"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPattern = keyPattern {
            try encodeContainer.encode(keyPattern, forKey: .keyPattern)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPattern)
        keyPattern = keyPatternDecoded
    }
}

extension DataExchangeClientTypes.AutoExportRevisionDestinationEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutoExportRevisionDestinationEntry(bucket: \(Swift.String(describing: bucket)), keyPattern: \(Swift.String(describing: keyPattern)))"}
}

extension DataExchangeClientTypes {
    /// A revision destination is the Amazon S3 bucket folder destination to where the export will be sent.
    public struct AutoExportRevisionDestinationEntry: Swift.Equatable {
        /// The S3 bucket that is the destination for the event action.
        /// This member is required.
        public var bucket: Swift.String?
        /// A string representing the pattern for generated names of the individual assets in the revision. For more information about key patterns, see [Key patterns when exporting revisions](https://docs.aws.amazon.com/data-exchange/latest/userguide/jobs.html#revision-export-keypatterns).
        public var keyPattern: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            keyPattern: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.keyPattern = keyPattern
        }
    }

}

extension DataExchangeClientTypes.AutoExportRevisionToS3RequestDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "Encryption"
        case revisionDestination = "RevisionDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let revisionDestination = revisionDestination {
            try encodeContainer.encode(revisionDestination, forKey: .revisionDestination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportServerSideEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let revisionDestinationDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AutoExportRevisionDestinationEntry.self, forKey: .revisionDestination)
        revisionDestination = revisionDestinationDecoded
    }
}

extension DataExchangeClientTypes.AutoExportRevisionToS3RequestDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutoExportRevisionToS3RequestDetails(encryption: \(Swift.String(describing: encryption)), revisionDestination: \(Swift.String(describing: revisionDestination)))"}
}

extension DataExchangeClientTypes {
    /// Details of the operation to be performed by the job.
    public struct AutoExportRevisionToS3RequestDetails: Swift.Equatable {
        /// Encryption configuration for the auto export job.
        public var encryption: DataExchangeClientTypes.ExportServerSideEncryption?
        /// A revision destination is the Amazon S3 bucket folder destination to where the export will be sent.
        /// This member is required.
        public var revisionDestination: DataExchangeClientTypes.AutoExportRevisionDestinationEntry?

        public init (
            encryption: DataExchangeClientTypes.ExportServerSideEncryption? = nil,
            revisionDestination: DataExchangeClientTypes.AutoExportRevisionDestinationEntry? = nil
        )
        {
            self.encryption = encryption
            self.revisionDestination = revisionDestination
        }
    }

}

extension CancelJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelJobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension CancelJobInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct CancelJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelJobOutputError>
}

public struct CancelJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelJobOutputError>
}

public struct CancelJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CancelJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelJobOutputError>
}

public struct CancelJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CancelJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let jobId = input.jobId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("jobId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/jobs/\(jobId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelJobOutputError>
}

public struct CancelJobInput: Swift.Equatable {
    /// The unique identifier for a job.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelJobInputBody: Swift.Equatable {
}

extension CancelJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelJobOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelJobOutputResponse()"}
}

extension CancelJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct CancelJobOutputResponseBody: Swift.Equatable {
}

extension CancelJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DataExchangeClientTypes {
    public enum Code: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDeniedException
        case internalServerException
        case malwareDetected
        case malwareScanEncryptedFile
        case resourceNotFoundException
        case serviceQuotaExceededException
        case validationException
        case sdkUnknown(Swift.String)

        public static var allCases: [Code] {
            return [
                .accessDeniedException,
                .internalServerException,
                .malwareDetected,
                .malwareScanEncryptedFile,
                .resourceNotFoundException,
                .serviceQuotaExceededException,
                .validationException,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDeniedException: return "ACCESS_DENIED_EXCEPTION"
            case .internalServerException: return "INTERNAL_SERVER_EXCEPTION"
            case .malwareDetected: return "MALWARE_DETECTED"
            case .malwareScanEncryptedFile: return "MALWARE_SCAN_ENCRYPTED_FILE"
            case .resourceNotFoundException: return "RESOURCE_NOT_FOUND_EXCEPTION"
            case .serviceQuotaExceededException: return "SERVICE_QUOTA_EXCEEDED_EXCEPTION"
            case .validationException: return "VALIDATION_EXCEPTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Code(rawValue: rawValue) ?? Code.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request couldn't be completed because it conflicted with the current state of the resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The request couldn't be completed because it conflicted with the current state of the resource.
    /// This member is required.
    public var message: Swift.String?
    /// The unique identifier for the resource with the conflict.
    public var resourceId: Swift.String?
    /// The type of the resource with the conflict.
    public var resourceType: DataExchangeClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: DataExchangeClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: DataExchangeClientTypes.ResourceType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CreateDataSetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataSetOutputError>
}

extension CreateDataSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataSetInput(assetType: \(Swift.String(describing: assetType)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDataSetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetType = "AssetType"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetType = assetType {
            try encodeContainer.encode(assetType.rawValue, forKey: .assetType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDataSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataSetOutputError>
}

public struct CreateDataSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataSetOutputError>
}

public struct CreateDataSetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataSetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateDataSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDataSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataSetOutputError>
}

public struct CreateDataSetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataSetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateDataSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/data-sets"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDataSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataSetOutputError>
}

/// The request body for CreateDataSet.
public struct CreateDataSetInput: Swift.Equatable {
    /// The type of asset that is added to a data set.
    /// This member is required.
    public var assetType: DataExchangeClientTypes.AssetType?
    /// A description for the data set. This value can be up to 16,348 characters long.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the data set.
    /// This member is required.
    public var name: Swift.String?
    /// A data set tag is an optional label that you can assign to a data set when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to these data sets and revisions.
    public var tags: [Swift.String:Swift.String]?

    public init (
        assetType: DataExchangeClientTypes.AssetType? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assetType = assetType
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateDataSetInputBody: Swift.Equatable {
    public let assetType: DataExchangeClientTypes.AssetType?
    public let description: Swift.String?
    public let name: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateDataSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetType = "AssetType"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataSetOutputResponse(arn: \(Swift.String(describing: arn)), assetType: \(Swift.String(describing: assetType)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), origin: \(Swift.String(describing: origin)), originDetails: \(Swift.String(describing: originDetails)), sourceId: \(Swift.String(describing: sourceId)), tags: \(Swift.String(describing: tags)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension CreateDataSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDataSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.assetType = output.assetType
            self.createdAt = output.createdAt
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.origin = output.origin
            self.originDetails = output.originDetails
            self.sourceId = output.sourceId
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.assetType = nil
            self.createdAt = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.origin = nil
            self.originDetails = nil
            self.sourceId = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateDataSetOutputResponse: Swift.Equatable {
    /// The ARN for the data set.
    public var arn: Swift.String?
    /// The type of asset that is added to a data set.
    public var assetType: DataExchangeClientTypes.AssetType?
    /// The date and time that the data set was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The description for the data set.
    public var description: Swift.String?
    /// The unique identifier for the data set.
    public var id: Swift.String?
    /// The name of the data set.
    public var name: Swift.String?
    /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
    public var origin: DataExchangeClientTypes.Origin?
    /// If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.
    public var originDetails: DataExchangeClientTypes.OriginDetails?
    /// The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.
    public var sourceId: Swift.String?
    /// The tags for the data set.
    public var tags: [Swift.String:Swift.String]?
    /// The date and time that the data set was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        assetType: DataExchangeClientTypes.AssetType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        origin: DataExchangeClientTypes.Origin? = nil,
        originDetails: DataExchangeClientTypes.OriginDetails? = nil,
        sourceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.assetType = assetType
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
        self.origin = origin
        self.originDetails = originDetails
        self.sourceId = sourceId
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct CreateDataSetOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let assetType: DataExchangeClientTypes.AssetType?
    public let createdAt: ClientRuntime.Date?
    public let description: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let origin: DataExchangeClientTypes.Origin?
    public let originDetails: DataExchangeClientTypes.OriginDetails?
    public let sourceId: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let updatedAt: ClientRuntime.Date?
}

extension CreateDataSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case origin = "Origin"
        case originDetails = "OriginDetails"
        case sourceId = "SourceId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let originDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Origin.self, forKey: .origin)
        origin = originDecoded
        let originDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.OriginDetails.self, forKey: .originDetails)
        originDetails = originDetailsDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

public struct CreateEventActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventActionOutputError>
}

extension CreateEventActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventActionInput(action: \(Swift.String(describing: action)), event: \(Swift.String(describing: event)))"}
}

extension CreateEventActionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case event = "Event"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let event = event {
            try encodeContainer.encode(event, forKey: .event)
        }
    }
}

public struct CreateEventActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventActionOutputError>
}

public struct CreateEventActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventActionOutputError>
}

public struct CreateEventActionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventActionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateEventActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEventActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventActionOutputError>
}

public struct CreateEventActionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventActionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateEventActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/event-actions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEventActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventActionOutputError>
}

/// The request body for CreateEventAction.
public struct CreateEventActionInput: Swift.Equatable {
    /// What occurs after a certain event.
    /// This member is required.
    public var action: DataExchangeClientTypes.Action?
    /// What occurs to start an action.
    /// This member is required.
    public var event: DataExchangeClientTypes.Event?

    public init (
        action: DataExchangeClientTypes.Action? = nil,
        event: DataExchangeClientTypes.Event? = nil
    )
    {
        self.action = action
        self.event = event
    }
}

struct CreateEventActionInputBody: Swift.Equatable {
    public let action: DataExchangeClientTypes.Action?
    public let event: DataExchangeClientTypes.Event?
}

extension CreateEventActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case event = "Event"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let eventDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Event.self, forKey: .event)
        event = eventDecoded
    }
}

extension CreateEventActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEventActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventActionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventActionOutputResponse(action: \(Swift.String(describing: action)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), event: \(Swift.String(describing: event)), id: \(Swift.String(describing: id)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension CreateEventActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEventActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.event = output.event
            self.id = output.id
            self.updatedAt = output.updatedAt
        } else {
            self.action = nil
            self.arn = nil
            self.createdAt = nil
            self.event = nil
            self.id = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateEventActionOutputResponse: Swift.Equatable {
    /// What occurs after a certain event.
    public var action: DataExchangeClientTypes.Action?
    /// The ARN for the event action.
    public var arn: Swift.String?
    /// The date and time that the event action was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// What occurs to start an action.
    public var event: DataExchangeClientTypes.Event?
    /// The unique identifier for the event action.
    public var id: Swift.String?
    /// The date and time that the event action was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init (
        action: DataExchangeClientTypes.Action? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        event: DataExchangeClientTypes.Event? = nil,
        id: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.createdAt = createdAt
        self.event = event
        self.id = id
        self.updatedAt = updatedAt
    }
}

struct CreateEventActionOutputResponseBody: Swift.Equatable {
    public let action: DataExchangeClientTypes.Action?
    public let arn: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let event: DataExchangeClientTypes.Event?
    public let id: Swift.String?
    public let updatedAt: ClientRuntime.Date?
}

extension CreateEventActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case event = "Event"
        case id = "Id"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let eventDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

public struct CreateJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateJobOutputError>
}

extension CreateJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateJobInput(details: \(Swift.String(describing: details)), type: \(Swift.String(describing: type)))"}
}

extension CreateJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateJobOutputError>
}

public struct CreateJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateJobOutputError>
}

public struct CreateJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateJobOutputError>
}

public struct CreateJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/jobs"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateJobOutputError>
}

/// The request body for CreateJob.
public struct CreateJobInput: Swift.Equatable {
    /// The details for the CreateJob request.
    /// This member is required.
    public var details: DataExchangeClientTypes.RequestDetails?
    /// The type of job to be created.
    /// This member is required.
    public var type: DataExchangeClientTypes.ModelType?

    public init (
        details: DataExchangeClientTypes.RequestDetails? = nil,
        type: DataExchangeClientTypes.ModelType? = nil
    )
    {
        self.details = details
        self.type = type
    }
}

struct CreateJobInputBody: Swift.Equatable {
    public let details: DataExchangeClientTypes.RequestDetails?
    public let type: DataExchangeClientTypes.ModelType?
}

extension CreateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.RequestDetails.self, forKey: .details)
        details = detailsDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateJobOutputResponse(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), details: \(Swift.String(describing: details)), errors: \(Swift.String(describing: errors)), id: \(Swift.String(describing: id)), state: \(Swift.String(describing: state)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension CreateJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.details = output.details
            self.errors = output.errors
            self.id = output.id
            self.state = output.state
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.createdAt = nil
            self.details = nil
            self.errors = nil
            self.id = nil
            self.state = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateJobOutputResponse: Swift.Equatable {
    /// The ARN for the job.
    public var arn: Swift.String?
    /// The date and time that the job was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// Details about the job.
    public var details: DataExchangeClientTypes.ResponseDetails?
    /// The errors associated with jobs.
    public var errors: [DataExchangeClientTypes.JobError]?
    /// The unique identifier for the job.
    public var id: Swift.String?
    /// The state of the job.
    public var state: DataExchangeClientTypes.State?
    /// The job type.
    public var type: DataExchangeClientTypes.ModelType?
    /// The date and time that the job was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        details: DataExchangeClientTypes.ResponseDetails? = nil,
        errors: [DataExchangeClientTypes.JobError]? = nil,
        id: Swift.String? = nil,
        state: DataExchangeClientTypes.State? = nil,
        type: DataExchangeClientTypes.ModelType? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.details = details
        self.errors = errors
        self.id = id
        self.state = state
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct CreateJobOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let details: DataExchangeClientTypes.ResponseDetails?
    public let errors: [DataExchangeClientTypes.JobError]?
    public let id: Swift.String?
    public let state: DataExchangeClientTypes.State?
    public let type: DataExchangeClientTypes.ModelType?
    public let updatedAt: ClientRuntime.Date?
}

extension CreateJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case details = "Details"
        case errors = "Errors"
        case id = "Id"
        case state = "State"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ResponseDetails.self, forKey: .details)
        details = detailsDecoded
        let errorsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.JobError?].self, forKey: .errors)
        var errorsDecoded0:[DataExchangeClientTypes.JobError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [DataExchangeClientTypes.JobError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

public struct CreateRevisionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRevisionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRevisionOutputError>
}

extension CreateRevisionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRevisionInput(comment: \(Swift.String(describing: comment)), dataSetId: \(Swift.String(describing: dataSetId)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateRevisionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRevisionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRevisionOutputError>
}

public struct CreateRevisionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRevisionOutputError>
}

public struct CreateRevisionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRevisionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateRevisionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRevisionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRevisionOutputError>
}

public struct CreateRevisionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRevisionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateRevisionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let dataSetId = input.dataSetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dataSetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRevisionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRevisionOutputError>
}

/// The request body for CreateRevision.
public struct CreateRevisionInput: Swift.Equatable {
    /// An optional comment about the revision.
    public var comment: Swift.String?
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// A revision tag is an optional label that you can assign to a revision when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to these data sets and revisions.
    public var tags: [Swift.String:Swift.String]?

    public init (
        comment: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.comment = comment
        self.dataSetId = dataSetId
        self.tags = tags
    }
}

struct CreateRevisionInputBody: Swift.Equatable {
    public let comment: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateRevisionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRevisionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRevisionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRevisionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRevisionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRevisionOutputResponse(arn: \(Swift.String(describing: arn)), comment: \(Swift.String(describing: comment)), createdAt: \(Swift.String(describing: createdAt)), dataSetId: \(Swift.String(describing: dataSetId)), finalized: \(Swift.String(describing: finalized)), id: \(Swift.String(describing: id)), sourceId: \(Swift.String(describing: sourceId)), tags: \(Swift.String(describing: tags)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension CreateRevisionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRevisionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.comment = output.comment
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.finalized = output.finalized
            self.id = output.id
            self.sourceId = output.sourceId
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.comment = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.finalized = nil
            self.id = nil
            self.sourceId = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateRevisionOutputResponse: Swift.Equatable {
    /// The ARN for the revision.
    public var arn: Swift.String?
    /// An optional comment about the revision.
    public var comment: Swift.String?
    /// The date and time that the revision was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The unique identifier for the data set associated with this revision.
    public var dataSetId: Swift.String?
    /// To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products. Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.
    public var finalized: Swift.Bool?
    /// The unique identifier for the revision.
    public var id: Swift.String?
    /// The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.
    public var sourceId: Swift.String?
    /// The tags for the revision.
    public var tags: [Swift.String:Swift.String]?
    /// The date and time that the revision was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        comment: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        dataSetId: Swift.String? = nil,
        finalized: Swift.Bool? = nil,
        id: Swift.String? = nil,
        sourceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.comment = comment
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.finalized = finalized
        self.id = id
        self.sourceId = sourceId
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct CreateRevisionOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let comment: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let dataSetId: Swift.String?
    public let finalized: Swift.Bool?
    public let id: Swift.String?
    public let sourceId: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let updatedAt: ClientRuntime.Date?
}

extension CreateRevisionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case comment = "Comment"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case finalized = "Finalized"
        case id = "Id"
        case sourceId = "SourceId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataExchangeClientTypes.DataSetEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case origin = "Origin"
        case originDetails = "OriginDetails"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetType = assetType {
            try encodeContainer.encode(assetType.rawValue, forKey: .assetType)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let origin = origin {
            try encodeContainer.encode(origin.rawValue, forKey: .origin)
        }
        if let originDetails = originDetails {
            try encodeContainer.encode(originDetails, forKey: .originDetails)
        }
        if let sourceId = sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let originDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Origin.self, forKey: .origin)
        origin = originDecoded
        let originDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.OriginDetails.self, forKey: .originDetails)
        originDetails = originDetailsDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataExchangeClientTypes.DataSetEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSetEntry(arn: \(Swift.String(describing: arn)), assetType: \(Swift.String(describing: assetType)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), origin: \(Swift.String(describing: origin)), originDetails: \(Swift.String(describing: originDetails)), sourceId: \(Swift.String(describing: sourceId)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension DataExchangeClientTypes {
    /// A data set is an AWS resource with one or more revisions.
    public struct DataSetEntry: Swift.Equatable {
        /// The ARN for the data set.
        /// This member is required.
        public var arn: Swift.String?
        /// The type of asset that is added to a data set.
        /// This member is required.
        public var assetType: DataExchangeClientTypes.AssetType?
        /// The date and time that the data set was created, in ISO 8601 format.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description for the data set.
        /// This member is required.
        public var description: Swift.String?
        /// The unique identifier for the data set.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the data set.
        /// This member is required.
        public var name: Swift.String?
        /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
        /// This member is required.
        public var origin: DataExchangeClientTypes.Origin?
        /// If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.
        public var originDetails: DataExchangeClientTypes.OriginDetails?
        /// The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.
        public var sourceId: Swift.String?
        /// The date and time that the data set was last updated, in ISO 8601 format.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            assetType: DataExchangeClientTypes.AssetType? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            origin: DataExchangeClientTypes.Origin? = nil,
            originDetails: DataExchangeClientTypes.OriginDetails? = nil,
            sourceId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.assetType = assetType
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.origin = origin
            self.originDetails = originDetails
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }
    }

}

extension DeleteAssetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssetInput(assetId: \(Swift.String(describing: assetId)), dataSetId: \(Swift.String(describing: dataSetId)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension DeleteAssetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAssetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssetOutputError>
}

public struct DeleteAssetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssetOutputError>
}

public struct DeleteAssetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAssetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAssetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssetOutputError>
}

public struct DeleteAssetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAssetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let dataSetId = input.dataSetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dataSetId is nil and needs a value for the path of this operation"))))
        }
        guard let revisionId = input.revisionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("revisionId is nil and needs a value for the path of this operation"))))
        }
        guard let assetId = input.assetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions/\(revisionId.urlPercentEncoding())/assets/\(assetId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAssetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssetOutputError>
}

public struct DeleteAssetInput: Swift.Equatable {
    /// The unique identifier for an asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The unique identifier for a revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.dataSetId = dataSetId
        self.revisionId = revisionId
    }
}

struct DeleteAssetInputBody: Swift.Equatable {
}

extension DeleteAssetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssetOutputResponse()"}
}

extension DeleteAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAssetOutputResponseBody: Swift.Equatable {
}

extension DeleteAssetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDataSetInput(dataSetId: \(Swift.String(describing: dataSetId)))"}
}

extension DeleteDataSetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDataSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDataSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDataSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDataSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDataSetOutputError>
}

public struct DeleteDataSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDataSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDataSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDataSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDataSetOutputError>
}

public struct DeleteDataSetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDataSetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteDataSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDataSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDataSetOutputError>
}

public struct DeleteDataSetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDataSetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteDataSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let dataSetId = input.dataSetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dataSetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/data-sets/\(dataSetId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDataSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDataSetOutputError>
}

public struct DeleteDataSetInput: Swift.Equatable {
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init (
        dataSetId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
    }
}

struct DeleteDataSetInputBody: Swift.Equatable {
}

extension DeleteDataSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDataSetOutputResponse()"}
}

extension DeleteDataSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDataSetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDataSetOutputResponseBody: Swift.Equatable {
}

extension DeleteDataSetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEventActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventActionInput(eventActionId: \(Swift.String(describing: eventActionId)))"}
}

extension DeleteEventActionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteEventActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventActionOutputError>
}

public struct DeleteEventActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventActionOutputError>
}

public struct DeleteEventActionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventActionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteEventActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEventActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventActionOutputError>
}

public struct DeleteEventActionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventActionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteEventActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let eventActionId = input.eventActionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("eventActionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/event-actions/\(eventActionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEventActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventActionOutputError>
}

public struct DeleteEventActionInput: Swift.Equatable {
    /// The unique identifier for the event action.
    /// This member is required.
    public var eventActionId: Swift.String?

    public init (
        eventActionId: Swift.String? = nil
    )
    {
        self.eventActionId = eventActionId
    }
}

struct DeleteEventActionInputBody: Swift.Equatable {
}

extension DeleteEventActionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEventActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventActionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventActionOutputResponse()"}
}

extension DeleteEventActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventActionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteEventActionOutputResponseBody: Swift.Equatable {
}

extension DeleteEventActionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRevisionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRevisionInput(dataSetId: \(Swift.String(describing: dataSetId)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension DeleteRevisionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteRevisionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRevisionOutputError>
}

public struct DeleteRevisionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRevisionOutputError>
}

public struct DeleteRevisionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRevisionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteRevisionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRevisionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRevisionOutputError>
}

public struct DeleteRevisionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRevisionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteRevisionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let dataSetId = input.dataSetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dataSetId is nil and needs a value for the path of this operation"))))
        }
        guard let revisionId = input.revisionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("revisionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions/\(revisionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRevisionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRevisionOutputError>
}

public struct DeleteRevisionInput: Swift.Equatable {
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The unique identifier for a revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init (
        dataSetId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.revisionId = revisionId
    }
}

struct DeleteRevisionInputBody: Swift.Equatable {
}

extension DeleteRevisionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRevisionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRevisionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRevisionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRevisionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRevisionOutputResponse()"}
}

extension DeleteRevisionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRevisionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRevisionOutputResponseBody: Swift.Equatable {
}

extension DeleteRevisionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DataExchangeClientTypes.Details: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importAssetFromSignedUrlJobErrorDetails = "ImportAssetFromSignedUrlJobErrorDetails"
        case importAssetsFromS3JobErrorDetails = "ImportAssetsFromS3JobErrorDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importAssetFromSignedUrlJobErrorDetails = importAssetFromSignedUrlJobErrorDetails {
            try encodeContainer.encode(importAssetFromSignedUrlJobErrorDetails, forKey: .importAssetFromSignedUrlJobErrorDetails)
        }
        if let importAssetsFromS3JobErrorDetails = importAssetsFromS3JobErrorDetails {
            var importAssetsFromS3JobErrorDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .importAssetsFromS3JobErrorDetails)
            for listofassetsourceentry0 in importAssetsFromS3JobErrorDetails {
                try importAssetsFromS3JobErrorDetailsContainer.encode(listofassetsourceentry0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importAssetFromSignedUrlJobErrorDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetFromSignedUrlJobErrorDetails.self, forKey: .importAssetFromSignedUrlJobErrorDetails)
        importAssetFromSignedUrlJobErrorDetails = importAssetFromSignedUrlJobErrorDetailsDecoded
        let importAssetsFromS3JobErrorDetailsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.AssetSourceEntry?].self, forKey: .importAssetsFromS3JobErrorDetails)
        var importAssetsFromS3JobErrorDetailsDecoded0:[DataExchangeClientTypes.AssetSourceEntry]? = nil
        if let importAssetsFromS3JobErrorDetailsContainer = importAssetsFromS3JobErrorDetailsContainer {
            importAssetsFromS3JobErrorDetailsDecoded0 = [DataExchangeClientTypes.AssetSourceEntry]()
            for structure0 in importAssetsFromS3JobErrorDetailsContainer {
                if let structure0 = structure0 {
                    importAssetsFromS3JobErrorDetailsDecoded0?.append(structure0)
                }
            }
        }
        importAssetsFromS3JobErrorDetails = importAssetsFromS3JobErrorDetailsDecoded0
    }
}

extension DataExchangeClientTypes.Details: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Details(importAssetFromSignedUrlJobErrorDetails: \(Swift.String(describing: importAssetFromSignedUrlJobErrorDetails)), importAssetsFromS3JobErrorDetails: \(Swift.String(describing: importAssetsFromS3JobErrorDetails)))"}
}

extension DataExchangeClientTypes {
    /// Information about the job error.
    public struct Details: Swift.Equatable {
        /// Information about the job error.
        public var importAssetFromSignedUrlJobErrorDetails: DataExchangeClientTypes.ImportAssetFromSignedUrlJobErrorDetails?
        /// Information about the job error.
        public var importAssetsFromS3JobErrorDetails: [DataExchangeClientTypes.AssetSourceEntry]?

        public init (
            importAssetFromSignedUrlJobErrorDetails: DataExchangeClientTypes.ImportAssetFromSignedUrlJobErrorDetails? = nil,
            importAssetsFromS3JobErrorDetails: [DataExchangeClientTypes.AssetSourceEntry]? = nil
        )
        {
            self.importAssetFromSignedUrlJobErrorDetails = importAssetFromSignedUrlJobErrorDetails
            self.importAssetsFromS3JobErrorDetails = importAssetsFromS3JobErrorDetails
        }
    }

}

extension DataExchangeClientTypes.Event: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revisionPublished = "RevisionPublished"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let revisionPublished = revisionPublished {
            try encodeContainer.encode(revisionPublished, forKey: .revisionPublished)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionPublishedDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.RevisionPublished.self, forKey: .revisionPublished)
        revisionPublished = revisionPublishedDecoded
    }
}

extension DataExchangeClientTypes.Event: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Event(revisionPublished: \(Swift.String(describing: revisionPublished)))"}
}

extension DataExchangeClientTypes {
    /// What occurs to start an action.
    public struct Event: Swift.Equatable {
        /// What occurs to start the revision publish action.
        public var revisionPublished: DataExchangeClientTypes.RevisionPublished?

        public init (
            revisionPublished: DataExchangeClientTypes.RevisionPublished? = nil
        )
        {
            self.revisionPublished = revisionPublished
        }
    }

}

extension DataExchangeClientTypes.EventActionEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case event = "Event"
        case id = "Id"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let event = event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let eventDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataExchangeClientTypes.EventActionEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventActionEntry(action: \(Swift.String(describing: action)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), event: \(Swift.String(describing: event)), id: \(Swift.String(describing: id)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension DataExchangeClientTypes {
    /// An event action is an object that defines the relationship between a specific event and an automated action that will be taken on behalf of the customer.
    public struct EventActionEntry: Swift.Equatable {
        /// What occurs after a certain event.
        /// This member is required.
        public var action: DataExchangeClientTypes.Action?
        /// The Amazon Resource Name (ARN) for the event action.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the event action was created, in ISO 8601 format.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// What occurs to start an action.
        /// This member is required.
        public var event: DataExchangeClientTypes.Event?
        /// The unique identifier for the event action.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time that the event action was last updated, in ISO 8601 format.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            action: DataExchangeClientTypes.Action? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            event: DataExchangeClientTypes.Event? = nil,
            id: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.action = action
            self.arn = arn
            self.createdAt = createdAt
            self.event = event
            self.id = id
            self.updatedAt = updatedAt
        }
    }

}

extension DataExchangeClientTypes {
    public enum ExceptionCause: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insufficients3bucketpolicy
        case s3accessdenied
        case sdkUnknown(Swift.String)

        public static var allCases: [ExceptionCause] {
            return [
                .insufficients3bucketpolicy,
                .s3accessdenied,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insufficients3bucketpolicy: return "InsufficientS3BucketPolicy"
            case .s3accessdenied: return "S3AccessDenied"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExceptionCause(rawValue: rawValue) ?? ExceptionCause.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.ExportAssetToSignedUrlRequestDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId = "AssetId"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes.ExportAssetToSignedUrlRequestDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportAssetToSignedUrlRequestDetails(assetId: \(Swift.String(describing: assetId)), dataSetId: \(Swift.String(describing: dataSetId)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension DataExchangeClientTypes {
    /// Details of the operation to be performed by the job.
    public struct ExportAssetToSignedUrlRequestDetails: Swift.Equatable {
        /// The unique identifier for the asset that is exported to a signed URL.
        /// This member is required.
        public var assetId: Swift.String?
        /// The unique identifier for the data set associated with this export job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for the revision associated with this export request.
        /// This member is required.
        public var revisionId: Swift.String?

        public init (
            assetId: Swift.String? = nil,
            dataSetId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.ExportAssetToSignedUrlResponseDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId = "AssetId"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
        case signedUrl = "SignedUrl"
        case signedUrlExpiresAt = "SignedUrlExpiresAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let signedUrl = signedUrl {
            try encodeContainer.encode(signedUrl, forKey: .signedUrl)
        }
        if let signedUrlExpiresAt = signedUrlExpiresAt {
            try encodeContainer.encode(signedUrlExpiresAt.timeIntervalSince1970, forKey: .signedUrlExpiresAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let signedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signedUrl)
        signedUrl = signedUrlDecoded
        let signedUrlExpiresAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .signedUrlExpiresAt)
        signedUrlExpiresAt = signedUrlExpiresAtDecoded
    }
}

extension DataExchangeClientTypes.ExportAssetToSignedUrlResponseDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportAssetToSignedUrlResponseDetails(assetId: \(Swift.String(describing: assetId)), dataSetId: \(Swift.String(describing: dataSetId)), revisionId: \(Swift.String(describing: revisionId)), signedUrl: \(Swift.String(describing: signedUrl)), signedUrlExpiresAt: \(Swift.String(describing: signedUrlExpiresAt)))"}
}

extension DataExchangeClientTypes {
    /// The details of the export to signed URL response.
    public struct ExportAssetToSignedUrlResponseDetails: Swift.Equatable {
        /// The unique identifier for the asset associated with this export job.
        /// This member is required.
        public var assetId: Swift.String?
        /// The unique identifier for the data set associated with this export job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for the revision associated with this export response.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The signed URL for the export request.
        public var signedUrl: Swift.String?
        /// The date and time that the signed URL expires, in ISO 8601 format.
        public var signedUrlExpiresAt: ClientRuntime.Date?

        public init (
            assetId: Swift.String? = nil,
            dataSetId: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            signedUrl: Swift.String? = nil,
            signedUrlExpiresAt: ClientRuntime.Date? = nil
        )
        {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.revisionId = revisionId
            self.signedUrl = signedUrl
            self.signedUrlExpiresAt = signedUrlExpiresAt
        }
    }

}

extension DataExchangeClientTypes.ExportAssetsToS3RequestDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetDestinations = "AssetDestinations"
        case dataSetId = "DataSetId"
        case encryption = "Encryption"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetDestinations = assetDestinations {
            var assetDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetDestinations)
            for listofassetdestinationentry0 in assetDestinations {
                try assetDestinationsContainer.encode(listofassetdestinationentry0)
            }
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetDestinationsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.AssetDestinationEntry?].self, forKey: .assetDestinations)
        var assetDestinationsDecoded0:[DataExchangeClientTypes.AssetDestinationEntry]? = nil
        if let assetDestinationsContainer = assetDestinationsContainer {
            assetDestinationsDecoded0 = [DataExchangeClientTypes.AssetDestinationEntry]()
            for structure0 in assetDestinationsContainer {
                if let structure0 = structure0 {
                    assetDestinationsDecoded0?.append(structure0)
                }
            }
        }
        assetDestinations = assetDestinationsDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportServerSideEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes.ExportAssetsToS3RequestDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportAssetsToS3RequestDetails(assetDestinations: \(Swift.String(describing: assetDestinations)), dataSetId: \(Swift.String(describing: dataSetId)), encryption: \(Swift.String(describing: encryption)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension DataExchangeClientTypes {
    /// Details of the operation to be performed by the job.
    public struct ExportAssetsToS3RequestDetails: Swift.Equatable {
        /// The destination for the asset.
        /// This member is required.
        public var assetDestinations: [DataExchangeClientTypes.AssetDestinationEntry]?
        /// The unique identifier for the data set associated with this export job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// Encryption configuration for the export job.
        public var encryption: DataExchangeClientTypes.ExportServerSideEncryption?
        /// The unique identifier for the revision associated with this export request.
        /// This member is required.
        public var revisionId: Swift.String?

        public init (
            assetDestinations: [DataExchangeClientTypes.AssetDestinationEntry]? = nil,
            dataSetId: Swift.String? = nil,
            encryption: DataExchangeClientTypes.ExportServerSideEncryption? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetDestinations = assetDestinations
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.ExportAssetsToS3ResponseDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetDestinations = "AssetDestinations"
        case dataSetId = "DataSetId"
        case encryption = "Encryption"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetDestinations = assetDestinations {
            var assetDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetDestinations)
            for listofassetdestinationentry0 in assetDestinations {
                try assetDestinationsContainer.encode(listofassetdestinationentry0)
            }
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetDestinationsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.AssetDestinationEntry?].self, forKey: .assetDestinations)
        var assetDestinationsDecoded0:[DataExchangeClientTypes.AssetDestinationEntry]? = nil
        if let assetDestinationsContainer = assetDestinationsContainer {
            assetDestinationsDecoded0 = [DataExchangeClientTypes.AssetDestinationEntry]()
            for structure0 in assetDestinationsContainer {
                if let structure0 = structure0 {
                    assetDestinationsDecoded0?.append(structure0)
                }
            }
        }
        assetDestinations = assetDestinationsDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportServerSideEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes.ExportAssetsToS3ResponseDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportAssetsToS3ResponseDetails(assetDestinations: \(Swift.String(describing: assetDestinations)), dataSetId: \(Swift.String(describing: dataSetId)), encryption: \(Swift.String(describing: encryption)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension DataExchangeClientTypes {
    /// Details about the export to Amazon S3 response.
    public struct ExportAssetsToS3ResponseDetails: Swift.Equatable {
        /// The destination in Amazon S3 where the asset is exported.
        /// This member is required.
        public var assetDestinations: [DataExchangeClientTypes.AssetDestinationEntry]?
        /// The unique identifier for the data set associated with this export job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// Encryption configuration of the export job.
        public var encryption: DataExchangeClientTypes.ExportServerSideEncryption?
        /// The unique identifier for the revision associated with this export response.
        /// This member is required.
        public var revisionId: Swift.String?

        public init (
            assetDestinations: [DataExchangeClientTypes.AssetDestinationEntry]? = nil,
            dataSetId: Swift.String? = nil,
            encryption: DataExchangeClientTypes.ExportServerSideEncryption? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetDestinations = assetDestinations
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.ExportRevisionsToS3RequestDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetId = "DataSetId"
        case encryption = "Encryption"
        case revisionDestinations = "RevisionDestinations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let revisionDestinations = revisionDestinations {
            var revisionDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revisionDestinations)
            for listofrevisiondestinationentry0 in revisionDestinations {
                try revisionDestinationsContainer.encode(listofrevisiondestinationentry0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportServerSideEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let revisionDestinationsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.RevisionDestinationEntry?].self, forKey: .revisionDestinations)
        var revisionDestinationsDecoded0:[DataExchangeClientTypes.RevisionDestinationEntry]? = nil
        if let revisionDestinationsContainer = revisionDestinationsContainer {
            revisionDestinationsDecoded0 = [DataExchangeClientTypes.RevisionDestinationEntry]()
            for structure0 in revisionDestinationsContainer {
                if let structure0 = structure0 {
                    revisionDestinationsDecoded0?.append(structure0)
                }
            }
        }
        revisionDestinations = revisionDestinationsDecoded0
    }
}

extension DataExchangeClientTypes.ExportRevisionsToS3RequestDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportRevisionsToS3RequestDetails(dataSetId: \(Swift.String(describing: dataSetId)), encryption: \(Swift.String(describing: encryption)), revisionDestinations: \(Swift.String(describing: revisionDestinations)))"}
}

extension DataExchangeClientTypes {
    /// Details of the operation to be performed by the job.
    public struct ExportRevisionsToS3RequestDetails: Swift.Equatable {
        /// The unique identifier for the data set associated with this export job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// Encryption configuration for the export job.
        public var encryption: DataExchangeClientTypes.ExportServerSideEncryption?
        /// The destination for the revision.
        /// This member is required.
        public var revisionDestinations: [DataExchangeClientTypes.RevisionDestinationEntry]?

        public init (
            dataSetId: Swift.String? = nil,
            encryption: DataExchangeClientTypes.ExportServerSideEncryption? = nil,
            revisionDestinations: [DataExchangeClientTypes.RevisionDestinationEntry]? = nil
        )
        {
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.revisionDestinations = revisionDestinations
        }
    }

}

extension DataExchangeClientTypes.ExportRevisionsToS3ResponseDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetId = "DataSetId"
        case encryption = "Encryption"
        case eventActionArn = "EventActionArn"
        case revisionDestinations = "RevisionDestinations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let eventActionArn = eventActionArn {
            try encodeContainer.encode(eventActionArn, forKey: .eventActionArn)
        }
        if let revisionDestinations = revisionDestinations {
            var revisionDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revisionDestinations)
            for listofrevisiondestinationentry0 in revisionDestinations {
                try revisionDestinationsContainer.encode(listofrevisiondestinationentry0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportServerSideEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let revisionDestinationsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.RevisionDestinationEntry?].self, forKey: .revisionDestinations)
        var revisionDestinationsDecoded0:[DataExchangeClientTypes.RevisionDestinationEntry]? = nil
        if let revisionDestinationsContainer = revisionDestinationsContainer {
            revisionDestinationsDecoded0 = [DataExchangeClientTypes.RevisionDestinationEntry]()
            for structure0 in revisionDestinationsContainer {
                if let structure0 = structure0 {
                    revisionDestinationsDecoded0?.append(structure0)
                }
            }
        }
        revisionDestinations = revisionDestinationsDecoded0
        let eventActionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventActionArn)
        eventActionArn = eventActionArnDecoded
    }
}

extension DataExchangeClientTypes.ExportRevisionsToS3ResponseDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportRevisionsToS3ResponseDetails(dataSetId: \(Swift.String(describing: dataSetId)), encryption: \(Swift.String(describing: encryption)), eventActionArn: \(Swift.String(describing: eventActionArn)), revisionDestinations: \(Swift.String(describing: revisionDestinations)))"}
}

extension DataExchangeClientTypes {
    /// Details about the export revisions to Amazon S3 response.
    public struct ExportRevisionsToS3ResponseDetails: Swift.Equatable {
        /// The unique identifier for the data set associated with this export job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// Encryption configuration of the export job.
        public var encryption: DataExchangeClientTypes.ExportServerSideEncryption?
        /// The Amazon Resource Name (ARN) of the event action.
        public var eventActionArn: Swift.String?
        /// The destination in Amazon S3 where the revision is exported.
        /// This member is required.
        public var revisionDestinations: [DataExchangeClientTypes.RevisionDestinationEntry]?

        public init (
            dataSetId: Swift.String? = nil,
            encryption: DataExchangeClientTypes.ExportServerSideEncryption? = nil,
            eventActionArn: Swift.String? = nil,
            revisionDestinations: [DataExchangeClientTypes.RevisionDestinationEntry]? = nil
        )
        {
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.eventActionArn = eventActionArn
            self.revisionDestinations = revisionDestinations
        }
    }

}

extension DataExchangeClientTypes.ExportServerSideEncryption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn = "KmsKeyArn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ServerSideEncryptionTypes.self, forKey: .type)
        type = typeDecoded
    }
}

extension DataExchangeClientTypes.ExportServerSideEncryption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportServerSideEncryption(kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), type: \(Swift.String(describing: type)))"}
}

extension DataExchangeClientTypes {
    /// Encryption configuration of the export job. Includes the encryption type in addition to the AWS KMS key. The KMS key is only necessary if you chose the KMS encryption. type.
    public struct ExportServerSideEncryption: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the AWS KMS key you want to use to encrypt the Amazon S3 objects. This parameter is required if you choose aws:kms as an encryption type.
        public var kmsKeyArn: Swift.String?
        /// The type of server side encryption used for encrypting the objects in Amazon S3.
        /// This member is required.
        public var type: DataExchangeClientTypes.ServerSideEncryptionTypes?

        public init (
            kmsKeyArn: Swift.String? = nil,
            type: DataExchangeClientTypes.ServerSideEncryptionTypes? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.type = type
        }
    }

}

extension GetAssetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssetInput(assetId: \(Swift.String(describing: assetId)), dataSetId: \(Swift.String(describing: dataSetId)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension GetAssetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAssetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssetOutputError>
}

public struct GetAssetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssetOutputError>
}

public struct GetAssetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAssetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAssetInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssetOutputError>
}

public struct GetAssetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAssetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let dataSetId = input.dataSetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dataSetId is nil and needs a value for the path of this operation"))))
        }
        guard let revisionId = input.revisionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("revisionId is nil and needs a value for the path of this operation"))))
        }
        guard let assetId = input.assetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions/\(revisionId.urlPercentEncoding())/assets/\(assetId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAssetInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssetOutputError>
}

public struct GetAssetInput: Swift.Equatable {
    /// The unique identifier for an asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The unique identifier for a revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.dataSetId = dataSetId
        self.revisionId = revisionId
    }
}

struct GetAssetInputBody: Swift.Equatable {
}

extension GetAssetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssetOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssetOutputResponse(arn: \(Swift.String(describing: arn)), assetDetails: \(Swift.String(describing: assetDetails)), assetType: \(Swift.String(describing: assetType)), createdAt: \(Swift.String(describing: createdAt)), dataSetId: \(Swift.String(describing: dataSetId)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), sourceId: \(Swift.String(describing: sourceId)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension GetAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAssetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.assetDetails = output.assetDetails
            self.assetType = output.assetType
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.id = output.id
            self.name = output.name
            self.revisionId = output.revisionId
            self.sourceId = output.sourceId
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.assetDetails = nil
            self.assetType = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.id = nil
            self.name = nil
            self.revisionId = nil
            self.sourceId = nil
            self.updatedAt = nil
        }
    }
}

public struct GetAssetOutputResponse: Swift.Equatable {
    /// The ARN for the asset.
    public var arn: Swift.String?
    /// Information about the asset.
    public var assetDetails: DataExchangeClientTypes.AssetDetails?
    /// The type of asset that is added to a data set.
    public var assetType: DataExchangeClientTypes.AssetType?
    /// The date and time that the asset was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The unique identifier for the data set associated with this asset.
    public var dataSetId: Swift.String?
    /// The unique identifier for the asset.
    public var id: Swift.String?
    /// The name of the asset. When importing from Amazon S3, the S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target S3 object key. When importing from Amazon API Gateway API, the API name is used as the asset name. When importing from Amazon Redshift, the datashare name is used as the asset name.
    public var name: Swift.String?
    /// The unique identifier for the revision associated with this asset.
    public var revisionId: Swift.String?
    /// The asset ID of the owned asset corresponding to the entitled asset being viewed. This parameter is returned when an asset owner is viewing the entitled copy of its owned asset.
    public var sourceId: Swift.String?
    /// The date and time that the asset was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        assetDetails: DataExchangeClientTypes.AssetDetails? = nil,
        assetType: DataExchangeClientTypes.AssetType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        dataSetId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        sourceId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.assetDetails = assetDetails
        self.assetType = assetType
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.id = id
        self.name = name
        self.revisionId = revisionId
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

struct GetAssetOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let assetDetails: DataExchangeClientTypes.AssetDetails?
    public let assetType: DataExchangeClientTypes.AssetType?
    public let createdAt: ClientRuntime.Date?
    public let dataSetId: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let revisionId: Swift.String?
    public let sourceId: Swift.String?
    public let updatedAt: ClientRuntime.Date?
}

extension GetAssetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assetDetails = "AssetDetails"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case id = "Id"
        case name = "Name"
        case revisionId = "RevisionId"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let assetDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetDetails.self, forKey: .assetDetails)
        assetDetails = assetDetailsDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GetDataSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataSetInput(dataSetId: \(Swift.String(describing: dataSetId)))"}
}

extension GetDataSetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDataSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDataSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDataSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDataSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDataSetOutputError>
}

public struct GetDataSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDataSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDataSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDataSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDataSetOutputError>
}

public struct GetDataSetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDataSetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDataSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDataSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDataSetOutputError>
}

public struct GetDataSetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDataSetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDataSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let dataSetId = input.dataSetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dataSetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/data-sets/\(dataSetId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDataSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDataSetOutputError>
}

public struct GetDataSetInput: Swift.Equatable {
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init (
        dataSetId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
    }
}

struct GetDataSetInputBody: Swift.Equatable {
}

extension GetDataSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDataSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataSetOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataSetOutputResponse(arn: \(Swift.String(describing: arn)), assetType: \(Swift.String(describing: assetType)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), origin: \(Swift.String(describing: origin)), originDetails: \(Swift.String(describing: originDetails)), sourceId: \(Swift.String(describing: sourceId)), tags: \(Swift.String(describing: tags)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension GetDataSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDataSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.assetType = output.assetType
            self.createdAt = output.createdAt
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.origin = output.origin
            self.originDetails = output.originDetails
            self.sourceId = output.sourceId
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.assetType = nil
            self.createdAt = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.origin = nil
            self.originDetails = nil
            self.sourceId = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetDataSetOutputResponse: Swift.Equatable {
    /// The ARN for the data set.
    public var arn: Swift.String?
    /// The type of asset that is added to a data set.
    public var assetType: DataExchangeClientTypes.AssetType?
    /// The date and time that the data set was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The description for the data set.
    public var description: Swift.String?
    /// The unique identifier for the data set.
    public var id: Swift.String?
    /// The name of the data set.
    public var name: Swift.String?
    /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
    public var origin: DataExchangeClientTypes.Origin?
    /// If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.
    public var originDetails: DataExchangeClientTypes.OriginDetails?
    /// The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.
    public var sourceId: Swift.String?
    /// The tags for the data set.
    public var tags: [Swift.String:Swift.String]?
    /// The date and time that the data set was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        assetType: DataExchangeClientTypes.AssetType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        origin: DataExchangeClientTypes.Origin? = nil,
        originDetails: DataExchangeClientTypes.OriginDetails? = nil,
        sourceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.assetType = assetType
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
        self.origin = origin
        self.originDetails = originDetails
        self.sourceId = sourceId
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetDataSetOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let assetType: DataExchangeClientTypes.AssetType?
    public let createdAt: ClientRuntime.Date?
    public let description: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let origin: DataExchangeClientTypes.Origin?
    public let originDetails: DataExchangeClientTypes.OriginDetails?
    public let sourceId: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let updatedAt: ClientRuntime.Date?
}

extension GetDataSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case origin = "Origin"
        case originDetails = "OriginDetails"
        case sourceId = "SourceId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let originDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Origin.self, forKey: .origin)
        origin = originDecoded
        let originDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.OriginDetails.self, forKey: .originDetails)
        originDetails = originDetailsDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GetEventActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEventActionInput(eventActionId: \(Swift.String(describing: eventActionId)))"}
}

extension GetEventActionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetEventActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEventActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEventActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventActionOutputError>
}

public struct GetEventActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEventActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEventActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventActionOutputError>
}

public struct GetEventActionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventActionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetEventActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEventActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventActionOutputError>
}

public struct GetEventActionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventActionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetEventActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let eventActionId = input.eventActionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("eventActionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/event-actions/\(eventActionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEventActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventActionOutputError>
}

public struct GetEventActionInput: Swift.Equatable {
    /// The unique identifier for the event action.
    /// This member is required.
    public var eventActionId: Swift.String?

    public init (
        eventActionId: Swift.String? = nil
    )
    {
        self.eventActionId = eventActionId
    }
}

struct GetEventActionInputBody: Swift.Equatable {
}

extension GetEventActionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEventActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEventActionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEventActionOutputResponse(action: \(Swift.String(describing: action)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), event: \(Swift.String(describing: event)), id: \(Swift.String(describing: id)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension GetEventActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEventActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.event = output.event
            self.id = output.id
            self.updatedAt = output.updatedAt
        } else {
            self.action = nil
            self.arn = nil
            self.createdAt = nil
            self.event = nil
            self.id = nil
            self.updatedAt = nil
        }
    }
}

public struct GetEventActionOutputResponse: Swift.Equatable {
    /// What occurs after a certain event.
    public var action: DataExchangeClientTypes.Action?
    /// The ARN for the event action.
    public var arn: Swift.String?
    /// The date and time that the event action was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// What occurs to start an action.
    public var event: DataExchangeClientTypes.Event?
    /// The unique identifier for the event action.
    public var id: Swift.String?
    /// The date and time that the event action was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init (
        action: DataExchangeClientTypes.Action? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        event: DataExchangeClientTypes.Event? = nil,
        id: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.createdAt = createdAt
        self.event = event
        self.id = id
        self.updatedAt = updatedAt
    }
}

struct GetEventActionOutputResponseBody: Swift.Equatable {
    public let action: DataExchangeClientTypes.Action?
    public let arn: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let event: DataExchangeClientTypes.Event?
    public let id: Swift.String?
    public let updatedAt: ClientRuntime.Date?
}

extension GetEventActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case event = "Event"
        case id = "Id"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let eventDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GetJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetJobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension GetJobInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobOutputError>
}

public struct GetJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobOutputError>
}

public struct GetJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobOutputError>
}

public struct GetJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let jobId = input.jobId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("jobId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/jobs/\(jobId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobOutputError>
}

public struct GetJobInput: Swift.Equatable {
    /// The unique identifier for a job.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetJobInputBody: Swift.Equatable {
}

extension GetJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetJobOutputResponse(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), details: \(Swift.String(describing: details)), errors: \(Swift.String(describing: errors)), id: \(Swift.String(describing: id)), state: \(Swift.String(describing: state)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension GetJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.details = output.details
            self.errors = output.errors
            self.id = output.id
            self.state = output.state
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.createdAt = nil
            self.details = nil
            self.errors = nil
            self.id = nil
            self.state = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct GetJobOutputResponse: Swift.Equatable {
    /// The ARN for the job.
    public var arn: Swift.String?
    /// The date and time that the job was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// Details about the job.
    public var details: DataExchangeClientTypes.ResponseDetails?
    /// The errors associated with jobs.
    public var errors: [DataExchangeClientTypes.JobError]?
    /// The unique identifier for the job.
    public var id: Swift.String?
    /// The state of the job.
    public var state: DataExchangeClientTypes.State?
    /// The job type.
    public var type: DataExchangeClientTypes.ModelType?
    /// The date and time that the job was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        details: DataExchangeClientTypes.ResponseDetails? = nil,
        errors: [DataExchangeClientTypes.JobError]? = nil,
        id: Swift.String? = nil,
        state: DataExchangeClientTypes.State? = nil,
        type: DataExchangeClientTypes.ModelType? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.details = details
        self.errors = errors
        self.id = id
        self.state = state
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct GetJobOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let details: DataExchangeClientTypes.ResponseDetails?
    public let errors: [DataExchangeClientTypes.JobError]?
    public let id: Swift.String?
    public let state: DataExchangeClientTypes.State?
    public let type: DataExchangeClientTypes.ModelType?
    public let updatedAt: ClientRuntime.Date?
}

extension GetJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case details = "Details"
        case errors = "Errors"
        case id = "Id"
        case state = "State"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ResponseDetails.self, forKey: .details)
        details = detailsDecoded
        let errorsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.JobError?].self, forKey: .errors)
        var errorsDecoded0:[DataExchangeClientTypes.JobError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [DataExchangeClientTypes.JobError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GetRevisionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRevisionInput(dataSetId: \(Swift.String(describing: dataSetId)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension GetRevisionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRevisionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRevisionOutputError>
}

public struct GetRevisionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRevisionOutputError>
}

public struct GetRevisionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRevisionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetRevisionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRevisionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRevisionOutputError>
}

public struct GetRevisionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRevisionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetRevisionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let dataSetId = input.dataSetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dataSetId is nil and needs a value for the path of this operation"))))
        }
        guard let revisionId = input.revisionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("revisionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions/\(revisionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRevisionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRevisionOutputError>
}

public struct GetRevisionInput: Swift.Equatable {
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The unique identifier for a revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init (
        dataSetId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.revisionId = revisionId
    }
}

struct GetRevisionInputBody: Swift.Equatable {
}

extension GetRevisionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRevisionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRevisionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRevisionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRevisionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRevisionOutputResponse(arn: \(Swift.String(describing: arn)), comment: \(Swift.String(describing: comment)), createdAt: \(Swift.String(describing: createdAt)), dataSetId: \(Swift.String(describing: dataSetId)), finalized: \(Swift.String(describing: finalized)), id: \(Swift.String(describing: id)), sourceId: \(Swift.String(describing: sourceId)), tags: \(Swift.String(describing: tags)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension GetRevisionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRevisionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.comment = output.comment
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.finalized = output.finalized
            self.id = output.id
            self.sourceId = output.sourceId
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.comment = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.finalized = nil
            self.id = nil
            self.sourceId = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetRevisionOutputResponse: Swift.Equatable {
    /// The ARN for the revision.
    public var arn: Swift.String?
    /// An optional comment about the revision.
    public var comment: Swift.String?
    /// The date and time that the revision was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The unique identifier for the data set associated with this revision.
    public var dataSetId: Swift.String?
    /// To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products. Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.
    public var finalized: Swift.Bool?
    /// The unique identifier for the revision.
    public var id: Swift.String?
    /// The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.
    public var sourceId: Swift.String?
    /// The tags for the revision.
    public var tags: [Swift.String:Swift.String]?
    /// The date and time that the revision was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        comment: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        dataSetId: Swift.String? = nil,
        finalized: Swift.Bool? = nil,
        id: Swift.String? = nil,
        sourceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.comment = comment
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.finalized = finalized
        self.id = id
        self.sourceId = sourceId
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetRevisionOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let comment: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let dataSetId: Swift.String?
    public let finalized: Swift.Bool?
    public let id: Swift.String?
    public let sourceId: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let updatedAt: ClientRuntime.Date?
}

extension GetRevisionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case comment = "Comment"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case finalized = "Finalized"
        case id = "Id"
        case sourceId = "SourceId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataExchangeClientTypes.ImportAssetFromApiGatewayApiRequestDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDescription = "ApiDescription"
        case apiId = "ApiId"
        case apiKey = "ApiKey"
        case apiName = "ApiName"
        case apiSpecificationMd5Hash = "ApiSpecificationMd5Hash"
        case dataSetId = "DataSetId"
        case protocolType = "ProtocolType"
        case revisionId = "RevisionId"
        case stage = "Stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiDescription = apiDescription {
            try encodeContainer.encode(apiDescription, forKey: .apiDescription)
        }
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiKey = apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let apiName = apiName {
            try encodeContainer.encode(apiName, forKey: .apiName)
        }
        if let apiSpecificationMd5Hash = apiSpecificationMd5Hash {
            try encodeContainer.encode(apiSpecificationMd5Hash, forKey: .apiSpecificationMd5Hash)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let protocolType = protocolType {
            try encodeContainer.encode(protocolType.rawValue, forKey: .protocolType)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiDescription)
        apiDescription = apiDescriptionDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let apiNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiName)
        apiName = apiNameDecoded
        let apiSpecificationMd5HashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiSpecificationMd5Hash)
        apiSpecificationMd5Hash = apiSpecificationMd5HashDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension DataExchangeClientTypes.ImportAssetFromApiGatewayApiRequestDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportAssetFromApiGatewayApiRequestDetails(apiDescription: \(Swift.String(describing: apiDescription)), apiId: \(Swift.String(describing: apiId)), apiKey: \(Swift.String(describing: apiKey)), apiName: \(Swift.String(describing: apiName)), apiSpecificationMd5Hash: \(Swift.String(describing: apiSpecificationMd5Hash)), dataSetId: \(Swift.String(describing: dataSetId)), protocolType: \(Swift.String(describing: protocolType)), revisionId: \(Swift.String(describing: revisionId)), stage: \(Swift.String(describing: stage)))"}
}

extension DataExchangeClientTypes {
    /// The request details.
    public struct ImportAssetFromApiGatewayApiRequestDetails: Swift.Equatable {
        /// The API description. Markdown supported.
        public var apiDescription: Swift.String?
        /// The API Gateway API ID.
        /// This member is required.
        public var apiId: Swift.String?
        /// The API Gateway API key.
        public var apiKey: Swift.String?
        /// The API name.
        /// This member is required.
        public var apiName: Swift.String?
        /// The Base64-encoded MD5 hash of the OpenAPI 3.0 JSON API specification file. It is used to ensure the integrity of the file.
        /// This member is required.
        public var apiSpecificationMd5Hash: Swift.String?
        /// The data set ID.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The protocol type.
        /// This member is required.
        public var protocolType: DataExchangeClientTypes.ProtocolType?
        /// The revision ID.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The API stage.
        /// This member is required.
        public var stage: Swift.String?

        public init (
            apiDescription: Swift.String? = nil,
            apiId: Swift.String? = nil,
            apiKey: Swift.String? = nil,
            apiName: Swift.String? = nil,
            apiSpecificationMd5Hash: Swift.String? = nil,
            dataSetId: Swift.String? = nil,
            protocolType: DataExchangeClientTypes.ProtocolType? = nil,
            revisionId: Swift.String? = nil,
            stage: Swift.String? = nil
        )
        {
            self.apiDescription = apiDescription
            self.apiId = apiId
            self.apiKey = apiKey
            self.apiName = apiName
            self.apiSpecificationMd5Hash = apiSpecificationMd5Hash
            self.dataSetId = dataSetId
            self.protocolType = protocolType
            self.revisionId = revisionId
            self.stage = stage
        }
    }

}

extension DataExchangeClientTypes.ImportAssetFromApiGatewayApiResponseDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDescription = "ApiDescription"
        case apiId = "ApiId"
        case apiKey = "ApiKey"
        case apiName = "ApiName"
        case apiSpecificationMd5Hash = "ApiSpecificationMd5Hash"
        case apiSpecificationUploadUrl = "ApiSpecificationUploadUrl"
        case apiSpecificationUploadUrlExpiresAt = "ApiSpecificationUploadUrlExpiresAt"
        case dataSetId = "DataSetId"
        case protocolType = "ProtocolType"
        case revisionId = "RevisionId"
        case stage = "Stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiDescription = apiDescription {
            try encodeContainer.encode(apiDescription, forKey: .apiDescription)
        }
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiKey = apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let apiName = apiName {
            try encodeContainer.encode(apiName, forKey: .apiName)
        }
        if let apiSpecificationMd5Hash = apiSpecificationMd5Hash {
            try encodeContainer.encode(apiSpecificationMd5Hash, forKey: .apiSpecificationMd5Hash)
        }
        if let apiSpecificationUploadUrl = apiSpecificationUploadUrl {
            try encodeContainer.encode(apiSpecificationUploadUrl, forKey: .apiSpecificationUploadUrl)
        }
        if let apiSpecificationUploadUrlExpiresAt = apiSpecificationUploadUrlExpiresAt {
            try encodeContainer.encode(apiSpecificationUploadUrlExpiresAt.timeIntervalSince1970, forKey: .apiSpecificationUploadUrlExpiresAt)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let protocolType = protocolType {
            try encodeContainer.encode(protocolType.rawValue, forKey: .protocolType)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiDescription)
        apiDescription = apiDescriptionDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let apiNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiName)
        apiName = apiNameDecoded
        let apiSpecificationMd5HashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiSpecificationMd5Hash)
        apiSpecificationMd5Hash = apiSpecificationMd5HashDecoded
        let apiSpecificationUploadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiSpecificationUploadUrl)
        apiSpecificationUploadUrl = apiSpecificationUploadUrlDecoded
        let apiSpecificationUploadUrlExpiresAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .apiSpecificationUploadUrlExpiresAt)
        apiSpecificationUploadUrlExpiresAt = apiSpecificationUploadUrlExpiresAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension DataExchangeClientTypes.ImportAssetFromApiGatewayApiResponseDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportAssetFromApiGatewayApiResponseDetails(apiDescription: \(Swift.String(describing: apiDescription)), apiId: \(Swift.String(describing: apiId)), apiKey: \(Swift.String(describing: apiKey)), apiName: \(Swift.String(describing: apiName)), apiSpecificationMd5Hash: \(Swift.String(describing: apiSpecificationMd5Hash)), apiSpecificationUploadUrl: \(Swift.String(describing: apiSpecificationUploadUrl)), apiSpecificationUploadUrlExpiresAt: \(Swift.String(describing: apiSpecificationUploadUrlExpiresAt)), dataSetId: \(Swift.String(describing: dataSetId)), protocolType: \(Swift.String(describing: protocolType)), revisionId: \(Swift.String(describing: revisionId)), stage: \(Swift.String(describing: stage)))"}
}

extension DataExchangeClientTypes {
    /// The response details.
    public struct ImportAssetFromApiGatewayApiResponseDetails: Swift.Equatable {
        /// The API description.
        public var apiDescription: Swift.String?
        /// The API ID.
        /// This member is required.
        public var apiId: Swift.String?
        /// The API key.
        public var apiKey: Swift.String?
        /// The API name.
        /// This member is required.
        public var apiName: Swift.String?
        /// The Base64-encoded Md5 hash for the API asset, used to ensure the integrity of the API at that location.
        /// This member is required.
        public var apiSpecificationMd5Hash: Swift.String?
        /// The upload URL of the API specification.
        /// This member is required.
        public var apiSpecificationUploadUrl: Swift.String?
        /// The date and time that the upload URL expires, in ISO 8601 format.
        /// This member is required.
        public var apiSpecificationUploadUrlExpiresAt: ClientRuntime.Date?
        /// The data set ID.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The protocol type.
        /// This member is required.
        public var protocolType: DataExchangeClientTypes.ProtocolType?
        /// The revision ID.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The API stage.
        /// This member is required.
        public var stage: Swift.String?

        public init (
            apiDescription: Swift.String? = nil,
            apiId: Swift.String? = nil,
            apiKey: Swift.String? = nil,
            apiName: Swift.String? = nil,
            apiSpecificationMd5Hash: Swift.String? = nil,
            apiSpecificationUploadUrl: Swift.String? = nil,
            apiSpecificationUploadUrlExpiresAt: ClientRuntime.Date? = nil,
            dataSetId: Swift.String? = nil,
            protocolType: DataExchangeClientTypes.ProtocolType? = nil,
            revisionId: Swift.String? = nil,
            stage: Swift.String? = nil
        )
        {
            self.apiDescription = apiDescription
            self.apiId = apiId
            self.apiKey = apiKey
            self.apiName = apiName
            self.apiSpecificationMd5Hash = apiSpecificationMd5Hash
            self.apiSpecificationUploadUrl = apiSpecificationUploadUrl
            self.apiSpecificationUploadUrlExpiresAt = apiSpecificationUploadUrlExpiresAt
            self.dataSetId = dataSetId
            self.protocolType = protocolType
            self.revisionId = revisionId
            self.stage = stage
        }
    }

}

extension DataExchangeClientTypes.ImportAssetFromSignedUrlJobErrorDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetName = "AssetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetName = assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
    }
}

extension DataExchangeClientTypes.ImportAssetFromSignedUrlJobErrorDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportAssetFromSignedUrlJobErrorDetails(assetName: \(Swift.String(describing: assetName)))"}
}

extension DataExchangeClientTypes {
    /// Information about the job error.
    public struct ImportAssetFromSignedUrlJobErrorDetails: Swift.Equatable {
        /// Information about the job error.
        /// This member is required.
        public var assetName: Swift.String?

        public init (
            assetName: Swift.String? = nil
        )
        {
            self.assetName = assetName
        }
    }

}

extension DataExchangeClientTypes.ImportAssetFromSignedUrlRequestDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetName = "AssetName"
        case dataSetId = "DataSetId"
        case md5Hash = "Md5Hash"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetName = assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let md5Hash = md5Hash {
            try encodeContainer.encode(md5Hash, forKey: .md5Hash)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let md5HashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .md5Hash)
        md5Hash = md5HashDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes.ImportAssetFromSignedUrlRequestDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportAssetFromSignedUrlRequestDetails(assetName: \(Swift.String(describing: assetName)), dataSetId: \(Swift.String(describing: dataSetId)), md5Hash: \(Swift.String(describing: md5Hash)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension DataExchangeClientTypes {
    /// Details of the operation to be performed by the job.
    public struct ImportAssetFromSignedUrlRequestDetails: Swift.Equatable {
        /// The name of the asset. When importing from Amazon S3, the S3 object key is used as the asset name.
        /// This member is required.
        public var assetName: Swift.String?
        /// The unique identifier for the data set associated with this import job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The Base64-encoded Md5 hash for the asset, used to ensure the integrity of the file at that location.
        /// This member is required.
        public var md5Hash: Swift.String?
        /// The unique identifier for the revision associated with this import request.
        /// This member is required.
        public var revisionId: Swift.String?

        public init (
            assetName: Swift.String? = nil,
            dataSetId: Swift.String? = nil,
            md5Hash: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetName = assetName
            self.dataSetId = dataSetId
            self.md5Hash = md5Hash
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.ImportAssetFromSignedUrlResponseDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetName = "AssetName"
        case dataSetId = "DataSetId"
        case md5Hash = "Md5Hash"
        case revisionId = "RevisionId"
        case signedUrl = "SignedUrl"
        case signedUrlExpiresAt = "SignedUrlExpiresAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetName = assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let md5Hash = md5Hash {
            try encodeContainer.encode(md5Hash, forKey: .md5Hash)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let signedUrl = signedUrl {
            try encodeContainer.encode(signedUrl, forKey: .signedUrl)
        }
        if let signedUrlExpiresAt = signedUrlExpiresAt {
            try encodeContainer.encode(signedUrlExpiresAt.timeIntervalSince1970, forKey: .signedUrlExpiresAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let md5HashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .md5Hash)
        md5Hash = md5HashDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let signedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signedUrl)
        signedUrl = signedUrlDecoded
        let signedUrlExpiresAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .signedUrlExpiresAt)
        signedUrlExpiresAt = signedUrlExpiresAtDecoded
    }
}

extension DataExchangeClientTypes.ImportAssetFromSignedUrlResponseDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportAssetFromSignedUrlResponseDetails(assetName: \(Swift.String(describing: assetName)), dataSetId: \(Swift.String(describing: dataSetId)), md5Hash: \(Swift.String(describing: md5Hash)), revisionId: \(Swift.String(describing: revisionId)), signedUrl: \(Swift.String(describing: signedUrl)), signedUrlExpiresAt: \(Swift.String(describing: signedUrlExpiresAt)))"}
}

extension DataExchangeClientTypes {
    /// The details in the response for an import request, including the signed URL and other information.
    public struct ImportAssetFromSignedUrlResponseDetails: Swift.Equatable {
        /// The name for the asset associated with this import job.
        /// This member is required.
        public var assetName: Swift.String?
        /// The unique identifier for the data set associated with this import job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The Base64-encoded Md5 hash for the asset, used to ensure the integrity of the file at that location.
        public var md5Hash: Swift.String?
        /// The unique identifier for the revision associated with this import response.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The signed URL.
        public var signedUrl: Swift.String?
        /// The time and date at which the signed URL expires, in ISO 8601 format.
        public var signedUrlExpiresAt: ClientRuntime.Date?

        public init (
            assetName: Swift.String? = nil,
            dataSetId: Swift.String? = nil,
            md5Hash: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            signedUrl: Swift.String? = nil,
            signedUrlExpiresAt: ClientRuntime.Date? = nil
        )
        {
            self.assetName = assetName
            self.dataSetId = dataSetId
            self.md5Hash = md5Hash
            self.revisionId = revisionId
            self.signedUrl = signedUrl
            self.signedUrlExpiresAt = signedUrlExpiresAt
        }
    }

}

extension DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesRequestDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSources = "AssetSources"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetSources = assetSources {
            var assetSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetSources)
            for listofredshiftdatashareassetsourceentry0 in assetSources {
                try assetSourcesContainer.encode(listofredshiftdatashareassetsourceentry0)
            }
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSourcesContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry?].self, forKey: .assetSources)
        var assetSourcesDecoded0:[DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]? = nil
        if let assetSourcesContainer = assetSourcesContainer {
            assetSourcesDecoded0 = [DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]()
            for structure0 in assetSourcesContainer {
                if let structure0 = structure0 {
                    assetSourcesDecoded0?.append(structure0)
                }
            }
        }
        assetSources = assetSourcesDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesRequestDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportAssetsFromRedshiftDataSharesRequestDetails(assetSources: \(Swift.String(describing: assetSources)), dataSetId: \(Swift.String(describing: dataSetId)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension DataExchangeClientTypes {
    /// Details from an import from Amazon Redshift datashare request.
    public struct ImportAssetsFromRedshiftDataSharesRequestDetails: Swift.Equatable {
        /// A list of Amazon Redshift datashare assets.
        /// This member is required.
        public var assetSources: [DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]?
        /// The unique identifier for the data set associated with this import job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for the revision associated with this import job.
        /// This member is required.
        public var revisionId: Swift.String?

        public init (
            assetSources: [DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]? = nil,
            dataSetId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetSources = assetSources
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesResponseDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSources = "AssetSources"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetSources = assetSources {
            var assetSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetSources)
            for listofredshiftdatashareassetsourceentry0 in assetSources {
                try assetSourcesContainer.encode(listofredshiftdatashareassetsourceentry0)
            }
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSourcesContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry?].self, forKey: .assetSources)
        var assetSourcesDecoded0:[DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]? = nil
        if let assetSourcesContainer = assetSourcesContainer {
            assetSourcesDecoded0 = [DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]()
            for structure0 in assetSourcesContainer {
                if let structure0 = structure0 {
                    assetSourcesDecoded0?.append(structure0)
                }
            }
        }
        assetSources = assetSourcesDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesResponseDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportAssetsFromRedshiftDataSharesResponseDetails(assetSources: \(Swift.String(describing: assetSources)), dataSetId: \(Swift.String(describing: dataSetId)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension DataExchangeClientTypes {
    /// Details from an import from Amazon Redshift datashare response.
    public struct ImportAssetsFromRedshiftDataSharesResponseDetails: Swift.Equatable {
        /// A list of Amazon Redshift datashare asset sources.
        /// This member is required.
        public var assetSources: [DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]?
        /// The unique identifier for the data set associated with this import job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for the revision associated with this import job.
        /// This member is required.
        public var revisionId: Swift.String?

        public init (
            assetSources: [DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]? = nil,
            dataSetId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetSources = assetSources
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.ImportAssetsFromS3RequestDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSources = "AssetSources"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetSources = assetSources {
            var assetSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetSources)
            for listofassetsourceentry0 in assetSources {
                try assetSourcesContainer.encode(listofassetsourceentry0)
            }
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSourcesContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.AssetSourceEntry?].self, forKey: .assetSources)
        var assetSourcesDecoded0:[DataExchangeClientTypes.AssetSourceEntry]? = nil
        if let assetSourcesContainer = assetSourcesContainer {
            assetSourcesDecoded0 = [DataExchangeClientTypes.AssetSourceEntry]()
            for structure0 in assetSourcesContainer {
                if let structure0 = structure0 {
                    assetSourcesDecoded0?.append(structure0)
                }
            }
        }
        assetSources = assetSourcesDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes.ImportAssetsFromS3RequestDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportAssetsFromS3RequestDetails(assetSources: \(Swift.String(describing: assetSources)), dataSetId: \(Swift.String(describing: dataSetId)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension DataExchangeClientTypes {
    /// Details of the operation to be performed by the job.
    public struct ImportAssetsFromS3RequestDetails: Swift.Equatable {
        /// Is a list of S3 bucket and object key pairs.
        /// This member is required.
        public var assetSources: [DataExchangeClientTypes.AssetSourceEntry]?
        /// The unique identifier for the data set associated with this import job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for the revision associated with this import request.
        /// This member is required.
        public var revisionId: Swift.String?

        public init (
            assetSources: [DataExchangeClientTypes.AssetSourceEntry]? = nil,
            dataSetId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetSources = assetSources
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.ImportAssetsFromS3ResponseDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSources = "AssetSources"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetSources = assetSources {
            var assetSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetSources)
            for listofassetsourceentry0 in assetSources {
                try assetSourcesContainer.encode(listofassetsourceentry0)
            }
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSourcesContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.AssetSourceEntry?].self, forKey: .assetSources)
        var assetSourcesDecoded0:[DataExchangeClientTypes.AssetSourceEntry]? = nil
        if let assetSourcesContainer = assetSourcesContainer {
            assetSourcesDecoded0 = [DataExchangeClientTypes.AssetSourceEntry]()
            for structure0 in assetSourcesContainer {
                if let structure0 = structure0 {
                    assetSourcesDecoded0?.append(structure0)
                }
            }
        }
        assetSources = assetSourcesDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes.ImportAssetsFromS3ResponseDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportAssetsFromS3ResponseDetails(assetSources: \(Swift.String(describing: assetSources)), dataSetId: \(Swift.String(describing: dataSetId)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension DataExchangeClientTypes {
    /// Details from an import from Amazon S3 response.
    public struct ImportAssetsFromS3ResponseDetails: Swift.Equatable {
        /// Is a list of Amazon S3 bucket and object key pairs.
        /// This member is required.
        public var assetSources: [DataExchangeClientTypes.AssetSourceEntry]?
        /// The unique identifier for the data set associated with this import job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for the revision associated with this import response.
        /// This member is required.
        public var revisionId: Swift.String?

        public init (
            assetSources: [DataExchangeClientTypes.AssetSourceEntry]? = nil,
            dataSetId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetSources = assetSources
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception occurred with the service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The message identifying the service exception that occurred.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataExchangeClientTypes.JobEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case details = "Details"
        case errors = "Errors"
        case id = "Id"
        case state = "State"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let details = details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for listofjoberror0 in errors {
                try errorsContainer.encode(listofjoberror0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ResponseDetails.self, forKey: .details)
        details = detailsDecoded
        let errorsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.JobError?].self, forKey: .errors)
        var errorsDecoded0:[DataExchangeClientTypes.JobError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [DataExchangeClientTypes.JobError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataExchangeClientTypes.JobEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobEntry(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), details: \(Swift.String(describing: details)), errors: \(Swift.String(describing: errors)), id: \(Swift.String(describing: id)), state: \(Swift.String(describing: state)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension DataExchangeClientTypes {
    /// AWS Data Exchange Jobs are asynchronous import or export operations used to create or copy assets. A data set owner can both import and export as they see fit. Someone with an entitlement to a data set can only export. Jobs are deleted 90 days after they are created.
    public struct JobEntry: Swift.Equatable {
        /// The ARN for the job.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the job was created, in ISO 8601 format.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Details of the operation to be performed by the job, such as export destination details or import source details.
        /// This member is required.
        public var details: DataExchangeClientTypes.ResponseDetails?
        /// Errors for jobs.
        public var errors: [DataExchangeClientTypes.JobError]?
        /// The unique identifier for the job.
        /// This member is required.
        public var id: Swift.String?
        /// The state of the job.
        /// This member is required.
        public var state: DataExchangeClientTypes.State?
        /// The job type.
        /// This member is required.
        public var type: DataExchangeClientTypes.ModelType?
        /// The date and time that the job was last updated, in ISO 8601 format.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            details: DataExchangeClientTypes.ResponseDetails? = nil,
            errors: [DataExchangeClientTypes.JobError]? = nil,
            id: Swift.String? = nil,
            state: DataExchangeClientTypes.State? = nil,
            type: DataExchangeClientTypes.ModelType? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.details = details
            self.errors = errors
            self.id = id
            self.state = state
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension DataExchangeClientTypes.JobError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case details = "Details"
        case limitName = "LimitName"
        case limitValue = "LimitValue"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let details = details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let limitName = limitName {
            try encodeContainer.encode(limitName.rawValue, forKey: .limitName)
        }
        if let limitValue = limitValue {
            try encodeContainer.encode(limitValue, forKey: .limitValue)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Code.self, forKey: .code)
        code = codeDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Details.self, forKey: .details)
        details = detailsDecoded
        let limitNameDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.JobErrorLimitName.self, forKey: .limitName)
        limitName = limitNameDecoded
        let limitValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .limitValue)
        limitValue = limitValueDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.JobErrorResourceTypes.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension DataExchangeClientTypes.JobError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobError(code: \(Swift.String(describing: code)), details: \(Swift.String(describing: details)), limitName: \(Swift.String(describing: limitName)), limitValue: \(Swift.String(describing: limitValue)), message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension DataExchangeClientTypes {
    /// An error that occurred with the job request.
    public struct JobError: Swift.Equatable {
        /// The code for the job error.
        /// This member is required.
        public var code: DataExchangeClientTypes.Code?
        /// The details about the job error.
        public var details: DataExchangeClientTypes.Details?
        /// The name of the limit that was reached.
        public var limitName: DataExchangeClientTypes.JobErrorLimitName?
        /// The value of the exceeded limit.
        public var limitValue: Swift.Double?
        /// The message related to the job error.
        /// This member is required.
        public var message: Swift.String?
        /// The unique identifier for the resource related to the error.
        public var resourceId: Swift.String?
        /// The type of resource related to the error.
        public var resourceType: DataExchangeClientTypes.JobErrorResourceTypes?

        public init (
            code: DataExchangeClientTypes.Code? = nil,
            details: DataExchangeClientTypes.Details? = nil,
            limitName: DataExchangeClientTypes.JobErrorLimitName? = nil,
            limitValue: Swift.Double? = nil,
            message: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: DataExchangeClientTypes.JobErrorResourceTypes? = nil
        )
        {
            self.code = code
            self.details = details
            self.limitName = limitName
            self.limitValue = limitValue
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension DataExchangeClientTypes {
    /// The name of the limit that was reached.
    public enum JobErrorLimitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonRedshiftDatashareAssetsPerRevision
        case assetSizeInGb
        case assetsPerRevision
        case sdkUnknown(Swift.String)

        public static var allCases: [JobErrorLimitName] {
            return [
                .amazonRedshiftDatashareAssetsPerRevision,
                .assetSizeInGb,
                .assetsPerRevision,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonRedshiftDatashareAssetsPerRevision: return "Amazon Redshift datashare assets per revision"
            case .assetSizeInGb: return "Asset size in GB"
            case .assetsPerRevision: return "Assets per revision"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobErrorLimitName(rawValue: rawValue) ?? JobErrorLimitName.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes {
    /// The types of resource which the job error can apply to.
    public enum JobErrorResourceTypes: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asset
        case dataSet
        case revision
        case sdkUnknown(Swift.String)

        public static var allCases: [JobErrorResourceTypes] {
            return [
                .asset,
                .dataSet,
                .revision,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case .dataSet: return "DATA_SET"
            case .revision: return "REVISION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobErrorResourceTypes(rawValue: rawValue) ?? JobErrorResourceTypes.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes {
    public enum LimitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonApiGatewayApiAssetsPerRevision
        case amazonRedshiftDatashareAssetsPerImportJobFromRedshift
        case amazonRedshiftDatashareAssetsPerRevision
        case assetPerExportJobFromAmazonS3
        case assetSizeInGb
        case assetsPerImportJobFromAmazonS3
        case assetsPerRevision
        case autoExportEventActionsPerDataSet
        case concurrentInProgressJobsToExportAssetsToAmazonS3
        case concurrentInProgressJobsToExportAssetsToASignedUrl
        case concurrentInProgressJobsToExportRevisionsToAmazonS3
        case concurrentInProgressJobsToImportAssetsFromAmazonRedshiftDatashares
        case concurrentInProgressJobsToImportAssetsFromAmazonS3
        case concurrentInProgressJobsToImportAssetsFromASignedUrl
        case concurrentInProgressJobsToImportAssetsFromAnApiGatewayApi
        case dataSetsPerAccount
        case dataSetsPerProduct
        case eventActionsPerAccount
        case productsPerAccount
        case revisionsPerAmazonApiGatewayApiDataSet
        case revisionsPerAmazonRedshiftDatashareDataSet
        case revisionsPerDataSet
        case sdkUnknown(Swift.String)

        public static var allCases: [LimitName] {
            return [
                .amazonApiGatewayApiAssetsPerRevision,
                .amazonRedshiftDatashareAssetsPerImportJobFromRedshift,
                .amazonRedshiftDatashareAssetsPerRevision,
                .assetPerExportJobFromAmazonS3,
                .assetSizeInGb,
                .assetsPerImportJobFromAmazonS3,
                .assetsPerRevision,
                .autoExportEventActionsPerDataSet,
                .concurrentInProgressJobsToExportAssetsToAmazonS3,
                .concurrentInProgressJobsToExportAssetsToASignedUrl,
                .concurrentInProgressJobsToExportRevisionsToAmazonS3,
                .concurrentInProgressJobsToImportAssetsFromAmazonRedshiftDatashares,
                .concurrentInProgressJobsToImportAssetsFromAmazonS3,
                .concurrentInProgressJobsToImportAssetsFromASignedUrl,
                .concurrentInProgressJobsToImportAssetsFromAnApiGatewayApi,
                .dataSetsPerAccount,
                .dataSetsPerProduct,
                .eventActionsPerAccount,
                .productsPerAccount,
                .revisionsPerAmazonApiGatewayApiDataSet,
                .revisionsPerAmazonRedshiftDatashareDataSet,
                .revisionsPerDataSet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonApiGatewayApiAssetsPerRevision: return "Amazon API Gateway API assets per revision"
            case .amazonRedshiftDatashareAssetsPerImportJobFromRedshift: return "Amazon Redshift datashare assets per import job from Redshift"
            case .amazonRedshiftDatashareAssetsPerRevision: return "Amazon Redshift datashare assets per revision"
            case .assetPerExportJobFromAmazonS3: return "Asset per export job from Amazon S3"
            case .assetSizeInGb: return "Asset size in GB"
            case .assetsPerImportJobFromAmazonS3: return "Assets per import job from Amazon S3"
            case .assetsPerRevision: return "Assets per revision"
            case .autoExportEventActionsPerDataSet: return "Auto export event actions per data set"
            case .concurrentInProgressJobsToExportAssetsToAmazonS3: return "Concurrent in progress jobs to export assets to Amazon S3"
            case .concurrentInProgressJobsToExportAssetsToASignedUrl: return "Concurrent in progress jobs to export assets to a signed URL"
            case .concurrentInProgressJobsToExportRevisionsToAmazonS3: return "Concurrent in progress jobs to export revisions to Amazon S3"
            case .concurrentInProgressJobsToImportAssetsFromAmazonRedshiftDatashares: return "Concurrent in progress jobs to import assets from Amazon Redshift datashares"
            case .concurrentInProgressJobsToImportAssetsFromAmazonS3: return "Concurrent in progress jobs to import assets from Amazon S3"
            case .concurrentInProgressJobsToImportAssetsFromASignedUrl: return "Concurrent in progress jobs to import assets from a signed URL"
            case .concurrentInProgressJobsToImportAssetsFromAnApiGatewayApi: return "Concurrent in progress jobs to import assets from an API Gateway API"
            case .dataSetsPerAccount: return "Data sets per account"
            case .dataSetsPerProduct: return "Data sets per product"
            case .eventActionsPerAccount: return "Event actions per account"
            case .productsPerAccount: return "Products per account"
            case .revisionsPerAmazonApiGatewayApiDataSet: return "Revisions per Amazon API Gateway API data set"
            case .revisionsPerAmazonRedshiftDatashareDataSet: return "Revisions per Amazon Redshift datashare data set"
            case .revisionsPerDataSet: return "Revisions per data set"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LimitName(rawValue: rawValue) ?? LimitName.sdkUnknown(rawValue)
        }
    }
}

extension ListDataSetRevisionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataSetRevisionsInput(dataSetId: \(Swift.String(describing: dataSetId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDataSetRevisionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDataSetRevisionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSetRevisionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataSetRevisionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSetRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataSetRevisionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSetRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSetRevisionsOutputError>
}

public struct ListDataSetRevisionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSetRevisionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataSetRevisionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSetRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataSetRevisionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSetRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSetRevisionsOutputError>
}

public struct ListDataSetRevisionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSetRevisionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDataSetRevisionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSetRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDataSetRevisionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSetRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSetRevisionsOutputError>
}

public struct ListDataSetRevisionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSetRevisionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDataSetRevisionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSetRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let dataSetId = input.dataSetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dataSetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDataSetRevisionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSetRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSetRevisionsOutputError>
}

public struct ListDataSetRevisionsInput: Swift.Equatable {
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The maximum number of results returned by a single call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init (
        dataSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSetRevisionsInputBody: Swift.Equatable {
}

extension ListDataSetRevisionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSetRevisionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSetRevisionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataSetRevisionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSetRevisionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataSetRevisionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), revisions: \(Swift.String(describing: revisions)))"}
}

extension ListDataSetRevisionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDataSetRevisionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.revisions = output.revisions
        } else {
            self.nextToken = nil
            self.revisions = nil
        }
    }
}

public struct ListDataSetRevisionsOutputResponse: Swift.Equatable {
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// The asset objects listed by the request.
    public var revisions: [DataExchangeClientTypes.RevisionEntry]?

    public init (
        nextToken: Swift.String? = nil,
        revisions: [DataExchangeClientTypes.RevisionEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.revisions = revisions
    }
}

struct ListDataSetRevisionsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let revisions: [DataExchangeClientTypes.RevisionEntry]?
}

extension ListDataSetRevisionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case revisions = "Revisions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let revisionsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.RevisionEntry?].self, forKey: .revisions)
        var revisionsDecoded0:[DataExchangeClientTypes.RevisionEntry]? = nil
        if let revisionsContainer = revisionsContainer {
            revisionsDecoded0 = [DataExchangeClientTypes.RevisionEntry]()
            for structure0 in revisionsContainer {
                if let structure0 = structure0 {
                    revisionsDecoded0?.append(structure0)
                }
            }
        }
        revisions = revisionsDecoded0
    }
}

extension ListDataSetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataSetsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), origin: \(Swift.String(describing: origin)))"}
}

extension ListDataSetsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDataSetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataSetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataSetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSetsOutputError>
}

public struct ListDataSetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataSetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let origin = input.operationInput.origin {
            let originQueryItem = ClientRuntime.URLQueryItem(name: "origin".urlPercentEncoding(), value: Swift.String(origin).urlPercentEncoding())
            input.builder.withQueryItem(originQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataSetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSetsOutputError>
}

public struct ListDataSetsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSetsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDataSetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDataSetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSetsOutputError>
}

public struct ListDataSetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataSetsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDataSetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/data-sets"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDataSetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataSetsOutputError>
}

public struct ListDataSetsInput: Swift.Equatable {
    /// The maximum number of results returned by a single call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
    public var origin: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        origin: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.origin = origin
    }
}

struct ListDataSetsInputBody: Swift.Equatable {
}

extension ListDataSetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataSetsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataSetsOutputResponse(dataSets: \(Swift.String(describing: dataSets)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDataSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDataSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSets = output.dataSets
            self.nextToken = output.nextToken
        } else {
            self.dataSets = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSetsOutputResponse: Swift.Equatable {
    /// The data set objects listed by the request.
    public var dataSets: [DataExchangeClientTypes.DataSetEntry]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init (
        dataSets: [DataExchangeClientTypes.DataSetEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSets = dataSets
        self.nextToken = nextToken
    }
}

struct ListDataSetsOutputResponseBody: Swift.Equatable {
    public let dataSets: [DataExchangeClientTypes.DataSetEntry]?
    public let nextToken: Swift.String?
}

extension ListDataSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSets = "DataSets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.DataSetEntry?].self, forKey: .dataSets)
        var dataSetsDecoded0:[DataExchangeClientTypes.DataSetEntry]? = nil
        if let dataSetsContainer = dataSetsContainer {
            dataSetsDecoded0 = [DataExchangeClientTypes.DataSetEntry]()
            for structure0 in dataSetsContainer {
                if let structure0 = structure0 {
                    dataSetsDecoded0?.append(structure0)
                }
            }
        }
        dataSets = dataSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEventActionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEventActionsInput(eventSourceId: \(Swift.String(describing: eventSourceId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEventActionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListEventActionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventActionsOutputError>
}

public struct ListEventActionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let eventSourceId = input.operationInput.eventSourceId {
            let eventSourceIdQueryItem = ClientRuntime.URLQueryItem(name: "eventSourceId".urlPercentEncoding(), value: Swift.String(eventSourceId).urlPercentEncoding())
            input.builder.withQueryItem(eventSourceIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventActionsOutputError>
}

public struct ListEventActionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventActionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListEventActionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEventActionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventActionsOutputError>
}

public struct ListEventActionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventActionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListEventActionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/event-actions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEventActionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventActionsOutputError>
}

public struct ListEventActionsInput: Swift.Equatable {
    /// The unique identifier for the event source.
    public var eventSourceId: Swift.String?
    /// The maximum number of results returned by a single call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init (
        eventSourceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventSourceId = eventSourceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventActionsInputBody: Swift.Equatable {
}

extension ListEventActionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEventActionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventActionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventActionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventActionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEventActionsOutputResponse(eventActions: \(Swift.String(describing: eventActions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEventActionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEventActionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventActions = output.eventActions
            self.nextToken = output.nextToken
        } else {
            self.eventActions = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventActionsOutputResponse: Swift.Equatable {
    /// The event action objects listed by the request.
    public var eventActions: [DataExchangeClientTypes.EventActionEntry]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init (
        eventActions: [DataExchangeClientTypes.EventActionEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventActions = eventActions
        self.nextToken = nextToken
    }
}

struct ListEventActionsOutputResponseBody: Swift.Equatable {
    public let eventActions: [DataExchangeClientTypes.EventActionEntry]?
    public let nextToken: Swift.String?
}

extension ListEventActionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventActions = "EventActions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventActionsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.EventActionEntry?].self, forKey: .eventActions)
        var eventActionsDecoded0:[DataExchangeClientTypes.EventActionEntry]? = nil
        if let eventActionsContainer = eventActionsContainer {
            eventActionsDecoded0 = [DataExchangeClientTypes.EventActionEntry]()
            for structure0 in eventActionsContainer {
                if let structure0 = structure0 {
                    eventActionsDecoded0?.append(structure0)
                }
            }
        }
        eventActions = eventActionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListJobsInput(dataSetId: \(Swift.String(describing: dataSetId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension ListJobsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsOutputError>
}

public struct ListJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let dataSetId = input.operationInput.dataSetId {
            let dataSetIdQueryItem = ClientRuntime.URLQueryItem(name: "dataSetId".urlPercentEncoding(), value: Swift.String(dataSetId).urlPercentEncoding())
            input.builder.withQueryItem(dataSetIdQueryItem)
        }
        if let revisionId = input.operationInput.revisionId {
            let revisionIdQueryItem = ClientRuntime.URLQueryItem(name: "revisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            input.builder.withQueryItem(revisionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsOutputError>
}

public struct ListJobsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsOutputError>
}

public struct ListJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/jobs"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsOutputError>
}

public struct ListJobsInput: Swift.Equatable {
    /// The unique identifier for a data set.
    public var dataSetId: Swift.String?
    /// The maximum number of results returned by a single call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// The unique identifier for a revision.
    public var revisionId: Swift.String?

    public init (
        dataSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.revisionId = revisionId
    }
}

struct ListJobsInputBody: Swift.Equatable {
}

extension ListJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListJobsOutputResponse(jobs: \(Swift.String(describing: jobs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutputResponse: Swift.Equatable {
    /// The jobs listed by the request.
    public var jobs: [DataExchangeClientTypes.JobEntry]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init (
        jobs: [DataExchangeClientTypes.JobEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListJobsOutputResponseBody: Swift.Equatable {
    public let jobs: [DataExchangeClientTypes.JobEntry]?
    public let nextToken: Swift.String?
}

extension ListJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs = "Jobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.JobEntry?].self, forKey: .jobs)
        var jobsDecoded0:[DataExchangeClientTypes.JobEntry]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [DataExchangeClientTypes.JobEntry]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRevisionAssetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRevisionAssetsInput(dataSetId: \(Swift.String(describing: dataSetId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension ListRevisionAssetsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRevisionAssetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRevisionAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRevisionAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRevisionAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRevisionAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRevisionAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRevisionAssetsOutputError>
}

public struct ListRevisionAssetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRevisionAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRevisionAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRevisionAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRevisionAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRevisionAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRevisionAssetsOutputError>
}

public struct ListRevisionAssetsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRevisionAssetsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListRevisionAssetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRevisionAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRevisionAssetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRevisionAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRevisionAssetsOutputError>
}

public struct ListRevisionAssetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRevisionAssetsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListRevisionAssetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRevisionAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let dataSetId = input.dataSetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dataSetId is nil and needs a value for the path of this operation"))))
        }
        guard let revisionId = input.revisionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("revisionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions/\(revisionId.urlPercentEncoding())/assets"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRevisionAssetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRevisionAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRevisionAssetsOutputError>
}

public struct ListRevisionAssetsInput: Swift.Equatable {
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The maximum number of results returned by a single call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// The unique identifier for a revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init (
        dataSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.revisionId = revisionId
    }
}

struct ListRevisionAssetsInputBody: Swift.Equatable {
}

extension ListRevisionAssetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRevisionAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRevisionAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRevisionAssetsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRevisionAssetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRevisionAssetsOutputResponse(assets: \(Swift.String(describing: assets)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRevisionAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRevisionAssetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assets = output.assets
            self.nextToken = output.nextToken
        } else {
            self.assets = nil
            self.nextToken = nil
        }
    }
}

public struct ListRevisionAssetsOutputResponse: Swift.Equatable {
    /// The asset objects listed by the request.
    public var assets: [DataExchangeClientTypes.AssetEntry]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init (
        assets: [DataExchangeClientTypes.AssetEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assets = assets
        self.nextToken = nextToken
    }
}

struct ListRevisionAssetsOutputResponseBody: Swift.Equatable {
    public let assets: [DataExchangeClientTypes.AssetEntry]?
    public let nextToken: Swift.String?
}

extension ListRevisionAssetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assets = "Assets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.AssetEntry?].self, forKey: .assets)
        var assetsDecoded0:[DataExchangeClientTypes.AssetEntry]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [DataExchangeClientTypes.AssetEntry]()
            for structure0 in assetsContainer {
                if let structure0 = structure0 {
                    assetsDecoded0?.append(structure0)
                }
            }
        }
        assets = assetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies an AWS resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A label that consists of a customer-defined key and an optional value.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DataExchangeClientTypes {
    /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers). When an owned data set is published in a product, AWS Data Exchange creates a copy of the data set. Subscribers can access that copy of the data set as an entitled data set.
    public enum Origin: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case entitled
        case owned
        case sdkUnknown(Swift.String)

        public static var allCases: [Origin] {
            return [
                .entitled,
                .owned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .entitled: return "ENTITLED"
            case .owned: return "OWNED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Origin(rawValue: rawValue) ?? Origin.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.OriginDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productId = "ProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
    }
}

extension DataExchangeClientTypes.OriginDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginDetails(productId: \(Swift.String(describing: productId)))"}
}

extension DataExchangeClientTypes {
    /// Information about the origin of the data set.
    public struct OriginDetails: Swift.Equatable {
        /// The product ID of the origin of the data set.
        /// This member is required.
        public var productId: Swift.String?

        public init (
            productId: Swift.String? = nil
        )
        {
            self.productId = productId
        }
    }

}

extension DataExchangeClientTypes {
    public enum ProtocolType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rest
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtocolType] {
            return [
                .rest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rest: return "REST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProtocolType(rawValue: rawValue) ?? ProtocolType.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.RedshiftDataShareAsset: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DataExchangeClientTypes.RedshiftDataShareAsset: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedshiftDataShareAsset(arn: \(Swift.String(describing: arn)))"}
}

extension DataExchangeClientTypes {
    /// The Amazon Redshift datashare asset.
    public struct RedshiftDataShareAsset: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the datashare asset.
        /// This member is required.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataShareArn = "DataShareArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataShareArn = dataShareArn {
            try encodeContainer.encode(dataShareArn, forKey: .dataShareArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataShareArn)
        dataShareArn = dataShareArnDecoded
    }
}

extension DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedshiftDataShareAssetSourceEntry(dataShareArn: \(Swift.String(describing: dataShareArn)))"}
}

extension DataExchangeClientTypes {
    /// The source of the Amazon Redshift datashare asset.
    public struct RedshiftDataShareAssetSourceEntry: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the datashare asset.
        /// This member is required.
        public var dataShareArn: Swift.String?

        public init (
            dataShareArn: Swift.String? = nil
        )
        {
            self.dataShareArn = dataShareArn
        }
    }

}

extension DataExchangeClientTypes.RequestDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportAssetToSignedUrl = "ExportAssetToSignedUrl"
        case exportAssetsToS3 = "ExportAssetsToS3"
        case exportRevisionsToS3 = "ExportRevisionsToS3"
        case importAssetFromApiGatewayApi = "ImportAssetFromApiGatewayApi"
        case importAssetFromSignedUrl = "ImportAssetFromSignedUrl"
        case importAssetsFromRedshiftDataShares = "ImportAssetsFromRedshiftDataShares"
        case importAssetsFromS3 = "ImportAssetsFromS3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportAssetToSignedUrl = exportAssetToSignedUrl {
            try encodeContainer.encode(exportAssetToSignedUrl, forKey: .exportAssetToSignedUrl)
        }
        if let exportAssetsToS3 = exportAssetsToS3 {
            try encodeContainer.encode(exportAssetsToS3, forKey: .exportAssetsToS3)
        }
        if let exportRevisionsToS3 = exportRevisionsToS3 {
            try encodeContainer.encode(exportRevisionsToS3, forKey: .exportRevisionsToS3)
        }
        if let importAssetFromApiGatewayApi = importAssetFromApiGatewayApi {
            try encodeContainer.encode(importAssetFromApiGatewayApi, forKey: .importAssetFromApiGatewayApi)
        }
        if let importAssetFromSignedUrl = importAssetFromSignedUrl {
            try encodeContainer.encode(importAssetFromSignedUrl, forKey: .importAssetFromSignedUrl)
        }
        if let importAssetsFromRedshiftDataShares = importAssetsFromRedshiftDataShares {
            try encodeContainer.encode(importAssetsFromRedshiftDataShares, forKey: .importAssetsFromRedshiftDataShares)
        }
        if let importAssetsFromS3 = importAssetsFromS3 {
            try encodeContainer.encode(importAssetsFromS3, forKey: .importAssetsFromS3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportAssetToSignedUrlDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportAssetToSignedUrlRequestDetails.self, forKey: .exportAssetToSignedUrl)
        exportAssetToSignedUrl = exportAssetToSignedUrlDecoded
        let exportAssetsToS3Decoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportAssetsToS3RequestDetails.self, forKey: .exportAssetsToS3)
        exportAssetsToS3 = exportAssetsToS3Decoded
        let exportRevisionsToS3Decoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportRevisionsToS3RequestDetails.self, forKey: .exportRevisionsToS3)
        exportRevisionsToS3 = exportRevisionsToS3Decoded
        let importAssetFromSignedUrlDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetFromSignedUrlRequestDetails.self, forKey: .importAssetFromSignedUrl)
        importAssetFromSignedUrl = importAssetFromSignedUrlDecoded
        let importAssetsFromS3Decoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetsFromS3RequestDetails.self, forKey: .importAssetsFromS3)
        importAssetsFromS3 = importAssetsFromS3Decoded
        let importAssetsFromRedshiftDataSharesDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesRequestDetails.self, forKey: .importAssetsFromRedshiftDataShares)
        importAssetsFromRedshiftDataShares = importAssetsFromRedshiftDataSharesDecoded
        let importAssetFromApiGatewayApiDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetFromApiGatewayApiRequestDetails.self, forKey: .importAssetFromApiGatewayApi)
        importAssetFromApiGatewayApi = importAssetFromApiGatewayApiDecoded
    }
}

extension DataExchangeClientTypes.RequestDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestDetails(exportAssetToSignedUrl: \(Swift.String(describing: exportAssetToSignedUrl)), exportAssetsToS3: \(Swift.String(describing: exportAssetsToS3)), exportRevisionsToS3: \(Swift.String(describing: exportRevisionsToS3)), importAssetFromApiGatewayApi: \(Swift.String(describing: importAssetFromApiGatewayApi)), importAssetFromSignedUrl: \(Swift.String(describing: importAssetFromSignedUrl)), importAssetsFromRedshiftDataShares: \(Swift.String(describing: importAssetsFromRedshiftDataShares)), importAssetsFromS3: \(Swift.String(describing: importAssetsFromS3)))"}
}

extension DataExchangeClientTypes {
    /// The details for the request.
    public struct RequestDetails: Swift.Equatable {
        /// Details about the export to signed URL request.
        public var exportAssetToSignedUrl: DataExchangeClientTypes.ExportAssetToSignedUrlRequestDetails?
        /// Details about the export to Amazon S3 request.
        public var exportAssetsToS3: DataExchangeClientTypes.ExportAssetsToS3RequestDetails?
        /// Details about the export to Amazon S3 request.
        public var exportRevisionsToS3: DataExchangeClientTypes.ExportRevisionsToS3RequestDetails?
        /// Information about the import asset from API Gateway API request.
        public var importAssetFromApiGatewayApi: DataExchangeClientTypes.ImportAssetFromApiGatewayApiRequestDetails?
        /// Details about the import from signed URL request.
        public var importAssetFromSignedUrl: DataExchangeClientTypes.ImportAssetFromSignedUrlRequestDetails?
        /// Details from an import from Amazon Redshift datashare request.
        public var importAssetsFromRedshiftDataShares: DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesRequestDetails?
        /// Details about the import from Amazon S3 request.
        public var importAssetsFromS3: DataExchangeClientTypes.ImportAssetsFromS3RequestDetails?

        public init (
            exportAssetToSignedUrl: DataExchangeClientTypes.ExportAssetToSignedUrlRequestDetails? = nil,
            exportAssetsToS3: DataExchangeClientTypes.ExportAssetsToS3RequestDetails? = nil,
            exportRevisionsToS3: DataExchangeClientTypes.ExportRevisionsToS3RequestDetails? = nil,
            importAssetFromApiGatewayApi: DataExchangeClientTypes.ImportAssetFromApiGatewayApiRequestDetails? = nil,
            importAssetFromSignedUrl: DataExchangeClientTypes.ImportAssetFromSignedUrlRequestDetails? = nil,
            importAssetsFromRedshiftDataShares: DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesRequestDetails? = nil,
            importAssetsFromS3: DataExchangeClientTypes.ImportAssetsFromS3RequestDetails? = nil
        )
        {
            self.exportAssetToSignedUrl = exportAssetToSignedUrl
            self.exportAssetsToS3 = exportAssetsToS3
            self.exportRevisionsToS3 = exportRevisionsToS3
            self.importAssetFromApiGatewayApi = importAssetFromApiGatewayApi
            self.importAssetFromSignedUrl = importAssetFromSignedUrl
            self.importAssetsFromRedshiftDataShares = importAssetsFromRedshiftDataShares
            self.importAssetsFromS3 = importAssetsFromS3
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource couldn't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The resource couldn't be found.
    /// This member is required.
    public var message: Swift.String?
    /// The unique identifier for the resource that couldn't be found.
    public var resourceId: Swift.String?
    /// The type of resource that couldn't be found.
    public var resourceType: DataExchangeClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: DataExchangeClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: DataExchangeClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension DataExchangeClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asset
        case dataSet
        case eventAction
        case job
        case revision
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .asset,
                .dataSet,
                .eventAction,
                .job,
                .revision,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case .dataSet: return "DATA_SET"
            case .eventAction: return "EVENT_ACTION"
            case .job: return "JOB"
            case .revision: return "REVISION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.ResponseDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportAssetToSignedUrl = "ExportAssetToSignedUrl"
        case exportAssetsToS3 = "ExportAssetsToS3"
        case exportRevisionsToS3 = "ExportRevisionsToS3"
        case importAssetFromApiGatewayApi = "ImportAssetFromApiGatewayApi"
        case importAssetFromSignedUrl = "ImportAssetFromSignedUrl"
        case importAssetsFromRedshiftDataShares = "ImportAssetsFromRedshiftDataShares"
        case importAssetsFromS3 = "ImportAssetsFromS3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportAssetToSignedUrl = exportAssetToSignedUrl {
            try encodeContainer.encode(exportAssetToSignedUrl, forKey: .exportAssetToSignedUrl)
        }
        if let exportAssetsToS3 = exportAssetsToS3 {
            try encodeContainer.encode(exportAssetsToS3, forKey: .exportAssetsToS3)
        }
        if let exportRevisionsToS3 = exportRevisionsToS3 {
            try encodeContainer.encode(exportRevisionsToS3, forKey: .exportRevisionsToS3)
        }
        if let importAssetFromApiGatewayApi = importAssetFromApiGatewayApi {
            try encodeContainer.encode(importAssetFromApiGatewayApi, forKey: .importAssetFromApiGatewayApi)
        }
        if let importAssetFromSignedUrl = importAssetFromSignedUrl {
            try encodeContainer.encode(importAssetFromSignedUrl, forKey: .importAssetFromSignedUrl)
        }
        if let importAssetsFromRedshiftDataShares = importAssetsFromRedshiftDataShares {
            try encodeContainer.encode(importAssetsFromRedshiftDataShares, forKey: .importAssetsFromRedshiftDataShares)
        }
        if let importAssetsFromS3 = importAssetsFromS3 {
            try encodeContainer.encode(importAssetsFromS3, forKey: .importAssetsFromS3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportAssetToSignedUrlDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportAssetToSignedUrlResponseDetails.self, forKey: .exportAssetToSignedUrl)
        exportAssetToSignedUrl = exportAssetToSignedUrlDecoded
        let exportAssetsToS3Decoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportAssetsToS3ResponseDetails.self, forKey: .exportAssetsToS3)
        exportAssetsToS3 = exportAssetsToS3Decoded
        let exportRevisionsToS3Decoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportRevisionsToS3ResponseDetails.self, forKey: .exportRevisionsToS3)
        exportRevisionsToS3 = exportRevisionsToS3Decoded
        let importAssetFromSignedUrlDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetFromSignedUrlResponseDetails.self, forKey: .importAssetFromSignedUrl)
        importAssetFromSignedUrl = importAssetFromSignedUrlDecoded
        let importAssetsFromS3Decoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetsFromS3ResponseDetails.self, forKey: .importAssetsFromS3)
        importAssetsFromS3 = importAssetsFromS3Decoded
        let importAssetsFromRedshiftDataSharesDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesResponseDetails.self, forKey: .importAssetsFromRedshiftDataShares)
        importAssetsFromRedshiftDataShares = importAssetsFromRedshiftDataSharesDecoded
        let importAssetFromApiGatewayApiDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetFromApiGatewayApiResponseDetails.self, forKey: .importAssetFromApiGatewayApi)
        importAssetFromApiGatewayApi = importAssetFromApiGatewayApiDecoded
    }
}

extension DataExchangeClientTypes.ResponseDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResponseDetails(exportAssetToSignedUrl: \(Swift.String(describing: exportAssetToSignedUrl)), exportAssetsToS3: \(Swift.String(describing: exportAssetsToS3)), exportRevisionsToS3: \(Swift.String(describing: exportRevisionsToS3)), importAssetFromApiGatewayApi: \(Swift.String(describing: importAssetFromApiGatewayApi)), importAssetFromSignedUrl: \(Swift.String(describing: importAssetFromSignedUrl)), importAssetsFromRedshiftDataShares: \(Swift.String(describing: importAssetsFromRedshiftDataShares)), importAssetsFromS3: \(Swift.String(describing: importAssetsFromS3)))"}
}

extension DataExchangeClientTypes {
    /// Details for the response.
    public struct ResponseDetails: Swift.Equatable {
        /// Details for the export to signed URL response.
        public var exportAssetToSignedUrl: DataExchangeClientTypes.ExportAssetToSignedUrlResponseDetails?
        /// Details for the export to Amazon S3 response.
        public var exportAssetsToS3: DataExchangeClientTypes.ExportAssetsToS3ResponseDetails?
        /// Details for the export revisions to Amazon S3 response.
        public var exportRevisionsToS3: DataExchangeClientTypes.ExportRevisionsToS3ResponseDetails?
        /// The response details.
        public var importAssetFromApiGatewayApi: DataExchangeClientTypes.ImportAssetFromApiGatewayApiResponseDetails?
        /// Details for the import from signed URL response.
        public var importAssetFromSignedUrl: DataExchangeClientTypes.ImportAssetFromSignedUrlResponseDetails?
        /// Details from an import from Amazon Redshift datashare response.
        public var importAssetsFromRedshiftDataShares: DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesResponseDetails?
        /// Details for the import from Amazon S3 response.
        public var importAssetsFromS3: DataExchangeClientTypes.ImportAssetsFromS3ResponseDetails?

        public init (
            exportAssetToSignedUrl: DataExchangeClientTypes.ExportAssetToSignedUrlResponseDetails? = nil,
            exportAssetsToS3: DataExchangeClientTypes.ExportAssetsToS3ResponseDetails? = nil,
            exportRevisionsToS3: DataExchangeClientTypes.ExportRevisionsToS3ResponseDetails? = nil,
            importAssetFromApiGatewayApi: DataExchangeClientTypes.ImportAssetFromApiGatewayApiResponseDetails? = nil,
            importAssetFromSignedUrl: DataExchangeClientTypes.ImportAssetFromSignedUrlResponseDetails? = nil,
            importAssetsFromRedshiftDataShares: DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesResponseDetails? = nil,
            importAssetsFromS3: DataExchangeClientTypes.ImportAssetsFromS3ResponseDetails? = nil
        )
        {
            self.exportAssetToSignedUrl = exportAssetToSignedUrl
            self.exportAssetsToS3 = exportAssetsToS3
            self.exportRevisionsToS3 = exportRevisionsToS3
            self.importAssetFromApiGatewayApi = importAssetFromApiGatewayApi
            self.importAssetFromSignedUrl = importAssetFromSignedUrl
            self.importAssetsFromRedshiftDataShares = importAssetsFromRedshiftDataShares
            self.importAssetsFromS3 = importAssetsFromS3
        }
    }

}

extension DataExchangeClientTypes.RevisionDestinationEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case keyPattern = "KeyPattern"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPattern = keyPattern {
            try encodeContainer.encode(keyPattern, forKey: .keyPattern)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPattern)
        keyPattern = keyPatternDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes.RevisionDestinationEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevisionDestinationEntry(bucket: \(Swift.String(describing: bucket)), keyPattern: \(Swift.String(describing: keyPattern)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension DataExchangeClientTypes {
    /// The destination where the assets in the revision will be exported.
    public struct RevisionDestinationEntry: Swift.Equatable {
        /// The S3 bucket that is the destination for the assets in the revision.
        /// This member is required.
        public var bucket: Swift.String?
        /// A string representing the pattern for generated names of the individual assets in the revision. For more information about key patterns, see [Key patterns when exporting revisions](https://docs.aws.amazon.com/data-exchange/latest/userguide/jobs.html#revision-export-keypatterns).
        public var keyPattern: Swift.String?
        /// The unique identifier for the revision.
        /// This member is required.
        public var revisionId: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            keyPattern: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.keyPattern = keyPattern
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.RevisionEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case comment = "Comment"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case finalized = "Finalized"
        case id = "Id"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let finalized = finalized {
            try encodeContainer.encode(finalized, forKey: .finalized)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let sourceId = sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataExchangeClientTypes.RevisionEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevisionEntry(arn: \(Swift.String(describing: arn)), comment: \(Swift.String(describing: comment)), createdAt: \(Swift.String(describing: createdAt)), dataSetId: \(Swift.String(describing: dataSetId)), finalized: \(Swift.String(describing: finalized)), id: \(Swift.String(describing: id)), sourceId: \(Swift.String(describing: sourceId)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension DataExchangeClientTypes {
    /// A revision is a container for one or more assets.
    public struct RevisionEntry: Swift.Equatable {
        /// The ARN for the revision.
        /// This member is required.
        public var arn: Swift.String?
        /// An optional comment about the revision.
        public var comment: Swift.String?
        /// The date and time that the revision was created, in ISO 8601 format.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The unique identifier for the data set associated with this revision.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products. Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.
        public var finalized: Swift.Bool?
        /// The unique identifier for the revision.
        /// This member is required.
        public var id: Swift.String?
        /// The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.
        public var sourceId: Swift.String?
        /// The date and time that the revision was last updated, in ISO 8601 format.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            comment: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            dataSetId: Swift.String? = nil,
            finalized: Swift.Bool? = nil,
            id: Swift.String? = nil,
            sourceId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.comment = comment
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.finalized = finalized
            self.id = id
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }
    }

}

extension DataExchangeClientTypes.RevisionPublished: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetId = "DataSetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
    }
}

extension DataExchangeClientTypes.RevisionPublished: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevisionPublished(dataSetId: \(Swift.String(describing: dataSetId)))"}
}

extension DataExchangeClientTypes {
    /// Information about the published revision.
    public struct RevisionPublished: Swift.Equatable {
        /// The data set ID of the published revision.
        /// This member is required.
        public var dataSetId: Swift.String?

        public init (
            dataSetId: Swift.String? = nil
        )
        {
            self.dataSetId = dataSetId
        }
    }

}

extension DataExchangeClientTypes.S3SnapshotAsset: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .size)
        size = sizeDecoded
    }
}

extension DataExchangeClientTypes.S3SnapshotAsset: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3SnapshotAsset(size: \(Swift.String(describing: size)))"}
}

extension DataExchangeClientTypes {
    /// The S3 object that is the asset.
    public struct S3SnapshotAsset: Swift.Equatable {
        /// The size of the S3 object that is the object.
        /// This member is required.
        public var size: Swift.Double?

        public init (
            size: Swift.Double? = nil
        )
        {
            self.size = size
        }
    }

}

public struct SendApiAssetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendApiAssetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendApiAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendApiAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let bodydata = body.data(using: .utf8)
            let bodybody = ClientRuntime.HttpBody.data(bodydata)
            input.builder.withBody(bodybody)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendApiAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendApiAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendApiAssetOutputError>
}

extension SendApiAssetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendApiAssetInput(assetId: \(Swift.String(describing: assetId)), body: \(Swift.String(describing: body)), dataSetId: \(Swift.String(describing: dataSetId)), method: \(Swift.String(describing: method)), path: \(Swift.String(describing: path)), queryStringParameters: \(Swift.String(describing: queryStringParameters)), requestHeaders: \(Swift.String(describing: requestHeaders)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension SendApiAssetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
    }
}

public struct SendApiAssetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendApiAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendApiAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendApiAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let assetId = input.operationInput.assetId {
            input.builder.withHeader(name: "x-amzn-dataexchange-asset-id", value: Swift.String(assetId))
        }
        if let dataSetId = input.operationInput.dataSetId {
            input.builder.withHeader(name: "x-amzn-dataexchange-data-set-id", value: Swift.String(dataSetId))
        }
        if let method = input.operationInput.method {
            input.builder.withHeader(name: "x-amzn-dataexchange-http-method", value: Swift.String(method))
        }
        if let path = input.operationInput.path {
            input.builder.withHeader(name: "x-amzn-dataexchange-path", value: Swift.String(path))
        }
        if let revisionId = input.operationInput.revisionId {
            input.builder.withHeader(name: "x-amzn-dataexchange-revision-id", value: Swift.String(revisionId))
        }
        if let requestHeaders = input.operationInput.requestHeaders {
            for (prefixHeaderMapKey, prefixHeaderMapValue) in requestHeaders {
                input.builder.withHeader(name: "x-amzn-dataexchange-header-\(prefixHeaderMapKey)", value: Swift.String(prefixHeaderMapValue))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendApiAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendApiAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendApiAssetOutputError>
}

public struct SendApiAssetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendApiAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendApiAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendApiAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let queryStringParameters = input.operationInput.queryStringParameters {
            let currentQueryItemNames = input.builder.currentQueryItems.map({$0.name})
            queryStringParameters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    let queryItem = ClientRuntime.URLQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                    input.builder.withQueryItem(queryItem)
                }
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendApiAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendApiAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendApiAssetOutputError>
}

public struct SendApiAssetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendApiAssetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: SendApiAssetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendApiAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "api-fulfill.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendApiAssetInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendApiAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendApiAssetOutputError>
}

public struct SendApiAssetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendApiAssetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: SendApiAssetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendApiAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendApiAssetInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendApiAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendApiAssetOutputError>
}

/// The request body for SendApiAsset.
public struct SendApiAssetInput: Swift.Equatable {
    /// Asset ID value for the API request.
    /// This member is required.
    public var assetId: Swift.String?
    /// The request body.
    public var body: Swift.String?
    /// Data set ID value for the API request.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// HTTP method value for the API request. Alternatively, you can use the appropriate verb in your request.
    public var method: Swift.String?
    /// URI path value for the API request. Alternatively, you can set the URI path directly by invoking /v1/{pathValue}
    public var path: Swift.String?
    /// Attach query string parameters to the end of the URI (for example, /v1/examplePath?exampleParam=exampleValue).
    public var queryStringParameters: [Swift.String:Swift.String]?
    /// Any header value prefixed with x-amzn-dataexchange-header- will have that stripped before sending the Asset API request. Use this when you want to override a header that AWS Data Exchange uses. Alternatively, you can use the header without a prefix to the HTTP request.
    public var requestHeaders: [Swift.String:Swift.String]?
    /// Revision ID value for the API request.
    /// This member is required.
    public var revisionId: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        body: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        method: Swift.String? = nil,
        path: Swift.String? = nil,
        queryStringParameters: [Swift.String:Swift.String]? = nil,
        requestHeaders: [Swift.String:Swift.String]? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.body = body
        self.dataSetId = dataSetId
        self.method = method
        self.path = path
        self.queryStringParameters = queryStringParameters
        self.requestHeaders = requestHeaders
        self.revisionId = revisionId
    }
}

struct SendApiAssetInputBody: Swift.Equatable {
    public let body: Swift.String?
}

extension SendApiAssetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
    }
}

extension SendApiAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendApiAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendApiAssetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendApiAssetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendApiAssetOutputResponse(body: \(Swift.String(describing: body)), responseHeaders: \(Swift.String(describing: responseHeaders)))"}
}

extension SendApiAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let keysForResponseHeaders = httpResponse.headers.dictionary.keys
        if (!keysForResponseHeaders.isEmpty) {
            var mapMember = [Swift.String: String]()
            for headerKey in keysForResponseHeaders {
                let mapMemberValue = httpResponse.headers.dictionary[headerKey]?[0]
                mapMember[headerKey] = mapMemberValue
            }
            self.responseHeaders = mapMember
        } else {
            self.responseHeaders = [:]
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let output = Swift.String(data: data, encoding: .utf8) {
                self.body = output
            } else {
                self.body = nil
            }
        } else {
            self.body = nil
        }
    }
}

public struct SendApiAssetOutputResponse: Swift.Equatable {
    /// The response body from the underlying API tracked by the API asset.
    public var body: Swift.String?
    /// The response headers from the underlying API tracked by the API asset.
    public var responseHeaders: [Swift.String:Swift.String]?

    public init (
        body: Swift.String? = nil,
        responseHeaders: [Swift.String:Swift.String]? = nil
    )
    {
        self.body = body
        self.responseHeaders = responseHeaders
    }
}

struct SendApiAssetOutputResponseBody: Swift.Equatable {
    public let body: Swift.String?
}

extension SendApiAssetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
    }
}

extension DataExchangeClientTypes {
    /// The types of encryption supported in export jobs to Amazon S3.
    public enum ServerSideEncryptionTypes: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes256
        case awsKms
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerSideEncryptionTypes] {
            return [
                .aes256,
                .awsKms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes256: return "AES256"
            case .awsKms: return "aws:kms"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerSideEncryptionTypes(rawValue: rawValue) ?? ServerSideEncryptionTypes.sdkUnknown(rawValue)
        }
    }
}

extension ServiceLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceLimitExceededException(limitName: \(Swift.String(describing: limitName)), limitValue: \(Swift.String(describing: limitValue)), message: \(Swift.String(describing: message)))"}
}

extension ServiceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limitName = output.limitName
            self.limitValue = output.limitValue
            self.message = output.message
        } else {
            self.limitName = nil
            self.limitValue = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has exceeded the quotas imposed by the service.
public struct ServiceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The name of the quota that was exceeded.
    public var limitName: DataExchangeClientTypes.LimitName?
    /// The maximum value for the service-specific limit.
    public var limitValue: Swift.Double?
    /// The request has exceeded the quotas imposed by the service.
    /// This member is required.
    public var message: Swift.String?

    public init (
        limitName: DataExchangeClientTypes.LimitName? = nil,
        limitValue: Swift.Double? = nil,
        message: Swift.String? = nil
    )
    {
        self.limitName = limitName
        self.limitValue = limitValue
        self.message = message
    }
}

struct ServiceLimitExceededExceptionBody: Swift.Equatable {
    public let limitName: DataExchangeClientTypes.LimitName?
    public let limitValue: Swift.Double?
    public let message: Swift.String?
}

extension ServiceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitName = "LimitName"
        case limitValue = "LimitValue"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitNameDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.LimitName.self, forKey: .limitName)
        limitName = limitNameDecoded
        let limitValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .limitValue)
        limitValue = limitValueDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartJobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension StartJobInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct StartJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartJobOutputError>
}

public struct StartJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartJobOutputError>
}

public struct StartJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartJobOutputError>
}

public struct StartJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let jobId = input.jobId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("jobId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/jobs/\(jobId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartJobOutputError>
}

public struct StartJobInput: Swift.Equatable {
    /// The unique identifier for a job.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartJobInputBody: Swift.Equatable {
}

extension StartJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StartJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartJobOutputResponse()"}
}

extension StartJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct StartJobOutputResponseBody: Swift.Equatable {
}

extension StartJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DataExchangeClientTypes {
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case error
        case inProgress
        case timedOut
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .cancelled,
                .completed,
                .error,
                .inProgress,
                .timedOut,
                .waiting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case .timedOut: return "TIMED_OUT"
            case .waiting: return "WAITING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

/// The request body for TagResource.
public struct TagResourceInput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies an AWS resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A label that consists of a customer-defined key and an optional value.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit on the number of requests per second was exceeded.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The limit on the number of requests per second was exceeded.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataExchangeClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case exportAssetsToS3
        case exportAssetToSignedUrl
        case exportRevisionsToS3
        case importAssetsFromRedshiftDataShares
        case importAssetsFromS3
        case importAssetFromApiGatewayApi
        case importAssetFromSignedUrl
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .exportAssetsToS3,
                .exportAssetToSignedUrl,
                .exportRevisionsToS3,
                .importAssetsFromRedshiftDataShares,
                .importAssetsFromS3,
                .importAssetFromApiGatewayApi,
                .importAssetFromSignedUrl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .exportAssetsToS3: return "EXPORT_ASSETS_TO_S3"
            case .exportAssetToSignedUrl: return "EXPORT_ASSET_TO_SIGNED_URL"
            case .exportRevisionsToS3: return "EXPORT_REVISIONS_TO_S3"
            case .importAssetsFromRedshiftDataShares: return "IMPORT_ASSETS_FROM_REDSHIFT_DATA_SHARES"
            case .importAssetsFromS3: return "IMPORT_ASSETS_FROM_S3"
            case .importAssetFromApiGatewayApi: return "IMPORT_ASSET_FROM_API_GATEWAY_API"
            case .importAssetFromSignedUrl: return "IMPORT_ASSET_FROM_SIGNED_URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies an AWS resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key tags.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateAssetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetOutputError>
}

extension UpdateAssetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssetInput(assetId: \(Swift.String(describing: assetId)), dataSetId: \(Swift.String(describing: dataSetId)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension UpdateAssetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAssetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetOutputError>
}

public struct UpdateAssetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetOutputError>
}

public struct UpdateAssetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateAssetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAssetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetOutputError>
}

public struct UpdateAssetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateAssetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let dataSetId = input.dataSetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dataSetId is nil and needs a value for the path of this operation"))))
        }
        guard let revisionId = input.revisionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("revisionId is nil and needs a value for the path of this operation"))))
        }
        guard let assetId = input.assetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions/\(revisionId.urlPercentEncoding())/assets/\(assetId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAssetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetOutputError>
}

/// The request body for UpdateAsset.
public struct UpdateAssetInput: Swift.Equatable {
    /// The unique identifier for an asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The name of the asset. When importing from Amazon S3, the S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target S3 object key. When importing from Amazon API Gateway API, the API name is used as the asset name. When importing from Amazon Redshift, the datashare name is used as the asset name.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifier for a revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.dataSetId = dataSetId
        self.name = name
        self.revisionId = revisionId
    }
}

struct UpdateAssetInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension UpdateAssetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssetOutputResponse(arn: \(Swift.String(describing: arn)), assetDetails: \(Swift.String(describing: assetDetails)), assetType: \(Swift.String(describing: assetType)), createdAt: \(Swift.String(describing: createdAt)), dataSetId: \(Swift.String(describing: dataSetId)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), sourceId: \(Swift.String(describing: sourceId)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension UpdateAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAssetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.assetDetails = output.assetDetails
            self.assetType = output.assetType
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.id = output.id
            self.name = output.name
            self.revisionId = output.revisionId
            self.sourceId = output.sourceId
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.assetDetails = nil
            self.assetType = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.id = nil
            self.name = nil
            self.revisionId = nil
            self.sourceId = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateAssetOutputResponse: Swift.Equatable {
    /// The ARN for the asset.
    public var arn: Swift.String?
    /// Information about the asset.
    public var assetDetails: DataExchangeClientTypes.AssetDetails?
    /// The type of asset that is added to a data set.
    public var assetType: DataExchangeClientTypes.AssetType?
    /// The date and time that the asset was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The unique identifier for the data set associated with this asset.
    public var dataSetId: Swift.String?
    /// The unique identifier for the asset.
    public var id: Swift.String?
    /// The name of the asset. When importing from Amazon S3, the S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target S3 object key. When importing from Amazon API Gateway API, the API name is used as the asset name. When importing from Amazon Redshift, the datashare name is used as the asset name.
    public var name: Swift.String?
    /// The unique identifier for the revision associated with this asset.
    public var revisionId: Swift.String?
    /// The asset ID of the owned asset corresponding to the entitled asset being viewed. This parameter is returned when an asset owner is viewing the entitled copy of its owned asset.
    public var sourceId: Swift.String?
    /// The date and time that the asset was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        assetDetails: DataExchangeClientTypes.AssetDetails? = nil,
        assetType: DataExchangeClientTypes.AssetType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        dataSetId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        sourceId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.assetDetails = assetDetails
        self.assetType = assetType
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.id = id
        self.name = name
        self.revisionId = revisionId
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

struct UpdateAssetOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let assetDetails: DataExchangeClientTypes.AssetDetails?
    public let assetType: DataExchangeClientTypes.AssetType?
    public let createdAt: ClientRuntime.Date?
    public let dataSetId: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let revisionId: Swift.String?
    public let sourceId: Swift.String?
    public let updatedAt: ClientRuntime.Date?
}

extension UpdateAssetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assetDetails = "AssetDetails"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case id = "Id"
        case name = "Name"
        case revisionId = "RevisionId"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let assetDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetDetails.self, forKey: .assetDetails)
        assetDetails = assetDetailsDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

public struct UpdateDataSetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDataSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDataSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDataSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDataSetOutputError>
}

extension UpdateDataSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataSetInput(dataSetId: \(Swift.String(describing: dataSetId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)))"}
}

extension UpdateDataSetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateDataSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDataSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDataSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDataSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDataSetOutputError>
}

public struct UpdateDataSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDataSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDataSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDataSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDataSetOutputError>
}

public struct UpdateDataSetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDataSetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateDataSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDataSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDataSetOutputError>
}

public struct UpdateDataSetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDataSetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateDataSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let dataSetId = input.dataSetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dataSetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/data-sets/\(dataSetId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDataSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDataSetOutputError>
}

/// The request body for UpdateDataSet.
public struct UpdateDataSetInput: Swift.Equatable {
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The description for the data set.
    public var description: Swift.String?
    /// The name of the data set.
    public var name: Swift.String?

    public init (
        dataSetId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.description = description
        self.name = name
    }
}

struct UpdateDataSetInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let name: Swift.String?
}

extension UpdateDataSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateDataSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataSetOutputResponse(arn: \(Swift.String(describing: arn)), assetType: \(Swift.String(describing: assetType)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), origin: \(Swift.String(describing: origin)), originDetails: \(Swift.String(describing: originDetails)), sourceId: \(Swift.String(describing: sourceId)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension UpdateDataSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDataSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.assetType = output.assetType
            self.createdAt = output.createdAt
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.origin = output.origin
            self.originDetails = output.originDetails
            self.sourceId = output.sourceId
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.assetType = nil
            self.createdAt = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.origin = nil
            self.originDetails = nil
            self.sourceId = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateDataSetOutputResponse: Swift.Equatable {
    /// The ARN for the data set.
    public var arn: Swift.String?
    /// The type of asset that is added to a data set.
    public var assetType: DataExchangeClientTypes.AssetType?
    /// The date and time that the data set was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The description for the data set.
    public var description: Swift.String?
    /// The unique identifier for the data set.
    public var id: Swift.String?
    /// The name of the data set.
    public var name: Swift.String?
    /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
    public var origin: DataExchangeClientTypes.Origin?
    /// If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.
    public var originDetails: DataExchangeClientTypes.OriginDetails?
    /// The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.
    public var sourceId: Swift.String?
    /// The date and time that the data set was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        assetType: DataExchangeClientTypes.AssetType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        origin: DataExchangeClientTypes.Origin? = nil,
        originDetails: DataExchangeClientTypes.OriginDetails? = nil,
        sourceId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.assetType = assetType
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
        self.origin = origin
        self.originDetails = originDetails
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

struct UpdateDataSetOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let assetType: DataExchangeClientTypes.AssetType?
    public let createdAt: ClientRuntime.Date?
    public let description: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let origin: DataExchangeClientTypes.Origin?
    public let originDetails: DataExchangeClientTypes.OriginDetails?
    public let sourceId: Swift.String?
    public let updatedAt: ClientRuntime.Date?
}

extension UpdateDataSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case origin = "Origin"
        case originDetails = "OriginDetails"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let originDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Origin.self, forKey: .origin)
        origin = originDecoded
        let originDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.OriginDetails.self, forKey: .originDetails)
        originDetails = originDetailsDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

public struct UpdateEventActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEventActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEventActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEventActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEventActionOutputError>
}

extension UpdateEventActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEventActionInput(action: \(Swift.String(describing: action)), eventActionId: \(Swift.String(describing: eventActionId)))"}
}

extension UpdateEventActionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
    }
}

public struct UpdateEventActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEventActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEventActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEventActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEventActionOutputError>
}

public struct UpdateEventActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEventActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEventActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEventActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEventActionOutputError>
}

public struct UpdateEventActionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEventActionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateEventActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEventActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEventActionOutputError>
}

public struct UpdateEventActionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEventActionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateEventActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEventActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let eventActionId = input.eventActionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("eventActionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/event-actions/\(eventActionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEventActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEventActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEventActionOutputError>
}

/// The request body for UpdateEventAction.
public struct UpdateEventActionInput: Swift.Equatable {
    /// What occurs after a certain event.
    public var action: DataExchangeClientTypes.Action?
    /// The unique identifier for the event action.
    /// This member is required.
    public var eventActionId: Swift.String?

    public init (
        action: DataExchangeClientTypes.Action? = nil,
        eventActionId: Swift.String? = nil
    )
    {
        self.action = action
        self.eventActionId = eventActionId
    }
}

struct UpdateEventActionInputBody: Swift.Equatable {
    public let action: DataExchangeClientTypes.Action?
}

extension UpdateEventActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Action.self, forKey: .action)
        action = actionDecoded
    }
}

extension UpdateEventActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEventActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEventActionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEventActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEventActionOutputResponse(action: \(Swift.String(describing: action)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), event: \(Swift.String(describing: event)), id: \(Swift.String(describing: id)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension UpdateEventActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateEventActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.event = output.event
            self.id = output.id
            self.updatedAt = output.updatedAt
        } else {
            self.action = nil
            self.arn = nil
            self.createdAt = nil
            self.event = nil
            self.id = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateEventActionOutputResponse: Swift.Equatable {
    /// What occurs after a certain event.
    public var action: DataExchangeClientTypes.Action?
    /// The ARN for the event action.
    public var arn: Swift.String?
    /// The date and time that the event action was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// What occurs to start an action.
    public var event: DataExchangeClientTypes.Event?
    /// The unique identifier for the event action.
    public var id: Swift.String?
    /// The date and time that the event action was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init (
        action: DataExchangeClientTypes.Action? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        event: DataExchangeClientTypes.Event? = nil,
        id: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.createdAt = createdAt
        self.event = event
        self.id = id
        self.updatedAt = updatedAt
    }
}

struct UpdateEventActionOutputResponseBody: Swift.Equatable {
    public let action: DataExchangeClientTypes.Action?
    public let arn: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let event: DataExchangeClientTypes.Event?
    public let id: Swift.String?
    public let updatedAt: ClientRuntime.Date?
}

extension UpdateEventActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case event = "Event"
        case id = "Id"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let eventDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

public struct UpdateRevisionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRevisionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRevisionOutputError>
}

extension UpdateRevisionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRevisionInput(comment: \(Swift.String(describing: comment)), dataSetId: \(Swift.String(describing: dataSetId)), finalized: \(Swift.String(describing: finalized)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension UpdateRevisionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case finalized = "Finalized"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let finalized = finalized {
            try encodeContainer.encode(finalized, forKey: .finalized)
        }
    }
}

public struct UpdateRevisionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRevisionOutputError>
}

public struct UpdateRevisionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRevisionOutputError>
}

public struct UpdateRevisionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRevisionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateRevisionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRevisionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRevisionOutputError>
}

public struct UpdateRevisionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRevisionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateRevisionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let dataSetId = input.dataSetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dataSetId is nil and needs a value for the path of this operation"))))
        }
        guard let revisionId = input.revisionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("revisionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions/\(revisionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRevisionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRevisionOutputError>
}

/// The request body for UpdateRevision.
public struct UpdateRevisionInput: Swift.Equatable {
    /// An optional comment about the revision.
    public var comment: Swift.String?
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products.
    public var finalized: Swift.Bool?
    /// The unique identifier for a revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init (
        comment: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        finalized: Swift.Bool? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.comment = comment
        self.dataSetId = dataSetId
        self.finalized = finalized
        self.revisionId = revisionId
    }
}

struct UpdateRevisionInputBody: Swift.Equatable {
    public let comment: Swift.String?
    public let finalized: Swift.Bool?
}

extension UpdateRevisionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case finalized = "Finalized"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
    }
}

extension UpdateRevisionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRevisionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRevisionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRevisionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRevisionOutputResponse(arn: \(Swift.String(describing: arn)), comment: \(Swift.String(describing: comment)), createdAt: \(Swift.String(describing: createdAt)), dataSetId: \(Swift.String(describing: dataSetId)), finalized: \(Swift.String(describing: finalized)), id: \(Swift.String(describing: id)), sourceId: \(Swift.String(describing: sourceId)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension UpdateRevisionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRevisionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.comment = output.comment
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.finalized = output.finalized
            self.id = output.id
            self.sourceId = output.sourceId
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.comment = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.finalized = nil
            self.id = nil
            self.sourceId = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateRevisionOutputResponse: Swift.Equatable {
    /// The ARN for the revision.
    public var arn: Swift.String?
    /// An optional comment about the revision.
    public var comment: Swift.String?
    /// The date and time that the revision was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The unique identifier for the data set associated with this revision.
    public var dataSetId: Swift.String?
    /// To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products. Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.
    public var finalized: Swift.Bool?
    /// The unique identifier for the revision.
    public var id: Swift.String?
    /// The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.
    public var sourceId: Swift.String?
    /// The date and time that the revision was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        comment: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        dataSetId: Swift.String? = nil,
        finalized: Swift.Bool? = nil,
        id: Swift.String? = nil,
        sourceId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.comment = comment
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.finalized = finalized
        self.id = id
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

struct UpdateRevisionOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let comment: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let dataSetId: Swift.String?
    public let finalized: Swift.Bool?
    public let id: Swift.String?
    public let sourceId: Swift.String?
    public let updatedAt: ClientRuntime.Date?
}

extension UpdateRevisionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case comment = "Comment"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case finalized = "Finalized"
        case id = "Id"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(exceptionCause: \(Swift.String(describing: exceptionCause)), message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.exceptionCause = output.exceptionCause
            self.message = output.message
        } else {
            self.exceptionCause = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was invalid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message that informs you about what the exception was.
    public var exceptionCause: DataExchangeClientTypes.ExceptionCause?
    /// The message that informs you about what was invalid about the request.
    /// This member is required.
    public var message: Swift.String?

    public init (
        exceptionCause: DataExchangeClientTypes.ExceptionCause? = nil,
        message: Swift.String? = nil
    )
    {
        self.exceptionCause = exceptionCause
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let exceptionCause: DataExchangeClientTypes.ExceptionCause?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionCause = "ExceptionCause"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let exceptionCauseDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExceptionCause.self, forKey: .exceptionCause)
        exceptionCause = exceptionCauseDecoded
    }
}
