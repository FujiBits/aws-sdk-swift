// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension DeviceFarmClientTypes.AccountSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountNumber
        case defaultJobTimeoutMinutes
        case maxJobTimeoutMinutes
        case maxSlots
        case skipAppResign
        case trialMinutes
        case unmeteredDevices
        case unmeteredRemoteAccessDevices
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountNumber = awsAccountNumber {
            try encodeContainer.encode(awsAccountNumber, forKey: .awsAccountNumber)
        }
        if let defaultJobTimeoutMinutes = defaultJobTimeoutMinutes {
            try encodeContainer.encode(defaultJobTimeoutMinutes, forKey: .defaultJobTimeoutMinutes)
        }
        if let maxJobTimeoutMinutes = maxJobTimeoutMinutes {
            try encodeContainer.encode(maxJobTimeoutMinutes, forKey: .maxJobTimeoutMinutes)
        }
        if let maxSlots = maxSlots {
            var maxSlotsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .maxSlots)
            for (dictKey0, maxslotmap0) in maxSlots {
                try maxSlotsContainer.encode(maxslotmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let skipAppResign = skipAppResign {
            try encodeContainer.encode(skipAppResign, forKey: .skipAppResign)
        }
        if let trialMinutes = trialMinutes {
            try encodeContainer.encode(trialMinutes, forKey: .trialMinutes)
        }
        if let unmeteredDevices = unmeteredDevices {
            var unmeteredDevicesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .unmeteredDevices)
            for (dictKey0, purchaseddevicesmap0) in unmeteredDevices {
                try unmeteredDevicesContainer.encode(purchaseddevicesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevices {
            var unmeteredRemoteAccessDevicesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .unmeteredRemoteAccessDevices)
            for (dictKey0, purchaseddevicesmap0) in unmeteredRemoteAccessDevices {
                try unmeteredRemoteAccessDevicesContainer.encode(purchaseddevicesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountNumber)
        awsAccountNumber = awsAccountNumberDecoded
        let unmeteredDevicesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .unmeteredDevices)
        var unmeteredDevicesDecoded0: [Swift.String:Swift.Int]? = nil
        if let unmeteredDevicesContainer = unmeteredDevicesContainer {
            unmeteredDevicesDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integer0) in unmeteredDevicesContainer {
                if let integer0 = integer0 {
                    unmeteredDevicesDecoded0?[key0] = integer0
                }
            }
        }
        unmeteredDevices = unmeteredDevicesDecoded0
        let unmeteredRemoteAccessDevicesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .unmeteredRemoteAccessDevices)
        var unmeteredRemoteAccessDevicesDecoded0: [Swift.String:Swift.Int]? = nil
        if let unmeteredRemoteAccessDevicesContainer = unmeteredRemoteAccessDevicesContainer {
            unmeteredRemoteAccessDevicesDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integer0) in unmeteredRemoteAccessDevicesContainer {
                if let integer0 = integer0 {
                    unmeteredRemoteAccessDevicesDecoded0?[key0] = integer0
                }
            }
        }
        unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevicesDecoded0
        let maxJobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxJobTimeoutMinutes)
        maxJobTimeoutMinutes = maxJobTimeoutMinutesDecoded
        let trialMinutesDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TrialMinutes.self, forKey: .trialMinutes)
        trialMinutes = trialMinutesDecoded
        let maxSlotsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .maxSlots)
        var maxSlotsDecoded0: [Swift.String:Swift.Int]? = nil
        if let maxSlotsContainer = maxSlotsContainer {
            maxSlotsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integer0) in maxSlotsContainer {
                if let integer0 = integer0 {
                    maxSlotsDecoded0?[key0] = integer0
                }
            }
        }
        maxSlots = maxSlotsDecoded0
        let defaultJobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultJobTimeoutMinutes)
        defaultJobTimeoutMinutes = defaultJobTimeoutMinutesDecoded
        let skipAppResignDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .skipAppResign)
        skipAppResign = skipAppResignDecoded
    }
}

extension DeviceFarmClientTypes.AccountSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountSettings(awsAccountNumber: \(Swift.String(describing: awsAccountNumber)), defaultJobTimeoutMinutes: \(Swift.String(describing: defaultJobTimeoutMinutes)), maxJobTimeoutMinutes: \(Swift.String(describing: maxJobTimeoutMinutes)), maxSlots: \(Swift.String(describing: maxSlots)), skipAppResign: \(Swift.String(describing: skipAppResign)), trialMinutes: \(Swift.String(describing: trialMinutes)), unmeteredDevices: \(Swift.String(describing: unmeteredDevices)), unmeteredRemoteAccessDevices: \(Swift.String(describing: unmeteredRemoteAccessDevices)))"}
}

extension DeviceFarmClientTypes {
    /// A container for account-level settings in AWS Device Farm.
    public struct AccountSettings: Swift.Equatable {
        /// The AWS account number specified in the AccountSettings
        ///             container.
        public var awsAccountNumber: Swift.String?
        /// The default number of minutes (at the account level) a test run executes before it times out. The
        ///             default value is 150 minutes.
        public var defaultJobTimeoutMinutes: Swift.Int?
        /// The maximum number of minutes a test run executes before it times out.
        public var maxJobTimeoutMinutes: Swift.Int?
        /// The maximum number of device slots that the AWS account can purchase. Each maximum
        ///             is expressed as an offering-id:number pair, where the
        ///                 offering-id represents one of the IDs returned by the
        ///                 ListOfferings command.
        public var maxSlots: [Swift.String:Swift.Int]?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public
        ///             devices, Device Farm always signs your apps again.
        ///         For more information about how Device Farm re-signs your apps, see <a href="https://aws.amazon.com/device-farm/faq/">Do you modify my app? in the AWS Device
        ///                 Farm FAQs.
        public var skipAppResign: Swift.Bool?
        /// Information about an AWS account's usage of free trial device minutes.
        public var trialMinutes: DeviceFarmClientTypes.TrialMinutes?
        /// Returns the unmetered devices you have purchased or want to purchase.
        public var unmeteredDevices: [Swift.String:Swift.Int]?
        /// Returns the unmetered remote access devices you have purchased or want to
        ///             purchase.
        public var unmeteredRemoteAccessDevices: [Swift.String:Swift.Int]?

        public init (
            awsAccountNumber: Swift.String? = nil,
            defaultJobTimeoutMinutes: Swift.Int? = nil,
            maxJobTimeoutMinutes: Swift.Int? = nil,
            maxSlots: [Swift.String:Swift.Int]? = nil,
            skipAppResign: Swift.Bool? = nil,
            trialMinutes: DeviceFarmClientTypes.TrialMinutes? = nil,
            unmeteredDevices: [Swift.String:Swift.Int]? = nil,
            unmeteredRemoteAccessDevices: [Swift.String:Swift.Int]? = nil
        )
        {
            self.awsAccountNumber = awsAccountNumber
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.maxJobTimeoutMinutes = maxJobTimeoutMinutes
            self.maxSlots = maxSlots
            self.skipAppResign = skipAppResign
            self.trialMinutes = trialMinutes
            self.unmeteredDevices = unmeteredDevices
            self.unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevices
        }
    }

}

extension ArgumentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ArgumentException(message: \(Swift.String(describing: message)))"}
}

extension ArgumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An invalid argument was specified.
public struct ArgumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any additional information about the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ArgumentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeviceFarmClientTypes.Artifact: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case `extension` = "extension"
        case name
        case type
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let `extension` = `extension` {
            try encodeContainer.encode(`extension`, forKey: .`extension`)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ArtifactType.self, forKey: .type)
        type = typeDecoded
        let extensionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extension)
        `extension` = extensionDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension DeviceFarmClientTypes.Artifact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Artifact(arn: \(Swift.String(describing: arn)), extension: \(Swift.String(describing: `extension`)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)), url: \(Swift.String(describing: url)))"}
}

extension DeviceFarmClientTypes {
    /// Represents the output of a test. Examples of artifacts include logs and
    ///             screenshots.
    public struct Artifact: Swift.Equatable {
        /// The artifact's file extension.
        public var `extension`: Swift.String?
        /// The artifact's ARN.
        public var arn: Swift.String?
        /// The artifact's name.
        public var name: Swift.String?
        /// The artifact's type.
        ///         Allowed values include the following:
        ///
        ///
        ///                 UNKNOWN
        ///
        ///
        ///                 SCREENSHOT
        ///
        ///
        ///                 DEVICE_LOG
        ///
        ///
        ///                 MESSAGE_LOG
        ///
        ///
        ///                 VIDEO_LOG
        ///
        ///
        ///                 RESULT_LOG
        ///
        ///
        ///                 SERVICE_LOG
        ///
        ///
        ///                 WEBKIT_LOG
        ///
        ///
        ///                 INSTRUMENTATION_OUTPUT
        ///
        ///
        ///                 EXERCISER_MONKEY_OUTPUT: the artifact (log) generated by an Android fuzz test.
        ///
        ///
        ///                 CALABASH_JSON_OUTPUT
        ///
        ///
        ///                 CALABASH_PRETTY_OUTPUT
        ///
        ///
        ///                 CALABASH_STANDARD_OUTPUT
        ///
        ///
        ///                 CALABASH_JAVA_XML_OUTPUT
        ///
        ///
        ///                 AUTOMATION_OUTPUT
        ///
        ///
        ///                 APPIUM_SERVER_OUTPUT
        ///
        ///
        ///                 APPIUM_JAVA_OUTPUT
        ///
        ///
        ///                 APPIUM_JAVA_XML_OUTPUT
        ///
        ///
        ///                 APPIUM_PYTHON_OUTPUT
        ///
        ///
        ///                 APPIUM_PYTHON_XML_OUTPUT
        ///
        ///
        ///                 EXPLORER_EVENT_LOG
        ///
        ///
        ///                 EXPLORER_SUMMARY_LOG
        ///
        ///
        ///                 APPLICATION_CRASH_REPORT
        ///
        ///
        ///                 XCTEST_LOG
        ///
        ///
        ///                 VIDEO
        ///
        ///
        ///                 CUSTOMER_ARTIFACT
        ///
        ///
        ///                 CUSTOMER_ARTIFACT_LOG
        ///
        ///
        ///                 TESTSPEC_OUTPUT
        ///
        ///
        public var type: DeviceFarmClientTypes.ArtifactType?
        /// The presigned Amazon S3 URL that can be used with a GET request to download the artifact's
        ///             file.
        public var url: Swift.String?

        public init (
            `extension`: Swift.String? = nil,
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            type: DeviceFarmClientTypes.ArtifactType? = nil,
            url: Swift.String? = nil
        )
        {
            self.`extension` = `extension`
            self.arn = arn
            self.name = name
            self.type = type
            self.url = url
        }
    }

}

extension DeviceFarmClientTypes {
    public enum ArtifactCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case file
        case log
        case screenshot
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactCategory] {
            return [
                .file,
                .log,
                .screenshot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .file: return "FILE"
            case .log: return "LOG"
            case .screenshot: return "SCREENSHOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactCategory(rawValue: rawValue) ?? ArtifactCategory.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum ArtifactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appiumJavaOutput
        case appiumJavaXmlOutput
        case appiumPythonOutput
        case appiumPythonXmlOutput
        case appiumServerOutput
        case applicationCrashReport
        case automationOutput
        case calabashJavaXmlOutput
        case calabashJsonOutput
        case calabashPrettyOutput
        case calabashStandardOutput
        case customerArtifact
        case customerArtifactLog
        case deviceLog
        case exerciserMonkeyOutput
        case explorerEventLog
        case explorerSummaryLog
        case instrumentationOutput
        case messageLog
        case resultLog
        case screenshot
        case serviceLog
        case testspecOutput
        case unknown
        case video
        case videoLog
        case webkitLog
        case xctestLog
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactType] {
            return [
                .appiumJavaOutput,
                .appiumJavaXmlOutput,
                .appiumPythonOutput,
                .appiumPythonXmlOutput,
                .appiumServerOutput,
                .applicationCrashReport,
                .automationOutput,
                .calabashJavaXmlOutput,
                .calabashJsonOutput,
                .calabashPrettyOutput,
                .calabashStandardOutput,
                .customerArtifact,
                .customerArtifactLog,
                .deviceLog,
                .exerciserMonkeyOutput,
                .explorerEventLog,
                .explorerSummaryLog,
                .instrumentationOutput,
                .messageLog,
                .resultLog,
                .screenshot,
                .serviceLog,
                .testspecOutput,
                .unknown,
                .video,
                .videoLog,
                .webkitLog,
                .xctestLog,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appiumJavaOutput: return "APPIUM_JAVA_OUTPUT"
            case .appiumJavaXmlOutput: return "APPIUM_JAVA_XML_OUTPUT"
            case .appiumPythonOutput: return "APPIUM_PYTHON_OUTPUT"
            case .appiumPythonXmlOutput: return "APPIUM_PYTHON_XML_OUTPUT"
            case .appiumServerOutput: return "APPIUM_SERVER_OUTPUT"
            case .applicationCrashReport: return "APPLICATION_CRASH_REPORT"
            case .automationOutput: return "AUTOMATION_OUTPUT"
            case .calabashJavaXmlOutput: return "CALABASH_JAVA_XML_OUTPUT"
            case .calabashJsonOutput: return "CALABASH_JSON_OUTPUT"
            case .calabashPrettyOutput: return "CALABASH_PRETTY_OUTPUT"
            case .calabashStandardOutput: return "CALABASH_STANDARD_OUTPUT"
            case .customerArtifact: return "CUSTOMER_ARTIFACT"
            case .customerArtifactLog: return "CUSTOMER_ARTIFACT_LOG"
            case .deviceLog: return "DEVICE_LOG"
            case .exerciserMonkeyOutput: return "EXERCISER_MONKEY_OUTPUT"
            case .explorerEventLog: return "EXPLORER_EVENT_LOG"
            case .explorerSummaryLog: return "EXPLORER_SUMMARY_LOG"
            case .instrumentationOutput: return "INSTRUMENTATION_OUTPUT"
            case .messageLog: return "MESSAGE_LOG"
            case .resultLog: return "RESULT_LOG"
            case .screenshot: return "SCREENSHOT"
            case .serviceLog: return "SERVICE_LOG"
            case .testspecOutput: return "TESTSPEC_OUTPUT"
            case .unknown: return "UNKNOWN"
            case .video: return "VIDEO"
            case .videoLog: return "VIDEO_LOG"
            case .webkitLog: return "WEBKIT_LOG"
            case .xctestLog: return "XCTEST_LOG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactType(rawValue: rawValue) ?? ArtifactType.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum BillingMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case metered
        case unmetered
        case sdkUnknown(Swift.String)

        public static var allCases: [BillingMethod] {
            return [
                .metered,
                .unmetered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .metered: return "METERED"
            case .unmetered: return "UNMETERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BillingMethod(rawValue: rawValue) ?? BillingMethod.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.CPU: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case clock
        case frequency
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = architecture {
            try encodeContainer.encode(architecture, forKey: .architecture)
        }
        if let clock = clock {
            try encodeContainer.encode(clock, forKey: .clock)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frequency)
        frequency = frequencyDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecture)
        architecture = architectureDecoded
        let clockDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .clock)
        clock = clockDecoded
    }
}

extension DeviceFarmClientTypes.CPU: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CPU(architecture: \(Swift.String(describing: architecture)), clock: \(Swift.String(describing: clock)), frequency: \(Swift.String(describing: frequency)))"}
}

extension DeviceFarmClientTypes {
    /// Represents the amount of CPU that an app is using on a physical device. Does not represent system-wide
    ///             CPU usage.
    public struct CPU: Swift.Equatable {
        /// The CPU's architecture (for example, x86 or ARM).
        public var architecture: Swift.String?
        /// The clock speed of the device's CPU, expressed in hertz (Hz). For example, a 1.2
        ///             GHz CPU is expressed as 1200000000.
        public var clock: Swift.Double?
        /// The CPU's frequency.
        public var frequency: Swift.String?

        public init (
            architecture: Swift.String? = nil,
            clock: Swift.Double? = nil,
            frequency: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.clock = clock
            self.frequency = frequency
        }
    }

}

extension CannotDeleteException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CannotDeleteException(message: \(Swift.String(describing: message)))"}
}

extension CannotDeleteException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CannotDeleteExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested object could not be deleted.
public struct CannotDeleteException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CannotDeleteExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CannotDeleteExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeviceFarmClientTypes.Counters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errored
        case failed
        case passed
        case skipped
        case stopped
        case total
        case warned
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errored = errored {
            try encodeContainer.encode(errored, forKey: .errored)
        }
        if let failed = failed {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if let passed = passed {
            try encodeContainer.encode(passed, forKey: .passed)
        }
        if let skipped = skipped {
            try encodeContainer.encode(skipped, forKey: .skipped)
        }
        if let stopped = stopped {
            try encodeContainer.encode(stopped, forKey: .stopped)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let warned = warned {
            try encodeContainer.encode(warned, forKey: .warned)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .total)
        total = totalDecoded
        let passedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .passed)
        passed = passedDecoded
        let failedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failed)
        failed = failedDecoded
        let warnedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .warned)
        warned = warnedDecoded
        let erroredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errored)
        errored = erroredDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stopped)
        stopped = stoppedDecoded
        let skippedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .skipped)
        skipped = skippedDecoded
    }
}

extension DeviceFarmClientTypes.Counters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Counters(errored: \(Swift.String(describing: errored)), failed: \(Swift.String(describing: failed)), passed: \(Swift.String(describing: passed)), skipped: \(Swift.String(describing: skipped)), stopped: \(Swift.String(describing: stopped)), total: \(Swift.String(describing: total)), warned: \(Swift.String(describing: warned)))"}
}

extension DeviceFarmClientTypes {
    /// Represents entity counters.
    public struct Counters: Swift.Equatable {
        /// The number of errored entities.
        public var errored: Swift.Int?
        /// The number of failed entities.
        public var failed: Swift.Int?
        /// The number of passed entities.
        public var passed: Swift.Int?
        /// The number of skipped entities.
        public var skipped: Swift.Int?
        /// The number of stopped entities.
        public var stopped: Swift.Int?
        /// The total number of entities.
        public var total: Swift.Int?
        /// The number of warned entities.
        public var warned: Swift.Int?

        public init (
            errored: Swift.Int? = nil,
            failed: Swift.Int? = nil,
            passed: Swift.Int? = nil,
            skipped: Swift.Int? = nil,
            stopped: Swift.Int? = nil,
            total: Swift.Int? = nil,
            warned: Swift.Int? = nil
        )
        {
            self.errored = errored
            self.failed = failed
            self.passed = passed
            self.skipped = skipped
            self.stopped = stopped
            self.total = total
            self.warned = warned
        }
    }

}

public struct CreateDevicePoolInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDevicePoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDevicePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDevicePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDevicePoolOutputError>
}

extension CreateDevicePoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDevicePoolInput(description: \(Swift.String(describing: description)), maxDevices: \(Swift.String(describing: maxDevices)), name: \(Swift.String(describing: name)), projectArn: \(Swift.String(describing: projectArn)), rules: \(Swift.String(describing: rules)))"}
}

extension CreateDevicePoolInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case maxDevices
        case name
        case projectArn
        case rules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let maxDevices = maxDevices {
            try encodeContainer.encode(maxDevices, forKey: .maxDevices)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rules0 in rules {
                try rulesContainer.encode(rules0)
            }
        }
    }
}

public struct CreateDevicePoolInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDevicePoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDevicePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDevicePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDevicePoolOutputError>
}

public struct CreateDevicePoolInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDevicePoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDevicePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDevicePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDevicePoolOutputError>
}

public struct CreateDevicePoolInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDevicePoolInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateDevicePoolInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDevicePoolInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDevicePoolOutputError>
}

public struct CreateDevicePoolInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDevicePoolInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateDevicePoolInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDevicePoolInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDevicePoolOutputError>
}

/// Represents a request to the create device pool operation.
public struct CreateDevicePoolInput: Swift.Equatable {
    /// The device pool's description.
    public var description: Swift.String?
    /// The number of devices that Device Farm can add to your device pool. Device Farm adds devices that are
    ///             available and meet the criteria that you assign for the rules parameter. Depending on how many
    ///             devices meet these constraints, your device pool might contain fewer devices than the value for this
    ///             parameter.
    ///         By specifying the maximum number of devices, you can control the costs that you incur
    ///             by running tests.
    public var maxDevices: Swift.Int?
    /// The device pool's name.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the project for the device pool.
    /// This member is required.
    public var projectArn: Swift.String?
    /// The device pool's rules.
    /// This member is required.
    public var rules: [DeviceFarmClientTypes.Rule]?

    public init (
        description: Swift.String? = nil,
        maxDevices: Swift.Int? = nil,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        rules: [DeviceFarmClientTypes.Rule]? = nil
    )
    {
        self.description = description
        self.maxDevices = maxDevices
        self.name = name
        self.projectArn = projectArn
        self.rules = rules
    }
}

struct CreateDevicePoolInputBody: Swift.Equatable {
    public let projectArn: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let rules: [DeviceFarmClientTypes.Rule]?
    public let maxDevices: Swift.Int?
}

extension CreateDevicePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case maxDevices
        case name
        case projectArn
        case rules
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[DeviceFarmClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [DeviceFarmClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let maxDevicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDevices)
        maxDevices = maxDevicesDecoded
    }
}

extension CreateDevicePoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDevicePoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDevicePoolOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDevicePoolOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDevicePoolOutputResponse(devicePool: \(Swift.String(describing: devicePool)))"}
}

extension CreateDevicePoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDevicePoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devicePool = output.devicePool
        } else {
            self.devicePool = nil
        }
    }
}

/// Represents the result of a create device pool request.
public struct CreateDevicePoolOutputResponse: Swift.Equatable {
    /// The newly created device pool.
    public var devicePool: DeviceFarmClientTypes.DevicePool?

    public init (
        devicePool: DeviceFarmClientTypes.DevicePool? = nil
    )
    {
        self.devicePool = devicePool
    }
}

struct CreateDevicePoolOutputResponseBody: Swift.Equatable {
    public let devicePool: DeviceFarmClientTypes.DevicePool?
}

extension CreateDevicePoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePool
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePoolDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePool.self, forKey: .devicePool)
        devicePool = devicePoolDecoded
    }
}

public struct CreateInstanceProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInstanceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInstanceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInstanceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInstanceProfileOutputError>
}

extension CreateInstanceProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInstanceProfileInput(description: \(Swift.String(describing: description)), excludeAppPackagesFromCleanup: \(Swift.String(describing: excludeAppPackagesFromCleanup)), name: \(Swift.String(describing: name)), packageCleanup: \(Swift.String(describing: packageCleanup)), rebootAfterUse: \(Swift.String(describing: rebootAfterUse)))"}
}

extension CreateInstanceProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case excludeAppPackagesFromCleanup
        case name
        case packageCleanup
        case rebootAfterUse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup {
            var excludeAppPackagesFromCleanupContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeAppPackagesFromCleanup)
            for packageids0 in excludeAppPackagesFromCleanup {
                try excludeAppPackagesFromCleanupContainer.encode(packageids0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageCleanup = packageCleanup {
            try encodeContainer.encode(packageCleanup, forKey: .packageCleanup)
        }
        if let rebootAfterUse = rebootAfterUse {
            try encodeContainer.encode(rebootAfterUse, forKey: .rebootAfterUse)
        }
    }
}

public struct CreateInstanceProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInstanceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInstanceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInstanceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInstanceProfileOutputError>
}

public struct CreateInstanceProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInstanceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInstanceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInstanceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInstanceProfileOutputError>
}

public struct CreateInstanceProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInstanceProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateInstanceProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateInstanceProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInstanceProfileOutputError>
}

public struct CreateInstanceProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInstanceProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateInstanceProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateInstanceProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInstanceProfileOutputError>
}

public struct CreateInstanceProfileInput: Swift.Equatable {
    /// The description of your instance profile.
    public var description: Swift.String?
    /// An array of strings that specifies the list of app packages that should not be cleaned up from the device
    ///             after a test run.
    ///         The list of packages is considered only if you set packageCleanup to
    ///             true.
    public var excludeAppPackagesFromCleanup: [Swift.String]?
    /// The name of your instance profile.
    /// This member is required.
    public var name: Swift.String?
    /// When set to true, Device Farm removes app packages after a test run. The default value is
    ///                 false for private devices.
    public var packageCleanup: Swift.Bool?
    /// When set to true, Device Farm reboots the instance after a test run. The default value is
    ///                 true.
    public var rebootAfterUse: Swift.Bool?

    public init (
        description: Swift.String? = nil,
        excludeAppPackagesFromCleanup: [Swift.String]? = nil,
        name: Swift.String? = nil,
        packageCleanup: Swift.Bool? = nil,
        rebootAfterUse: Swift.Bool? = nil
    )
    {
        self.description = description
        self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
        self.name = name
        self.packageCleanup = packageCleanup
        self.rebootAfterUse = rebootAfterUse
    }
}

struct CreateInstanceProfileInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let packageCleanup: Swift.Bool?
    public let excludeAppPackagesFromCleanup: [Swift.String]?
    public let rebootAfterUse: Swift.Bool?
}

extension CreateInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case excludeAppPackagesFromCleanup
        case name
        case packageCleanup
        case rebootAfterUse
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let packageCleanupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .packageCleanup)
        packageCleanup = packageCleanupDecoded
        let excludeAppPackagesFromCleanupContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeAppPackagesFromCleanup)
        var excludeAppPackagesFromCleanupDecoded0:[Swift.String]? = nil
        if let excludeAppPackagesFromCleanupContainer = excludeAppPackagesFromCleanupContainer {
            excludeAppPackagesFromCleanupDecoded0 = [Swift.String]()
            for string0 in excludeAppPackagesFromCleanupContainer {
                if let string0 = string0 {
                    excludeAppPackagesFromCleanupDecoded0?.append(string0)
                }
            }
        }
        excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanupDecoded0
        let rebootAfterUseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rebootAfterUse)
        rebootAfterUse = rebootAfterUseDecoded
    }
}

extension CreateInstanceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInstanceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInstanceProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInstanceProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInstanceProfileOutputResponse(instanceProfile: \(Swift.String(describing: instanceProfile)))"}
}

extension CreateInstanceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateInstanceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

public struct CreateInstanceProfileOutputResponse: Swift.Equatable {
    /// An object that contains information about your instance profile.
    public var instanceProfile: DeviceFarmClientTypes.InstanceProfile?

    public init (
        instanceProfile: DeviceFarmClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct CreateInstanceProfileOutputResponseBody: Swift.Equatable {
    public let instanceProfile: DeviceFarmClientTypes.InstanceProfile?
}

extension CreateInstanceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

public struct CreateNetworkProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNetworkProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateNetworkProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateNetworkProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNetworkProfileOutputError>
}

extension CreateNetworkProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkProfileInput(description: \(Swift.String(describing: description)), downlinkBandwidthBits: \(Swift.String(describing: downlinkBandwidthBits)), downlinkDelayMs: \(Swift.String(describing: downlinkDelayMs)), downlinkJitterMs: \(Swift.String(describing: downlinkJitterMs)), downlinkLossPercent: \(Swift.String(describing: downlinkLossPercent)), name: \(Swift.String(describing: name)), projectArn: \(Swift.String(describing: projectArn)), type: \(Swift.String(describing: type)), uplinkBandwidthBits: \(Swift.String(describing: uplinkBandwidthBits)), uplinkDelayMs: \(Swift.String(describing: uplinkDelayMs)), uplinkJitterMs: \(Swift.String(describing: uplinkJitterMs)), uplinkLossPercent: \(Swift.String(describing: uplinkLossPercent)))"}
}

extension CreateNetworkProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case downlinkBandwidthBits
        case downlinkDelayMs
        case downlinkJitterMs
        case downlinkLossPercent
        case name
        case projectArn
        case type
        case uplinkBandwidthBits
        case uplinkDelayMs
        case uplinkJitterMs
        case uplinkLossPercent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let downlinkBandwidthBits = downlinkBandwidthBits {
            try encodeContainer.encode(downlinkBandwidthBits, forKey: .downlinkBandwidthBits)
        }
        if let downlinkDelayMs = downlinkDelayMs {
            try encodeContainer.encode(downlinkDelayMs, forKey: .downlinkDelayMs)
        }
        if let downlinkJitterMs = downlinkJitterMs {
            try encodeContainer.encode(downlinkJitterMs, forKey: .downlinkJitterMs)
        }
        if downlinkLossPercent != 0 {
            try encodeContainer.encode(downlinkLossPercent, forKey: .downlinkLossPercent)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uplinkBandwidthBits = uplinkBandwidthBits {
            try encodeContainer.encode(uplinkBandwidthBits, forKey: .uplinkBandwidthBits)
        }
        if let uplinkDelayMs = uplinkDelayMs {
            try encodeContainer.encode(uplinkDelayMs, forKey: .uplinkDelayMs)
        }
        if let uplinkJitterMs = uplinkJitterMs {
            try encodeContainer.encode(uplinkJitterMs, forKey: .uplinkJitterMs)
        }
        if uplinkLossPercent != 0 {
            try encodeContainer.encode(uplinkLossPercent, forKey: .uplinkLossPercent)
        }
    }
}

public struct CreateNetworkProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNetworkProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateNetworkProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateNetworkProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNetworkProfileOutputError>
}

public struct CreateNetworkProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNetworkProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateNetworkProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateNetworkProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNetworkProfileOutputError>
}

public struct CreateNetworkProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNetworkProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateNetworkProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateNetworkProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNetworkProfileOutputError>
}

public struct CreateNetworkProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNetworkProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateNetworkProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateNetworkProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNetworkProfileOutputError>
}

public struct CreateNetworkProfileInput: Swift.Equatable {
    /// The description of the network profile.
    public var description: Swift.String?
    /// The data throughput rate in bits per second, as an integer from 0 to
    ///             104857600.
    public var downlinkBandwidthBits: Swift.Int?
    /// Delay time for all packets to destination in milliseconds as an integer from 0 to
    ///             2000.
    public var downlinkDelayMs: Swift.Int?
    /// Time variation in the delay of received packets in milliseconds as an integer from
    ///             0 to 2000.
    public var downlinkJitterMs: Swift.Int?
    /// Proportion of received packets that fail to arrive from 0 to 100 percent.
    public var downlinkLossPercent: Swift.Int
    /// The name for the new network profile.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the project for which you want to create a
    ///             network profile.
    /// This member is required.
    public var projectArn: Swift.String?
    /// The type of network profile to create. Valid values are listed here.
    public var type: DeviceFarmClientTypes.NetworkProfileType?
    /// The data throughput rate in bits per second, as an integer from 0 to
    ///             104857600.
    public var uplinkBandwidthBits: Swift.Int?
    /// Delay time for all packets to destination in milliseconds as an integer from 0 to
    ///             2000.
    public var uplinkDelayMs: Swift.Int?
    /// Time variation in the delay of received packets in milliseconds as an integer from
    ///             0 to 2000.
    public var uplinkJitterMs: Swift.Int?
    /// Proportion of transmitted packets that fail to arrive from 0 to 100
    ///             percent.
    public var uplinkLossPercent: Swift.Int

    public init (
        description: Swift.String? = nil,
        downlinkBandwidthBits: Swift.Int? = nil,
        downlinkDelayMs: Swift.Int? = nil,
        downlinkJitterMs: Swift.Int? = nil,
        downlinkLossPercent: Swift.Int = 0,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        type: DeviceFarmClientTypes.NetworkProfileType? = nil,
        uplinkBandwidthBits: Swift.Int? = nil,
        uplinkDelayMs: Swift.Int? = nil,
        uplinkJitterMs: Swift.Int? = nil,
        uplinkLossPercent: Swift.Int = 0
    )
    {
        self.description = description
        self.downlinkBandwidthBits = downlinkBandwidthBits
        self.downlinkDelayMs = downlinkDelayMs
        self.downlinkJitterMs = downlinkJitterMs
        self.downlinkLossPercent = downlinkLossPercent
        self.name = name
        self.projectArn = projectArn
        self.type = type
        self.uplinkBandwidthBits = uplinkBandwidthBits
        self.uplinkDelayMs = uplinkDelayMs
        self.uplinkJitterMs = uplinkJitterMs
        self.uplinkLossPercent = uplinkLossPercent
    }
}

struct CreateNetworkProfileInputBody: Swift.Equatable {
    public let projectArn: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let type: DeviceFarmClientTypes.NetworkProfileType?
    public let uplinkBandwidthBits: Swift.Int?
    public let downlinkBandwidthBits: Swift.Int?
    public let uplinkDelayMs: Swift.Int?
    public let downlinkDelayMs: Swift.Int?
    public let uplinkJitterMs: Swift.Int?
    public let downlinkJitterMs: Swift.Int?
    public let uplinkLossPercent: Swift.Int
    public let downlinkLossPercent: Swift.Int
}

extension CreateNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case downlinkBandwidthBits
        case downlinkDelayMs
        case downlinkJitterMs
        case downlinkLossPercent
        case name
        case projectArn
        case type
        case uplinkBandwidthBits
        case uplinkDelayMs
        case uplinkJitterMs
        case uplinkLossPercent
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfileType.self, forKey: .type)
        type = typeDecoded
        let uplinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkBandwidthBits)
        uplinkBandwidthBits = uplinkBandwidthBitsDecoded
        let downlinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkBandwidthBits)
        downlinkBandwidthBits = downlinkBandwidthBitsDecoded
        let uplinkDelayMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkDelayMs)
        uplinkDelayMs = uplinkDelayMsDecoded
        let downlinkDelayMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkDelayMs)
        downlinkDelayMs = downlinkDelayMsDecoded
        let uplinkJitterMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkJitterMs)
        uplinkJitterMs = uplinkJitterMsDecoded
        let downlinkJitterMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkJitterMs)
        downlinkJitterMs = downlinkJitterMsDecoded
        let uplinkLossPercentDecoded = try containerValues.decode(Swift.Int.self, forKey: .uplinkLossPercent)
        uplinkLossPercent = uplinkLossPercentDecoded
        let downlinkLossPercentDecoded = try containerValues.decode(Swift.Int.self, forKey: .downlinkLossPercent)
        downlinkLossPercent = downlinkLossPercentDecoded
    }
}

extension CreateNetworkProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNetworkProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNetworkProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNetworkProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkProfileOutputResponse(networkProfile: \(Swift.String(describing: networkProfile)))"}
}

extension CreateNetworkProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateNetworkProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkProfile = output.networkProfile
        } else {
            self.networkProfile = nil
        }
    }
}

public struct CreateNetworkProfileOutputResponse: Swift.Equatable {
    /// The network profile that is returned by the create network profile
    ///             request.
    public var networkProfile: DeviceFarmClientTypes.NetworkProfile?

    public init (
        networkProfile: DeviceFarmClientTypes.NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

struct CreateNetworkProfileOutputResponseBody: Swift.Equatable {
    public let networkProfile: DeviceFarmClientTypes.NetworkProfile?
}

extension CreateNetworkProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfile.self, forKey: .networkProfile)
        networkProfile = networkProfileDecoded
    }
}

public struct CreateProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

extension CreateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectInput(defaultJobTimeoutMinutes: \(Swift.String(describing: defaultJobTimeoutMinutes)), name: \(Swift.String(describing: name)))"}
}

extension CreateProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultJobTimeoutMinutes
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultJobTimeoutMinutes = defaultJobTimeoutMinutes {
            try encodeContainer.encode(defaultJobTimeoutMinutes, forKey: .defaultJobTimeoutMinutes)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

/// Represents a request to the create project operation.
public struct CreateProjectInput: Swift.Equatable {
    /// Sets the execution timeout value (in minutes) for a project. All test runs in this project use the
    ///             specified execution timeout value unless overridden when scheduling a run.
    public var defaultJobTimeoutMinutes: Swift.Int?
    /// The project's name.
    /// This member is required.
    public var name: Swift.String?

    public init (
        defaultJobTimeoutMinutes: Swift.Int? = nil,
        name: Swift.String? = nil
    )
    {
        self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
        self.name = name
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let defaultJobTimeoutMinutes: Swift.Int?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultJobTimeoutMinutes
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultJobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultJobTimeoutMinutes)
        defaultJobTimeoutMinutes = defaultJobTimeoutMinutesDecoded
    }
}

extension CreateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOperationException" : self = .tagOperationException(try TagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case tagOperationException(TagOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectOutputResponse(project: \(Swift.String(describing: project)))"}
}

extension CreateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

/// Represents the result of a create project request.
public struct CreateProjectOutputResponse: Swift.Equatable {
    /// The newly created project.
    public var project: DeviceFarmClientTypes.Project?

    public init (
        project: DeviceFarmClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct CreateProjectOutputResponseBody: Swift.Equatable {
    public let project: DeviceFarmClientTypes.Project?
}

extension CreateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

extension DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingMethod
        case vpceConfigurationArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingMethod = billingMethod {
            try encodeContainer.encode(billingMethod.rawValue, forKey: .billingMethod)
        }
        if let vpceConfigurationArns = vpceConfigurationArns {
            var vpceConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpceConfigurationArns)
            for amazonresourcenames0 in vpceConfigurationArns {
                try vpceConfigurationArnsContainer.encode(amazonresourcenames0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingMethodDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.BillingMethod.self, forKey: .billingMethod)
        billingMethod = billingMethodDecoded
        let vpceConfigurationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpceConfigurationArns)
        var vpceConfigurationArnsDecoded0:[Swift.String]? = nil
        if let vpceConfigurationArnsContainer = vpceConfigurationArnsContainer {
            vpceConfigurationArnsDecoded0 = [Swift.String]()
            for string0 in vpceConfigurationArnsContainer {
                if let string0 = string0 {
                    vpceConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        vpceConfigurationArns = vpceConfigurationArnsDecoded0
    }
}

extension DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRemoteAccessSessionConfiguration(billingMethod: \(Swift.String(describing: billingMethod)), vpceConfigurationArns: \(Swift.String(describing: vpceConfigurationArns)))"}
}

extension DeviceFarmClientTypes {
    /// Configuration settings for a remote access session, including billing
    ///             method.
    public struct CreateRemoteAccessSessionConfiguration: Swift.Equatable {
        /// The billing method for the remote access session.
        public var billingMethod: DeviceFarmClientTypes.BillingMethod?
        /// An array of ARNs included in the VPC endpoint configuration.
        public var vpceConfigurationArns: [Swift.String]?

        public init (
            billingMethod: DeviceFarmClientTypes.BillingMethod? = nil,
            vpceConfigurationArns: [Swift.String]? = nil
        )
        {
            self.billingMethod = billingMethod
            self.vpceConfigurationArns = vpceConfigurationArns
        }
    }

}

public struct CreateRemoteAccessSessionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRemoteAccessSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRemoteAccessSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRemoteAccessSessionOutputError>
}

extension CreateRemoteAccessSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRemoteAccessSessionInput(clientId: \(Swift.String(describing: clientId)), configuration: \(Swift.String(describing: configuration)), deviceArn: \(Swift.String(describing: deviceArn)), instanceArn: \(Swift.String(describing: instanceArn)), interactionMode: \(Swift.String(describing: interactionMode)), name: \(Swift.String(describing: name)), projectArn: \(Swift.String(describing: projectArn)), remoteDebugEnabled: \(Swift.String(describing: remoteDebugEnabled)), remoteRecordAppArn: \(Swift.String(describing: remoteRecordAppArn)), remoteRecordEnabled: \(Swift.String(describing: remoteRecordEnabled)), skipAppResign: \(Swift.String(describing: skipAppResign)), sshPublicKey: \(Swift.String(describing: sshPublicKey)))"}
}

extension CreateRemoteAccessSessionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case configuration
        case deviceArn
        case instanceArn
        case interactionMode
        case name
        case projectArn
        case remoteDebugEnabled
        case remoteRecordAppArn
        case remoteRecordEnabled
        case skipAppResign
        case sshPublicKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let interactionMode = interactionMode {
            try encodeContainer.encode(interactionMode.rawValue, forKey: .interactionMode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let remoteDebugEnabled = remoteDebugEnabled {
            try encodeContainer.encode(remoteDebugEnabled, forKey: .remoteDebugEnabled)
        }
        if let remoteRecordAppArn = remoteRecordAppArn {
            try encodeContainer.encode(remoteRecordAppArn, forKey: .remoteRecordAppArn)
        }
        if let remoteRecordEnabled = remoteRecordEnabled {
            try encodeContainer.encode(remoteRecordEnabled, forKey: .remoteRecordEnabled)
        }
        if let skipAppResign = skipAppResign {
            try encodeContainer.encode(skipAppResign, forKey: .skipAppResign)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
    }
}

public struct CreateRemoteAccessSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRemoteAccessSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRemoteAccessSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRemoteAccessSessionOutputError>
}

public struct CreateRemoteAccessSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRemoteAccessSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRemoteAccessSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRemoteAccessSessionOutputError>
}

public struct CreateRemoteAccessSessionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRemoteAccessSessionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateRemoteAccessSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRemoteAccessSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRemoteAccessSessionOutputError>
}

public struct CreateRemoteAccessSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRemoteAccessSessionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateRemoteAccessSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRemoteAccessSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRemoteAccessSessionOutputError>
}

/// Creates and submits a request to start a remote access session.
public struct CreateRemoteAccessSessionInput: Swift.Equatable {
    /// Unique identifier for the client. If you want access to multiple devices on the same client, you should
    ///             pass the same clientId value in each call to CreateRemoteAccessSession. This
    ///             identifier is required only if remoteDebugEnabled is set to true.
    ///         Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
    ///                 longer supported.
    public var clientId: Swift.String?
    /// The configuration information for the remote access session request.
    public var configuration: DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration?
    /// The ARN of the device for which you want to create a remote access session.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the device instance for which you want to create a
    ///             remote access session.
    public var instanceArn: Swift.String?
    /// The interaction mode of the remote access session. Valid values are:
    ///
    ///
    ///                 INTERACTIVE: You can interact with the iOS device by viewing, touching, and
    ///                     rotating the screen. You cannot run XCUITest framework-based tests in this
    ///                     mode.
    ///
    ///
    ///                 NO_VIDEO: You are connected to the device, but cannot interact with it or view the screen. This
    ///                     mode has the fastest test execution speed. You can run XCUITest framework-based tests in this
    ///                     mode.
    ///
    ///
    ///                 VIDEO_ONLY: You can view the screen, but cannot touch or rotate it. You can run XCUITest
    ///                     framework-based tests and watch the screen in this mode.
    ///
    ///
    public var interactionMode: DeviceFarmClientTypes.InteractionMode?
    /// The name of the remote access session to create.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the project for which you want to create a remote
    ///             access session.
    /// This member is required.
    public var projectArn: Swift.String?
    /// Set to true if you want to access devices remotely for debugging in
    ///             your remote access session.
    ///         Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
    ///                 longer supported.
    public var remoteDebugEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) for the app to be recorded in the remote access
    ///             session.
    public var remoteRecordAppArn: Swift.String?
    /// Set to true to enable remote recording for the remote access
    ///             session.
    public var remoteRecordEnabled: Swift.Bool?
    /// When set to true, for private devices, Device Farm does not sign your app again. For public
    ///             devices, Device Farm always signs your apps again.
    ///         For more information on how Device Farm modifies your uploads during tests, see <a href="https://aws.amazon.com/device-farm/faq/">Do you modify my app?
    ///
    public var skipAppResign: Swift.Bool?
    /// Ignored. The public key of the ssh key pair you want to use for connecting to remote
    ///             devices in your remote debugging session. This key is required only if remoteDebugEnabled is
    ///             set to true.
    ///         Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
    ///                 longer supported.
    public var sshPublicKey: Swift.String?

    public init (
        clientId: Swift.String? = nil,
        configuration: DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration? = nil,
        deviceArn: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        interactionMode: DeviceFarmClientTypes.InteractionMode? = nil,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        remoteDebugEnabled: Swift.Bool? = nil,
        remoteRecordAppArn: Swift.String? = nil,
        remoteRecordEnabled: Swift.Bool? = nil,
        skipAppResign: Swift.Bool? = nil,
        sshPublicKey: Swift.String? = nil
    )
    {
        self.clientId = clientId
        self.configuration = configuration
        self.deviceArn = deviceArn
        self.instanceArn = instanceArn
        self.interactionMode = interactionMode
        self.name = name
        self.projectArn = projectArn
        self.remoteDebugEnabled = remoteDebugEnabled
        self.remoteRecordAppArn = remoteRecordAppArn
        self.remoteRecordEnabled = remoteRecordEnabled
        self.skipAppResign = skipAppResign
        self.sshPublicKey = sshPublicKey
    }
}

struct CreateRemoteAccessSessionInputBody: Swift.Equatable {
    public let projectArn: Swift.String?
    public let deviceArn: Swift.String?
    public let instanceArn: Swift.String?
    public let sshPublicKey: Swift.String?
    public let remoteDebugEnabled: Swift.Bool?
    public let remoteRecordEnabled: Swift.Bool?
    public let remoteRecordAppArn: Swift.String?
    public let name: Swift.String?
    public let clientId: Swift.String?
    public let configuration: DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration?
    public let interactionMode: DeviceFarmClientTypes.InteractionMode?
    public let skipAppResign: Swift.Bool?
}

extension CreateRemoteAccessSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case configuration
        case deviceArn
        case instanceArn
        case interactionMode
        case name
        case projectArn
        case remoteDebugEnabled
        case remoteRecordAppArn
        case remoteRecordEnabled
        case skipAppResign
        case sshPublicKey
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let remoteDebugEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteDebugEnabled)
        remoteDebugEnabled = remoteDebugEnabledDecoded
        let remoteRecordEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteRecordEnabled)
        remoteRecordEnabled = remoteRecordEnabledDecoded
        let remoteRecordAppArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteRecordAppArn)
        remoteRecordAppArn = remoteRecordAppArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let interactionModeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.InteractionMode.self, forKey: .interactionMode)
        interactionMode = interactionModeDecoded
        let skipAppResignDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .skipAppResign)
        skipAppResign = skipAppResignDecoded
    }
}

extension CreateRemoteAccessSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRemoteAccessSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRemoteAccessSessionOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRemoteAccessSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRemoteAccessSessionOutputResponse(remoteAccessSession: \(Swift.String(describing: remoteAccessSession)))"}
}

extension CreateRemoteAccessSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRemoteAccessSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.remoteAccessSession = output.remoteAccessSession
        } else {
            self.remoteAccessSession = nil
        }
    }
}

/// Represents the server response from a request to create a remote access
///             session.
public struct CreateRemoteAccessSessionOutputResponse: Swift.Equatable {
    /// A container that describes the remote access session when the request to create a
    ///             remote access session is sent.
    public var remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession?

    public init (
        remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession? = nil
    )
    {
        self.remoteAccessSession = remoteAccessSession
    }
}

struct CreateRemoteAccessSessionOutputResponseBody: Swift.Equatable {
    public let remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession?
}

extension CreateRemoteAccessSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case remoteAccessSession
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteAccessSessionDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.RemoteAccessSession.self, forKey: .remoteAccessSession)
        remoteAccessSession = remoteAccessSessionDecoded
    }
}

public struct CreateTestGridProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTestGridProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTestGridProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTestGridProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTestGridProjectOutputError>
}

extension CreateTestGridProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTestGridProjectInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension CreateTestGridProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct CreateTestGridProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTestGridProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTestGridProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTestGridProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTestGridProjectOutputError>
}

public struct CreateTestGridProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTestGridProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTestGridProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTestGridProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTestGridProjectOutputError>
}

public struct CreateTestGridProjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTestGridProjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateTestGridProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTestGridProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTestGridProjectOutputError>
}

public struct CreateTestGridProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTestGridProjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateTestGridProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTestGridProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTestGridProjectOutputError>
}

public struct CreateTestGridProjectInput: Swift.Equatable {
    /// Human-readable description of the project.
    public var description: Swift.String?
    /// Human-readable name of the Selenium testing project.
    /// This member is required.
    public var name: Swift.String?
    /// The VPC security groups and subnets that are attached to a project.
    public var vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig? = nil
    )
    {
        self.description = description
        self.name = name
        self.vpcConfig = vpcConfig
    }
}

struct CreateTestGridProjectInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig?
}

extension CreateTestGridProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case vpcConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridVpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension CreateTestGridProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTestGridProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTestGridProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTestGridProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTestGridProjectOutputResponse(testGridProject: \(Swift.String(describing: testGridProject)))"}
}

extension CreateTestGridProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTestGridProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.testGridProject = output.testGridProject
        } else {
            self.testGridProject = nil
        }
    }
}

public struct CreateTestGridProjectOutputResponse: Swift.Equatable {
    /// ARN of the Selenium testing project that was created.
    public var testGridProject: DeviceFarmClientTypes.TestGridProject?

    public init (
        testGridProject: DeviceFarmClientTypes.TestGridProject? = nil
    )
    {
        self.testGridProject = testGridProject
    }
}

struct CreateTestGridProjectOutputResponseBody: Swift.Equatable {
    public let testGridProject: DeviceFarmClientTypes.TestGridProject?
}

extension CreateTestGridProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case testGridProject
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridProjectDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridProject.self, forKey: .testGridProject)
        testGridProject = testGridProjectDecoded
    }
}

public struct CreateTestGridUrlInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTestGridUrlInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTestGridUrlInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTestGridUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTestGridUrlInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTestGridUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTestGridUrlOutputError>
}

extension CreateTestGridUrlInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTestGridUrlInput(expiresInSeconds: \(Swift.String(describing: expiresInSeconds)), projectArn: \(Swift.String(describing: projectArn)))"}
}

extension CreateTestGridUrlInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresInSeconds
        case projectArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiresInSeconds = expiresInSeconds {
            try encodeContainer.encode(expiresInSeconds, forKey: .expiresInSeconds)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
    }
}

public struct CreateTestGridUrlInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTestGridUrlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTestGridUrlInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTestGridUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTestGridUrlInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTestGridUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTestGridUrlOutputError>
}

public struct CreateTestGridUrlInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTestGridUrlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTestGridUrlInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTestGridUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTestGridUrlInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTestGridUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTestGridUrlOutputError>
}

public struct CreateTestGridUrlInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTestGridUrlInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateTestGridUrlInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTestGridUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTestGridUrlInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTestGridUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTestGridUrlOutputError>
}

public struct CreateTestGridUrlInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTestGridUrlInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateTestGridUrlInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTestGridUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTestGridUrlInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTestGridUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTestGridUrlOutputError>
}

public struct CreateTestGridUrlInput: Swift.Equatable {
    /// Lifetime, in seconds, of the URL.
    /// This member is required.
    public var expiresInSeconds: Swift.Int?
    /// ARN (from CreateTestGridProject or ListTestGridProjects) to associate
    ///          with the short-term URL.
    /// This member is required.
    public var projectArn: Swift.String?

    public init (
        expiresInSeconds: Swift.Int? = nil,
        projectArn: Swift.String? = nil
    )
    {
        self.expiresInSeconds = expiresInSeconds
        self.projectArn = projectArn
    }
}

struct CreateTestGridUrlInputBody: Swift.Equatable {
    public let projectArn: Swift.String?
    public let expiresInSeconds: Swift.Int?
}

extension CreateTestGridUrlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresInSeconds
        case projectArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let expiresInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresInSeconds)
        expiresInSeconds = expiresInSecondsDecoded
    }
}

extension CreateTestGridUrlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTestGridUrlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTestGridUrlOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTestGridUrlOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTestGridUrlOutputResponse(expires: \(Swift.String(describing: expires)), url: \(Swift.String(describing: url)))"}
}

extension CreateTestGridUrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTestGridUrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expires = output.expires
            self.url = output.url
        } else {
            self.expires = nil
            self.url = nil
        }
    }
}

public struct CreateTestGridUrlOutputResponse: Swift.Equatable {
    /// The number of seconds the URL from CreateTestGridUrlResult$url stays active.
    public var expires: ClientRuntime.Date?
    /// A signed URL, expiring in CreateTestGridUrlRequest$expiresInSeconds seconds, to be passed
    ///          to a RemoteWebDriver.
    public var url: Swift.String?

    public init (
        expires: ClientRuntime.Date? = nil,
        url: Swift.String? = nil
    )
    {
        self.expires = expires
        self.url = url
    }
}

struct CreateTestGridUrlOutputResponseBody: Swift.Equatable {
    public let url: Swift.String?
    public let expires: ClientRuntime.Date?
}

extension CreateTestGridUrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expires
        case url
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let expiresDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expires)
        expires = expiresDecoded
    }
}

public struct CreateUploadInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUploadOutputError>
}

extension CreateUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUploadInput(contentType: \(Swift.String(describing: contentType)), name: \(Swift.String(describing: name)), projectArn: \(Swift.String(describing: projectArn)), type: \(Swift.String(describing: type)))"}
}

extension CreateUploadInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case name
        case projectArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateUploadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUploadOutputError>
}

public struct CreateUploadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUploadOutputError>
}

public struct CreateUploadInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUploadInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUploadOutputError>
}

public struct CreateUploadInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUploadInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUploadOutputError>
}

/// Represents a request to the create upload operation.
public struct CreateUploadInput: Swift.Equatable {
    /// The upload's content type (for example, application/octet-stream).
    public var contentType: Swift.String?
    /// The upload's file name. The name should not contain any forward slashes (/). If you are
    ///             uploading an iOS app, the file name must end with the .ipa extension. If you are uploading an
    ///             Android app, the file name must end with the .apk extension. For all others, the file name must
    ///             end with the .zip file extension.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the project for the upload.
    /// This member is required.
    public var projectArn: Swift.String?
    /// The upload's upload type.
    ///         Must be one of the following values:
    ///
    ///
    ///                 ANDROID_APP
    ///
    ///
    ///                 IOS_APP
    ///
    ///
    ///                 WEB_APP
    ///
    ///
    ///                 EXTERNAL_DATA
    ///
    ///
    ///                 APPIUM_JAVA_JUNIT_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_JAVA_TESTNG_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_PYTHON_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_NODE_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_RUBY_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_WEB_PYTHON_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_WEB_NODE_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_WEB_RUBY_TEST_PACKAGE
    ///
    ///
    ///                 CALABASH_TEST_PACKAGE
    ///
    ///
    ///                 INSTRUMENTATION_TEST_PACKAGE
    ///
    ///
    ///                 UIAUTOMATION_TEST_PACKAGE
    ///
    ///
    ///                 UIAUTOMATOR_TEST_PACKAGE
    ///
    ///
    ///                 XCTEST_TEST_PACKAGE
    ///
    ///
    ///                 XCTEST_UI_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_JAVA_JUNIT_TEST_SPEC
    ///
    ///
    ///                 APPIUM_JAVA_TESTNG_TEST_SPEC
    ///
    ///
    ///                 APPIUM_PYTHON_TEST_SPEC
    ///
    ///
    ///                 APPIUM_NODE_TEST_SPEC
    ///
    ///
    ///                 APPIUM_RUBY_TEST_SPEC
    ///
    ///
    ///                 APPIUM_WEB_JAVA_JUNIT_TEST_SPEC
    ///
    ///
    ///                 APPIUM_WEB_JAVA_TESTNG_TEST_SPEC
    ///
    ///
    ///                 APPIUM_WEB_PYTHON_TEST_SPEC
    ///
    ///
    ///                 APPIUM_WEB_NODE_TEST_SPEC
    ///
    ///
    ///                 APPIUM_WEB_RUBY_TEST_SPEC
    ///
    ///
    ///                 INSTRUMENTATION_TEST_SPEC
    ///
    ///
    ///                 XCTEST_UI_TEST_SPEC
    ///
    ///
    ///          If you call CreateUpload with WEB_APP specified, AWS
    ///             Device Farm throws an ArgumentException error.
    /// This member is required.
    public var type: DeviceFarmClientTypes.UploadType?

    public init (
        contentType: Swift.String? = nil,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        type: DeviceFarmClientTypes.UploadType? = nil
    )
    {
        self.contentType = contentType
        self.name = name
        self.projectArn = projectArn
        self.type = type
    }
}

struct CreateUploadInputBody: Swift.Equatable {
    public let projectArn: Swift.String?
    public let name: Swift.String?
    public let type: DeviceFarmClientTypes.UploadType?
    public let contentType: Swift.String?
}

extension CreateUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case name
        case projectArn
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.UploadType.self, forKey: .type)
        type = typeDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension CreateUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUploadOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUploadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUploadOutputResponse(upload: \(Swift.String(describing: upload)))"}
}

extension CreateUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.upload = output.upload
        } else {
            self.upload = nil
        }
    }
}

/// Represents the result of a create upload request.
public struct CreateUploadOutputResponse: Swift.Equatable {
    /// The newly created upload.
    public var upload: DeviceFarmClientTypes.Upload?

    public init (
        upload: DeviceFarmClientTypes.Upload? = nil
    )
    {
        self.upload = upload
    }
}

struct CreateUploadOutputResponseBody: Swift.Equatable {
    public let upload: DeviceFarmClientTypes.Upload?
}

extension CreateUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case upload
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Upload.self, forKey: .upload)
        upload = uploadDecoded
    }
}

public struct CreateVPCEConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVPCEConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVPCEConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVPCEConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVPCEConfigurationOutputError>
}

extension CreateVPCEConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVPCEConfigurationInput(serviceDnsName: \(Swift.String(describing: serviceDnsName)), vpceConfigurationDescription: \(Swift.String(describing: vpceConfigurationDescription)), vpceConfigurationName: \(Swift.String(describing: vpceConfigurationName)), vpceServiceName: \(Swift.String(describing: vpceServiceName)))"}
}

extension CreateVPCEConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceDnsName
        case vpceConfigurationDescription
        case vpceConfigurationName
        case vpceServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceDnsName = serviceDnsName {
            try encodeContainer.encode(serviceDnsName, forKey: .serviceDnsName)
        }
        if let vpceConfigurationDescription = vpceConfigurationDescription {
            try encodeContainer.encode(vpceConfigurationDescription, forKey: .vpceConfigurationDescription)
        }
        if let vpceConfigurationName = vpceConfigurationName {
            try encodeContainer.encode(vpceConfigurationName, forKey: .vpceConfigurationName)
        }
        if let vpceServiceName = vpceServiceName {
            try encodeContainer.encode(vpceServiceName, forKey: .vpceServiceName)
        }
    }
}

public struct CreateVPCEConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVPCEConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVPCEConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVPCEConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVPCEConfigurationOutputError>
}

public struct CreateVPCEConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVPCEConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVPCEConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVPCEConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVPCEConfigurationOutputError>
}

public struct CreateVPCEConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVPCEConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateVPCEConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateVPCEConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVPCEConfigurationOutputError>
}

public struct CreateVPCEConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVPCEConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateVPCEConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateVPCEConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVPCEConfigurationOutputError>
}

public struct CreateVPCEConfigurationInput: Swift.Equatable {
    /// The DNS name of the service running in your VPC that you want Device Farm to
    ///             test.
    /// This member is required.
    public var serviceDnsName: Swift.String?
    /// An optional description that provides details about your VPC endpoint configuration.
    public var vpceConfigurationDescription: Swift.String?
    /// The friendly name you give to your VPC endpoint configuration, to manage your
    ///             configurations more easily.
    /// This member is required.
    public var vpceConfigurationName: Swift.String?
    /// The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.
    /// This member is required.
    public var vpceServiceName: Swift.String?

    public init (
        serviceDnsName: Swift.String? = nil,
        vpceConfigurationDescription: Swift.String? = nil,
        vpceConfigurationName: Swift.String? = nil,
        vpceServiceName: Swift.String? = nil
    )
    {
        self.serviceDnsName = serviceDnsName
        self.vpceConfigurationDescription = vpceConfigurationDescription
        self.vpceConfigurationName = vpceConfigurationName
        self.vpceServiceName = vpceServiceName
    }
}

struct CreateVPCEConfigurationInputBody: Swift.Equatable {
    public let vpceConfigurationName: Swift.String?
    public let vpceServiceName: Swift.String?
    public let serviceDnsName: Swift.String?
    public let vpceConfigurationDescription: Swift.String?
}

extension CreateVPCEConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceDnsName
        case vpceConfigurationDescription
        case vpceConfigurationName
        case vpceServiceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpceConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceConfigurationName)
        vpceConfigurationName = vpceConfigurationNameDecoded
        let vpceServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceServiceName)
        vpceServiceName = vpceServiceNameDecoded
        let serviceDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceDnsName)
        serviceDnsName = serviceDnsNameDecoded
        let vpceConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceConfigurationDescription)
        vpceConfigurationDescription = vpceConfigurationDescriptionDecoded
    }
}

extension CreateVPCEConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVPCEConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVPCEConfigurationOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVPCEConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVPCEConfigurationOutputResponse(vpceConfiguration: \(Swift.String(describing: vpceConfiguration)))"}
}

extension CreateVPCEConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateVPCEConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpceConfiguration = output.vpceConfiguration
        } else {
            self.vpceConfiguration = nil
        }
    }
}

public struct CreateVPCEConfigurationOutputResponse: Swift.Equatable {
    /// An object that contains information about your VPC endpoint configuration.
    public var vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration?

    public init (
        vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration? = nil
    )
    {
        self.vpceConfiguration = vpceConfiguration
    }
}

struct CreateVPCEConfigurationOutputResponseBody: Swift.Equatable {
    public let vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration?
}

extension CreateVPCEConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpceConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpceConfigurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.VPCEConfiguration.self, forKey: .vpceConfiguration)
        vpceConfiguration = vpceConfigurationDecoded
    }
}

extension DeviceFarmClientTypes {
    public enum CurrencyCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case usd
        case sdkUnknown(Swift.String)

        public static var allCases: [CurrencyCode] {
            return [
                .usd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .usd: return "USD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CurrencyCode(rawValue: rawValue) ?? CurrencyCode.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.CustomerArtifactPaths: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case androidPaths
        case deviceHostPaths
        case iosPaths
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let androidPaths = androidPaths {
            var androidPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .androidPaths)
            for androidpaths0 in androidPaths {
                try androidPathsContainer.encode(androidpaths0)
            }
        }
        if let deviceHostPaths = deviceHostPaths {
            var deviceHostPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceHostPaths)
            for devicehostpaths0 in deviceHostPaths {
                try deviceHostPathsContainer.encode(devicehostpaths0)
            }
        }
        if let iosPaths = iosPaths {
            var iosPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iosPaths)
            for iospaths0 in iosPaths {
                try iosPathsContainer.encode(iospaths0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iosPathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .iosPaths)
        var iosPathsDecoded0:[Swift.String]? = nil
        if let iosPathsContainer = iosPathsContainer {
            iosPathsDecoded0 = [Swift.String]()
            for string0 in iosPathsContainer {
                if let string0 = string0 {
                    iosPathsDecoded0?.append(string0)
                }
            }
        }
        iosPaths = iosPathsDecoded0
        let androidPathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .androidPaths)
        var androidPathsDecoded0:[Swift.String]? = nil
        if let androidPathsContainer = androidPathsContainer {
            androidPathsDecoded0 = [Swift.String]()
            for string0 in androidPathsContainer {
                if let string0 = string0 {
                    androidPathsDecoded0?.append(string0)
                }
            }
        }
        androidPaths = androidPathsDecoded0
        let deviceHostPathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceHostPaths)
        var deviceHostPathsDecoded0:[Swift.String]? = nil
        if let deviceHostPathsContainer = deviceHostPathsContainer {
            deviceHostPathsDecoded0 = [Swift.String]()
            for string0 in deviceHostPathsContainer {
                if let string0 = string0 {
                    deviceHostPathsDecoded0?.append(string0)
                }
            }
        }
        deviceHostPaths = deviceHostPathsDecoded0
    }
}

extension DeviceFarmClientTypes.CustomerArtifactPaths: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomerArtifactPaths(androidPaths: \(Swift.String(describing: androidPaths)), deviceHostPaths: \(Swift.String(describing: deviceHostPaths)), iosPaths: \(Swift.String(describing: iosPaths)))"}
}

extension DeviceFarmClientTypes {
    /// A JSON object that specifies the paths where the artifacts generated by the customer's tests, on the
    ///             device or in the test environment, are pulled from.
    ///         Specify deviceHostPaths and optionally specify either
    ///                 iosPaths or androidPaths.
    ///         For web app tests, you can specify both iosPaths and
    ///                 androidPaths.
    public struct CustomerArtifactPaths: Swift.Equatable {
        /// Comma-separated list of paths on the Android device where the artifacts generated by the customer's
        ///             tests are pulled from.
        public var androidPaths: [Swift.String]?
        /// Comma-separated list of paths in the test execution environment where the artifacts generated by the
        ///             customer's tests are pulled from.
        public var deviceHostPaths: [Swift.String]?
        /// Comma-separated list of paths on the iOS device where the artifacts generated by the customer's tests
        ///             are pulled from.
        public var iosPaths: [Swift.String]?

        public init (
            androidPaths: [Swift.String]? = nil,
            deviceHostPaths: [Swift.String]? = nil,
            iosPaths: [Swift.String]? = nil
        )
        {
            self.androidPaths = androidPaths
            self.deviceHostPaths = deviceHostPaths
            self.iosPaths = iosPaths
        }
    }

}

public struct DeleteDevicePoolInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDevicePoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDevicePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDevicePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDevicePoolOutputError>
}

extension DeleteDevicePoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDevicePoolInput(arn: \(Swift.String(describing: arn)))"}
}

extension DeleteDevicePoolInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteDevicePoolInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDevicePoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDevicePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDevicePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDevicePoolOutputError>
}

public struct DeleteDevicePoolInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDevicePoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDevicePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDevicePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDevicePoolOutputError>
}

public struct DeleteDevicePoolInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDevicePoolInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteDevicePoolInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDevicePoolInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDevicePoolOutputError>
}

public struct DeleteDevicePoolInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDevicePoolInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteDevicePoolInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDevicePoolInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDevicePoolOutputError>
}

/// Represents a request to the delete device pool operation.
public struct DeleteDevicePoolInput: Swift.Equatable {
    /// Represents the Amazon Resource Name (ARN) of the Device Farm device pool to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteDevicePoolInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension DeleteDevicePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteDevicePoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDevicePoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDevicePoolOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDevicePoolOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDevicePoolOutputResponse()"}
}

extension DeleteDevicePoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Represents the result of a delete device pool request.
public struct DeleteDevicePoolOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDevicePoolOutputResponseBody: Swift.Equatable {
}

extension DeleteDevicePoolOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteInstanceProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInstanceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInstanceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInstanceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInstanceProfileOutputError>
}

extension DeleteInstanceProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteInstanceProfileInput(arn: \(Swift.String(describing: arn)))"}
}

extension DeleteInstanceProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteInstanceProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInstanceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInstanceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInstanceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInstanceProfileOutputError>
}

public struct DeleteInstanceProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInstanceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInstanceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInstanceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInstanceProfileOutputError>
}

public struct DeleteInstanceProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInstanceProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteInstanceProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteInstanceProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInstanceProfileOutputError>
}

public struct DeleteInstanceProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInstanceProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteInstanceProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteInstanceProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInstanceProfileOutputError>
}

public struct DeleteInstanceProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the instance profile you are requesting to
    ///             delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteInstanceProfileInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension DeleteInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteInstanceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInstanceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInstanceProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInstanceProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteInstanceProfileOutputResponse()"}
}

extension DeleteInstanceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInstanceProfileOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteInstanceProfileOutputResponseBody: Swift.Equatable {
}

extension DeleteInstanceProfileOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteNetworkProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNetworkProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteNetworkProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteNetworkProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNetworkProfileOutputError>
}

extension DeleteNetworkProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteNetworkProfileInput(arn: \(Swift.String(describing: arn)))"}
}

extension DeleteNetworkProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteNetworkProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNetworkProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteNetworkProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteNetworkProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNetworkProfileOutputError>
}

public struct DeleteNetworkProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNetworkProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteNetworkProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteNetworkProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNetworkProfileOutputError>
}

public struct DeleteNetworkProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNetworkProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteNetworkProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteNetworkProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNetworkProfileOutputError>
}

public struct DeleteNetworkProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNetworkProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteNetworkProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteNetworkProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNetworkProfileOutputError>
}

public struct DeleteNetworkProfileInput: Swift.Equatable {
    /// The ARN of the network profile to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteNetworkProfileInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension DeleteNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteNetworkProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNetworkProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNetworkProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNetworkProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteNetworkProfileOutputResponse()"}
}

extension DeleteNetworkProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNetworkProfileOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteNetworkProfileOutputResponseBody: Swift.Equatable {
}

extension DeleteNetworkProfileOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

extension DeleteProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProjectInput(arn: \(Swift.String(describing: arn)))"}
}

extension DeleteProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

/// Represents a request to the delete project operation.
public struct DeleteProjectInput: Swift.Equatable {
    /// Represents the Amazon Resource Name (ARN) of the Device Farm project to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension DeleteProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProjectOutputResponse()"}
}

extension DeleteProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Represents the result of a delete project request.
public struct DeleteProjectOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteProjectOutputResponseBody: Swift.Equatable {
}

extension DeleteProjectOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteRemoteAccessSessionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRemoteAccessSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRemoteAccessSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRemoteAccessSessionOutputError>
}

extension DeleteRemoteAccessSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRemoteAccessSessionInput(arn: \(Swift.String(describing: arn)))"}
}

extension DeleteRemoteAccessSessionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteRemoteAccessSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRemoteAccessSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRemoteAccessSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRemoteAccessSessionOutputError>
}

public struct DeleteRemoteAccessSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRemoteAccessSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRemoteAccessSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRemoteAccessSessionOutputError>
}

public struct DeleteRemoteAccessSessionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRemoteAccessSessionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteRemoteAccessSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRemoteAccessSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRemoteAccessSessionOutputError>
}

public struct DeleteRemoteAccessSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRemoteAccessSessionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteRemoteAccessSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRemoteAccessSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRemoteAccessSessionOutputError>
}

/// Represents the request to delete the specified remote access session.
public struct DeleteRemoteAccessSessionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the session for which you want to delete remote
    ///             access.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteRemoteAccessSessionInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension DeleteRemoteAccessSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteRemoteAccessSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRemoteAccessSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRemoteAccessSessionOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRemoteAccessSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRemoteAccessSessionOutputResponse()"}
}

extension DeleteRemoteAccessSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// The response from the server when a request is made to delete the remote access
///             session.
public struct DeleteRemoteAccessSessionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRemoteAccessSessionOutputResponseBody: Swift.Equatable {
}

extension DeleteRemoteAccessSessionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteRunInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRunOutputError>
}

extension DeleteRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRunInput(arn: \(Swift.String(describing: arn)))"}
}

extension DeleteRunInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRunOutputError>
}

public struct DeleteRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRunOutputError>
}

public struct DeleteRunInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRunInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRunOutputError>
}

public struct DeleteRunInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRunInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRunOutputError>
}

/// Represents a request to the delete run operation.
public struct DeleteRunInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the run to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteRunInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension DeleteRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRunOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRunOutputResponse()"}
}

extension DeleteRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Represents the result of a delete run request.
public struct DeleteRunOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRunOutputResponseBody: Swift.Equatable {
}

extension DeleteRunOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteTestGridProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTestGridProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTestGridProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTestGridProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTestGridProjectOutputError>
}

extension DeleteTestGridProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTestGridProjectInput(projectArn: \(Swift.String(describing: projectArn)))"}
}

extension DeleteTestGridProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
    }
}

public struct DeleteTestGridProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTestGridProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTestGridProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTestGridProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTestGridProjectOutputError>
}

public struct DeleteTestGridProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTestGridProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTestGridProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTestGridProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTestGridProjectOutputError>
}

public struct DeleteTestGridProjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTestGridProjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteTestGridProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTestGridProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTestGridProjectOutputError>
}

public struct DeleteTestGridProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTestGridProjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteTestGridProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTestGridProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTestGridProjectOutputError>
}

public struct DeleteTestGridProjectInput: Swift.Equatable {
    /// The ARN of the project to delete, from CreateTestGridProject or ListTestGridProjects.
    /// This member is required.
    public var projectArn: Swift.String?

    public init (
        projectArn: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
    }
}

struct DeleteTestGridProjectInputBody: Swift.Equatable {
    public let projectArn: Swift.String?
}

extension DeleteTestGridProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension DeleteTestGridProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTestGridProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CannotDeleteException" : self = .cannotDeleteException(try CannotDeleteException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTestGridProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case cannotDeleteException(CannotDeleteException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTestGridProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTestGridProjectOutputResponse()"}
}

extension DeleteTestGridProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTestGridProjectOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteTestGridProjectOutputResponseBody: Swift.Equatable {
}

extension DeleteTestGridProjectOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteUploadInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUploadOutputError>
}

extension DeleteUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUploadInput(arn: \(Swift.String(describing: arn)))"}
}

extension DeleteUploadInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteUploadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUploadOutputError>
}

public struct DeleteUploadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUploadOutputError>
}

public struct DeleteUploadInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUploadInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUploadOutputError>
}

public struct DeleteUploadInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUploadInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUploadOutputError>
}

/// Represents a request to the delete upload operation.
public struct DeleteUploadInput: Swift.Equatable {
    /// Represents the Amazon Resource Name (ARN) of the Device Farm upload to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteUploadInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension DeleteUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUploadOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUploadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUploadOutputResponse()"}
}

extension DeleteUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Represents the result of a delete upload request.
public struct DeleteUploadOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteUploadOutputResponseBody: Swift.Equatable {
}

extension DeleteUploadOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteVPCEConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVPCEConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVPCEConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVPCEConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVPCEConfigurationOutputError>
}

extension DeleteVPCEConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVPCEConfigurationInput(arn: \(Swift.String(describing: arn)))"}
}

extension DeleteVPCEConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteVPCEConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVPCEConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVPCEConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVPCEConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVPCEConfigurationOutputError>
}

public struct DeleteVPCEConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVPCEConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVPCEConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVPCEConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVPCEConfigurationOutputError>
}

public struct DeleteVPCEConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVPCEConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteVPCEConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVPCEConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVPCEConfigurationOutputError>
}

public struct DeleteVPCEConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVPCEConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteVPCEConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVPCEConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVPCEConfigurationOutputError>
}

public struct DeleteVPCEConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to
    ///             delete.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteVPCEConfigurationInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension DeleteVPCEConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteVPCEConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVPCEConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVPCEConfigurationOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case invalidOperationException(InvalidOperationException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVPCEConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVPCEConfigurationOutputResponse()"}
}

extension DeleteVPCEConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVPCEConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteVPCEConfigurationOutputResponseBody: Swift.Equatable {
}

extension DeleteVPCEConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeviceFarmClientTypes.Device: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case availability
        case carrier
        case cpu
        case fleetName
        case fleetType
        case formFactor
        case heapSize
        case image
        case instances
        case manufacturer
        case memory
        case model
        case modelId
        case name
        case os
        case platform
        case radio
        case remoteAccessEnabled
        case remoteDebugEnabled
        case resolution
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let availability = availability {
            try encodeContainer.encode(availability.rawValue, forKey: .availability)
        }
        if let carrier = carrier {
            try encodeContainer.encode(carrier, forKey: .carrier)
        }
        if let cpu = cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let fleetType = fleetType {
            try encodeContainer.encode(fleetType, forKey: .fleetType)
        }
        if let formFactor = formFactor {
            try encodeContainer.encode(formFactor.rawValue, forKey: .formFactor)
        }
        if let heapSize = heapSize {
            try encodeContainer.encode(heapSize, forKey: .heapSize)
        }
        if let image = image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if let instances = instances {
            var instancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instances)
            for deviceinstances0 in instances {
                try instancesContainer.encode(deviceinstances0)
            }
        }
        if let manufacturer = manufacturer {
            try encodeContainer.encode(manufacturer, forKey: .manufacturer)
        }
        if let memory = memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let os = os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let radio = radio {
            try encodeContainer.encode(radio, forKey: .radio)
        }
        if let remoteAccessEnabled = remoteAccessEnabled {
            try encodeContainer.encode(remoteAccessEnabled, forKey: .remoteAccessEnabled)
        }
        if let remoteDebugEnabled = remoteDebugEnabled {
            try encodeContainer.encode(remoteDebugEnabled, forKey: .remoteDebugEnabled)
        }
        if let resolution = resolution {
            try encodeContainer.encode(resolution, forKey: .resolution)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let manufacturerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manufacturer)
        manufacturer = manufacturerDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let formFactorDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceFormFactor.self, forKey: .formFactor)
        formFactor = formFactorDecoded
        let platformDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePlatform.self, forKey: .platform)
        platform = platformDecoded
        let osDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .os)
        os = osDecoded
        let cpuDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.CPU.self, forKey: .cpu)
        cpu = cpuDecoded
        let resolutionDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Resolution.self, forKey: .resolution)
        resolution = resolutionDecoded
        let heapSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .heapSize)
        heapSize = heapSizeDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memory)
        memory = memoryDecoded
        let imageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .image)
        image = imageDecoded
        let carrierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .carrier)
        carrier = carrierDecoded
        let radioDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .radio)
        radio = radioDecoded
        let remoteAccessEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteAccessEnabled)
        remoteAccessEnabled = remoteAccessEnabledDecoded
        let remoteDebugEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteDebugEnabled)
        remoteDebugEnabled = remoteDebugEnabledDecoded
        let fleetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetType)
        fleetType = fleetTypeDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let instancesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DeviceInstance?].self, forKey: .instances)
        var instancesDecoded0:[DeviceFarmClientTypes.DeviceInstance]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [DeviceFarmClientTypes.DeviceInstance]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let availabilityDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceAvailability.self, forKey: .availability)
        availability = availabilityDecoded
    }
}

extension DeviceFarmClientTypes.Device: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Device(arn: \(Swift.String(describing: arn)), availability: \(Swift.String(describing: availability)), carrier: \(Swift.String(describing: carrier)), cpu: \(Swift.String(describing: cpu)), fleetName: \(Swift.String(describing: fleetName)), fleetType: \(Swift.String(describing: fleetType)), formFactor: \(Swift.String(describing: formFactor)), heapSize: \(Swift.String(describing: heapSize)), image: \(Swift.String(describing: image)), instances: \(Swift.String(describing: instances)), manufacturer: \(Swift.String(describing: manufacturer)), memory: \(Swift.String(describing: memory)), model: \(Swift.String(describing: model)), modelId: \(Swift.String(describing: modelId)), name: \(Swift.String(describing: name)), os: \(Swift.String(describing: os)), platform: \(Swift.String(describing: platform)), radio: \(Swift.String(describing: radio)), remoteAccessEnabled: \(Swift.String(describing: remoteAccessEnabled)), remoteDebugEnabled: \(Swift.String(describing: remoteDebugEnabled)), resolution: \(Swift.String(describing: resolution)))"}
}

extension DeviceFarmClientTypes {
    /// Represents a device type that an app is tested against.
    public struct Device: Swift.Equatable {
        /// The device's ARN.
        public var arn: Swift.String?
        /// Indicates how likely a device is available for a test run. Currently available in the ListDevices and GetDevice API methods.
        public var availability: DeviceFarmClientTypes.DeviceAvailability?
        /// The device's carrier.
        public var carrier: Swift.String?
        /// Information about the device's CPU.
        public var cpu: DeviceFarmClientTypes.CPU?
        /// The name of the fleet to which this device belongs.
        public var fleetName: Swift.String?
        /// The type of fleet to which this device belongs. Possible values are PRIVATE and PUBLIC.
        public var fleetType: Swift.String?
        /// The device's form factor.
        ///         Allowed values include:
        ///
        ///
        ///                 PHONE
        ///
        ///
        ///                 TABLET
        ///
        ///
        public var formFactor: DeviceFarmClientTypes.DeviceFormFactor?
        /// The device's heap size, expressed in bytes.
        public var heapSize: Swift.Int?
        /// The device's image name.
        public var image: Swift.String?
        /// The instances that belong to this device.
        public var instances: [DeviceFarmClientTypes.DeviceInstance]?
        /// The device's manufacturer name.
        public var manufacturer: Swift.String?
        /// The device's total memory size, expressed in bytes.
        public var memory: Swift.Int?
        /// The device's model name.
        public var model: Swift.String?
        /// The device's model ID.
        public var modelId: Swift.String?
        /// The device's display name.
        public var name: Swift.String?
        /// The device's operating system type.
        public var os: Swift.String?
        /// The device's platform.
        ///         Allowed values include:
        ///
        ///
        ///                 ANDROID
        ///
        ///
        ///                 IOS
        ///
        ///
        public var platform: DeviceFarmClientTypes.DevicePlatform?
        /// The device's radio.
        public var radio: Swift.String?
        /// Specifies whether remote access has been enabled for the specified
        ///             device.
        public var remoteAccessEnabled: Swift.Bool?
        /// This flag is set to true if remote debugging is enabled for the
        ///             device.
        ///         Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
        ///                 longer supported.
        public var remoteDebugEnabled: Swift.Bool?
        /// The resolution of the device.
        public var resolution: DeviceFarmClientTypes.Resolution?

        public init (
            arn: Swift.String? = nil,
            availability: DeviceFarmClientTypes.DeviceAvailability? = nil,
            carrier: Swift.String? = nil,
            cpu: DeviceFarmClientTypes.CPU? = nil,
            fleetName: Swift.String? = nil,
            fleetType: Swift.String? = nil,
            formFactor: DeviceFarmClientTypes.DeviceFormFactor? = nil,
            heapSize: Swift.Int? = nil,
            image: Swift.String? = nil,
            instances: [DeviceFarmClientTypes.DeviceInstance]? = nil,
            manufacturer: Swift.String? = nil,
            memory: Swift.Int? = nil,
            model: Swift.String? = nil,
            modelId: Swift.String? = nil,
            name: Swift.String? = nil,
            os: Swift.String? = nil,
            platform: DeviceFarmClientTypes.DevicePlatform? = nil,
            radio: Swift.String? = nil,
            remoteAccessEnabled: Swift.Bool? = nil,
            remoteDebugEnabled: Swift.Bool? = nil,
            resolution: DeviceFarmClientTypes.Resolution? = nil
        )
        {
            self.arn = arn
            self.availability = availability
            self.carrier = carrier
            self.cpu = cpu
            self.fleetName = fleetName
            self.fleetType = fleetType
            self.formFactor = formFactor
            self.heapSize = heapSize
            self.image = image
            self.instances = instances
            self.manufacturer = manufacturer
            self.memory = memory
            self.model = model
            self.modelId = modelId
            self.name = name
            self.os = os
            self.platform = platform
            self.radio = radio
            self.remoteAccessEnabled = remoteAccessEnabled
            self.remoteDebugEnabled = remoteDebugEnabled
            self.resolution = resolution
        }
    }

}

extension DeviceFarmClientTypes {
    public enum DeviceAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appiumVersion
        case arn
        case availability
        case fleetType
        case formFactor
        case instanceArn
        case instanceLabels
        case manufacturer
        case model
        case osVersion
        case platform
        case remoteAccessEnabled
        case remoteDebugEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceAttribute] {
            return [
                .appiumVersion,
                .arn,
                .availability,
                .fleetType,
                .formFactor,
                .instanceArn,
                .instanceLabels,
                .manufacturer,
                .model,
                .osVersion,
                .platform,
                .remoteAccessEnabled,
                .remoteDebugEnabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appiumVersion: return "APPIUM_VERSION"
            case .arn: return "ARN"
            case .availability: return "AVAILABILITY"
            case .fleetType: return "FLEET_TYPE"
            case .formFactor: return "FORM_FACTOR"
            case .instanceArn: return "INSTANCE_ARN"
            case .instanceLabels: return "INSTANCE_LABELS"
            case .manufacturer: return "MANUFACTURER"
            case .model: return "MODEL"
            case .osVersion: return "OS_VERSION"
            case .platform: return "PLATFORM"
            case .remoteAccessEnabled: return "REMOTE_ACCESS_ENABLED"
            case .remoteDebugEnabled: return "REMOTE_DEBUG_ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceAttribute(rawValue: rawValue) ?? DeviceAttribute.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum DeviceAvailability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case busy
        case highlyAvailable
        case temporaryNotAvailable
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceAvailability] {
            return [
                .available,
                .busy,
                .highlyAvailable,
                .temporaryNotAvailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .busy: return "BUSY"
            case .highlyAvailable: return "HIGHLY_AVAILABLE"
            case .temporaryNotAvailable: return "TEMPORARY_NOT_AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceAvailability(rawValue: rawValue) ?? DeviceAvailability.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.DeviceFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for devicefiltervalues0 in values {
                try valuesContainer.encode(devicefiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceFilterAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.RuleOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DeviceFarmClientTypes.DeviceFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceFilter(attribute: \(Swift.String(describing: attribute)), operator: \(Swift.String(describing: `operator`)), values: \(Swift.String(describing: values)))"}
}

extension DeviceFarmClientTypes {
    /// Represents a device filter used to select a set of devices to be included in a test
    ///             run. This data structure is passed in as the deviceSelectionConfiguration
    ///             parameter to ScheduleRun. For an example of the JSON request syntax, see
    ///                 ScheduleRun.
    ///         It is also passed in as the filters parameter to
    ///             ListDevices. For an example of the JSON request syntax, see ListDevices.
    public struct DeviceFilter: Swift.Equatable {
        /// Specifies how Device Farm compares the filter's attribute to the value. See the attribute
        ///             descriptions.
        /// This member is required.
        public var `operator`: DeviceFarmClientTypes.RuleOperator?
        /// The aspect of a device such as platform or model used as the selection criteria in a
        ///             device filter.
        ///         The supported operators for each attribute are provided in the following list.
        ///
        ///             ARN
        ///
        ///                     The Amazon Resource Name (ARN) of the device (for example,
        ///                             arn:aws:devicefarm:us-west-2::device:12345Example).
        ///                     Supported operators: EQUALS, IN, NOT_IN
        ///
        ///
        ///             PLATFORM
        ///
        ///                     The device platform. Valid values are ANDROID or IOS.
        ///                     Supported operators: EQUALS
        ///
        ///
        ///             OS_VERSION
        ///
        ///                     The operating system version (for example, 10.3.2).
        ///                     Supported operators: EQUALS, GREATER_THAN,
        ///                             GREATER_THAN_OR_EQUALS, IN,
        ///                             LESS_THAN, LESS_THAN_OR_EQUALS,
        ///                             NOT_IN
        ///
        ///
        ///             MODEL
        ///
        ///                     The device model (for example, iPad 5th Gen).
        ///                     Supported operators: CONTAINS, EQUALS,
        ///                             IN, NOT_IN
        ///
        ///
        ///             AVAILABILITY
        ///
        ///                     The current availability of the device. Valid values are AVAILABLE,
        ///                         HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.
        ///                     Supported operators: EQUALS
        ///
        ///
        ///             FORM_FACTOR
        ///
        ///                     The device form factor. Valid values are PHONE or TABLET.
        ///                     Supported operators: EQUALS
        ///
        ///
        ///             MANUFACTURER
        ///
        ///                     The device manufacturer (for example, Apple).
        ///                     Supported operators: EQUALS, IN,
        ///                             NOT_IN
        ///
        ///
        ///             REMOTE_ACCESS_ENABLED
        ///
        ///                     Whether the device is enabled for remote access. Valid values are TRUE or
        ///                         FALSE.
        ///                     Supported operators: EQUALS
        ///
        ///
        ///             REMOTE_DEBUG_ENABLED
        ///
        ///                     Whether the device is enabled for remote debugging. Valid values are TRUE or FALSE.
        ///                     Supported operators: EQUALS
        ///
        ///                     Because remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no longer
        ///                             supported, this filter is ignored.
        ///
        ///             INSTANCE_ARN
        ///
        ///                     The Amazon Resource Name (ARN) of the device instance.
        ///                     Supported operators: EQUALS, IN,
        ///                             NOT_IN
        ///
        ///
        ///             INSTANCE_LABELS
        ///
        ///                     The label of the device instance.
        ///                     Supported operators: CONTAINS
        ///
        ///
        ///             FLEET_TYPE
        ///
        ///                     The fleet type. Valid values are PUBLIC or PRIVATE.
        ///                     Supported operators: EQUALS
        ///
        ///
        ///
        /// This member is required.
        public var attribute: DeviceFarmClientTypes.DeviceFilterAttribute?
        /// An array of one or more filter values used in a device filter.
        ///         <p class="title">
        ///             Operator Values
        ///
        ///
        ///
        ///                 The IN and NOT_IN operators can take a values array that has more than one
        ///                     element.
        ///
        ///
        ///                 The other operators require an array with a single element.
        ///
        ///
        ///         <p class="title">
        ///             Attribute Values
        ///
        ///
        ///
        ///                 The PLATFORM attribute can be set to ANDROID or IOS.
        ///
        ///
        ///                 The AVAILABILITY attribute can be set to AVAILABLE, HIGHLY_AVAILABLE, BUSY, or
        ///                     TEMPORARY_NOT_AVAILABLE.
        ///
        ///
        ///                 The FORM_FACTOR attribute can be set to PHONE or TABLET.
        ///
        ///
        ///                 The FLEET_TYPE attribute can be set to PUBLIC or PRIVATE.
        ///
        ///
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            `operator`: DeviceFarmClientTypes.RuleOperator? = nil,
            attribute: DeviceFarmClientTypes.DeviceFilterAttribute? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.`operator` = `operator`
            self.attribute = attribute
            self.values = values
        }
    }

}

extension DeviceFarmClientTypes {
    public enum DeviceFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arn
        case availability
        case fleetType
        case formFactor
        case instanceArn
        case instanceLabels
        case manufacturer
        case model
        case osVersion
        case platform
        case remoteAccessEnabled
        case remoteDebugEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceFilterAttribute] {
            return [
                .arn,
                .availability,
                .fleetType,
                .formFactor,
                .instanceArn,
                .instanceLabels,
                .manufacturer,
                .model,
                .osVersion,
                .platform,
                .remoteAccessEnabled,
                .remoteDebugEnabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arn: return "ARN"
            case .availability: return "AVAILABILITY"
            case .fleetType: return "FLEET_TYPE"
            case .formFactor: return "FORM_FACTOR"
            case .instanceArn: return "INSTANCE_ARN"
            case .instanceLabels: return "INSTANCE_LABELS"
            case .manufacturer: return "MANUFACTURER"
            case .model: return "MODEL"
            case .osVersion: return "OS_VERSION"
            case .platform: return "PLATFORM"
            case .remoteAccessEnabled: return "REMOTE_ACCESS_ENABLED"
            case .remoteDebugEnabled: return "REMOTE_DEBUG_ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceFilterAttribute(rawValue: rawValue) ?? DeviceFilterAttribute.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum DeviceFormFactor: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case phone
        case tablet
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceFormFactor] {
            return [
                .phone,
                .tablet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .phone: return "PHONE"
            case .tablet: return "TABLET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceFormFactor(rawValue: rawValue) ?? DeviceFormFactor.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.DeviceInstance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case deviceArn
        case instanceProfile
        case labels
        case status
        case udid
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let instanceProfile = instanceProfile {
            try encodeContainer.encode(instanceProfile, forKey: .instanceProfile)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for instancelabels0 in labels {
                try labelsContainer.encode(instancelabels0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let udid = udid {
            try encodeContainer.encode(udid, forKey: .udid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.InstanceStatus.self, forKey: .status)
        status = statusDecoded
        let udidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .udid)
        udid = udidDecoded
        let instanceProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

extension DeviceFarmClientTypes.DeviceInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceInstance(arn: \(Swift.String(describing: arn)), deviceArn: \(Swift.String(describing: deviceArn)), instanceProfile: \(Swift.String(describing: instanceProfile)), labels: \(Swift.String(describing: labels)), status: \(Swift.String(describing: status)), udid: \(Swift.String(describing: udid)))"}
}

extension DeviceFarmClientTypes {
    /// Represents the device instance.
    public struct DeviceInstance: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the device instance.
        public var arn: Swift.String?
        /// The ARN of the device.
        public var deviceArn: Swift.String?
        /// A object that contains information about the instance profile.
        public var instanceProfile: DeviceFarmClientTypes.InstanceProfile?
        /// An array of strings that describe the device instance.
        public var labels: [Swift.String]?
        /// The status of the device instance. Valid values are listed here.
        public var status: DeviceFarmClientTypes.InstanceStatus?
        /// Unique device identifier for the device instance.
        public var udid: Swift.String?

        public init (
            arn: Swift.String? = nil,
            deviceArn: Swift.String? = nil,
            instanceProfile: DeviceFarmClientTypes.InstanceProfile? = nil,
            labels: [Swift.String]? = nil,
            status: DeviceFarmClientTypes.InstanceStatus? = nil,
            udid: Swift.String? = nil
        )
        {
            self.arn = arn
            self.deviceArn = deviceArn
            self.instanceProfile = instanceProfile
            self.labels = labels
            self.status = status
            self.udid = udid
        }
    }

}

extension DeviceFarmClientTypes.DeviceMinutes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metered
        case total
        case unmetered
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metered = metered {
            try encodeContainer.encode(metered, forKey: .metered)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let unmetered = unmetered {
            try encodeContainer.encode(unmetered, forKey: .unmetered)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .total)
        total = totalDecoded
        let meteredDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .metered)
        metered = meteredDecoded
        let unmeteredDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .unmetered)
        unmetered = unmeteredDecoded
    }
}

extension DeviceFarmClientTypes.DeviceMinutes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceMinutes(metered: \(Swift.String(describing: metered)), total: \(Swift.String(describing: total)), unmetered: \(Swift.String(describing: unmetered)))"}
}

extension DeviceFarmClientTypes {
    /// Represents the total (metered or unmetered) minutes used by the resource to run
    ///             tests. Contains the sum of minutes consumed by all children.
    public struct DeviceMinutes: Swift.Equatable {
        /// When specified, represents only the sum of metered minutes used by the resource to
        ///             run tests.
        public var metered: Swift.Double?
        /// When specified, represents the total minutes used by the resource to run
        ///             tests.
        public var total: Swift.Double?
        /// When specified, represents only the sum of unmetered minutes used by the resource
        ///             to run tests.
        public var unmetered: Swift.Double?

        public init (
            metered: Swift.Double? = nil,
            total: Swift.Double? = nil,
            unmetered: Swift.Double? = nil
        )
        {
            self.metered = metered
            self.total = total
            self.unmetered = unmetered
        }
    }

}

extension DeviceFarmClientTypes {
    public enum DevicePlatform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case android
        case ios
        case sdkUnknown(Swift.String)

        public static var allCases: [DevicePlatform] {
            return [
                .android,
                .ios,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .android: return "ANDROID"
            case .ios: return "IOS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DevicePlatform(rawValue: rawValue) ?? DevicePlatform.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.DevicePool: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case maxDevices
        case name
        case rules
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let maxDevices = maxDevices {
            try encodeContainer.encode(maxDevices, forKey: .maxDevices)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rules0 in rules {
                try rulesContainer.encode(rules0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePoolType.self, forKey: .type)
        type = typeDecoded
        let rulesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[DeviceFarmClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [DeviceFarmClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let maxDevicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDevices)
        maxDevices = maxDevicesDecoded
    }
}

extension DeviceFarmClientTypes.DevicePool: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DevicePool(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), maxDevices: \(Swift.String(describing: maxDevices)), name: \(Swift.String(describing: name)), rules: \(Swift.String(describing: rules)), type: \(Swift.String(describing: type)))"}
}

extension DeviceFarmClientTypes {
    /// Represents a collection of device types.
    public struct DevicePool: Swift.Equatable {
        /// The device pool's ARN.
        public var arn: Swift.String?
        /// The device pool's description.
        public var description: Swift.String?
        /// The number of devices that Device Farm can add to your device pool. Device Farm adds devices that are
        ///             available and meet the criteria that you assign for the rules parameter. Depending on how many
        ///             devices meet these constraints, your device pool might contain fewer devices than the value for this
        ///             parameter.
        ///         By specifying the maximum number of devices, you can control the costs that you incur
        ///             by running tests.
        public var maxDevices: Swift.Int?
        /// The device pool's name.
        public var name: Swift.String?
        /// Information about the device pool's rules.
        public var rules: [DeviceFarmClientTypes.Rule]?
        /// The device pool's type.
        ///         Allowed values include:
        ///
        ///
        ///                 CURATED: A device pool that is created and managed by AWS Device
        ///                     Farm.
        ///
        ///
        ///                 PRIVATE: A device pool that is created and managed by the device pool
        ///                     developer.
        ///
        ///
        public var type: DeviceFarmClientTypes.DevicePoolType?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            maxDevices: Swift.Int? = nil,
            name: Swift.String? = nil,
            rules: [DeviceFarmClientTypes.Rule]? = nil,
            type: DeviceFarmClientTypes.DevicePoolType? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.maxDevices = maxDevices
            self.name = name
            self.rules = rules
            self.type = type
        }
    }

}

extension DeviceFarmClientTypes.DevicePoolCompatibilityResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatible
        case device
        case incompatibilityMessages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatible = compatible {
            try encodeContainer.encode(compatible, forKey: .compatible)
        }
        if let device = device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let incompatibilityMessages = incompatibilityMessages {
            var incompatibilityMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .incompatibilityMessages)
            for incompatibilitymessages0 in incompatibilityMessages {
                try incompatibilityMessagesContainer.encode(incompatibilitymessages0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
        let compatibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .compatible)
        compatible = compatibleDecoded
        let incompatibilityMessagesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.IncompatibilityMessage?].self, forKey: .incompatibilityMessages)
        var incompatibilityMessagesDecoded0:[DeviceFarmClientTypes.IncompatibilityMessage]? = nil
        if let incompatibilityMessagesContainer = incompatibilityMessagesContainer {
            incompatibilityMessagesDecoded0 = [DeviceFarmClientTypes.IncompatibilityMessage]()
            for structure0 in incompatibilityMessagesContainer {
                if let structure0 = structure0 {
                    incompatibilityMessagesDecoded0?.append(structure0)
                }
            }
        }
        incompatibilityMessages = incompatibilityMessagesDecoded0
    }
}

extension DeviceFarmClientTypes.DevicePoolCompatibilityResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DevicePoolCompatibilityResult(compatible: \(Swift.String(describing: compatible)), device: \(Swift.String(describing: device)), incompatibilityMessages: \(Swift.String(describing: incompatibilityMessages)))"}
}

extension DeviceFarmClientTypes {
    /// Represents a device pool compatibility result.
    public struct DevicePoolCompatibilityResult: Swift.Equatable {
        /// Whether the result was compatible with the device pool.
        public var compatible: Swift.Bool?
        /// The device (phone or tablet) to return information about.
        public var device: DeviceFarmClientTypes.Device?
        /// Information about the compatibility.
        public var incompatibilityMessages: [DeviceFarmClientTypes.IncompatibilityMessage]?

        public init (
            compatible: Swift.Bool? = nil,
            device: DeviceFarmClientTypes.Device? = nil,
            incompatibilityMessages: [DeviceFarmClientTypes.IncompatibilityMessage]? = nil
        )
        {
            self.compatible = compatible
            self.device = device
            self.incompatibilityMessages = incompatibilityMessages
        }
    }

}

extension DeviceFarmClientTypes {
    public enum DevicePoolType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case curated
        case `private`
        case sdkUnknown(Swift.String)

        public static var allCases: [DevicePoolType] {
            return [
                .curated,
                .private,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .curated: return "CURATED"
            case .private: return "PRIVATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DevicePoolType(rawValue: rawValue) ?? DevicePoolType.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.DeviceSelectionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxDevices
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for devicefilters0 in filters {
                try filtersContainer.encode(devicefilters0)
            }
        }
        if let maxDevices = maxDevices {
            try encodeContainer.encode(maxDevices, forKey: .maxDevices)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DeviceFilter?].self, forKey: .filters)
        var filtersDecoded0:[DeviceFarmClientTypes.DeviceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DeviceFarmClientTypes.DeviceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxDevicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDevices)
        maxDevices = maxDevicesDecoded
    }
}

extension DeviceFarmClientTypes.DeviceSelectionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceSelectionConfiguration(filters: \(Swift.String(describing: filters)), maxDevices: \(Swift.String(describing: maxDevices)))"}
}

extension DeviceFarmClientTypes {
    /// Represents the device filters used in a test run and the maximum number of devices to be included in the
    ///             run. It is passed in as the deviceSelectionConfiguration request parameter in ScheduleRun.
    public struct DeviceSelectionConfiguration: Swift.Equatable {
        /// Used to dynamically select a set of devices for a test run. A filter is made up of an
        ///             attribute, an operator, and one or more values.
        ///
        ///
        ///
        ///                   Attribute
        ///
        ///                 The aspect of a device such as platform or model used as the selection
        ///                     criteria in a device filter.
        ///                 Allowed values include:
        ///
        ///
        ///                         ARN: The Amazon Resource Name (ARN) of the device (for example,
        ///                                 arn:aws:devicefarm:us-west-2::device:12345Example).
        ///
        ///
        ///                         PLATFORM: The device platform. Valid values are ANDROID or
        ///                             IOS.
        ///
        ///
        ///                         OS_VERSION: The operating system version (for example,
        ///                             10.3.2).
        ///
        ///
        ///                         MODEL: The device model (for example, iPad 5th Gen).
        ///
        ///
        ///                         AVAILABILITY: The current availability of the device. Valid values
        ///                             are AVAILABLE, HIGHLY_AVAILABLE, BUSY, or
        ///                             TEMPORARY_NOT_AVAILABLE.
        ///
        ///
        ///                         FORM_FACTOR: The device form factor. Valid values are PHONE or
        ///                             TABLET.
        ///
        ///
        ///                         MANUFACTURER: The device manufacturer (for example,
        ///                             Apple).
        ///
        ///
        ///                         REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote
        ///                             access. Valid values are TRUE or FALSE.
        ///
        ///
        ///                         REMOTE_DEBUG_ENABLED: Whether the device is enabled for remote debugging. Valid values
        ///                             are TRUE or FALSE. Because remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
        ///                                 longer supported, this filter is ignored.
        ///
        ///
        ///                         INSTANCE_ARN: The Amazon Resource Name (ARN) of the device
        ///                             instance.
        ///
        ///
        ///                         INSTANCE_LABELS: The label of the device instance.
        ///
        ///
        ///                         FLEET_TYPE: The fleet type. Valid values are PUBLIC or PRIVATE.
        ///
        ///
        ///
        ///
        ///
        ///                   Operator
        ///
        ///                 The filter operator.
        ///
        ///
        ///                         The EQUALS operator is available for every attribute except
        ///                             INSTANCE_LABELS.
        ///
        ///
        ///                         The CONTAINS operator is available for the INSTANCE_LABELS and MODEL
        ///                             attributes.
        ///
        ///
        ///                         The IN and NOT_IN operators are available for the ARN, OS_VERSION,
        ///                             MODEL, MANUFACTURER, and INSTANCE_ARN attributes.
        ///
        ///
        ///                         The LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUALS, and
        ///                             GREATER_THAN_OR_EQUALS operators are also available for the OS_VERSION
        ///                             attribute.
        ///
        ///
        ///
        ///
        ///
        ///                   Values
        ///
        ///                 An array of one or more filter values.
        ///                 <p class="title">
        ///                   Operator Values
        ///
        ///
        ///
        ///                         The IN and NOT_IN operators can take a values array that has more than
        ///                             one element.
        ///
        ///
        ///                         The other operators require an array with a single element.
        ///
        ///
        ///                 <p class="title">
        ///                   Attribute Values
        ///
        ///
        ///
        ///                         The PLATFORM attribute can be set to ANDROID or IOS.
        ///
        ///
        ///                         The AVAILABILITY attribute can be set to AVAILABLE, HIGHLY_AVAILABLE, BUSY, or
        ///                             TEMPORARY_NOT_AVAILABLE.
        ///
        ///
        ///                         The FORM_FACTOR attribute can be set to PHONE or TABLET.
        ///
        ///
        ///                         The FLEET_TYPE attribute can be set to PUBLIC or PRIVATE.
        ///
        ///
        ///
        ///
        /// This member is required.
        public var filters: [DeviceFarmClientTypes.DeviceFilter]?
        /// The maximum number of devices to be included in a test run.
        /// This member is required.
        public var maxDevices: Swift.Int?

        public init (
            filters: [DeviceFarmClientTypes.DeviceFilter]? = nil,
            maxDevices: Swift.Int? = nil
        )
        {
            self.filters = filters
            self.maxDevices = maxDevices
        }
    }

}

extension DeviceFarmClientTypes.DeviceSelectionResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case matchedDevicesCount
        case maxDevices
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for devicefilters0 in filters {
                try filtersContainer.encode(devicefilters0)
            }
        }
        if let matchedDevicesCount = matchedDevicesCount {
            try encodeContainer.encode(matchedDevicesCount, forKey: .matchedDevicesCount)
        }
        if let maxDevices = maxDevices {
            try encodeContainer.encode(maxDevices, forKey: .maxDevices)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DeviceFilter?].self, forKey: .filters)
        var filtersDecoded0:[DeviceFarmClientTypes.DeviceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DeviceFarmClientTypes.DeviceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let matchedDevicesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .matchedDevicesCount)
        matchedDevicesCount = matchedDevicesCountDecoded
        let maxDevicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDevices)
        maxDevices = maxDevicesDecoded
    }
}

extension DeviceFarmClientTypes.DeviceSelectionResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceSelectionResult(filters: \(Swift.String(describing: filters)), matchedDevicesCount: \(Swift.String(describing: matchedDevicesCount)), maxDevices: \(Swift.String(describing: maxDevices)))"}
}

extension DeviceFarmClientTypes {
    /// Contains the run results requested by the device selection configuration and how many devices were
    ///             returned. For an example of the JSON response syntax, see ScheduleRun.
    public struct DeviceSelectionResult: Swift.Equatable {
        /// The filters in a device selection result.
        public var filters: [DeviceFarmClientTypes.DeviceFilter]?
        /// The number of devices that matched the device filter selection criteria.
        public var matchedDevicesCount: Swift.Int?
        /// The maximum number of devices to be selected by a device filter and included in a test
        ///             run.
        public var maxDevices: Swift.Int?

        public init (
            filters: [DeviceFarmClientTypes.DeviceFilter]? = nil,
            matchedDevicesCount: Swift.Int? = nil,
            maxDevices: Swift.Int? = nil
        )
        {
            self.filters = filters
            self.matchedDevicesCount = matchedDevicesCount
            self.maxDevices = maxDevices
        }
    }

}

extension DeviceFarmClientTypes.ExecutionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountsCleanup
        case appPackagesCleanup
        case jobTimeoutMinutes
        case skipAppResign
        case videoCapture
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountsCleanup = accountsCleanup {
            try encodeContainer.encode(accountsCleanup, forKey: .accountsCleanup)
        }
        if let appPackagesCleanup = appPackagesCleanup {
            try encodeContainer.encode(appPackagesCleanup, forKey: .appPackagesCleanup)
        }
        if let jobTimeoutMinutes = jobTimeoutMinutes {
            try encodeContainer.encode(jobTimeoutMinutes, forKey: .jobTimeoutMinutes)
        }
        if let skipAppResign = skipAppResign {
            try encodeContainer.encode(skipAppResign, forKey: .skipAppResign)
        }
        if let videoCapture = videoCapture {
            try encodeContainer.encode(videoCapture, forKey: .videoCapture)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .jobTimeoutMinutes)
        jobTimeoutMinutes = jobTimeoutMinutesDecoded
        let accountsCleanupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accountsCleanup)
        accountsCleanup = accountsCleanupDecoded
        let appPackagesCleanupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .appPackagesCleanup)
        appPackagesCleanup = appPackagesCleanupDecoded
        let videoCaptureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .videoCapture)
        videoCapture = videoCaptureDecoded
        let skipAppResignDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .skipAppResign)
        skipAppResign = skipAppResignDecoded
    }
}

extension DeviceFarmClientTypes.ExecutionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecutionConfiguration(accountsCleanup: \(Swift.String(describing: accountsCleanup)), appPackagesCleanup: \(Swift.String(describing: appPackagesCleanup)), jobTimeoutMinutes: \(Swift.String(describing: jobTimeoutMinutes)), skipAppResign: \(Swift.String(describing: skipAppResign)), videoCapture: \(Swift.String(describing: videoCapture)))"}
}

extension DeviceFarmClientTypes {
    /// Represents configuration information about a test run, such as the execution
    ///             timeout (in minutes).
    public struct ExecutionConfiguration: Swift.Equatable {
        /// True if account cleanup is enabled at the beginning of the test. Otherwise, false.
        public var accountsCleanup: Swift.Bool?
        /// True if app package cleanup is enabled at the beginning of the test. Otherwise, false.
        public var appPackagesCleanup: Swift.Bool?
        /// The number of minutes a test run executes before it times out.
        public var jobTimeoutMinutes: Swift.Int?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public
        ///             devices, Device Farm always signs your apps again.
        ///         For more information about how Device Farm re-signs your apps, see <a href="https://aws.amazon.com/device-farm/faq/">Do you modify my app? in the AWS Device
        ///                 Farm FAQs.
        public var skipAppResign: Swift.Bool?
        /// Set to true to enable video capture. Otherwise, set to false. The default is true.
        public var videoCapture: Swift.Bool?

        public init (
            accountsCleanup: Swift.Bool? = nil,
            appPackagesCleanup: Swift.Bool? = nil,
            jobTimeoutMinutes: Swift.Int? = nil,
            skipAppResign: Swift.Bool? = nil,
            videoCapture: Swift.Bool? = nil
        )
        {
            self.accountsCleanup = accountsCleanup
            self.appPackagesCleanup = appPackagesCleanup
            self.jobTimeoutMinutes = jobTimeoutMinutes
            self.skipAppResign = skipAppResign
            self.videoCapture = videoCapture
        }
    }

}

extension DeviceFarmClientTypes {
    public enum ExecutionResult: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case errored
        case failed
        case passed
        case pending
        case skipped
        case stopped
        case warned
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionResult] {
            return [
                .errored,
                .failed,
                .passed,
                .pending,
                .skipped,
                .stopped,
                .warned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .errored: return "ERRORED"
            case .failed: return "FAILED"
            case .passed: return "PASSED"
            case .pending: return "PENDING"
            case .skipped: return "SKIPPED"
            case .stopped: return "STOPPED"
            case .warned: return "WARNED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionResult(rawValue: rawValue) ?? ExecutionResult.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum ExecutionResultCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case parsingFailed
        case vpcEndpointSetupFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionResultCode] {
            return [
                .parsingFailed,
                .vpcEndpointSetupFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .parsingFailed: return "PARSING_FAILED"
            case .vpcEndpointSetupFailed: return "VPC_ENDPOINT_SETUP_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionResultCode(rawValue: rawValue) ?? ExecutionResultCode.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum ExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case pending
        case pendingConcurrnecy
        case pendingDevice
        case preparing
        case processing
        case running
        case scheduling
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .completed,
                .pending,
                .pendingConcurrnecy,
                .pendingDevice,
                .preparing,
                .processing,
                .running,
                .scheduling,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .pending: return "PENDING"
            case .pendingConcurrnecy: return "PENDING_CONCURRENCY"
            case .pendingDevice: return "PENDING_DEVICE"
            case .preparing: return "PREPARING"
            case .processing: return "PROCESSING"
            case .running: return "RUNNING"
            case .scheduling: return "SCHEDULING"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionStatus(rawValue: rawValue) ?? ExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetAccountSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccountSettingsInput()"}
}

extension GetAccountSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAccountSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccountSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccountSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccountSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccountSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAccountSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccountSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAccountSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccountSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

/// Represents the request sent to retrieve the account settings.
public struct GetAccountSettingsInput: Swift.Equatable {

    public init() {}
}

struct GetAccountSettingsInputBody: Swift.Equatable {
}

extension GetAccountSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountSettingsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccountSettingsOutputResponse(accountSettings: \(Swift.String(describing: accountSettings)))"}
}

extension GetAccountSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountSettings = output.accountSettings
        } else {
            self.accountSettings = nil
        }
    }
}

/// Represents the account settings return values from the
///                 GetAccountSettings request.
public struct GetAccountSettingsOutputResponse: Swift.Equatable {
    /// The account settings.
    public var accountSettings: DeviceFarmClientTypes.AccountSettings?

    public init (
        accountSettings: DeviceFarmClientTypes.AccountSettings? = nil
    )
    {
        self.accountSettings = accountSettings
    }
}

struct GetAccountSettingsOutputResponseBody: Swift.Equatable {
    public let accountSettings: DeviceFarmClientTypes.AccountSettings?
}

extension GetAccountSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
    }
}

public struct GetDeviceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeviceOutputError>
}

extension GetDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeviceInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetDeviceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeviceOutputError>
}

public struct GetDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeviceOutputError>
}

public struct GetDeviceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeviceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeviceOutputError>
}

public struct GetDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeviceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeviceOutputError>
}

/// Represents a request to the get device request.
public struct GetDeviceInput: Swift.Equatable {
    /// The device type's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetDeviceInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct GetDeviceInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeviceInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeviceInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeviceInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeviceInstanceOutputError>
}

extension GetDeviceInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeviceInstanceInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetDeviceInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetDeviceInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeviceInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeviceInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeviceInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeviceInstanceOutputError>
}

public struct GetDeviceInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeviceInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeviceInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeviceInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeviceInstanceOutputError>
}

public struct GetDeviceInstanceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeviceInstanceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDeviceInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDeviceInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeviceInstanceOutputError>
}

public struct GetDeviceInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeviceInstanceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDeviceInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDeviceInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeviceInstanceOutputError>
}

public struct GetDeviceInstanceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the instance you're requesting information
    ///             about.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetDeviceInstanceInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetDeviceInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetDeviceInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceInstanceOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeviceInstanceOutputResponse(deviceInstance: \(Swift.String(describing: deviceInstance)))"}
}

extension GetDeviceInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeviceInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceInstance = output.deviceInstance
        } else {
            self.deviceInstance = nil
        }
    }
}

public struct GetDeviceInstanceOutputResponse: Swift.Equatable {
    /// An object that contains information about your device instance.
    public var deviceInstance: DeviceFarmClientTypes.DeviceInstance?

    public init (
        deviceInstance: DeviceFarmClientTypes.DeviceInstance? = nil
    )
    {
        self.deviceInstance = deviceInstance
    }
}

struct GetDeviceInstanceOutputResponseBody: Swift.Equatable {
    public let deviceInstance: DeviceFarmClientTypes.DeviceInstance?
}

extension GetDeviceInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceInstance
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceInstanceDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceInstance.self, forKey: .deviceInstance)
        deviceInstance = deviceInstanceDecoded
    }
}

extension GetDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeviceOutputResponse(device: \(Swift.String(describing: device)))"}
}

extension GetDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

/// Represents the result of a get device request.
public struct GetDeviceOutputResponse: Swift.Equatable {
    /// An object that contains information about the requested device.
    public var device: DeviceFarmClientTypes.Device?

    public init (
        device: DeviceFarmClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

struct GetDeviceOutputResponseBody: Swift.Equatable {
    public let device: DeviceFarmClientTypes.Device?
}

extension GetDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
    }
}

public struct GetDevicePoolCompatibilityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePoolCompatibilityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicePoolCompatibilityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePoolCompatibilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicePoolCompatibilityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePoolCompatibilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePoolCompatibilityOutputError>
}

extension GetDevicePoolCompatibilityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicePoolCompatibilityInput(appArn: \(Swift.String(describing: appArn)), configuration: \(Swift.String(describing: configuration)), devicePoolArn: \(Swift.String(describing: devicePoolArn)), test: \(Swift.String(describing: test)), testType: \(Swift.String(describing: testType)))"}
}

extension GetDevicePoolCompatibilityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case configuration
        case devicePoolArn
        case test
        case testType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let devicePoolArn = devicePoolArn {
            try encodeContainer.encode(devicePoolArn, forKey: .devicePoolArn)
        }
        if let test = test {
            try encodeContainer.encode(test, forKey: .test)
        }
        if let testType = testType {
            try encodeContainer.encode(testType.rawValue, forKey: .testType)
        }
    }
}

public struct GetDevicePoolCompatibilityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePoolCompatibilityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicePoolCompatibilityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePoolCompatibilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicePoolCompatibilityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePoolCompatibilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePoolCompatibilityOutputError>
}

public struct GetDevicePoolCompatibilityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePoolCompatibilityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicePoolCompatibilityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePoolCompatibilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicePoolCompatibilityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePoolCompatibilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePoolCompatibilityOutputError>
}

public struct GetDevicePoolCompatibilityInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePoolCompatibilityInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDevicePoolCompatibilityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePoolCompatibilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDevicePoolCompatibilityInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePoolCompatibilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePoolCompatibilityOutputError>
}

public struct GetDevicePoolCompatibilityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePoolCompatibilityInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDevicePoolCompatibilityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePoolCompatibilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDevicePoolCompatibilityInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePoolCompatibilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePoolCompatibilityOutputError>
}

/// Represents a request to the get device pool compatibility operation.
public struct GetDevicePoolCompatibilityInput: Swift.Equatable {
    /// The ARN of the app that is associated with the specified device pool.
    public var appArn: Swift.String?
    /// An object that contains information about the settings for a run.
    public var configuration: DeviceFarmClientTypes.ScheduleRunConfiguration?
    /// The device pool's ARN.
    /// This member is required.
    public var devicePoolArn: Swift.String?
    /// Information about the uploaded test to be run against the device pool.
    public var test: DeviceFarmClientTypes.ScheduleRunTest?
    /// The test type for the specified device pool.
    ///         Allowed values include the following:
    ///
    ///
    ///                 BUILTIN_FUZZ.
    ///
    ///
    ///                 BUILTIN_EXPLORER. For Android, an app explorer that traverses an Android app, interacting with
    ///                     it and capturing screenshots at the same time.
    ///
    ///
    ///                 APPIUM_JAVA_JUNIT.
    ///
    ///
    ///                 APPIUM_JAVA_TESTNG.
    ///
    ///
    ///                 APPIUM_PYTHON.
    ///
    ///
    ///                 APPIUM_NODE.
    ///
    ///
    ///                 APPIUM_RUBY.
    ///
    ///
    ///                 APPIUM_WEB_JAVA_JUNIT.
    ///
    ///
    ///                 APPIUM_WEB_JAVA_TESTNG.
    ///
    ///
    ///                 APPIUM_WEB_PYTHON.
    ///
    ///
    ///                 APPIUM_WEB_NODE.
    ///
    ///
    ///                 APPIUM_WEB_RUBY.
    ///
    ///
    ///                 CALABASH.
    ///
    ///
    ///                 INSTRUMENTATION.
    ///
    ///
    ///                 UIAUTOMATION.
    ///
    ///
    ///                 UIAUTOMATOR.
    ///
    ///
    ///                 XCTEST.
    ///
    ///
    ///                 XCTEST_UI.
    ///
    ///
    public var testType: DeviceFarmClientTypes.TestType?

    public init (
        appArn: Swift.String? = nil,
        configuration: DeviceFarmClientTypes.ScheduleRunConfiguration? = nil,
        devicePoolArn: Swift.String? = nil,
        test: DeviceFarmClientTypes.ScheduleRunTest? = nil,
        testType: DeviceFarmClientTypes.TestType? = nil
    )
    {
        self.appArn = appArn
        self.configuration = configuration
        self.devicePoolArn = devicePoolArn
        self.test = test
        self.testType = testType
    }
}

struct GetDevicePoolCompatibilityInputBody: Swift.Equatable {
    public let devicePoolArn: Swift.String?
    public let appArn: Swift.String?
    public let testType: DeviceFarmClientTypes.TestType?
    public let test: DeviceFarmClientTypes.ScheduleRunTest?
    public let configuration: DeviceFarmClientTypes.ScheduleRunConfiguration?
}

extension GetDevicePoolCompatibilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case configuration
        case devicePoolArn
        case test
        case testType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePoolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devicePoolArn)
        devicePoolArn = devicePoolArnDecoded
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let testTypeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestType.self, forKey: .testType)
        testType = testTypeDecoded
        let testDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ScheduleRunTest.self, forKey: .test)
        test = testDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ScheduleRunConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension GetDevicePoolCompatibilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicePoolCompatibilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDevicePoolCompatibilityOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicePoolCompatibilityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicePoolCompatibilityOutputResponse(compatibleDevices: \(Swift.String(describing: compatibleDevices)), incompatibleDevices: \(Swift.String(describing: incompatibleDevices)))"}
}

extension GetDevicePoolCompatibilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDevicePoolCompatibilityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.compatibleDevices = output.compatibleDevices
            self.incompatibleDevices = output.incompatibleDevices
        } else {
            self.compatibleDevices = nil
            self.incompatibleDevices = nil
        }
    }
}

/// Represents the result of describe device pool compatibility request.
public struct GetDevicePoolCompatibilityOutputResponse: Swift.Equatable {
    /// Information about compatible devices.
    public var compatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]?
    /// Information about incompatible devices.
    public var incompatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]?

    public init (
        compatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]? = nil,
        incompatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]? = nil
    )
    {
        self.compatibleDevices = compatibleDevices
        self.incompatibleDevices = incompatibleDevices
    }
}

struct GetDevicePoolCompatibilityOutputResponseBody: Swift.Equatable {
    public let compatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]?
    public let incompatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]?
}

extension GetDevicePoolCompatibilityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleDevices
        case incompatibleDevices
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compatibleDevicesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DevicePoolCompatibilityResult?].self, forKey: .compatibleDevices)
        var compatibleDevicesDecoded0:[DeviceFarmClientTypes.DevicePoolCompatibilityResult]? = nil
        if let compatibleDevicesContainer = compatibleDevicesContainer {
            compatibleDevicesDecoded0 = [DeviceFarmClientTypes.DevicePoolCompatibilityResult]()
            for structure0 in compatibleDevicesContainer {
                if let structure0 = structure0 {
                    compatibleDevicesDecoded0?.append(structure0)
                }
            }
        }
        compatibleDevices = compatibleDevicesDecoded0
        let incompatibleDevicesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DevicePoolCompatibilityResult?].self, forKey: .incompatibleDevices)
        var incompatibleDevicesDecoded0:[DeviceFarmClientTypes.DevicePoolCompatibilityResult]? = nil
        if let incompatibleDevicesContainer = incompatibleDevicesContainer {
            incompatibleDevicesDecoded0 = [DeviceFarmClientTypes.DevicePoolCompatibilityResult]()
            for structure0 in incompatibleDevicesContainer {
                if let structure0 = structure0 {
                    incompatibleDevicesDecoded0?.append(structure0)
                }
            }
        }
        incompatibleDevices = incompatibleDevicesDecoded0
    }
}

public struct GetDevicePoolInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePoolOutputError>
}

extension GetDevicePoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicePoolInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetDevicePoolInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetDevicePoolInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePoolOutputError>
}

public struct GetDevicePoolInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePoolOutputError>
}

public struct GetDevicePoolInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePoolInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDevicePoolInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDevicePoolInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePoolOutputError>
}

public struct GetDevicePoolInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePoolInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDevicePoolInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDevicePoolInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePoolOutputError>
}

/// Represents a request to the get device pool operation.
public struct GetDevicePoolInput: Swift.Equatable {
    /// The device pool's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetDevicePoolInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetDevicePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetDevicePoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicePoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDevicePoolOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicePoolOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicePoolOutputResponse(devicePool: \(Swift.String(describing: devicePool)))"}
}

extension GetDevicePoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDevicePoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devicePool = output.devicePool
        } else {
            self.devicePool = nil
        }
    }
}

/// Represents the result of a get device pool request.
public struct GetDevicePoolOutputResponse: Swift.Equatable {
    /// An object that contains information about the requested device pool.
    public var devicePool: DeviceFarmClientTypes.DevicePool?

    public init (
        devicePool: DeviceFarmClientTypes.DevicePool? = nil
    )
    {
        self.devicePool = devicePool
    }
}

struct GetDevicePoolOutputResponseBody: Swift.Equatable {
    public let devicePool: DeviceFarmClientTypes.DevicePool?
}

extension GetDevicePoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePool
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePoolDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePool.self, forKey: .devicePool)
        devicePool = devicePoolDecoded
    }
}

public struct GetInstanceProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstanceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInstanceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInstanceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstanceProfileOutputError>
}

extension GetInstanceProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInstanceProfileInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetInstanceProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetInstanceProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstanceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInstanceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInstanceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstanceProfileOutputError>
}

public struct GetInstanceProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstanceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInstanceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInstanceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstanceProfileOutputError>
}

public struct GetInstanceProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstanceProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetInstanceProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetInstanceProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstanceProfileOutputError>
}

public struct GetInstanceProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInstanceProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetInstanceProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetInstanceProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInstanceProfileOutputError>
}

public struct GetInstanceProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an instance profile.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetInstanceProfileInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetInstanceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInstanceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInstanceProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInstanceProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInstanceProfileOutputResponse(instanceProfile: \(Swift.String(describing: instanceProfile)))"}
}

extension GetInstanceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInstanceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

public struct GetInstanceProfileOutputResponse: Swift.Equatable {
    /// An object that contains information about an instance profile.
    public var instanceProfile: DeviceFarmClientTypes.InstanceProfile?

    public init (
        instanceProfile: DeviceFarmClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct GetInstanceProfileOutputResponseBody: Swift.Equatable {
    public let instanceProfile: DeviceFarmClientTypes.InstanceProfile?
}

extension GetInstanceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

public struct GetJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobOutputError>
}

extension GetJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetJobInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobOutputError>
}

public struct GetJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobOutputError>
}

public struct GetJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobOutputError>
}

public struct GetJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobOutputError>
}

/// Represents a request to the get job operation.
public struct GetJobInput: Swift.Equatable {
    /// The job's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetJobInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetJobOutputResponse(job: \(Swift.String(describing: job)))"}
}

extension GetJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

/// Represents the result of a get job request.
public struct GetJobOutputResponse: Swift.Equatable {
    /// An object that contains information about the requested job.
    public var job: DeviceFarmClientTypes.Job?

    public init (
        job: DeviceFarmClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct GetJobOutputResponseBody: Swift.Equatable {
    public let job: DeviceFarmClientTypes.Job?
}

extension GetJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

public struct GetNetworkProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkProfileOutputError>
}

extension GetNetworkProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkProfileInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetNetworkProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetNetworkProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkProfileOutputError>
}

public struct GetNetworkProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkProfileOutputError>
}

public struct GetNetworkProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetNetworkProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetNetworkProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkProfileOutputError>
}

public struct GetNetworkProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetNetworkProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetNetworkProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkProfileOutputError>
}

public struct GetNetworkProfileInput: Swift.Equatable {
    /// The ARN of the network profile to return information about.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetNetworkProfileInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetNetworkProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNetworkProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkProfileOutputResponse(networkProfile: \(Swift.String(describing: networkProfile)))"}
}

extension GetNetworkProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNetworkProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkProfile = output.networkProfile
        } else {
            self.networkProfile = nil
        }
    }
}

public struct GetNetworkProfileOutputResponse: Swift.Equatable {
    /// The network profile.
    public var networkProfile: DeviceFarmClientTypes.NetworkProfile?

    public init (
        networkProfile: DeviceFarmClientTypes.NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

struct GetNetworkProfileOutputResponseBody: Swift.Equatable {
    public let networkProfile: DeviceFarmClientTypes.NetworkProfile?
}

extension GetNetworkProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfile.self, forKey: .networkProfile)
        networkProfile = networkProfileDecoded
    }
}

public struct GetOfferingStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOfferingStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOfferingStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOfferingStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOfferingStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOfferingStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOfferingStatusOutputError>
}

extension GetOfferingStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOfferingStatusInput(nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetOfferingStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetOfferingStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOfferingStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOfferingStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOfferingStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOfferingStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOfferingStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOfferingStatusOutputError>
}

public struct GetOfferingStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOfferingStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOfferingStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOfferingStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOfferingStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOfferingStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOfferingStatusOutputError>
}

public struct GetOfferingStatusInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOfferingStatusInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetOfferingStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOfferingStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOfferingStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOfferingStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOfferingStatusOutputError>
}

public struct GetOfferingStatusInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOfferingStatusInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetOfferingStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOfferingStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOfferingStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOfferingStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOfferingStatusOutputError>
}

/// Represents the request to retrieve the offering status for the specified customer
///             or account.
public struct GetOfferingStatusInput: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct GetOfferingStatusInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
}

extension GetOfferingStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetOfferingStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOfferingStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOfferingStatusOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOfferingStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOfferingStatusOutputResponse(current: \(Swift.String(describing: current)), nextPeriod: \(Swift.String(describing: nextPeriod)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetOfferingStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOfferingStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.current = output.current
            self.nextPeriod = output.nextPeriod
            self.nextToken = output.nextToken
        } else {
            self.current = nil
            self.nextPeriod = nil
            self.nextToken = nil
        }
    }
}

/// Returns the status result for a device offering.
public struct GetOfferingStatusOutputResponse: Swift.Equatable {
    /// When specified, gets the offering status for the current period.
    public var current: [Swift.String:DeviceFarmClientTypes.OfferingStatus]?
    /// When specified, gets the offering status for the next period.
    public var nextPeriod: [Swift.String:DeviceFarmClientTypes.OfferingStatus]?
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        current: [Swift.String:DeviceFarmClientTypes.OfferingStatus]? = nil,
        nextPeriod: [Swift.String:DeviceFarmClientTypes.OfferingStatus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.current = current
        self.nextPeriod = nextPeriod
        self.nextToken = nextToken
    }
}

struct GetOfferingStatusOutputResponseBody: Swift.Equatable {
    public let current: [Swift.String:DeviceFarmClientTypes.OfferingStatus]?
    public let nextPeriod: [Swift.String:DeviceFarmClientTypes.OfferingStatus]?
    public let nextToken: Swift.String?
}

extension GetOfferingStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case current
        case nextPeriod
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentContainer = try containerValues.decodeIfPresent([Swift.String: DeviceFarmClientTypes.OfferingStatus?].self, forKey: .current)
        var currentDecoded0: [Swift.String:DeviceFarmClientTypes.OfferingStatus]? = nil
        if let currentContainer = currentContainer {
            currentDecoded0 = [Swift.String:DeviceFarmClientTypes.OfferingStatus]()
            for (key0, offeringstatus0) in currentContainer {
                if let offeringstatus0 = offeringstatus0 {
                    currentDecoded0?[key0] = offeringstatus0
                }
            }
        }
        current = currentDecoded0
        let nextPeriodContainer = try containerValues.decodeIfPresent([Swift.String: DeviceFarmClientTypes.OfferingStatus?].self, forKey: .nextPeriod)
        var nextPeriodDecoded0: [Swift.String:DeviceFarmClientTypes.OfferingStatus]? = nil
        if let nextPeriodContainer = nextPeriodContainer {
            nextPeriodDecoded0 = [Swift.String:DeviceFarmClientTypes.OfferingStatus]()
            for (key0, offeringstatus0) in nextPeriodContainer {
                if let offeringstatus0 = offeringstatus0 {
                    nextPeriodDecoded0?[key0] = offeringstatus0
                }
            }
        }
        nextPeriod = nextPeriodDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProjectOutputError>
}

extension GetProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProjectInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProjectOutputError>
}

public struct GetProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProjectOutputError>
}

public struct GetProjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProjectOutputError>
}

public struct GetProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProjectOutputError>
}

/// Represents a request to the get project operation.
public struct GetProjectInput: Swift.Equatable {
    /// The project's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetProjectInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProjectOutputResponse(project: \(Swift.String(describing: project)))"}
}

extension GetProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

/// Represents the result of a get project request.
public struct GetProjectOutputResponse: Swift.Equatable {
    /// The project to get information about.
    public var project: DeviceFarmClientTypes.Project?

    public init (
        project: DeviceFarmClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct GetProjectOutputResponseBody: Swift.Equatable {
    public let project: DeviceFarmClientTypes.Project?
}

extension GetProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

public struct GetRemoteAccessSessionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRemoteAccessSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRemoteAccessSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRemoteAccessSessionOutputError>
}

extension GetRemoteAccessSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRemoteAccessSessionInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetRemoteAccessSessionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetRemoteAccessSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRemoteAccessSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRemoteAccessSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRemoteAccessSessionOutputError>
}

public struct GetRemoteAccessSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRemoteAccessSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRemoteAccessSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRemoteAccessSessionOutputError>
}

public struct GetRemoteAccessSessionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRemoteAccessSessionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetRemoteAccessSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRemoteAccessSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRemoteAccessSessionOutputError>
}

public struct GetRemoteAccessSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRemoteAccessSessionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetRemoteAccessSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRemoteAccessSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRemoteAccessSessionOutputError>
}

/// Represents the request to get information about the specified remote access
///             session.
public struct GetRemoteAccessSessionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the remote access session about which you want to
    ///             get session information.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetRemoteAccessSessionInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetRemoteAccessSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetRemoteAccessSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRemoteAccessSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRemoteAccessSessionOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRemoteAccessSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRemoteAccessSessionOutputResponse(remoteAccessSession: \(Swift.String(describing: remoteAccessSession)))"}
}

extension GetRemoteAccessSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRemoteAccessSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.remoteAccessSession = output.remoteAccessSession
        } else {
            self.remoteAccessSession = nil
        }
    }
}

/// Represents the response from the server that lists detailed information about the
///             remote access session.
public struct GetRemoteAccessSessionOutputResponse: Swift.Equatable {
    /// A container that lists detailed information about the remote access
    ///             session.
    public var remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession?

    public init (
        remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession? = nil
    )
    {
        self.remoteAccessSession = remoteAccessSession
    }
}

struct GetRemoteAccessSessionOutputResponseBody: Swift.Equatable {
    public let remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession?
}

extension GetRemoteAccessSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case remoteAccessSession
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteAccessSessionDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.RemoteAccessSession.self, forKey: .remoteAccessSession)
        remoteAccessSession = remoteAccessSessionDecoded
    }
}

public struct GetRunInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRunOutputError>
}

extension GetRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRunInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetRunInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRunOutputError>
}

public struct GetRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRunOutputError>
}

public struct GetRunInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRunInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRunOutputError>
}

public struct GetRunInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRunInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRunOutputError>
}

/// Represents a request to the get run operation.
public struct GetRunInput: Swift.Equatable {
    /// The run's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetRunInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRunOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRunOutputResponse(run: \(Swift.String(describing: run)))"}
}

extension GetRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.run = output.run
        } else {
            self.run = nil
        }
    }
}

/// Represents the result of a get run request.
public struct GetRunOutputResponse: Swift.Equatable {
    /// The run to get results from.
    public var run: DeviceFarmClientTypes.Run?

    public init (
        run: DeviceFarmClientTypes.Run? = nil
    )
    {
        self.run = run
    }
}

struct GetRunOutputResponseBody: Swift.Equatable {
    public let run: DeviceFarmClientTypes.Run?
}

extension GetRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case run
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Run.self, forKey: .run)
        run = runDecoded
    }
}

public struct GetSuiteInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSuiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSuiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteOutputError>
}

extension GetSuiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSuiteInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetSuiteInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetSuiteInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSuiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSuiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteOutputError>
}

public struct GetSuiteInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSuiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSuiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteOutputError>
}

public struct GetSuiteInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetSuiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSuiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteOutputError>
}

public struct GetSuiteInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetSuiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSuiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteOutputError>
}

/// Represents a request to the get suite operation.
public struct GetSuiteInput: Swift.Equatable {
    /// The suite's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetSuiteInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetSuiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetSuiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSuiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSuiteOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSuiteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSuiteOutputResponse(suite: \(Swift.String(describing: suite)))"}
}

extension GetSuiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSuiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.suite = output.suite
        } else {
            self.suite = nil
        }
    }
}

/// Represents the result of a get suite request.
public struct GetSuiteOutputResponse: Swift.Equatable {
    /// A collection of one or more tests.
    public var suite: DeviceFarmClientTypes.Suite?

    public init (
        suite: DeviceFarmClientTypes.Suite? = nil
    )
    {
        self.suite = suite
    }
}

struct GetSuiteOutputResponseBody: Swift.Equatable {
    public let suite: DeviceFarmClientTypes.Suite?
}

extension GetSuiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suite
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Suite.self, forKey: .suite)
        suite = suiteDecoded
    }
}

public struct GetTestGridProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTestGridProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTestGridProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTestGridProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTestGridProjectOutputError>
}

extension GetTestGridProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTestGridProjectInput(projectArn: \(Swift.String(describing: projectArn)))"}
}

extension GetTestGridProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
    }
}

public struct GetTestGridProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTestGridProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTestGridProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTestGridProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTestGridProjectOutputError>
}

public struct GetTestGridProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTestGridProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTestGridProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTestGridProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTestGridProjectOutputError>
}

public struct GetTestGridProjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTestGridProjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetTestGridProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTestGridProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTestGridProjectOutputError>
}

public struct GetTestGridProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTestGridProjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetTestGridProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTestGridProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTestGridProjectOutputError>
}

public struct GetTestGridProjectInput: Swift.Equatable {
    /// The ARN of the Selenium testing project, from either CreateTestGridProject or ListTestGridProjects.
    /// This member is required.
    public var projectArn: Swift.String?

    public init (
        projectArn: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
    }
}

struct GetTestGridProjectInputBody: Swift.Equatable {
    public let projectArn: Swift.String?
}

extension GetTestGridProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension GetTestGridProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTestGridProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTestGridProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTestGridProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTestGridProjectOutputResponse(testGridProject: \(Swift.String(describing: testGridProject)))"}
}

extension GetTestGridProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTestGridProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.testGridProject = output.testGridProject
        } else {
            self.testGridProject = nil
        }
    }
}

public struct GetTestGridProjectOutputResponse: Swift.Equatable {
    /// A TestGridProject.
    public var testGridProject: DeviceFarmClientTypes.TestGridProject?

    public init (
        testGridProject: DeviceFarmClientTypes.TestGridProject? = nil
    )
    {
        self.testGridProject = testGridProject
    }
}

struct GetTestGridProjectOutputResponseBody: Swift.Equatable {
    public let testGridProject: DeviceFarmClientTypes.TestGridProject?
}

extension GetTestGridProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case testGridProject
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridProjectDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridProject.self, forKey: .testGridProject)
        testGridProject = testGridProjectDecoded
    }
}

public struct GetTestGridSessionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTestGridSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTestGridSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTestGridSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTestGridSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTestGridSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTestGridSessionOutputError>
}

extension GetTestGridSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTestGridSessionInput(projectArn: \(Swift.String(describing: projectArn)), sessionArn: \(Swift.String(describing: sessionArn)), sessionId: \(Swift.String(describing: sessionId)))"}
}

extension GetTestGridSessionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case sessionArn
        case sessionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let sessionArn = sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

public struct GetTestGridSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTestGridSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTestGridSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTestGridSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTestGridSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTestGridSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTestGridSessionOutputError>
}

public struct GetTestGridSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTestGridSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTestGridSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTestGridSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTestGridSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTestGridSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTestGridSessionOutputError>
}

public struct GetTestGridSessionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTestGridSessionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetTestGridSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTestGridSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTestGridSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTestGridSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTestGridSessionOutputError>
}

public struct GetTestGridSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTestGridSessionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetTestGridSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTestGridSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTestGridSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTestGridSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTestGridSessionOutputError>
}

public struct GetTestGridSessionInput: Swift.Equatable {
    /// The ARN for the project that this session belongs to. See CreateTestGridProject and ListTestGridProjects.
    public var projectArn: Swift.String?
    /// An ARN that uniquely identifies a TestGridSession.
    public var sessionArn: Swift.String?
    /// An ID associated with this session.
    public var sessionId: Swift.String?

    public init (
        projectArn: Swift.String? = nil,
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
        self.sessionArn = sessionArn
        self.sessionId = sessionId
    }
}

struct GetTestGridSessionInputBody: Swift.Equatable {
    public let projectArn: Swift.String?
    public let sessionId: Swift.String?
    public let sessionArn: Swift.String?
}

extension GetTestGridSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case sessionArn
        case sessionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let sessionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
    }
}

extension GetTestGridSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTestGridSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTestGridSessionOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTestGridSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTestGridSessionOutputResponse(testGridSession: \(Swift.String(describing: testGridSession)))"}
}

extension GetTestGridSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTestGridSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.testGridSession = output.testGridSession
        } else {
            self.testGridSession = nil
        }
    }
}

public struct GetTestGridSessionOutputResponse: Swift.Equatable {
    /// The TestGridSession that was requested.
    public var testGridSession: DeviceFarmClientTypes.TestGridSession?

    public init (
        testGridSession: DeviceFarmClientTypes.TestGridSession? = nil
    )
    {
        self.testGridSession = testGridSession
    }
}

struct GetTestGridSessionOutputResponseBody: Swift.Equatable {
    public let testGridSession: DeviceFarmClientTypes.TestGridSession?
}

extension GetTestGridSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case testGridSession
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridSessionDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridSession.self, forKey: .testGridSession)
        testGridSession = testGridSessionDecoded
    }
}

public struct GetTestInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTestOutputError>
}

extension GetTestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTestInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetTestInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetTestInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTestOutputError>
}

public struct GetTestInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTestOutputError>
}

public struct GetTestInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTestInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetTestInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTestInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTestOutputError>
}

public struct GetTestInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTestInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetTestInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTestInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTestOutputError>
}

/// Represents a request to the get test operation.
public struct GetTestInput: Swift.Equatable {
    /// The test's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetTestInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetTestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetTestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTestOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTestOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTestOutputResponse(test: \(Swift.String(describing: test)))"}
}

extension GetTestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.test = output.test
        } else {
            self.test = nil
        }
    }
}

/// Represents the result of a get test request.
public struct GetTestOutputResponse: Swift.Equatable {
    /// A test condition that is evaluated.
    public var test: DeviceFarmClientTypes.Test?

    public init (
        test: DeviceFarmClientTypes.Test? = nil
    )
    {
        self.test = test
    }
}

struct GetTestOutputResponseBody: Swift.Equatable {
    public let test: DeviceFarmClientTypes.Test?
}

extension GetTestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case test
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Test.self, forKey: .test)
        test = testDecoded
    }
}

public struct GetUploadInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUploadOutputError>
}

extension GetUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetUploadInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetUploadInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetUploadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUploadOutputError>
}

public struct GetUploadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUploadOutputError>
}

public struct GetUploadInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUploadInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUploadOutputError>
}

public struct GetUploadInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUploadInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUploadOutputError>
}

/// Represents a request to the get upload operation.
public struct GetUploadInput: Swift.Equatable {
    /// The upload's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetUploadInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUploadOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUploadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetUploadOutputResponse(upload: \(Swift.String(describing: upload)))"}
}

extension GetUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.upload = output.upload
        } else {
            self.upload = nil
        }
    }
}

/// Represents the result of a get upload request.
public struct GetUploadOutputResponse: Swift.Equatable {
    /// An app or a set of one or more tests to upload or that have been
    ///             uploaded.
    public var upload: DeviceFarmClientTypes.Upload?

    public init (
        upload: DeviceFarmClientTypes.Upload? = nil
    )
    {
        self.upload = upload
    }
}

struct GetUploadOutputResponseBody: Swift.Equatable {
    public let upload: DeviceFarmClientTypes.Upload?
}

extension GetUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case upload
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Upload.self, forKey: .upload)
        upload = uploadDecoded
    }
}

public struct GetVPCEConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVPCEConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVPCEConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVPCEConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVPCEConfigurationOutputError>
}

extension GetVPCEConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVPCEConfigurationInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetVPCEConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetVPCEConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVPCEConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVPCEConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVPCEConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVPCEConfigurationOutputError>
}

public struct GetVPCEConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVPCEConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVPCEConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVPCEConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVPCEConfigurationOutputError>
}

public struct GetVPCEConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVPCEConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetVPCEConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVPCEConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVPCEConfigurationOutputError>
}

public struct GetVPCEConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVPCEConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetVPCEConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVPCEConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVPCEConfigurationOutputError>
}

public struct GetVPCEConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to
    ///             describe.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetVPCEConfigurationInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetVPCEConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetVPCEConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVPCEConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVPCEConfigurationOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVPCEConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVPCEConfigurationOutputResponse(vpceConfiguration: \(Swift.String(describing: vpceConfiguration)))"}
}

extension GetVPCEConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVPCEConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpceConfiguration = output.vpceConfiguration
        } else {
            self.vpceConfiguration = nil
        }
    }
}

public struct GetVPCEConfigurationOutputResponse: Swift.Equatable {
    /// An object that contains information about your VPC endpoint configuration.
    public var vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration?

    public init (
        vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration? = nil
    )
    {
        self.vpceConfiguration = vpceConfiguration
    }
}

struct GetVPCEConfigurationOutputResponseBody: Swift.Equatable {
    public let vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration?
}

extension GetVPCEConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpceConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpceConfigurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.VPCEConfiguration.self, forKey: .vpceConfiguration)
        vpceConfiguration = vpceConfigurationDecoded
    }
}

extension IdempotencyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdempotencyException(message: \(Swift.String(describing: message)))"}
}

extension IdempotencyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IdempotencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An entity with the same name already exists.
public struct IdempotencyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any additional information about the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotencyExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IdempotencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeviceFarmClientTypes.IncompatibilityMessage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceAttribute.self, forKey: .type)
        type = typeDecoded
    }
}

extension DeviceFarmClientTypes.IncompatibilityMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncompatibilityMessage(message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension DeviceFarmClientTypes {
    /// Represents information about incompatibility.
    public struct IncompatibilityMessage: Swift.Equatable {
        /// A message about the incompatibility.
        public var message: Swift.String?
        /// The type of incompatibility.
        ///         Allowed values include:
        ///
        ///
        ///                 ARN
        ///
        ///
        ///                 FORM_FACTOR (for example, phone or tablet)
        ///
        ///
        ///                 MANUFACTURER
        ///
        ///
        ///                 PLATFORM (for example, Android or iOS)
        ///
        ///
        ///                 REMOTE_ACCESS_ENABLED
        ///
        ///
        ///                 APPIUM_VERSION
        ///
        ///
        public var type: DeviceFarmClientTypes.DeviceAttribute?

        public init (
            message: Swift.String? = nil,
            type: DeviceFarmClientTypes.DeviceAttribute? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

public struct InstallToRemoteAccessSessionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InstallToRemoteAccessSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InstallToRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InstallToRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InstallToRemoteAccessSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InstallToRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InstallToRemoteAccessSessionOutputError>
}

extension InstallToRemoteAccessSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstallToRemoteAccessSessionInput(appArn: \(Swift.String(describing: appArn)), remoteAccessSessionArn: \(Swift.String(describing: remoteAccessSessionArn)))"}
}

extension InstallToRemoteAccessSessionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case remoteAccessSessionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let remoteAccessSessionArn = remoteAccessSessionArn {
            try encodeContainer.encode(remoteAccessSessionArn, forKey: .remoteAccessSessionArn)
        }
    }
}

public struct InstallToRemoteAccessSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InstallToRemoteAccessSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InstallToRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InstallToRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InstallToRemoteAccessSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InstallToRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InstallToRemoteAccessSessionOutputError>
}

public struct InstallToRemoteAccessSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InstallToRemoteAccessSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InstallToRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InstallToRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InstallToRemoteAccessSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InstallToRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InstallToRemoteAccessSessionOutputError>
}

public struct InstallToRemoteAccessSessionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InstallToRemoteAccessSessionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: InstallToRemoteAccessSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InstallToRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = InstallToRemoteAccessSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<InstallToRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InstallToRemoteAccessSessionOutputError>
}

public struct InstallToRemoteAccessSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InstallToRemoteAccessSessionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: InstallToRemoteAccessSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InstallToRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = InstallToRemoteAccessSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<InstallToRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InstallToRemoteAccessSessionOutputError>
}

/// Represents the request to install an Android application (in .apk format) or an iOS
///             application (in .ipa format) as part of a remote access session.
public struct InstallToRemoteAccessSessionInput: Swift.Equatable {
    /// The ARN of the app about which you are requesting information.
    /// This member is required.
    public var appArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the remote access session about which you are
    ///             requesting information.
    /// This member is required.
    public var remoteAccessSessionArn: Swift.String?

    public init (
        appArn: Swift.String? = nil,
        remoteAccessSessionArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.remoteAccessSessionArn = remoteAccessSessionArn
    }
}

struct InstallToRemoteAccessSessionInputBody: Swift.Equatable {
    public let remoteAccessSessionArn: Swift.String?
    public let appArn: Swift.String?
}

extension InstallToRemoteAccessSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case remoteAccessSessionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteAccessSessionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteAccessSessionArn)
        remoteAccessSessionArn = remoteAccessSessionArnDecoded
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
    }
}

extension InstallToRemoteAccessSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InstallToRemoteAccessSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InstallToRemoteAccessSessionOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InstallToRemoteAccessSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstallToRemoteAccessSessionOutputResponse(appUpload: \(Swift.String(describing: appUpload)))"}
}

extension InstallToRemoteAccessSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InstallToRemoteAccessSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appUpload = output.appUpload
        } else {
            self.appUpload = nil
        }
    }
}

/// Represents the response from the server after AWS Device Farm makes a request to
///             install to a remote access session.
public struct InstallToRemoteAccessSessionOutputResponse: Swift.Equatable {
    /// An app to upload or that has been uploaded.
    public var appUpload: DeviceFarmClientTypes.Upload?

    public init (
        appUpload: DeviceFarmClientTypes.Upload? = nil
    )
    {
        self.appUpload = appUpload
    }
}

struct InstallToRemoteAccessSessionOutputResponseBody: Swift.Equatable {
    public let appUpload: DeviceFarmClientTypes.Upload?
}

extension InstallToRemoteAccessSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appUpload
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appUploadDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Upload.self, forKey: .appUpload)
        appUpload = appUploadDecoded
    }
}

extension DeviceFarmClientTypes.InstanceProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case excludeAppPackagesFromCleanup
        case name
        case packageCleanup
        case rebootAfterUse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup {
            var excludeAppPackagesFromCleanupContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeAppPackagesFromCleanup)
            for packageids0 in excludeAppPackagesFromCleanup {
                try excludeAppPackagesFromCleanupContainer.encode(packageids0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageCleanup = packageCleanup {
            try encodeContainer.encode(packageCleanup, forKey: .packageCleanup)
        }
        if let rebootAfterUse = rebootAfterUse {
            try encodeContainer.encode(rebootAfterUse, forKey: .rebootAfterUse)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let packageCleanupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .packageCleanup)
        packageCleanup = packageCleanupDecoded
        let excludeAppPackagesFromCleanupContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeAppPackagesFromCleanup)
        var excludeAppPackagesFromCleanupDecoded0:[Swift.String]? = nil
        if let excludeAppPackagesFromCleanupContainer = excludeAppPackagesFromCleanupContainer {
            excludeAppPackagesFromCleanupDecoded0 = [Swift.String]()
            for string0 in excludeAppPackagesFromCleanupContainer {
                if let string0 = string0 {
                    excludeAppPackagesFromCleanupDecoded0?.append(string0)
                }
            }
        }
        excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanupDecoded0
        let rebootAfterUseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rebootAfterUse)
        rebootAfterUse = rebootAfterUseDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DeviceFarmClientTypes.InstanceProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceProfile(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), excludeAppPackagesFromCleanup: \(Swift.String(describing: excludeAppPackagesFromCleanup)), name: \(Swift.String(describing: name)), packageCleanup: \(Swift.String(describing: packageCleanup)), rebootAfterUse: \(Swift.String(describing: rebootAfterUse)))"}
}

extension DeviceFarmClientTypes {
    /// Represents the instance profile.
    public struct InstanceProfile: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the instance profile.
        public var arn: Swift.String?
        /// The description of the instance profile.
        public var description: Swift.String?
        /// An array of strings containing the list of app packages that should not be cleaned up from the device
        ///             after a test run completes.
        ///         The list of packages is considered only if you set packageCleanup to
        ///             true.
        public var excludeAppPackagesFromCleanup: [Swift.String]?
        /// The name of the instance profile.
        public var name: Swift.String?
        /// When set to true, Device Farm removes app packages after a test run. The default value is
        ///                 false for private devices.
        public var packageCleanup: Swift.Bool?
        /// When set to true, Device Farm reboots the instance after a test run. The default value is
        ///                 true.
        public var rebootAfterUse: Swift.Bool?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            excludeAppPackagesFromCleanup: [Swift.String]? = nil,
            name: Swift.String? = nil,
            packageCleanup: Swift.Bool? = nil,
            rebootAfterUse: Swift.Bool? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
            self.name = name
            self.packageCleanup = packageCleanup
            self.rebootAfterUse = rebootAfterUse
        }
    }

}

extension DeviceFarmClientTypes {
    public enum InstanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case inUse
        case notAvailable
        case preparing
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceStatus] {
            return [
                .available,
                .inUse,
                .notAvailable,
                .preparing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .inUse: return "IN_USE"
            case .notAvailable: return "NOT_AVAILABLE"
            case .preparing: return "PREPARING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceStatus(rawValue: rawValue) ?? InstanceStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum InteractionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case interactive
        case noVideo
        case videoOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [InteractionMode] {
            return [
                .interactive,
                .noVideo,
                .videoOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .interactive: return "INTERACTIVE"
            case .noVideo: return "NO_VIDEO"
            case .videoOnly: return "VIDEO_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InteractionMode(rawValue: rawValue) ?? InteractionMode.sdkUnknown(rawValue)
        }
    }
}

extension InternalServiceException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServiceException(message: \(Swift.String(describing: message)))"}
}

extension InternalServiceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal exception was raised in the service. Contact <a href="mailto:aws-devicefarm-support@amazon.com">aws-devicefarm-support@amazon.com if you see this
///          error.
public struct InternalServiceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidOperationException(message: \(Swift.String(describing: message)))"}
}

extension InvalidOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an error with the update request, or you do not have sufficient permissions
///             to update this VPC endpoint configuration.
public struct InvalidOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOperationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeviceFarmClientTypes.Job: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case counters
        case created
        case device
        case deviceMinutes
        case instanceArn
        case message
        case name
        case result
        case started
        case status
        case stopped
        case type
        case videoCapture
        case videoEndpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let counters = counters {
            try encodeContainer.encode(counters, forKey: .counters)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let device = device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let deviceMinutes = deviceMinutes {
            try encodeContainer.encode(deviceMinutes, forKey: .deviceMinutes)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let result = result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let started = started {
            try encodeContainer.encode(started.timeIntervalSince1970, forKey: .started)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopped = stopped {
            try encodeContainer.encode(stopped.timeIntervalSince1970, forKey: .stopped)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let videoCapture = videoCapture {
            try encodeContainer.encode(videoCapture, forKey: .videoCapture)
        }
        if let videoEndpoint = videoEndpoint {
            try encodeContainer.encode(videoEndpoint, forKey: .videoEndpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestType.self, forKey: .type)
        type = typeDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let startedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .started)
        started = startedDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopped)
        stopped = stoppedDecoded
        let countersDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Counters.self, forKey: .counters)
        counters = countersDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let deviceMinutesDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceMinutes.self, forKey: .deviceMinutes)
        deviceMinutes = deviceMinutesDecoded
        let videoEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoEndpoint)
        videoEndpoint = videoEndpointDecoded
        let videoCaptureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .videoCapture)
        videoCapture = videoCaptureDecoded
    }
}

extension DeviceFarmClientTypes.Job: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Job(arn: \(Swift.String(describing: arn)), counters: \(Swift.String(describing: counters)), created: \(Swift.String(describing: created)), device: \(Swift.String(describing: device)), deviceMinutes: \(Swift.String(describing: deviceMinutes)), instanceArn: \(Swift.String(describing: instanceArn)), message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)), result: \(Swift.String(describing: result)), started: \(Swift.String(describing: started)), status: \(Swift.String(describing: status)), stopped: \(Swift.String(describing: stopped)), type: \(Swift.String(describing: type)), videoCapture: \(Swift.String(describing: videoCapture)), videoEndpoint: \(Swift.String(describing: videoEndpoint)))"}
}

extension DeviceFarmClientTypes {
    /// Represents a device.
    public struct Job: Swift.Equatable {
        /// The job's ARN.
        public var arn: Swift.String?
        /// The job's result counters.
        public var counters: DeviceFarmClientTypes.Counters?
        /// When the job was created.
        public var created: ClientRuntime.Date?
        /// The device (phone or tablet).
        public var device: DeviceFarmClientTypes.Device?
        /// Represents the total (metered or unmetered) minutes used by the job.
        public var deviceMinutes: DeviceFarmClientTypes.DeviceMinutes?
        /// The ARN of the instance.
        public var instanceArn: Swift.String?
        /// A message about the job's result.
        public var message: Swift.String?
        /// The job's name.
        public var name: Swift.String?
        /// The job's result.
        ///         Allowed values include:
        ///
        ///
        ///                 PENDING
        ///
        ///
        ///                 PASSED
        ///
        ///
        ///                 WARNED
        ///
        ///
        ///                 FAILED
        ///
        ///
        ///                 SKIPPED
        ///
        ///
        ///                 ERRORED
        ///
        ///
        ///                 STOPPED
        ///
        ///
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// The job's start time.
        public var started: ClientRuntime.Date?
        /// The job's status.
        ///         Allowed values include:
        ///
        ///
        ///                 PENDING
        ///
        ///
        ///                 PENDING_CONCURRENCY
        ///
        ///
        ///                 PENDING_DEVICE
        ///
        ///
        ///                 PROCESSING
        ///
        ///
        ///                 SCHEDULING
        ///
        ///
        ///                 PREPARING
        ///
        ///
        ///                 RUNNING
        ///
        ///
        ///                 COMPLETED
        ///
        ///
        ///                 STOPPING
        ///
        ///
        public var status: DeviceFarmClientTypes.ExecutionStatus?
        /// The job's stop time.
        public var stopped: ClientRuntime.Date?
        /// The job's type.
        ///         Allowed values include the following:
        ///
        ///
        ///                 BUILTIN_FUZZ
        ///
        ///
        ///                 BUILTIN_EXPLORER. For Android, an app explorer that traverses an Android app, interacting with
        ///                     it and capturing screenshots at the same time.
        ///
        ///
        ///                 APPIUM_JAVA_JUNIT
        ///
        ///
        ///                 APPIUM_JAVA_TESTNG
        ///
        ///
        ///                 APPIUM_PYTHON
        ///
        ///
        ///                 APPIUM_NODE
        ///
        ///
        ///                 APPIUM_RUBY
        ///
        ///
        ///                 APPIUM_WEB_JAVA_JUNIT
        ///
        ///
        ///                 APPIUM_WEB_JAVA_TESTNG
        ///
        ///
        ///                 APPIUM_WEB_PYTHON
        ///
        ///
        ///                 APPIUM_WEB_NODE
        ///
        ///
        ///                 APPIUM_WEB_RUBY
        ///
        ///
        ///                 CALABASH
        ///
        ///
        ///                 INSTRUMENTATION
        ///
        ///
        ///                 UIAUTOMATION
        ///
        ///
        ///                 UIAUTOMATOR
        ///
        ///
        ///                 XCTEST
        ///
        ///
        ///                 XCTEST_UI
        ///
        ///
        public var type: DeviceFarmClientTypes.TestType?
        /// This value is set to true if video capture is enabled. Otherwise, it is set to false.
        public var videoCapture: Swift.Bool?
        /// The endpoint for streaming device video.
        public var videoEndpoint: Swift.String?

        public init (
            arn: Swift.String? = nil,
            counters: DeviceFarmClientTypes.Counters? = nil,
            created: ClientRuntime.Date? = nil,
            device: DeviceFarmClientTypes.Device? = nil,
            deviceMinutes: DeviceFarmClientTypes.DeviceMinutes? = nil,
            instanceArn: Swift.String? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            started: ClientRuntime.Date? = nil,
            status: DeviceFarmClientTypes.ExecutionStatus? = nil,
            stopped: ClientRuntime.Date? = nil,
            type: DeviceFarmClientTypes.TestType? = nil,
            videoCapture: Swift.Bool? = nil,
            videoEndpoint: Swift.String? = nil
        )
        {
            self.arn = arn
            self.counters = counters
            self.created = created
            self.device = device
            self.deviceMinutes = deviceMinutes
            self.instanceArn = instanceArn
            self.message = message
            self.name = name
            self.result = result
            self.started = started
            self.status = status
            self.stopped = stopped
            self.type = type
            self.videoCapture = videoCapture
            self.videoEndpoint = videoEndpoint
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A limit was exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any additional information about the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListArtifactsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListArtifactsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListArtifactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListArtifactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListArtifactsOutputError>
}

extension ListArtifactsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListArtifactsInput(arn: \(Swift.String(describing: arn)), nextToken: \(Swift.String(describing: nextToken)), type: \(Swift.String(describing: type)))"}
}

extension ListArtifactsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct ListArtifactsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListArtifactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListArtifactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListArtifactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListArtifactsOutputError>
}

public struct ListArtifactsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListArtifactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListArtifactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListArtifactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListArtifactsOutputError>
}

public struct ListArtifactsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListArtifactsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListArtifactsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListArtifactsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListArtifactsOutputError>
}

public struct ListArtifactsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListArtifactsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListArtifactsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListArtifactsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListArtifactsOutputError>
}

/// Represents a request to the list artifacts operation.
public struct ListArtifactsInput: Swift.Equatable {
    /// The run, job, suite, or test ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The artifacts' type.
    ///         Allowed values include:
    ///
    ///
    ///                 FILE
    ///
    ///
    ///                 LOG
    ///
    ///
    ///                 SCREENSHOT
    ///
    ///
    /// This member is required.
    public var type: DeviceFarmClientTypes.ArtifactCategory?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        type: DeviceFarmClientTypes.ArtifactCategory? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListArtifactsInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let type: DeviceFarmClientTypes.ArtifactCategory?
    public let nextToken: Swift.String?
}

extension ListArtifactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ArtifactCategory.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListArtifactsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListArtifactsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListArtifactsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListArtifactsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListArtifactsOutputResponse(artifacts: \(Swift.String(describing: artifacts)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListArtifactsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListArtifactsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.artifacts = output.artifacts
            self.nextToken = output.nextToken
        } else {
            self.artifacts = nil
            self.nextToken = nil
        }
    }
}

/// Represents the result of a list artifacts operation.
public struct ListArtifactsOutputResponse: Swift.Equatable {
    /// Information about the artifacts.
    public var artifacts: [DeviceFarmClientTypes.Artifact]?
    /// If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.
    public var nextToken: Swift.String?

    public init (
        artifacts: [DeviceFarmClientTypes.Artifact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.artifacts = artifacts
        self.nextToken = nextToken
    }
}

struct ListArtifactsOutputResponseBody: Swift.Equatable {
    public let artifacts: [DeviceFarmClientTypes.Artifact]?
    public let nextToken: Swift.String?
}

extension ListArtifactsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifacts
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Artifact?].self, forKey: .artifacts)
        var artifactsDecoded0:[DeviceFarmClientTypes.Artifact]? = nil
        if let artifactsContainer = artifactsContainer {
            artifactsDecoded0 = [DeviceFarmClientTypes.Artifact]()
            for structure0 in artifactsContainer {
                if let structure0 = structure0 {
                    artifactsDecoded0?.append(structure0)
                }
            }
        }
        artifacts = artifactsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDeviceInstancesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeviceInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeviceInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeviceInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeviceInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeviceInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeviceInstancesOutputError>
}

extension ListDeviceInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeviceInstancesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDeviceInstancesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDeviceInstancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeviceInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeviceInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeviceInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeviceInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeviceInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeviceInstancesOutputError>
}

public struct ListDeviceInstancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeviceInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeviceInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeviceInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeviceInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeviceInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeviceInstancesOutputError>
}

public struct ListDeviceInstancesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeviceInstancesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDeviceInstancesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeviceInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDeviceInstancesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeviceInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeviceInstancesOutputError>
}

public struct ListDeviceInstancesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeviceInstancesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDeviceInstancesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeviceInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDeviceInstancesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeviceInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeviceInstancesOutputError>
}

public struct ListDeviceInstancesInput: Swift.Equatable {
    /// An integer that specifies the maximum number of items you want to return in the API response.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceInstancesInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListDeviceInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeviceInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeviceInstancesOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceInstancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeviceInstancesOutputResponse(deviceInstances: \(Swift.String(describing: deviceInstances)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDeviceInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDeviceInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceInstances = output.deviceInstances
            self.nextToken = output.nextToken
        } else {
            self.deviceInstances = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceInstancesOutputResponse: Swift.Equatable {
    /// An object that contains information about your device instances.
    public var deviceInstances: [DeviceFarmClientTypes.DeviceInstance]?
    /// An identifier that can be used in the next call to this operation to return the next
    ///             set of items in the list.
    public var nextToken: Swift.String?

    public init (
        deviceInstances: [DeviceFarmClientTypes.DeviceInstance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceInstances = deviceInstances
        self.nextToken = nextToken
    }
}

struct ListDeviceInstancesOutputResponseBody: Swift.Equatable {
    public let deviceInstances: [DeviceFarmClientTypes.DeviceInstance]?
    public let nextToken: Swift.String?
}

extension ListDeviceInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceInstances
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceInstancesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DeviceInstance?].self, forKey: .deviceInstances)
        var deviceInstancesDecoded0:[DeviceFarmClientTypes.DeviceInstance]? = nil
        if let deviceInstancesContainer = deviceInstancesContainer {
            deviceInstancesDecoded0 = [DeviceFarmClientTypes.DeviceInstance]()
            for structure0 in deviceInstancesContainer {
                if let structure0 = structure0 {
                    deviceInstancesDecoded0?.append(structure0)
                }
            }
        }
        deviceInstances = deviceInstancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDevicePoolsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicePoolsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevicePoolsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicePoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevicePoolsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicePoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicePoolsOutputError>
}

extension ListDevicePoolsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevicePoolsInput(arn: \(Swift.String(describing: arn)), nextToken: \(Swift.String(describing: nextToken)), type: \(Swift.String(describing: type)))"}
}

extension ListDevicePoolsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct ListDevicePoolsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicePoolsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevicePoolsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicePoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevicePoolsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicePoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicePoolsOutputError>
}

public struct ListDevicePoolsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicePoolsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevicePoolsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicePoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevicePoolsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicePoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicePoolsOutputError>
}

public struct ListDevicePoolsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicePoolsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDevicePoolsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicePoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDevicePoolsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicePoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicePoolsOutputError>
}

public struct ListDevicePoolsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicePoolsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDevicePoolsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicePoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDevicePoolsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicePoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicePoolsOutputError>
}

/// Represents the result of a list device pools request.
public struct ListDevicePoolsInput: Swift.Equatable {
    /// The project ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The device pools' type.
    ///         Allowed values include:
    ///
    ///
    ///                 CURATED: A device pool that is created and managed by AWS Device
    ///                     Farm.
    ///
    ///
    ///                 PRIVATE: A device pool that is created and managed by the device pool
    ///                     developer.
    ///
    ///
    public var type: DeviceFarmClientTypes.DevicePoolType?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        type: DeviceFarmClientTypes.DevicePoolType? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListDevicePoolsInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let type: DeviceFarmClientTypes.DevicePoolType?
    public let nextToken: Swift.String?
}

extension ListDevicePoolsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePoolType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDevicePoolsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicePoolsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDevicePoolsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicePoolsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevicePoolsOutputResponse(devicePools: \(Swift.String(describing: devicePools)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDevicePoolsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDevicePoolsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devicePools = output.devicePools
            self.nextToken = output.nextToken
        } else {
            self.devicePools = nil
            self.nextToken = nil
        }
    }
}

/// Represents the result of a list device pools request.
public struct ListDevicePoolsOutputResponse: Swift.Equatable {
    /// Information about the device pools.
    public var devicePools: [DeviceFarmClientTypes.DevicePool]?
    /// If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.
    public var nextToken: Swift.String?

    public init (
        devicePools: [DeviceFarmClientTypes.DevicePool]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devicePools = devicePools
        self.nextToken = nextToken
    }
}

struct ListDevicePoolsOutputResponseBody: Swift.Equatable {
    public let devicePools: [DeviceFarmClientTypes.DevicePool]?
    public let nextToken: Swift.String?
}

extension ListDevicePoolsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePools
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePoolsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DevicePool?].self, forKey: .devicePools)
        var devicePoolsDecoded0:[DeviceFarmClientTypes.DevicePool]? = nil
        if let devicePoolsContainer = devicePoolsContainer {
            devicePoolsDecoded0 = [DeviceFarmClientTypes.DevicePool]()
            for structure0 in devicePoolsContainer {
                if let structure0 = structure0 {
                    devicePoolsDecoded0?.append(structure0)
                }
            }
        }
        devicePools = devicePoolsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDevicesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicesOutputError>
}

extension ListDevicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevicesInput(arn: \(Swift.String(describing: arn)), filters: \(Swift.String(describing: filters)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDevicesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case filters
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for devicefilters0 in filters {
                try filtersContainer.encode(devicefilters0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDevicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicesOutputError>
}

public struct ListDevicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicesOutputError>
}

public struct ListDevicesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDevicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDevicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicesOutputError>
}

public struct ListDevicesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDevicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDevicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicesOutputError>
}

/// Represents the result of a list devices request.
public struct ListDevicesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project.
    public var arn: Swift.String?
    /// Used to select a set of devices. A filter is made up of an attribute, an operator, and
    ///             one or more values.
    ///
    ///
    ///                 Attribute: The aspect of a device such as platform or model used as the
    ///                     selection criteria in a device filter.
    ///                 Allowed values include:
    ///
    ///
    ///                         ARN: The Amazon Resource Name (ARN) of the device (for example,
    ///                                 arn:aws:devicefarm:us-west-2::device:12345Example).
    ///
    ///
    ///                         PLATFORM: The device platform. Valid values are ANDROID or IOS.
    ///
    ///
    ///                         OS_VERSION: The operating system version (for example, 10.3.2).
    ///
    ///
    ///                         MODEL: The device model (for example, iPad 5th Gen).
    ///
    ///
    ///                         AVAILABILITY: The current availability of the device. Valid values are AVAILABLE,
    ///                             HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.
    ///
    ///
    ///                         FORM_FACTOR: The device form factor. Valid values are PHONE or TABLET.
    ///
    ///
    ///                         MANUFACTURER: The device manufacturer (for example, Apple).
    ///
    ///
    ///                         REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access. Valid values
    ///                             are TRUE or FALSE.
    ///
    ///
    ///                         REMOTE_DEBUG_ENABLED: Whether the device is enabled for remote debugging. Valid values
    ///                             are TRUE or FALSE. Because remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
    ///                                 longer supported, this attribute is ignored.
    ///
    ///
    ///                         INSTANCE_ARN: The Amazon Resource Name (ARN) of the device
    ///                             instance.
    ///
    ///
    ///                         INSTANCE_LABELS: The label of the device instance.
    ///
    ///
    ///                         FLEET_TYPE: The fleet type. Valid values are PUBLIC or PRIVATE.
    ///
    ///
    ///
    ///
    ///                 Operator: The filter operator.
    ///
    ///
    ///                         The EQUALS operator is available for every attribute except
    ///                             INSTANCE_LABELS.
    ///
    ///
    ///                         The CONTAINS operator is available for the INSTANCE_LABELS and MODEL
    ///                             attributes.
    ///
    ///
    ///                         The IN and NOT_IN operators are available for the ARN, OS_VERSION,
    ///                             MODEL, MANUFACTURER, and INSTANCE_ARN attributes.
    ///
    ///
    ///                         The LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUALS, and
    ///                             GREATER_THAN_OR_EQUALS operators are also available for the OS_VERSION
    ///                             attribute.
    ///
    ///
    ///
    ///
    ///                 Values: An array of one or more filter values.
    ///
    ///
    ///                         The IN and NOT_IN operators take a values array that has one or more
    ///                             elements.
    ///
    ///
    ///                         The other operators require an array with a single element.
    ///
    ///
    ///                         In a request, the AVAILABILITY attribute takes the following values: AVAILABLE,
    ///                             HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.
    ///
    ///
    ///
    ///
    public var filters: [DeviceFarmClientTypes.DeviceFilter]?
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        filters: [DeviceFarmClientTypes.DeviceFilter]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.filters = filters
        self.nextToken = nextToken
    }
}

struct ListDevicesInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let nextToken: Swift.String?
    public let filters: [DeviceFarmClientTypes.DeviceFilter]?
}

extension ListDevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case filters
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.DeviceFilter?].self, forKey: .filters)
        var filtersDecoded0:[DeviceFarmClientTypes.DeviceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DeviceFarmClientTypes.DeviceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDevicesOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevicesOutputResponse(devices: \(Swift.String(describing: devices)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

/// Represents the result of a list devices operation.
public struct ListDevicesOutputResponse: Swift.Equatable {
    /// Information about the devices.
    public var devices: [DeviceFarmClientTypes.Device]?
    /// If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.
    public var nextToken: Swift.String?

    public init (
        devices: [DeviceFarmClientTypes.Device]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct ListDevicesOutputResponseBody: Swift.Equatable {
    public let devices: [DeviceFarmClientTypes.Device]?
    public let nextToken: Swift.String?
}

extension ListDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Device?].self, forKey: .devices)
        var devicesDecoded0:[DeviceFarmClientTypes.Device]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [DeviceFarmClientTypes.Device]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListInstanceProfilesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInstanceProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInstanceProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInstanceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInstanceProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInstanceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInstanceProfilesOutputError>
}

extension ListInstanceProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInstanceProfilesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListInstanceProfilesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListInstanceProfilesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInstanceProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInstanceProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInstanceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInstanceProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInstanceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInstanceProfilesOutputError>
}

public struct ListInstanceProfilesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInstanceProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInstanceProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInstanceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInstanceProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInstanceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInstanceProfilesOutputError>
}

public struct ListInstanceProfilesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInstanceProfilesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListInstanceProfilesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInstanceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListInstanceProfilesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListInstanceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInstanceProfilesOutputError>
}

public struct ListInstanceProfilesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInstanceProfilesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListInstanceProfilesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInstanceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListInstanceProfilesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListInstanceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInstanceProfilesOutputError>
}

public struct ListInstanceProfilesInput: Swift.Equatable {
    /// An integer that specifies the maximum number of items you want to return in the API response.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstanceProfilesInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListInstanceProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstanceProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstanceProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstanceProfilesOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstanceProfilesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInstanceProfilesOutputResponse(instanceProfiles: \(Swift.String(describing: instanceProfiles)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListInstanceProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInstanceProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfiles = output.instanceProfiles
            self.nextToken = output.nextToken
        } else {
            self.instanceProfiles = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstanceProfilesOutputResponse: Swift.Equatable {
    /// An object that contains information about your instance profiles.
    public var instanceProfiles: [DeviceFarmClientTypes.InstanceProfile]?
    /// An identifier that can be used in the next call to this operation to return the next
    ///             set of items in the list.
    public var nextToken: Swift.String?

    public init (
        instanceProfiles: [DeviceFarmClientTypes.InstanceProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.nextToken = nextToken
    }
}

struct ListInstanceProfilesOutputResponseBody: Swift.Equatable {
    public let instanceProfiles: [DeviceFarmClientTypes.InstanceProfile]?
    public let nextToken: Swift.String?
}

extension ListInstanceProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfiles
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfilesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.InstanceProfile?].self, forKey: .instanceProfiles)
        var instanceProfilesDecoded0:[DeviceFarmClientTypes.InstanceProfile]? = nil
        if let instanceProfilesContainer = instanceProfilesContainer {
            instanceProfilesDecoded0 = [DeviceFarmClientTypes.InstanceProfile]()
            for structure0 in instanceProfilesContainer {
                if let structure0 = structure0 {
                    instanceProfilesDecoded0?.append(structure0)
                }
            }
        }
        instanceProfiles = instanceProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsOutputError>
}

extension ListJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListJobsInput(arn: \(Swift.String(describing: arn)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsOutputError>
}

public struct ListJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsOutputError>
}

public struct ListJobsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsOutputError>
}

public struct ListJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsOutputError>
}

/// Represents a request to the list jobs operation.
public struct ListJobsInput: Swift.Equatable {
    /// The run's Amazon Resource Name (ARN).
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListJobsInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let nextToken: Swift.String?
}

extension ListJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListJobsOutputResponse(jobs: \(Swift.String(describing: jobs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

/// Represents the result of a list jobs request.
public struct ListJobsOutputResponse: Swift.Equatable {
    /// Information about the jobs.
    public var jobs: [DeviceFarmClientTypes.Job]?
    /// If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.
    public var nextToken: Swift.String?

    public init (
        jobs: [DeviceFarmClientTypes.Job]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListJobsOutputResponseBody: Swift.Equatable {
    public let jobs: [DeviceFarmClientTypes.Job]?
    public let nextToken: Swift.String?
}

extension ListJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Job?].self, forKey: .jobs)
        var jobsDecoded0:[DeviceFarmClientTypes.Job]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [DeviceFarmClientTypes.Job]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListNetworkProfilesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNetworkProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNetworkProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNetworkProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNetworkProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNetworkProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNetworkProfilesOutputError>
}

extension ListNetworkProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListNetworkProfilesInput(arn: \(Swift.String(describing: arn)), nextToken: \(Swift.String(describing: nextToken)), type: \(Swift.String(describing: type)))"}
}

extension ListNetworkProfilesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct ListNetworkProfilesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNetworkProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNetworkProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNetworkProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNetworkProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNetworkProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNetworkProfilesOutputError>
}

public struct ListNetworkProfilesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNetworkProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNetworkProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNetworkProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNetworkProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNetworkProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNetworkProfilesOutputError>
}

public struct ListNetworkProfilesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNetworkProfilesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListNetworkProfilesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNetworkProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListNetworkProfilesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListNetworkProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNetworkProfilesOutputError>
}

public struct ListNetworkProfilesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNetworkProfilesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListNetworkProfilesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNetworkProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListNetworkProfilesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListNetworkProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNetworkProfilesOutputError>
}

public struct ListNetworkProfilesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project for which you want to list network
    ///             profiles.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The type of network profile to return information about. Valid values are listed here.
    public var type: DeviceFarmClientTypes.NetworkProfileType?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        type: DeviceFarmClientTypes.NetworkProfileType? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListNetworkProfilesInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let type: DeviceFarmClientTypes.NetworkProfileType?
    public let nextToken: Swift.String?
}

extension ListNetworkProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfileType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNetworkProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNetworkProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNetworkProfilesOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNetworkProfilesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListNetworkProfilesOutputResponse(networkProfiles: \(Swift.String(describing: networkProfiles)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListNetworkProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListNetworkProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkProfiles = output.networkProfiles
            self.nextToken = output.nextToken
        } else {
            self.networkProfiles = nil
            self.nextToken = nil
        }
    }
}

public struct ListNetworkProfilesOutputResponse: Swift.Equatable {
    /// A list of the available network profiles.
    public var networkProfiles: [DeviceFarmClientTypes.NetworkProfile]?
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        networkProfiles: [DeviceFarmClientTypes.NetworkProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkProfiles = networkProfiles
        self.nextToken = nextToken
    }
}

struct ListNetworkProfilesOutputResponseBody: Swift.Equatable {
    public let networkProfiles: [DeviceFarmClientTypes.NetworkProfile]?
    public let nextToken: Swift.String?
}

extension ListNetworkProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfiles
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfilesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.NetworkProfile?].self, forKey: .networkProfiles)
        var networkProfilesDecoded0:[DeviceFarmClientTypes.NetworkProfile]? = nil
        if let networkProfilesContainer = networkProfilesContainer {
            networkProfilesDecoded0 = [DeviceFarmClientTypes.NetworkProfile]()
            for structure0 in networkProfilesContainer {
                if let structure0 = structure0 {
                    networkProfilesDecoded0?.append(structure0)
                }
            }
        }
        networkProfiles = networkProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOfferingPromotionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOfferingPromotionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOfferingPromotionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOfferingPromotionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOfferingPromotionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOfferingPromotionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOfferingPromotionsOutputError>
}

extension ListOfferingPromotionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOfferingPromotionsInput(nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListOfferingPromotionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListOfferingPromotionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOfferingPromotionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOfferingPromotionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOfferingPromotionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOfferingPromotionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOfferingPromotionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOfferingPromotionsOutputError>
}

public struct ListOfferingPromotionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOfferingPromotionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOfferingPromotionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOfferingPromotionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOfferingPromotionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOfferingPromotionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOfferingPromotionsOutputError>
}

public struct ListOfferingPromotionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOfferingPromotionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListOfferingPromotionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOfferingPromotionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOfferingPromotionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOfferingPromotionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOfferingPromotionsOutputError>
}

public struct ListOfferingPromotionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOfferingPromotionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListOfferingPromotionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOfferingPromotionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOfferingPromotionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOfferingPromotionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOfferingPromotionsOutputError>
}

public struct ListOfferingPromotionsInput: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListOfferingPromotionsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
}

extension ListOfferingPromotionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOfferingPromotionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOfferingPromotionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOfferingPromotionsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOfferingPromotionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOfferingPromotionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), offeringPromotions: \(Swift.String(describing: offeringPromotions)))"}
}

extension ListOfferingPromotionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOfferingPromotionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.offeringPromotions = output.offeringPromotions
        } else {
            self.nextToken = nil
            self.offeringPromotions = nil
        }
    }
}

public struct ListOfferingPromotionsOutputResponse: Swift.Equatable {
    /// An identifier to be used in the next call to this operation, to return the next set
    ///             of items in the list.
    public var nextToken: Swift.String?
    /// Information about the offering promotions.
    public var offeringPromotions: [DeviceFarmClientTypes.OfferingPromotion]?

    public init (
        nextToken: Swift.String? = nil,
        offeringPromotions: [DeviceFarmClientTypes.OfferingPromotion]? = nil
    )
    {
        self.nextToken = nextToken
        self.offeringPromotions = offeringPromotions
    }
}

struct ListOfferingPromotionsOutputResponseBody: Swift.Equatable {
    public let offeringPromotions: [DeviceFarmClientTypes.OfferingPromotion]?
    public let nextToken: Swift.String?
}

extension ListOfferingPromotionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case offeringPromotions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringPromotionsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.OfferingPromotion?].self, forKey: .offeringPromotions)
        var offeringPromotionsDecoded0:[DeviceFarmClientTypes.OfferingPromotion]? = nil
        if let offeringPromotionsContainer = offeringPromotionsContainer {
            offeringPromotionsDecoded0 = [DeviceFarmClientTypes.OfferingPromotion]()
            for structure0 in offeringPromotionsContainer {
                if let structure0 = structure0 {
                    offeringPromotionsDecoded0?.append(structure0)
                }
            }
        }
        offeringPromotions = offeringPromotionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOfferingTransactionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOfferingTransactionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOfferingTransactionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOfferingTransactionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOfferingTransactionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOfferingTransactionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOfferingTransactionsOutputError>
}

extension ListOfferingTransactionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOfferingTransactionsInput(nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListOfferingTransactionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListOfferingTransactionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOfferingTransactionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOfferingTransactionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOfferingTransactionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOfferingTransactionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOfferingTransactionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOfferingTransactionsOutputError>
}

public struct ListOfferingTransactionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOfferingTransactionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOfferingTransactionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOfferingTransactionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOfferingTransactionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOfferingTransactionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOfferingTransactionsOutputError>
}

public struct ListOfferingTransactionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOfferingTransactionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListOfferingTransactionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOfferingTransactionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOfferingTransactionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOfferingTransactionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOfferingTransactionsOutputError>
}

public struct ListOfferingTransactionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOfferingTransactionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListOfferingTransactionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOfferingTransactionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOfferingTransactionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOfferingTransactionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOfferingTransactionsOutputError>
}

/// Represents the request to list the offering transaction history.
public struct ListOfferingTransactionsInput: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListOfferingTransactionsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
}

extension ListOfferingTransactionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOfferingTransactionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOfferingTransactionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOfferingTransactionsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOfferingTransactionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOfferingTransactionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), offeringTransactions: \(Swift.String(describing: offeringTransactions)))"}
}

extension ListOfferingTransactionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOfferingTransactionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.offeringTransactions = output.offeringTransactions
        } else {
            self.nextToken = nil
            self.offeringTransactions = nil
        }
    }
}

/// Returns the transaction log of the specified offerings.
public struct ListOfferingTransactionsOutputResponse: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The audit log of subscriptions you have purchased and modified through AWS Device
    ///             Farm.
    public var offeringTransactions: [DeviceFarmClientTypes.OfferingTransaction]?

    public init (
        nextToken: Swift.String? = nil,
        offeringTransactions: [DeviceFarmClientTypes.OfferingTransaction]? = nil
    )
    {
        self.nextToken = nextToken
        self.offeringTransactions = offeringTransactions
    }
}

struct ListOfferingTransactionsOutputResponseBody: Swift.Equatable {
    public let offeringTransactions: [DeviceFarmClientTypes.OfferingTransaction]?
    public let nextToken: Swift.String?
}

extension ListOfferingTransactionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case offeringTransactions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringTransactionsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.OfferingTransaction?].self, forKey: .offeringTransactions)
        var offeringTransactionsDecoded0:[DeviceFarmClientTypes.OfferingTransaction]? = nil
        if let offeringTransactionsContainer = offeringTransactionsContainer {
            offeringTransactionsDecoded0 = [DeviceFarmClientTypes.OfferingTransaction]()
            for structure0 in offeringTransactionsContainer {
                if let structure0 = structure0 {
                    offeringTransactionsDecoded0?.append(structure0)
                }
            }
        }
        offeringTransactions = offeringTransactionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOfferingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOfferingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOfferingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOfferingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOfferingsOutputError>
}

extension ListOfferingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOfferingsInput(nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListOfferingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListOfferingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOfferingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOfferingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOfferingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOfferingsOutputError>
}

public struct ListOfferingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOfferingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOfferingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOfferingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOfferingsOutputError>
}

public struct ListOfferingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOfferingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListOfferingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOfferingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOfferingsOutputError>
}

public struct ListOfferingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOfferingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListOfferingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOfferingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOfferingsOutputError>
}

/// Represents the request to list all offerings.
public struct ListOfferingsInput: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListOfferingsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
}

extension ListOfferingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOfferingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOfferingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOfferingsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOfferingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOfferingsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), offerings: \(Swift.String(describing: offerings)))"}
}

extension ListOfferingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.offerings = output.offerings
        } else {
            self.nextToken = nil
            self.offerings = nil
        }
    }
}

/// Represents the return values of the list of offerings.
public struct ListOfferingsOutputResponse: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// A value that represents the list offering results.
    public var offerings: [DeviceFarmClientTypes.Offering]?

    public init (
        nextToken: Swift.String? = nil,
        offerings: [DeviceFarmClientTypes.Offering]? = nil
    )
    {
        self.nextToken = nextToken
        self.offerings = offerings
    }
}

struct ListOfferingsOutputResponseBody: Swift.Equatable {
    public let offerings: [DeviceFarmClientTypes.Offering]?
    public let nextToken: Swift.String?
}

extension ListOfferingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case offerings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Offering?].self, forKey: .offerings)
        var offeringsDecoded0:[DeviceFarmClientTypes.Offering]? = nil
        if let offeringsContainer = offeringsContainer {
            offeringsDecoded0 = [DeviceFarmClientTypes.Offering]()
            for structure0 in offeringsContainer {
                if let structure0 = structure0 {
                    offeringsDecoded0?.append(structure0)
                }
            }
        }
        offerings = offeringsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListProjectsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

extension ListProjectsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectsInput(arn: \(Swift.String(describing: arn)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListProjectsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListProjectsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListProjectsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProjectsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListProjectsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProjectsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

/// Represents a request to the list projects operation.
public struct ListProjectsInput: Swift.Equatable {
    /// Optional. If no Amazon Resource Name (ARN) is specified, then AWS Device Farm
    ///             returns a list of all projects for the AWS account. You can also specify a project
    ///             ARN.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let nextToken: Swift.String?
}

extension ListProjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), projects: \(Swift.String(describing: projects)))"}
}

extension ListProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

/// Represents the result of a list projects request.
public struct ListProjectsOutputResponse: Swift.Equatable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.
    public var nextToken: Swift.String?
    /// Information about the projects.
    public var projects: [DeviceFarmClientTypes.Project]?

    public init (
        nextToken: Swift.String? = nil,
        projects: [DeviceFarmClientTypes.Project]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Swift.Equatable {
    public let projects: [DeviceFarmClientTypes.Project]?
    public let nextToken: Swift.String?
}

extension ListProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Project?].self, forKey: .projects)
        var projectsDecoded0:[DeviceFarmClientTypes.Project]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [DeviceFarmClientTypes.Project]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRemoteAccessSessionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRemoteAccessSessionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRemoteAccessSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRemoteAccessSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRemoteAccessSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRemoteAccessSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRemoteAccessSessionsOutputError>
}

extension ListRemoteAccessSessionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRemoteAccessSessionsInput(arn: \(Swift.String(describing: arn)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRemoteAccessSessionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRemoteAccessSessionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRemoteAccessSessionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRemoteAccessSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRemoteAccessSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRemoteAccessSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRemoteAccessSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRemoteAccessSessionsOutputError>
}

public struct ListRemoteAccessSessionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRemoteAccessSessionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRemoteAccessSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRemoteAccessSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRemoteAccessSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRemoteAccessSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRemoteAccessSessionsOutputError>
}

public struct ListRemoteAccessSessionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRemoteAccessSessionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListRemoteAccessSessionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRemoteAccessSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRemoteAccessSessionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRemoteAccessSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRemoteAccessSessionsOutputError>
}

public struct ListRemoteAccessSessionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRemoteAccessSessionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListRemoteAccessSessionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRemoteAccessSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRemoteAccessSessionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRemoteAccessSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRemoteAccessSessionsOutputError>
}

/// Represents the request to return information about the remote access
///             session.
public struct ListRemoteAccessSessionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project about which you are requesting
    ///             information.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListRemoteAccessSessionsInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let nextToken: Swift.String?
}

extension ListRemoteAccessSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRemoteAccessSessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRemoteAccessSessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRemoteAccessSessionsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRemoteAccessSessionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRemoteAccessSessionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), remoteAccessSessions: \(Swift.String(describing: remoteAccessSessions)))"}
}

extension ListRemoteAccessSessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRemoteAccessSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.remoteAccessSessions = output.remoteAccessSessions
        } else {
            self.nextToken = nil
            self.remoteAccessSessions = nil
        }
    }
}

/// Represents the response from the server after AWS Device Farm makes a request to
///             return information about the remote access session.
public struct ListRemoteAccessSessionsOutputResponse: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// A container that represents the metadata from the service about each remote access session you are
    ///             requesting.
    public var remoteAccessSessions: [DeviceFarmClientTypes.RemoteAccessSession]?

    public init (
        nextToken: Swift.String? = nil,
        remoteAccessSessions: [DeviceFarmClientTypes.RemoteAccessSession]? = nil
    )
    {
        self.nextToken = nextToken
        self.remoteAccessSessions = remoteAccessSessions
    }
}

struct ListRemoteAccessSessionsOutputResponseBody: Swift.Equatable {
    public let remoteAccessSessions: [DeviceFarmClientTypes.RemoteAccessSession]?
    public let nextToken: Swift.String?
}

extension ListRemoteAccessSessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case remoteAccessSessions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteAccessSessionsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.RemoteAccessSession?].self, forKey: .remoteAccessSessions)
        var remoteAccessSessionsDecoded0:[DeviceFarmClientTypes.RemoteAccessSession]? = nil
        if let remoteAccessSessionsContainer = remoteAccessSessionsContainer {
            remoteAccessSessionsDecoded0 = [DeviceFarmClientTypes.RemoteAccessSession]()
            for structure0 in remoteAccessSessionsContainer {
                if let structure0 = structure0 {
                    remoteAccessSessionsDecoded0?.append(structure0)
                }
            }
        }
        remoteAccessSessions = remoteAccessSessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRunsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRunsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRunsOutputError>
}

extension ListRunsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRunsInput(arn: \(Swift.String(describing: arn)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRunsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRunsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRunsOutputError>
}

public struct ListRunsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRunsOutputError>
}

public struct ListRunsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRunsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListRunsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRunsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRunsOutputError>
}

public struct ListRunsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRunsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListRunsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRunsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRunsOutputError>
}

/// Represents a request to the list runs operation.
public struct ListRunsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project for which you want to list
    ///             runs.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListRunsInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let nextToken: Swift.String?
}

extension ListRunsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRunsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRunsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRunsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRunsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRunsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), runs: \(Swift.String(describing: runs)))"}
}

extension ListRunsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRunsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.runs = output.runs
        } else {
            self.nextToken = nil
            self.runs = nil
        }
    }
}

/// Represents the result of a list runs request.
public struct ListRunsOutputResponse: Swift.Equatable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.
    public var nextToken: Swift.String?
    /// Information about the runs.
    public var runs: [DeviceFarmClientTypes.Run]?

    public init (
        nextToken: Swift.String? = nil,
        runs: [DeviceFarmClientTypes.Run]? = nil
    )
    {
        self.nextToken = nextToken
        self.runs = runs
    }
}

struct ListRunsOutputResponseBody: Swift.Equatable {
    public let runs: [DeviceFarmClientTypes.Run]?
    public let nextToken: Swift.String?
}

extension ListRunsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case runs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Run?].self, forKey: .runs)
        var runsDecoded0:[DeviceFarmClientTypes.Run]? = nil
        if let runsContainer = runsContainer {
            runsDecoded0 = [DeviceFarmClientTypes.Run]()
            for structure0 in runsContainer {
                if let structure0 = structure0 {
                    runsDecoded0?.append(structure0)
                }
            }
        }
        runs = runsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSamplesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSamplesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSamplesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSamplesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSamplesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSamplesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSamplesOutputError>
}

extension ListSamplesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSamplesInput(arn: \(Swift.String(describing: arn)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSamplesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSamplesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSamplesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSamplesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSamplesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSamplesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSamplesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSamplesOutputError>
}

public struct ListSamplesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSamplesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSamplesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSamplesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSamplesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSamplesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSamplesOutputError>
}

public struct ListSamplesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSamplesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListSamplesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSamplesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSamplesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSamplesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSamplesOutputError>
}

public struct ListSamplesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSamplesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListSamplesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSamplesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSamplesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSamplesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSamplesOutputError>
}

/// Represents a request to the list samples operation.
public struct ListSamplesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the job used to list samples.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListSamplesInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let nextToken: Swift.String?
}

extension ListSamplesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSamplesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSamplesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSamplesOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSamplesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSamplesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), samples: \(Swift.String(describing: samples)))"}
}

extension ListSamplesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSamplesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.samples = output.samples
        } else {
            self.nextToken = nil
            self.samples = nil
        }
    }
}

/// Represents the result of a list samples request.
public struct ListSamplesOutputResponse: Swift.Equatable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.
    public var nextToken: Swift.String?
    /// Information about the samples.
    public var samples: [DeviceFarmClientTypes.Sample]?

    public init (
        nextToken: Swift.String? = nil,
        samples: [DeviceFarmClientTypes.Sample]? = nil
    )
    {
        self.nextToken = nextToken
        self.samples = samples
    }
}

struct ListSamplesOutputResponseBody: Swift.Equatable {
    public let samples: [DeviceFarmClientTypes.Sample]?
    public let nextToken: Swift.String?
}

extension ListSamplesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case samples
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Sample?].self, forKey: .samples)
        var samplesDecoded0:[DeviceFarmClientTypes.Sample]? = nil
        if let samplesContainer = samplesContainer {
            samplesDecoded0 = [DeviceFarmClientTypes.Sample]()
            for structure0 in samplesContainer {
                if let structure0 = structure0 {
                    samplesDecoded0?.append(structure0)
                }
            }
        }
        samples = samplesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSuitesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuitesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSuitesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSuitesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuitesOutputError>
}

extension ListSuitesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSuitesInput(arn: \(Swift.String(describing: arn)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSuitesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSuitesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuitesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSuitesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSuitesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuitesOutputError>
}

public struct ListSuitesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuitesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSuitesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSuitesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuitesOutputError>
}

public struct ListSuitesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuitesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListSuitesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSuitesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuitesOutputError>
}

public struct ListSuitesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuitesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListSuitesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSuitesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuitesOutputError>
}

/// Represents a request to the list suites operation.
public struct ListSuitesInput: Swift.Equatable {
    /// The job's Amazon Resource Name (ARN).
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListSuitesInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let nextToken: Swift.String?
}

extension ListSuitesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSuitesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSuitesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSuitesOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSuitesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSuitesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), suites: \(Swift.String(describing: suites)))"}
}

extension ListSuitesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSuitesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.suites = output.suites
        } else {
            self.nextToken = nil
            self.suites = nil
        }
    }
}

/// Represents the result of a list suites request.
public struct ListSuitesOutputResponse: Swift.Equatable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.
    public var nextToken: Swift.String?
    /// Information about the suites.
    public var suites: [DeviceFarmClientTypes.Suite]?

    public init (
        nextToken: Swift.String? = nil,
        suites: [DeviceFarmClientTypes.Suite]? = nil
    )
    {
        self.nextToken = nextToken
        self.suites = suites
    }
}

struct ListSuitesOutputResponseBody: Swift.Equatable {
    public let suites: [DeviceFarmClientTypes.Suite]?
    public let nextToken: Swift.String?
}

extension ListSuitesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case suites
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suitesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Suite?].self, forKey: .suites)
        var suitesDecoded0:[DeviceFarmClientTypes.Suite]? = nil
        if let suitesContainer = suitesContainer {
            suitesDecoded0 = [DeviceFarmClientTypes.Suite]()
            for structure0 in suitesContainer {
                if let structure0 = structure0 {
                    suitesDecoded0?.append(structure0)
                }
            }
        }
        suites = suitesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource or resources for which to list tags. You can associate tags
    ///             with the following Device Farm resources: PROJECT, RUN,
    ///                 NETWORK_PROFILE, INSTANCE_PROFILE, DEVICE_INSTANCE,
    ///                 SESSION, DEVICE_POOL, DEVICE, and
    ///             VPCE_CONFIGURATION.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOperationException" : self = .tagOperationException(try TagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case notFoundException(NotFoundException)
    case tagOperationException(TagOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum
    ///             character length of 128 characters. Tag values can have a maximum length of 256 characters.
    public var tags: [DeviceFarmClientTypes.Tag]?

    public init (
        tags: [DeviceFarmClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [DeviceFarmClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DeviceFarmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DeviceFarmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListTestGridProjectsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridProjectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestGridProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestGridProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridProjectsOutputError>
}

extension ListTestGridProjectsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTestGridProjectsInput(maxResult: \(Swift.String(describing: maxResult)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTestGridProjectsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResult
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResult = maxResult {
            try encodeContainer.encode(maxResult, forKey: .maxResult)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTestGridProjectsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestGridProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestGridProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridProjectsOutputError>
}

public struct ListTestGridProjectsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestGridProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestGridProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridProjectsOutputError>
}

public struct ListTestGridProjectsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridProjectsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTestGridProjectsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTestGridProjectsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridProjectsOutputError>
}

public struct ListTestGridProjectsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridProjectsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTestGridProjectsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTestGridProjectsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridProjectsOutputError>
}

public struct ListTestGridProjectsInput: Swift.Equatable {
    /// Return no more than this number of results.
    public var maxResult: Swift.Int?
    /// From a response, used to continue a paginated listing.
    public var nextToken: Swift.String?

    public init (
        maxResult: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResult = maxResult
        self.nextToken = nextToken
    }
}

struct ListTestGridProjectsInputBody: Swift.Equatable {
    public let maxResult: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListTestGridProjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResult
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResult)
        maxResult = maxResultDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestGridProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestGridProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTestGridProjectsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestGridProjectsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTestGridProjectsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), testGridProjects: \(Swift.String(describing: testGridProjects)))"}
}

extension ListTestGridProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTestGridProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.testGridProjects = output.testGridProjects
        } else {
            self.nextToken = nil
            self.testGridProjects = nil
        }
    }
}

public struct ListTestGridProjectsOutputResponse: Swift.Equatable {
    /// Used for pagination. Pass into ListTestGridProjects to get more results in a paginated
    ///          request.
    public var nextToken: Swift.String?
    /// The list of TestGridProjects, based on a ListTestGridProjectsRequest.
    public var testGridProjects: [DeviceFarmClientTypes.TestGridProject]?

    public init (
        nextToken: Swift.String? = nil,
        testGridProjects: [DeviceFarmClientTypes.TestGridProject]? = nil
    )
    {
        self.nextToken = nextToken
        self.testGridProjects = testGridProjects
    }
}

struct ListTestGridProjectsOutputResponseBody: Swift.Equatable {
    public let testGridProjects: [DeviceFarmClientTypes.TestGridProject]?
    public let nextToken: Swift.String?
}

extension ListTestGridProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case testGridProjects
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridProjectsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.TestGridProject?].self, forKey: .testGridProjects)
        var testGridProjectsDecoded0:[DeviceFarmClientTypes.TestGridProject]? = nil
        if let testGridProjectsContainer = testGridProjectsContainer {
            testGridProjectsDecoded0 = [DeviceFarmClientTypes.TestGridProject]()
            for structure0 in testGridProjectsContainer {
                if let structure0 = structure0 {
                    testGridProjectsDecoded0?.append(structure0)
                }
            }
        }
        testGridProjects = testGridProjectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTestGridSessionActionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridSessionActionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestGridSessionActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridSessionActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestGridSessionActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridSessionActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridSessionActionsOutputError>
}

extension ListTestGridSessionActionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTestGridSessionActionsInput(maxResult: \(Swift.String(describing: maxResult)), nextToken: \(Swift.String(describing: nextToken)), sessionArn: \(Swift.String(describing: sessionArn)))"}
}

extension ListTestGridSessionActionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResult
        case nextToken
        case sessionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResult = maxResult {
            try encodeContainer.encode(maxResult, forKey: .maxResult)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sessionArn = sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
    }
}

public struct ListTestGridSessionActionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridSessionActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestGridSessionActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridSessionActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestGridSessionActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridSessionActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridSessionActionsOutputError>
}

public struct ListTestGridSessionActionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridSessionActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestGridSessionActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridSessionActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestGridSessionActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridSessionActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridSessionActionsOutputError>
}

public struct ListTestGridSessionActionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridSessionActionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTestGridSessionActionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridSessionActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTestGridSessionActionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridSessionActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridSessionActionsOutputError>
}

public struct ListTestGridSessionActionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridSessionActionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTestGridSessionActionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridSessionActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTestGridSessionActionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridSessionActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridSessionActionsOutputError>
}

public struct ListTestGridSessionActionsInput: Swift.Equatable {
    /// The maximum number of sessions to return per response.
    public var maxResult: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The ARN of the session to retrieve.
    /// This member is required.
    public var sessionArn: Swift.String?

    public init (
        maxResult: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionArn: Swift.String? = nil
    )
    {
        self.maxResult = maxResult
        self.nextToken = nextToken
        self.sessionArn = sessionArn
    }
}

struct ListTestGridSessionActionsInputBody: Swift.Equatable {
    public let sessionArn: Swift.String?
    public let maxResult: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListTestGridSessionActionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResult
        case nextToken
        case sessionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
        let maxResultDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResult)
        maxResult = maxResultDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestGridSessionActionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestGridSessionActionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTestGridSessionActionsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestGridSessionActionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTestGridSessionActionsOutputResponse(actions: \(Swift.String(describing: actions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTestGridSessionActionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTestGridSessionActionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.nextToken = output.nextToken
        } else {
            self.actions = nil
            self.nextToken = nil
        }
    }
}

public struct ListTestGridSessionActionsOutputResponse: Swift.Equatable {
    /// The action taken by the session.
    public var actions: [DeviceFarmClientTypes.TestGridSessionAction]?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init (
        actions: [DeviceFarmClientTypes.TestGridSessionAction]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

struct ListTestGridSessionActionsOutputResponseBody: Swift.Equatable {
    public let actions: [DeviceFarmClientTypes.TestGridSessionAction]?
    public let nextToken: Swift.String?
}

extension ListTestGridSessionActionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.TestGridSessionAction?].self, forKey: .actions)
        var actionsDecoded0:[DeviceFarmClientTypes.TestGridSessionAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [DeviceFarmClientTypes.TestGridSessionAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTestGridSessionArtifactsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridSessionArtifactsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestGridSessionArtifactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridSessionArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestGridSessionArtifactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridSessionArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridSessionArtifactsOutputError>
}

extension ListTestGridSessionArtifactsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTestGridSessionArtifactsInput(maxResult: \(Swift.String(describing: maxResult)), nextToken: \(Swift.String(describing: nextToken)), sessionArn: \(Swift.String(describing: sessionArn)), type: \(Swift.String(describing: type)))"}
}

extension ListTestGridSessionArtifactsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResult
        case nextToken
        case sessionArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResult = maxResult {
            try encodeContainer.encode(maxResult, forKey: .maxResult)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sessionArn = sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct ListTestGridSessionArtifactsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridSessionArtifactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestGridSessionArtifactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridSessionArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestGridSessionArtifactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridSessionArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridSessionArtifactsOutputError>
}

public struct ListTestGridSessionArtifactsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridSessionArtifactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestGridSessionArtifactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridSessionArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestGridSessionArtifactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridSessionArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridSessionArtifactsOutputError>
}

public struct ListTestGridSessionArtifactsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridSessionArtifactsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTestGridSessionArtifactsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridSessionArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTestGridSessionArtifactsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridSessionArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridSessionArtifactsOutputError>
}

public struct ListTestGridSessionArtifactsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridSessionArtifactsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTestGridSessionArtifactsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridSessionArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTestGridSessionArtifactsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridSessionArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridSessionArtifactsOutputError>
}

public struct ListTestGridSessionArtifactsInput: Swift.Equatable {
    /// The maximum number of results to be returned by a request.
    public var maxResult: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The ARN of a TestGridSession.
    /// This member is required.
    public var sessionArn: Swift.String?
    /// Limit results to a specified type of artifact.
    public var type: DeviceFarmClientTypes.TestGridSessionArtifactCategory?

    public init (
        maxResult: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionArn: Swift.String? = nil,
        type: DeviceFarmClientTypes.TestGridSessionArtifactCategory? = nil
    )
    {
        self.maxResult = maxResult
        self.nextToken = nextToken
        self.sessionArn = sessionArn
        self.type = type
    }
}

struct ListTestGridSessionArtifactsInputBody: Swift.Equatable {
    public let sessionArn: Swift.String?
    public let type: DeviceFarmClientTypes.TestGridSessionArtifactCategory?
    public let maxResult: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListTestGridSessionArtifactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResult
        case nextToken
        case sessionArn
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridSessionArtifactCategory.self, forKey: .type)
        type = typeDecoded
        let maxResultDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResult)
        maxResult = maxResultDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestGridSessionArtifactsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestGridSessionArtifactsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTestGridSessionArtifactsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestGridSessionArtifactsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTestGridSessionArtifactsOutputResponse(artifacts: \(Swift.String(describing: artifacts)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTestGridSessionArtifactsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTestGridSessionArtifactsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.artifacts = output.artifacts
            self.nextToken = output.nextToken
        } else {
            self.artifacts = nil
            self.nextToken = nil
        }
    }
}

public struct ListTestGridSessionArtifactsOutputResponse: Swift.Equatable {
    /// A list of test grid session artifacts for a TestGridSession.
    public var artifacts: [DeviceFarmClientTypes.TestGridSessionArtifact]?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init (
        artifacts: [DeviceFarmClientTypes.TestGridSessionArtifact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.artifacts = artifacts
        self.nextToken = nextToken
    }
}

struct ListTestGridSessionArtifactsOutputResponseBody: Swift.Equatable {
    public let artifacts: [DeviceFarmClientTypes.TestGridSessionArtifact]?
    public let nextToken: Swift.String?
}

extension ListTestGridSessionArtifactsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifacts
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.TestGridSessionArtifact?].self, forKey: .artifacts)
        var artifactsDecoded0:[DeviceFarmClientTypes.TestGridSessionArtifact]? = nil
        if let artifactsContainer = artifactsContainer {
            artifactsDecoded0 = [DeviceFarmClientTypes.TestGridSessionArtifact]()
            for structure0 in artifactsContainer {
                if let structure0 = structure0 {
                    artifactsDecoded0?.append(structure0)
                }
            }
        }
        artifacts = artifactsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTestGridSessionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridSessionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestGridSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestGridSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridSessionsOutputError>
}

extension ListTestGridSessionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTestGridSessionsInput(creationTimeAfter: \(Swift.String(describing: creationTimeAfter)), creationTimeBefore: \(Swift.String(describing: creationTimeBefore)), endTimeAfter: \(Swift.String(describing: endTimeAfter)), endTimeBefore: \(Swift.String(describing: endTimeBefore)), maxResult: \(Swift.String(describing: maxResult)), nextToken: \(Swift.String(describing: nextToken)), projectArn: \(Swift.String(describing: projectArn)), status: \(Swift.String(describing: status)))"}
}

extension ListTestGridSessionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimeAfter
        case creationTimeBefore
        case endTimeAfter
        case endTimeBefore
        case maxResult
        case nextToken
        case projectArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimeAfter = creationTimeAfter {
            try encodeContainer.encode(creationTimeAfter.timeIntervalSince1970, forKey: .creationTimeAfter)
        }
        if let creationTimeBefore = creationTimeBefore {
            try encodeContainer.encode(creationTimeBefore.timeIntervalSince1970, forKey: .creationTimeBefore)
        }
        if let endTimeAfter = endTimeAfter {
            try encodeContainer.encode(endTimeAfter.timeIntervalSince1970, forKey: .endTimeAfter)
        }
        if let endTimeBefore = endTimeBefore {
            try encodeContainer.encode(endTimeBefore.timeIntervalSince1970, forKey: .endTimeBefore)
        }
        if let maxResult = maxResult {
            try encodeContainer.encode(maxResult, forKey: .maxResult)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct ListTestGridSessionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridSessionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestGridSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestGridSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridSessionsOutputError>
}

public struct ListTestGridSessionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridSessionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestGridSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestGridSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridSessionsOutputError>
}

public struct ListTestGridSessionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridSessionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTestGridSessionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTestGridSessionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridSessionsOutputError>
}

public struct ListTestGridSessionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestGridSessionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTestGridSessionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestGridSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTestGridSessionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestGridSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestGridSessionsOutputError>
}

public struct ListTestGridSessionsInput: Swift.Equatable {
    /// Return only sessions created after this time.
    public var creationTimeAfter: ClientRuntime.Date?
    /// Return only  sessions created before this time.
    public var creationTimeBefore: ClientRuntime.Date?
    /// Return only sessions that ended after this time.
    public var endTimeAfter: ClientRuntime.Date?
    /// Return only sessions that ended before this time.
    public var endTimeBefore: ClientRuntime.Date?
    /// Return only this many results at a time.
    public var maxResult: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// ARN of a TestGridProject.
    /// This member is required.
    public var projectArn: Swift.String?
    /// Return only sessions in this state.
    public var status: DeviceFarmClientTypes.TestGridSessionStatus?

    public init (
        creationTimeAfter: ClientRuntime.Date? = nil,
        creationTimeBefore: ClientRuntime.Date? = nil,
        endTimeAfter: ClientRuntime.Date? = nil,
        endTimeBefore: ClientRuntime.Date? = nil,
        maxResult: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        status: DeviceFarmClientTypes.TestGridSessionStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.endTimeAfter = endTimeAfter
        self.endTimeBefore = endTimeBefore
        self.maxResult = maxResult
        self.nextToken = nextToken
        self.projectArn = projectArn
        self.status = status
    }
}

struct ListTestGridSessionsInputBody: Swift.Equatable {
    public let projectArn: Swift.String?
    public let status: DeviceFarmClientTypes.TestGridSessionStatus?
    public let creationTimeAfter: ClientRuntime.Date?
    public let creationTimeBefore: ClientRuntime.Date?
    public let endTimeAfter: ClientRuntime.Date?
    public let endTimeBefore: ClientRuntime.Date?
    public let maxResult: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListTestGridSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimeAfter
        case creationTimeBefore
        case endTimeAfter
        case endTimeBefore
        case maxResult
        case nextToken
        case projectArn
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridSessionStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeAfterDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTimeAfter)
        creationTimeAfter = creationTimeAfterDecoded
        let creationTimeBeforeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTimeBefore)
        creationTimeBefore = creationTimeBeforeDecoded
        let endTimeAfterDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTimeAfter)
        endTimeAfter = endTimeAfterDecoded
        let endTimeBeforeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTimeBefore)
        endTimeBefore = endTimeBeforeDecoded
        let maxResultDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResult)
        maxResult = maxResultDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestGridSessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestGridSessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTestGridSessionsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestGridSessionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTestGridSessionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), testGridSessions: \(Swift.String(describing: testGridSessions)))"}
}

extension ListTestGridSessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTestGridSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.testGridSessions = output.testGridSessions
        } else {
            self.nextToken = nil
            self.testGridSessions = nil
        }
    }
}

public struct ListTestGridSessionsOutputResponse: Swift.Equatable {
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The sessions that match the criteria in a ListTestGridSessionsRequest.
    public var testGridSessions: [DeviceFarmClientTypes.TestGridSession]?

    public init (
        nextToken: Swift.String? = nil,
        testGridSessions: [DeviceFarmClientTypes.TestGridSession]? = nil
    )
    {
        self.nextToken = nextToken
        self.testGridSessions = testGridSessions
    }
}

struct ListTestGridSessionsOutputResponseBody: Swift.Equatable {
    public let testGridSessions: [DeviceFarmClientTypes.TestGridSession]?
    public let nextToken: Swift.String?
}

extension ListTestGridSessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case testGridSessions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridSessionsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.TestGridSession?].self, forKey: .testGridSessions)
        var testGridSessionsDecoded0:[DeviceFarmClientTypes.TestGridSession]? = nil
        if let testGridSessionsContainer = testGridSessionsContainer {
            testGridSessionsDecoded0 = [DeviceFarmClientTypes.TestGridSession]()
            for structure0 in testGridSessionsContainer {
                if let structure0 = structure0 {
                    testGridSessionsDecoded0?.append(structure0)
                }
            }
        }
        testGridSessions = testGridSessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTestsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestsOutputError>
}

extension ListTestsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTestsInput(arn: \(Swift.String(describing: arn)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTestsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTestsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestsOutputError>
}

public struct ListTestsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTestsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTestsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestsOutputError>
}

public struct ListTestsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTestsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTestsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestsOutputError>
}

public struct ListTestsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTestsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTestsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTestsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTestsOutputError>
}

/// Represents a request to the list tests operation.
public struct ListTestsInput: Swift.Equatable {
    /// The test suite's Amazon Resource Name (ARN).
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListTestsInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let nextToken: Swift.String?
}

extension ListTestsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTestsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTestsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tests: \(Swift.String(describing: tests)))"}
}

extension ListTestsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTestsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tests = output.tests
        } else {
            self.nextToken = nil
            self.tests = nil
        }
    }
}

/// Represents the result of a list tests request.
public struct ListTestsOutputResponse: Swift.Equatable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.
    public var nextToken: Swift.String?
    /// Information about the tests.
    public var tests: [DeviceFarmClientTypes.Test]?

    public init (
        nextToken: Swift.String? = nil,
        tests: [DeviceFarmClientTypes.Test]? = nil
    )
    {
        self.nextToken = nextToken
        self.tests = tests
    }
}

struct ListTestsOutputResponseBody: Swift.Equatable {
    public let tests: [DeviceFarmClientTypes.Test]?
    public let nextToken: Swift.String?
}

extension ListTestsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tests
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Test?].self, forKey: .tests)
        var testsDecoded0:[DeviceFarmClientTypes.Test]? = nil
        if let testsContainer = testsContainer {
            testsDecoded0 = [DeviceFarmClientTypes.Test]()
            for structure0 in testsContainer {
                if let structure0 = structure0 {
                    testsDecoded0?.append(structure0)
                }
            }
        }
        tests = testsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListUniqueProblemsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUniqueProblemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUniqueProblemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUniqueProblemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUniqueProblemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUniqueProblemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUniqueProblemsOutputError>
}

extension ListUniqueProblemsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUniqueProblemsInput(arn: \(Swift.String(describing: arn)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListUniqueProblemsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListUniqueProblemsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUniqueProblemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUniqueProblemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUniqueProblemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUniqueProblemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUniqueProblemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUniqueProblemsOutputError>
}

public struct ListUniqueProblemsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUniqueProblemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUniqueProblemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUniqueProblemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUniqueProblemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUniqueProblemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUniqueProblemsOutputError>
}

public struct ListUniqueProblemsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUniqueProblemsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListUniqueProblemsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUniqueProblemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUniqueProblemsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUniqueProblemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUniqueProblemsOutputError>
}

public struct ListUniqueProblemsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUniqueProblemsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListUniqueProblemsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUniqueProblemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUniqueProblemsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUniqueProblemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUniqueProblemsOutputError>
}

/// Represents a request to the list unique problems operation.
public struct ListUniqueProblemsInput: Swift.Equatable {
    /// The unique problems' ARNs.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListUniqueProblemsInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let nextToken: Swift.String?
}

extension ListUniqueProblemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUniqueProblemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUniqueProblemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUniqueProblemsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUniqueProblemsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUniqueProblemsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), uniqueProblems: \(Swift.String(describing: uniqueProblems)))"}
}

extension ListUniqueProblemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUniqueProblemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.uniqueProblems = output.uniqueProblems
        } else {
            self.nextToken = nil
            self.uniqueProblems = nil
        }
    }
}

/// Represents the result of a list unique problems request.
public struct ListUniqueProblemsOutputResponse: Swift.Equatable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.
    public var nextToken: Swift.String?
    /// Information about the unique problems.
    ///         Allowed values include:
    ///
    ///
    ///                 PENDING
    ///
    ///
    ///                 PASSED
    ///
    ///
    ///                 WARNED
    ///
    ///
    ///                 FAILED
    ///
    ///
    ///                 SKIPPED
    ///
    ///
    ///                 ERRORED
    ///
    ///
    ///                 STOPPED
    ///
    ///
    public var uniqueProblems: [Swift.String:[DeviceFarmClientTypes.UniqueProblem]]?

    public init (
        nextToken: Swift.String? = nil,
        uniqueProblems: [Swift.String:[DeviceFarmClientTypes.UniqueProblem]]? = nil
    )
    {
        self.nextToken = nextToken
        self.uniqueProblems = uniqueProblems
    }
}

struct ListUniqueProblemsOutputResponseBody: Swift.Equatable {
    public let uniqueProblems: [Swift.String:[DeviceFarmClientTypes.UniqueProblem]]?
    public let nextToken: Swift.String?
}

extension ListUniqueProblemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case uniqueProblems
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uniqueProblemsContainer = try containerValues.decodeIfPresent([Swift.String: [DeviceFarmClientTypes.UniqueProblem?]?].self, forKey: .uniqueProblems)
        var uniqueProblemsDecoded0: [Swift.String:[DeviceFarmClientTypes.UniqueProblem]]? = nil
        if let uniqueProblemsContainer = uniqueProblemsContainer {
            uniqueProblemsDecoded0 = [Swift.String:[DeviceFarmClientTypes.UniqueProblem]]()
            for (key0, uniqueproblems0) in uniqueProblemsContainer {
                var uniqueproblems0Decoded0: [DeviceFarmClientTypes.UniqueProblem]? = nil
                if let uniqueproblems0 = uniqueproblems0 {
                    uniqueproblems0Decoded0 = [DeviceFarmClientTypes.UniqueProblem]()
                    for structure1 in uniqueproblems0 {
                        if let structure1 = structure1 {
                            uniqueproblems0Decoded0?.append(structure1)
                        }
                    }
                }
                uniqueProblemsDecoded0?[key0] = uniqueproblems0Decoded0
            }
        }
        uniqueProblems = uniqueProblemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListUploadsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUploadsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUploadsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUploadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUploadsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUploadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUploadsOutputError>
}

extension ListUploadsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUploadsInput(arn: \(Swift.String(describing: arn)), nextToken: \(Swift.String(describing: nextToken)), type: \(Swift.String(describing: type)))"}
}

extension ListUploadsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct ListUploadsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUploadsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUploadsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUploadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUploadsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUploadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUploadsOutputError>
}

public struct ListUploadsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUploadsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUploadsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUploadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUploadsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUploadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUploadsOutputError>
}

public struct ListUploadsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUploadsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListUploadsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUploadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUploadsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUploadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUploadsOutputError>
}

public struct ListUploadsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUploadsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListUploadsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUploadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUploadsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUploadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUploadsOutputError>
}

/// Represents a request to the list uploads operation.
public struct ListUploadsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project for which you want to list
    ///             uploads.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The type of upload.
    ///         Must be one of the following values:
    ///
    ///
    ///                 ANDROID_APP
    ///
    ///
    ///                 IOS_APP
    ///
    ///
    ///                 WEB_APP
    ///
    ///
    ///                 EXTERNAL_DATA
    ///
    ///
    ///                 APPIUM_JAVA_JUNIT_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_JAVA_TESTNG_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_PYTHON_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_NODE_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_RUBY_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_WEB_PYTHON_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_WEB_NODE_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_WEB_RUBY_TEST_PACKAGE
    ///
    ///
    ///                 CALABASH_TEST_PACKAGE
    ///
    ///
    ///                 INSTRUMENTATION_TEST_PACKAGE
    ///
    ///
    ///                 UIAUTOMATION_TEST_PACKAGE
    ///
    ///
    ///                 UIAUTOMATOR_TEST_PACKAGE
    ///
    ///
    ///                 XCTEST_TEST_PACKAGE
    ///
    ///
    ///                 XCTEST_UI_TEST_PACKAGE
    ///
    ///
    ///                 APPIUM_JAVA_JUNIT_TEST_SPEC
    ///
    ///
    ///                 APPIUM_JAVA_TESTNG_TEST_SPEC
    ///
    ///
    ///                 APPIUM_PYTHON_TEST_SPEC
    ///
    ///
    ///                 APPIUM_NODE_TEST_SPEC
    ///
    ///
    ///                  APPIUM_RUBY_TEST_SPEC
    ///
    ///
    ///                 APPIUM_WEB_JAVA_JUNIT_TEST_SPEC
    ///
    ///
    ///                 APPIUM_WEB_JAVA_TESTNG_TEST_SPEC
    ///
    ///
    ///                 APPIUM_WEB_PYTHON_TEST_SPEC
    ///
    ///
    ///                 APPIUM_WEB_NODE_TEST_SPEC
    ///
    ///
    ///                 APPIUM_WEB_RUBY_TEST_SPEC
    ///
    ///
    ///                 INSTRUMENTATION_TEST_SPEC
    ///
    ///
    ///                 XCTEST_UI_TEST_SPEC
    ///
    ///
    public var type: DeviceFarmClientTypes.UploadType?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        type: DeviceFarmClientTypes.UploadType? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListUploadsInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let type: DeviceFarmClientTypes.UploadType?
    public let nextToken: Swift.String?
}

extension ListUploadsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case nextToken
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.UploadType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUploadsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUploadsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUploadsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUploadsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUploadsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), uploads: \(Swift.String(describing: uploads)))"}
}

extension ListUploadsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUploadsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.uploads = output.uploads
        } else {
            self.nextToken = nil
            self.uploads = nil
        }
    }
}

/// Represents the result of a list uploads request.
public struct ListUploadsOutputResponse: Swift.Equatable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.
    public var nextToken: Swift.String?
    /// Information about the uploads.
    public var uploads: [DeviceFarmClientTypes.Upload]?

    public init (
        nextToken: Swift.String? = nil,
        uploads: [DeviceFarmClientTypes.Upload]? = nil
    )
    {
        self.nextToken = nextToken
        self.uploads = uploads
    }
}

struct ListUploadsOutputResponseBody: Swift.Equatable {
    public let uploads: [DeviceFarmClientTypes.Upload]?
    public let nextToken: Swift.String?
}

extension ListUploadsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case uploads
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Upload?].self, forKey: .uploads)
        var uploadsDecoded0:[DeviceFarmClientTypes.Upload]? = nil
        if let uploadsContainer = uploadsContainer {
            uploadsDecoded0 = [DeviceFarmClientTypes.Upload]()
            for structure0 in uploadsContainer {
                if let structure0 = structure0 {
                    uploadsDecoded0?.append(structure0)
                }
            }
        }
        uploads = uploadsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListVPCEConfigurationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVPCEConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVPCEConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVPCEConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVPCEConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVPCEConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVPCEConfigurationsOutputError>
}

extension ListVPCEConfigurationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVPCEConfigurationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListVPCEConfigurationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListVPCEConfigurationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVPCEConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVPCEConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVPCEConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVPCEConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVPCEConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVPCEConfigurationsOutputError>
}

public struct ListVPCEConfigurationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVPCEConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVPCEConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVPCEConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVPCEConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVPCEConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVPCEConfigurationsOutputError>
}

public struct ListVPCEConfigurationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVPCEConfigurationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListVPCEConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVPCEConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVPCEConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVPCEConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVPCEConfigurationsOutputError>
}

public struct ListVPCEConfigurationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVPCEConfigurationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListVPCEConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVPCEConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVPCEConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVPCEConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVPCEConfigurationsOutputError>
}

public struct ListVPCEConfigurationsInput: Swift.Equatable {
    /// An integer that specifies the maximum number of items you want to return in the API response.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVPCEConfigurationsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListVPCEConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVPCEConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVPCEConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVPCEConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVPCEConfigurationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVPCEConfigurationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), vpceConfigurations: \(Swift.String(describing: vpceConfigurations)))"}
}

extension ListVPCEConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListVPCEConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vpceConfigurations = output.vpceConfigurations
        } else {
            self.nextToken = nil
            self.vpceConfigurations = nil
        }
    }
}

public struct ListVPCEConfigurationsOutputResponse: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// An array of VPCEConfiguration objects that contain information about your VPC endpoint
    ///             configuration.
    public var vpceConfigurations: [DeviceFarmClientTypes.VPCEConfiguration]?

    public init (
        nextToken: Swift.String? = nil,
        vpceConfigurations: [DeviceFarmClientTypes.VPCEConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.vpceConfigurations = vpceConfigurations
    }
}

struct ListVPCEConfigurationsOutputResponseBody: Swift.Equatable {
    public let vpceConfigurations: [DeviceFarmClientTypes.VPCEConfiguration]?
    public let nextToken: Swift.String?
}

extension ListVPCEConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case vpceConfigurations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpceConfigurationsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.VPCEConfiguration?].self, forKey: .vpceConfigurations)
        var vpceConfigurationsDecoded0:[DeviceFarmClientTypes.VPCEConfiguration]? = nil
        if let vpceConfigurationsContainer = vpceConfigurationsContainer {
            vpceConfigurationsDecoded0 = [DeviceFarmClientTypes.VPCEConfiguration]()
            for structure0 in vpceConfigurationsContainer {
                if let structure0 = structure0 {
                    vpceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        vpceConfigurations = vpceConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DeviceFarmClientTypes.Location: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latitude
        case longitude
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latitude = latitude {
            try encodeContainer.encode(latitude, forKey: .latitude)
        }
        if let longitude = longitude {
            try encodeContainer.encode(longitude, forKey: .longitude)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latitudeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .latitude)
        latitude = latitudeDecoded
        let longitudeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .longitude)
        longitude = longitudeDecoded
    }
}

extension DeviceFarmClientTypes.Location: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Location(latitude: \(Swift.String(describing: latitude)), longitude: \(Swift.String(describing: longitude)))"}
}

extension DeviceFarmClientTypes {
    /// Represents a latitude and longitude pair, expressed in geographic coordinate system degrees (for
    ///             example, 47.6204, -122.3491).
    ///         Elevation is currently not supported.
    public struct Location: Swift.Equatable {
        /// The latitude.
        /// This member is required.
        public var latitude: Swift.Double?
        /// The longitude.
        /// This member is required.
        public var longitude: Swift.Double?

        public init (
            latitude: Swift.Double? = nil,
            longitude: Swift.Double? = nil
        )
        {
            self.latitude = latitude
            self.longitude = longitude
        }
    }

}

extension DeviceFarmClientTypes.MonetaryAmount: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount
        case currencyCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode.rawValue, forKey: .currencyCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .amount)
        amount = amountDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.CurrencyCode.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
    }
}

extension DeviceFarmClientTypes.MonetaryAmount: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MonetaryAmount(amount: \(Swift.String(describing: amount)), currencyCode: \(Swift.String(describing: currencyCode)))"}
}

extension DeviceFarmClientTypes {
    /// A number that represents the monetary amount for an offering or transaction.
    public struct MonetaryAmount: Swift.Equatable {
        /// The numerical amount of an offering or transaction.
        public var amount: Swift.Double?
        /// The currency code of a monetary amount. For example, USD means U.S. dollars.
        public var currencyCode: DeviceFarmClientTypes.CurrencyCode?

        public init (
            amount: Swift.Double? = nil,
            currencyCode: DeviceFarmClientTypes.CurrencyCode? = nil
        )
        {
            self.amount = amount
            self.currencyCode = currencyCode
        }
    }

}

extension DeviceFarmClientTypes.NetworkProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case downlinkBandwidthBits
        case downlinkDelayMs
        case downlinkJitterMs
        case downlinkLossPercent
        case name
        case type
        case uplinkBandwidthBits
        case uplinkDelayMs
        case uplinkJitterMs
        case uplinkLossPercent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let downlinkBandwidthBits = downlinkBandwidthBits {
            try encodeContainer.encode(downlinkBandwidthBits, forKey: .downlinkBandwidthBits)
        }
        if let downlinkDelayMs = downlinkDelayMs {
            try encodeContainer.encode(downlinkDelayMs, forKey: .downlinkDelayMs)
        }
        if let downlinkJitterMs = downlinkJitterMs {
            try encodeContainer.encode(downlinkJitterMs, forKey: .downlinkJitterMs)
        }
        if downlinkLossPercent != 0 {
            try encodeContainer.encode(downlinkLossPercent, forKey: .downlinkLossPercent)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uplinkBandwidthBits = uplinkBandwidthBits {
            try encodeContainer.encode(uplinkBandwidthBits, forKey: .uplinkBandwidthBits)
        }
        if let uplinkDelayMs = uplinkDelayMs {
            try encodeContainer.encode(uplinkDelayMs, forKey: .uplinkDelayMs)
        }
        if let uplinkJitterMs = uplinkJitterMs {
            try encodeContainer.encode(uplinkJitterMs, forKey: .uplinkJitterMs)
        }
        if uplinkLossPercent != 0 {
            try encodeContainer.encode(uplinkLossPercent, forKey: .uplinkLossPercent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfileType.self, forKey: .type)
        type = typeDecoded
        let uplinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkBandwidthBits)
        uplinkBandwidthBits = uplinkBandwidthBitsDecoded
        let downlinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkBandwidthBits)
        downlinkBandwidthBits = downlinkBandwidthBitsDecoded
        let uplinkDelayMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkDelayMs)
        uplinkDelayMs = uplinkDelayMsDecoded
        let downlinkDelayMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkDelayMs)
        downlinkDelayMs = downlinkDelayMsDecoded
        let uplinkJitterMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkJitterMs)
        uplinkJitterMs = uplinkJitterMsDecoded
        let downlinkJitterMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkJitterMs)
        downlinkJitterMs = downlinkJitterMsDecoded
        let uplinkLossPercentDecoded = try containerValues.decode(Swift.Int.self, forKey: .uplinkLossPercent)
        uplinkLossPercent = uplinkLossPercentDecoded
        let downlinkLossPercentDecoded = try containerValues.decode(Swift.Int.self, forKey: .downlinkLossPercent)
        downlinkLossPercent = downlinkLossPercentDecoded
    }
}

extension DeviceFarmClientTypes.NetworkProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkProfile(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), downlinkBandwidthBits: \(Swift.String(describing: downlinkBandwidthBits)), downlinkDelayMs: \(Swift.String(describing: downlinkDelayMs)), downlinkJitterMs: \(Swift.String(describing: downlinkJitterMs)), downlinkLossPercent: \(Swift.String(describing: downlinkLossPercent)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)), uplinkBandwidthBits: \(Swift.String(describing: uplinkBandwidthBits)), uplinkDelayMs: \(Swift.String(describing: uplinkDelayMs)), uplinkJitterMs: \(Swift.String(describing: uplinkJitterMs)), uplinkLossPercent: \(Swift.String(describing: uplinkLossPercent)))"}
}

extension DeviceFarmClientTypes {
    /// An array of settings that describes characteristics of a network profile.
    public struct NetworkProfile: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the network profile.
        public var arn: Swift.String?
        /// The description of the network profile.
        public var description: Swift.String?
        /// The data throughput rate in bits per second, as an integer from 0 to
        ///             104857600.
        public var downlinkBandwidthBits: Swift.Int?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to
        ///             2000.
        public var downlinkDelayMs: Swift.Int?
        /// Time variation in the delay of received packets in milliseconds as an integer from
        ///             0 to 2000.
        public var downlinkJitterMs: Swift.Int?
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public var downlinkLossPercent: Swift.Int
        /// The name of the network profile.
        public var name: Swift.String?
        /// The type of network profile. Valid values are listed here.
        public var type: DeviceFarmClientTypes.NetworkProfileType?
        /// The data throughput rate in bits per second, as an integer from 0 to
        ///             104857600.
        public var uplinkBandwidthBits: Swift.Int?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to
        ///             2000.
        public var uplinkDelayMs: Swift.Int?
        /// Time variation in the delay of received packets in milliseconds as an integer from
        ///             0 to 2000.
        public var uplinkJitterMs: Swift.Int?
        /// Proportion of transmitted packets that fail to arrive from 0 to 100
        ///             percent.
        public var uplinkLossPercent: Swift.Int

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            downlinkBandwidthBits: Swift.Int? = nil,
            downlinkDelayMs: Swift.Int? = nil,
            downlinkJitterMs: Swift.Int? = nil,
            downlinkLossPercent: Swift.Int = 0,
            name: Swift.String? = nil,
            type: DeviceFarmClientTypes.NetworkProfileType? = nil,
            uplinkBandwidthBits: Swift.Int? = nil,
            uplinkDelayMs: Swift.Int? = nil,
            uplinkJitterMs: Swift.Int? = nil,
            uplinkLossPercent: Swift.Int = 0
        )
        {
            self.arn = arn
            self.description = description
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.downlinkDelayMs = downlinkDelayMs
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkLossPercent = downlinkLossPercent
            self.name = name
            self.type = type
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.uplinkDelayMs = uplinkDelayMs
            self.uplinkJitterMs = uplinkJitterMs
            self.uplinkLossPercent = uplinkLossPercent
        }
    }

}

extension DeviceFarmClientTypes {
    public enum NetworkProfileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case curated
        case `private`
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkProfileType] {
            return [
                .curated,
                .private,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .curated: return "CURATED"
            case .private: return "PRIVATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkProfileType(rawValue: rawValue) ?? NetworkProfileType.sdkUnknown(rawValue)
        }
    }
}

extension NotEligibleException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotEligibleException(message: \(Swift.String(describing: message)))"}
}

extension NotEligibleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotEligibleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception gets thrown when a user is not eligible to perform the specified
///             transaction.
public struct NotEligibleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The HTTP response code of a Not Eligible exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotEligibleExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotEligibleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(message: \(Swift.String(describing: message)))"}
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified entity was not found.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any additional information about the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeviceFarmClientTypes.Offering: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case platform
        case recurringCharges
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recurringCharges)
            for recurringcharges0 in recurringCharges {
                try recurringChargesContainer.encode(recurringcharges0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.OfferingType.self, forKey: .type)
        type = typeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePlatform.self, forKey: .platform)
        platform = platformDecoded
        let recurringChargesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.RecurringCharge?].self, forKey: .recurringCharges)
        var recurringChargesDecoded0:[DeviceFarmClientTypes.RecurringCharge]? = nil
        if let recurringChargesContainer = recurringChargesContainer {
            recurringChargesDecoded0 = [DeviceFarmClientTypes.RecurringCharge]()
            for structure0 in recurringChargesContainer {
                if let structure0 = structure0 {
                    recurringChargesDecoded0?.append(structure0)
                }
            }
        }
        recurringCharges = recurringChargesDecoded0
    }
}

extension DeviceFarmClientTypes.Offering: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Offering(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), platform: \(Swift.String(describing: platform)), recurringCharges: \(Swift.String(describing: recurringCharges)), type: \(Swift.String(describing: type)))"}
}

extension DeviceFarmClientTypes {
    /// Represents the metadata of a device offering.
    public struct Offering: Swift.Equatable {
        /// A string that describes the offering.
        public var description: Swift.String?
        /// The ID that corresponds to a device offering.
        public var id: Swift.String?
        /// The platform of the device (for example, ANDROID or IOS).
        public var platform: DeviceFarmClientTypes.DevicePlatform?
        /// Specifies whether there are recurring charges for the offering.
        public var recurringCharges: [DeviceFarmClientTypes.RecurringCharge]?
        /// The type of offering (for example, RECURRING) for a device.
        public var type: DeviceFarmClientTypes.OfferingType?

        public init (
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            platform: DeviceFarmClientTypes.DevicePlatform? = nil,
            recurringCharges: [DeviceFarmClientTypes.RecurringCharge]? = nil,
            type: DeviceFarmClientTypes.OfferingType? = nil
        )
        {
            self.description = description
            self.id = id
            self.platform = platform
            self.recurringCharges = recurringCharges
            self.type = type
        }
    }

}

extension DeviceFarmClientTypes.OfferingPromotion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DeviceFarmClientTypes.OfferingPromotion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OfferingPromotion(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)))"}
}

extension DeviceFarmClientTypes {
    /// Represents information about an offering promotion.
    public struct OfferingPromotion: Swift.Equatable {
        /// A string that describes the offering promotion.
        public var description: Swift.String?
        /// The ID of the offering promotion.
        public var id: Swift.String?

        public init (
            description: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
        }
    }

}

extension DeviceFarmClientTypes.OfferingStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectiveOn
        case offering
        case quantity
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectiveOn = effectiveOn {
            try encodeContainer.encode(effectiveOn.timeIntervalSince1970, forKey: .effectiveOn)
        }
        if let offering = offering {
            try encodeContainer.encode(offering, forKey: .offering)
        }
        if let quantity = quantity {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.OfferingTransactionType.self, forKey: .type)
        type = typeDecoded
        let offeringDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Offering.self, forKey: .offering)
        offering = offeringDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        let effectiveOnDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .effectiveOn)
        effectiveOn = effectiveOnDecoded
    }
}

extension DeviceFarmClientTypes.OfferingStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OfferingStatus(effectiveOn: \(Swift.String(describing: effectiveOn)), offering: \(Swift.String(describing: offering)), quantity: \(Swift.String(describing: quantity)), type: \(Swift.String(describing: type)))"}
}

extension DeviceFarmClientTypes {
    /// The status of the offering.
    public struct OfferingStatus: Swift.Equatable {
        /// The date on which the offering is effective.
        public var effectiveOn: ClientRuntime.Date?
        /// Represents the metadata of an offering status.
        public var offering: DeviceFarmClientTypes.Offering?
        /// The number of available devices in the offering.
        public var quantity: Swift.Int?
        /// The type specified for the offering status.
        public var type: DeviceFarmClientTypes.OfferingTransactionType?

        public init (
            effectiveOn: ClientRuntime.Date? = nil,
            offering: DeviceFarmClientTypes.Offering? = nil,
            quantity: Swift.Int? = nil,
            type: DeviceFarmClientTypes.OfferingTransactionType? = nil
        )
        {
            self.effectiveOn = effectiveOn
            self.offering = offering
            self.quantity = quantity
            self.type = type
        }
    }

}

extension DeviceFarmClientTypes.OfferingTransaction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cost
        case createdOn
        case offeringPromotionId
        case offeringStatus
        case transactionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cost = cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let createdOn = createdOn {
            try encodeContainer.encode(createdOn.timeIntervalSince1970, forKey: .createdOn)
        }
        if let offeringPromotionId = offeringPromotionId {
            try encodeContainer.encode(offeringPromotionId, forKey: .offeringPromotionId)
        }
        if let offeringStatus = offeringStatus {
            try encodeContainer.encode(offeringStatus, forKey: .offeringStatus)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringStatusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.OfferingStatus.self, forKey: .offeringStatus)
        offeringStatus = offeringStatusDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let offeringPromotionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringPromotionId)
        offeringPromotionId = offeringPromotionIdDecoded
        let createdOnDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdOn)
        createdOn = createdOnDecoded
        let costDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.MonetaryAmount.self, forKey: .cost)
        cost = costDecoded
    }
}

extension DeviceFarmClientTypes.OfferingTransaction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OfferingTransaction(cost: \(Swift.String(describing: cost)), createdOn: \(Swift.String(describing: createdOn)), offeringPromotionId: \(Swift.String(describing: offeringPromotionId)), offeringStatus: \(Swift.String(describing: offeringStatus)), transactionId: \(Swift.String(describing: transactionId)))"}
}

extension DeviceFarmClientTypes {
    /// Represents the metadata of an offering transaction.
    public struct OfferingTransaction: Swift.Equatable {
        /// The cost of an offering transaction.
        public var cost: DeviceFarmClientTypes.MonetaryAmount?
        /// The date on which an offering transaction was created.
        public var createdOn: ClientRuntime.Date?
        /// The ID that corresponds to a device offering promotion.
        public var offeringPromotionId: Swift.String?
        /// The status of an offering transaction.
        public var offeringStatus: DeviceFarmClientTypes.OfferingStatus?
        /// The transaction ID of the offering transaction.
        public var transactionId: Swift.String?

        public init (
            cost: DeviceFarmClientTypes.MonetaryAmount? = nil,
            createdOn: ClientRuntime.Date? = nil,
            offeringPromotionId: Swift.String? = nil,
            offeringStatus: DeviceFarmClientTypes.OfferingStatus? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.cost = cost
            self.createdOn = createdOn
            self.offeringPromotionId = offeringPromotionId
            self.offeringStatus = offeringStatus
            self.transactionId = transactionId
        }
    }

}

extension DeviceFarmClientTypes {
    public enum OfferingTransactionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case purchase
        case renew
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferingTransactionType] {
            return [
                .purchase,
                .renew,
                .system,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .purchase: return "PURCHASE"
            case .renew: return "RENEW"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OfferingTransactionType(rawValue: rawValue) ?? OfferingTransactionType.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum OfferingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case recurring
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferingType] {
            return [
                .recurring,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .recurring: return "RECURRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OfferingType(rawValue: rawValue) ?? OfferingType.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.Problem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device
        case job
        case message
        case result
        case run
        case suite
        case test
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let device = device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let result = result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let run = run {
            try encodeContainer.encode(run, forKey: .run)
        }
        if let suite = suite {
            try encodeContainer.encode(suite, forKey: .suite)
        }
        if let test = test {
            try encodeContainer.encode(test, forKey: .test)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ProblemDetail.self, forKey: .run)
        run = runDecoded
        let jobDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ProblemDetail.self, forKey: .job)
        job = jobDecoded
        let suiteDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ProblemDetail.self, forKey: .suite)
        suite = suiteDecoded
        let testDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ProblemDetail.self, forKey: .test)
        test = testDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
        let resultDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeviceFarmClientTypes.Problem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Problem(device: \(Swift.String(describing: device)), job: \(Swift.String(describing: job)), message: \(Swift.String(describing: message)), result: \(Swift.String(describing: result)), run: \(Swift.String(describing: run)), suite: \(Swift.String(describing: suite)), test: \(Swift.String(describing: test)))"}
}

extension DeviceFarmClientTypes {
    /// Represents a specific warning or failure.
    public struct Problem: Swift.Equatable {
        /// Information about the associated device.
        public var device: DeviceFarmClientTypes.Device?
        /// Information about the associated job.
        public var job: DeviceFarmClientTypes.ProblemDetail?
        /// A message about the problem's result.
        public var message: Swift.String?
        /// The problem's result.
        ///         Allowed values include:
        ///
        ///
        ///                 PENDING
        ///
        ///
        ///                 PASSED
        ///
        ///
        ///                 WARNED
        ///
        ///
        ///                 FAILED
        ///
        ///
        ///                 SKIPPED
        ///
        ///
        ///                 ERRORED
        ///
        ///
        ///                 STOPPED
        ///
        ///
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// Information about the associated run.
        public var run: DeviceFarmClientTypes.ProblemDetail?
        /// Information about the associated suite.
        public var suite: DeviceFarmClientTypes.ProblemDetail?
        /// Information about the associated test.
        public var test: DeviceFarmClientTypes.ProblemDetail?

        public init (
            device: DeviceFarmClientTypes.Device? = nil,
            job: DeviceFarmClientTypes.ProblemDetail? = nil,
            message: Swift.String? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            run: DeviceFarmClientTypes.ProblemDetail? = nil,
            suite: DeviceFarmClientTypes.ProblemDetail? = nil,
            test: DeviceFarmClientTypes.ProblemDetail? = nil
        )
        {
            self.device = device
            self.job = job
            self.message = message
            self.result = result
            self.run = run
            self.suite = suite
            self.test = test
        }
    }

}

extension DeviceFarmClientTypes.ProblemDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeviceFarmClientTypes.ProblemDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProblemDetail(arn: \(Swift.String(describing: arn)), name: \(Swift.String(describing: name)))"}
}

extension DeviceFarmClientTypes {
    /// Information about a problem detail.
    public struct ProblemDetail: Swift.Equatable {
        /// The problem detail's ARN.
        public var arn: Swift.String?
        /// The problem detail's name.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension DeviceFarmClientTypes.Project: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case created
        case defaultJobTimeoutMinutes
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let defaultJobTimeoutMinutes = defaultJobTimeoutMinutes {
            try encodeContainer.encode(defaultJobTimeoutMinutes, forKey: .defaultJobTimeoutMinutes)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultJobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultJobTimeoutMinutes)
        defaultJobTimeoutMinutes = defaultJobTimeoutMinutesDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
    }
}

extension DeviceFarmClientTypes.Project: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Project(arn: \(Swift.String(describing: arn)), created: \(Swift.String(describing: created)), defaultJobTimeoutMinutes: \(Swift.String(describing: defaultJobTimeoutMinutes)), name: \(Swift.String(describing: name)))"}
}

extension DeviceFarmClientTypes {
    /// Represents an operating-system neutral workspace for running and managing
    ///             tests.
    public struct Project: Swift.Equatable {
        /// The project's ARN.
        public var arn: Swift.String?
        /// When the project was created.
        public var created: ClientRuntime.Date?
        /// The default number of minutes (at the project level) a test run executes before it times out. The
        ///             default value is 150 minutes.
        public var defaultJobTimeoutMinutes: Swift.Int?
        /// The project's name.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            defaultJobTimeoutMinutes: Swift.Int? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.created = created
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.name = name
        }
    }

}

public struct PurchaseOfferingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PurchaseOfferingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PurchaseOfferingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PurchaseOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PurchaseOfferingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PurchaseOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PurchaseOfferingOutputError>
}

extension PurchaseOfferingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PurchaseOfferingInput(offeringId: \(Swift.String(describing: offeringId)), offeringPromotionId: \(Swift.String(describing: offeringPromotionId)), quantity: \(Swift.String(describing: quantity)))"}
}

extension PurchaseOfferingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offeringId
        case offeringPromotionId
        case quantity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offeringId = offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let offeringPromotionId = offeringPromotionId {
            try encodeContainer.encode(offeringPromotionId, forKey: .offeringPromotionId)
        }
        if let quantity = quantity {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
    }
}

public struct PurchaseOfferingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PurchaseOfferingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PurchaseOfferingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PurchaseOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PurchaseOfferingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PurchaseOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PurchaseOfferingOutputError>
}

public struct PurchaseOfferingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PurchaseOfferingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PurchaseOfferingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PurchaseOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PurchaseOfferingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PurchaseOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PurchaseOfferingOutputError>
}

public struct PurchaseOfferingInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PurchaseOfferingInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PurchaseOfferingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PurchaseOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PurchaseOfferingInput
    public typealias MOutput = ClientRuntime.OperationOutput<PurchaseOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PurchaseOfferingOutputError>
}

public struct PurchaseOfferingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PurchaseOfferingInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PurchaseOfferingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PurchaseOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PurchaseOfferingInput
    public typealias MOutput = ClientRuntime.OperationOutput<PurchaseOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PurchaseOfferingOutputError>
}

/// Represents a request for a purchase offering.
public struct PurchaseOfferingInput: Swift.Equatable {
    /// The ID of the offering.
    /// This member is required.
    public var offeringId: Swift.String?
    /// The ID of the offering promotion to be applied to the purchase.
    public var offeringPromotionId: Swift.String?
    /// The number of device slots to purchase in an offering request.
    /// This member is required.
    public var quantity: Swift.Int?

    public init (
        offeringId: Swift.String? = nil,
        offeringPromotionId: Swift.String? = nil,
        quantity: Swift.Int? = nil
    )
    {
        self.offeringId = offeringId
        self.offeringPromotionId = offeringPromotionId
        self.quantity = quantity
    }
}

struct PurchaseOfferingInputBody: Swift.Equatable {
    public let offeringId: Swift.String?
    public let quantity: Swift.Int?
    public let offeringPromotionId: Swift.String?
}

extension PurchaseOfferingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offeringId
        case offeringPromotionId
        case quantity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        let offeringPromotionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringPromotionId)
        offeringPromotionId = offeringPromotionIdDecoded
    }
}

extension PurchaseOfferingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PurchaseOfferingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PurchaseOfferingOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PurchaseOfferingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PurchaseOfferingOutputResponse(offeringTransaction: \(Swift.String(describing: offeringTransaction)))"}
}

extension PurchaseOfferingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PurchaseOfferingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.offeringTransaction = output.offeringTransaction
        } else {
            self.offeringTransaction = nil
        }
    }
}

/// The result of the purchase offering (for example, success or failure).
public struct PurchaseOfferingOutputResponse: Swift.Equatable {
    /// Represents the offering transaction for the purchase result.
    public var offeringTransaction: DeviceFarmClientTypes.OfferingTransaction?

    public init (
        offeringTransaction: DeviceFarmClientTypes.OfferingTransaction? = nil
    )
    {
        self.offeringTransaction = offeringTransaction
    }
}

struct PurchaseOfferingOutputResponseBody: Swift.Equatable {
    public let offeringTransaction: DeviceFarmClientTypes.OfferingTransaction?
}

extension PurchaseOfferingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offeringTransaction
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringTransactionDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.OfferingTransaction.self, forKey: .offeringTransaction)
        offeringTransaction = offeringTransactionDecoded
    }
}

extension DeviceFarmClientTypes.Radios: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bluetooth
        case gps
        case nfc
        case wifi
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bluetooth = bluetooth {
            try encodeContainer.encode(bluetooth, forKey: .bluetooth)
        }
        if let gps = gps {
            try encodeContainer.encode(gps, forKey: .gps)
        }
        if let nfc = nfc {
            try encodeContainer.encode(nfc, forKey: .nfc)
        }
        if let wifi = wifi {
            try encodeContainer.encode(wifi, forKey: .wifi)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wifiDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .wifi)
        wifi = wifiDecoded
        let bluetoothDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bluetooth)
        bluetooth = bluetoothDecoded
        let nfcDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .nfc)
        nfc = nfcDecoded
        let gpsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .gps)
        gps = gpsDecoded
    }
}

extension DeviceFarmClientTypes.Radios: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Radios(bluetooth: \(Swift.String(describing: bluetooth)), gps: \(Swift.String(describing: gps)), nfc: \(Swift.String(describing: nfc)), wifi: \(Swift.String(describing: wifi)))"}
}

extension DeviceFarmClientTypes {
    /// Represents the set of radios and their states on a device. Examples of radios
    ///             include Wi-Fi, GPS, Bluetooth, and NFC.
    public struct Radios: Swift.Equatable {
        /// True if Bluetooth is enabled at the beginning of the test. Otherwise, false.
        public var bluetooth: Swift.Bool?
        /// True if GPS is enabled at the beginning of the test. Otherwise, false.
        public var gps: Swift.Bool?
        /// True if NFC is enabled at the beginning of the test. Otherwise, false.
        public var nfc: Swift.Bool?
        /// True if Wi-Fi is enabled at the beginning of the test. Otherwise, false.
        public var wifi: Swift.Bool?

        public init (
            bluetooth: Swift.Bool? = nil,
            gps: Swift.Bool? = nil,
            nfc: Swift.Bool? = nil,
            wifi: Swift.Bool? = nil
        )
        {
            self.bluetooth = bluetooth
            self.gps = gps
            self.nfc = nfc
            self.wifi = wifi
        }
    }

}

extension DeviceFarmClientTypes.RecurringCharge: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cost
        case frequency
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cost = cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.MonetaryAmount.self, forKey: .cost)
        cost = costDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.RecurringChargeFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
    }
}

extension DeviceFarmClientTypes.RecurringCharge: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecurringCharge(cost: \(Swift.String(describing: cost)), frequency: \(Swift.String(describing: frequency)))"}
}

extension DeviceFarmClientTypes {
    /// Specifies whether charges for devices are recurring.
    public struct RecurringCharge: Swift.Equatable {
        /// The cost of the recurring charge.
        public var cost: DeviceFarmClientTypes.MonetaryAmount?
        /// The frequency in which charges recur.
        public var frequency: DeviceFarmClientTypes.RecurringChargeFrequency?

        public init (
            cost: DeviceFarmClientTypes.MonetaryAmount? = nil,
            frequency: DeviceFarmClientTypes.RecurringChargeFrequency? = nil
        )
        {
            self.cost = cost
            self.frequency = frequency
        }
    }

}

extension DeviceFarmClientTypes {
    public enum RecurringChargeFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case monthly
        case sdkUnknown(Swift.String)

        public static var allCases: [RecurringChargeFrequency] {
            return [
                .monthly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .monthly: return "MONTHLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecurringChargeFrequency(rawValue: rawValue) ?? RecurringChargeFrequency.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.RemoteAccessSession: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case billingMethod
        case clientId
        case created
        case device
        case deviceMinutes
        case deviceUdid
        case endpoint
        case hostAddress
        case instanceArn
        case interactionMode
        case message
        case name
        case remoteDebugEnabled
        case remoteRecordAppArn
        case remoteRecordEnabled
        case result
        case skipAppResign
        case started
        case status
        case stopped
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billingMethod = billingMethod {
            try encodeContainer.encode(billingMethod.rawValue, forKey: .billingMethod)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let device = device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let deviceMinutes = deviceMinutes {
            try encodeContainer.encode(deviceMinutes, forKey: .deviceMinutes)
        }
        if let deviceUdid = deviceUdid {
            try encodeContainer.encode(deviceUdid, forKey: .deviceUdid)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let hostAddress = hostAddress {
            try encodeContainer.encode(hostAddress, forKey: .hostAddress)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let interactionMode = interactionMode {
            try encodeContainer.encode(interactionMode.rawValue, forKey: .interactionMode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let remoteDebugEnabled = remoteDebugEnabled {
            try encodeContainer.encode(remoteDebugEnabled, forKey: .remoteDebugEnabled)
        }
        if let remoteRecordAppArn = remoteRecordAppArn {
            try encodeContainer.encode(remoteRecordAppArn, forKey: .remoteRecordAppArn)
        }
        if let remoteRecordEnabled = remoteRecordEnabled {
            try encodeContainer.encode(remoteRecordEnabled, forKey: .remoteRecordEnabled)
        }
        if let result = result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let skipAppResign = skipAppResign {
            try encodeContainer.encode(skipAppResign, forKey: .skipAppResign)
        }
        if let started = started {
            try encodeContainer.encode(started.timeIntervalSince1970, forKey: .started)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopped = stopped {
            try encodeContainer.encode(stopped.timeIntervalSince1970, forKey: .stopped)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let startedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .started)
        started = startedDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopped)
        stopped = stoppedDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let remoteDebugEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteDebugEnabled)
        remoteDebugEnabled = remoteDebugEnabledDecoded
        let remoteRecordEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteRecordEnabled)
        remoteRecordEnabled = remoteRecordEnabledDecoded
        let remoteRecordAppArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteRecordAppArn)
        remoteRecordAppArn = remoteRecordAppArnDecoded
        let hostAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostAddress)
        hostAddress = hostAddressDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let billingMethodDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.BillingMethod.self, forKey: .billingMethod)
        billingMethod = billingMethodDecoded
        let deviceMinutesDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceMinutes.self, forKey: .deviceMinutes)
        deviceMinutes = deviceMinutesDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let deviceUdidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceUdid)
        deviceUdid = deviceUdidDecoded
        let interactionModeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.InteractionMode.self, forKey: .interactionMode)
        interactionMode = interactionModeDecoded
        let skipAppResignDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .skipAppResign)
        skipAppResign = skipAppResignDecoded
    }
}

extension DeviceFarmClientTypes.RemoteAccessSession: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoteAccessSession(arn: \(Swift.String(describing: arn)), billingMethod: \(Swift.String(describing: billingMethod)), clientId: \(Swift.String(describing: clientId)), created: \(Swift.String(describing: created)), device: \(Swift.String(describing: device)), deviceMinutes: \(Swift.String(describing: deviceMinutes)), deviceUdid: \(Swift.String(describing: deviceUdid)), endpoint: \(Swift.String(describing: endpoint)), hostAddress: \(Swift.String(describing: hostAddress)), instanceArn: \(Swift.String(describing: instanceArn)), interactionMode: \(Swift.String(describing: interactionMode)), message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)), remoteDebugEnabled: \(Swift.String(describing: remoteDebugEnabled)), remoteRecordAppArn: \(Swift.String(describing: remoteRecordAppArn)), remoteRecordEnabled: \(Swift.String(describing: remoteRecordEnabled)), result: \(Swift.String(describing: result)), skipAppResign: \(Swift.String(describing: skipAppResign)), started: \(Swift.String(describing: started)), status: \(Swift.String(describing: status)), stopped: \(Swift.String(describing: stopped)))"}
}

extension DeviceFarmClientTypes {
    /// Represents information about the remote access session.
    public struct RemoteAccessSession: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the remote access session.
        public var arn: Swift.String?
        /// The billing method of the remote access session. Possible values include METERED or
        ///                 UNMETERED. For more information about metered devices, see <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/welcome.html#welcome-terminology">AWS Device Farm
        ///                 terminology.
        public var billingMethod: DeviceFarmClientTypes.BillingMethod?
        /// Unique identifier of your client for the remote access session. Only returned if
        ///             remote debugging is enabled for the remote access session.
        ///         Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
        ///                 longer supported.
        public var clientId: Swift.String?
        /// The date and time the remote access session was created.
        public var created: ClientRuntime.Date?
        /// The device (phone or tablet) used in the remote access session.
        public var device: DeviceFarmClientTypes.Device?
        /// The number of minutes a device is used in a remote access session (including setup
        ///             and teardown minutes).
        public var deviceMinutes: DeviceFarmClientTypes.DeviceMinutes?
        /// Unique device identifier for the remote device. Only returned if remote debugging
        ///             is enabled for the remote access session.
        ///         Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
        ///                 longer supported.
        public var deviceUdid: Swift.String?
        /// The endpoint for the remote access sesssion.
        public var endpoint: Swift.String?
        /// IP address of the EC2 host where you need to connect to remotely debug devices.
        ///             Only returned if remote debugging is enabled for the remote access session.
        ///         Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
        ///                 longer supported.
        public var hostAddress: Swift.String?
        /// The ARN of the instance.
        public var instanceArn: Swift.String?
        /// The interaction mode of the remote access session. Valid values are:
        ///
        ///
        ///                 INTERACTIVE: You can interact with the iOS device by viewing, touching, and
        ///                     rotating the screen. You cannot run XCUITest framework-based tests in this
        ///                     mode.
        ///
        ///
        ///                 NO_VIDEO: You are connected to the device, but cannot interact with it or view the screen. This
        ///                     mode has the fastest test execution speed. You can run XCUITest framework-based tests in this
        ///                     mode.
        ///
        ///
        ///                 VIDEO_ONLY: You can view the screen, but cannot touch or rotate it. You can run XCUITest
        ///                     framework-based tests and watch the screen in this mode.
        ///
        ///
        public var interactionMode: DeviceFarmClientTypes.InteractionMode?
        /// A message about the remote access session.
        public var message: Swift.String?
        /// The name of the remote access session.
        public var name: Swift.String?
        /// This flag is set to true if remote debugging is enabled for the remote
        ///             access session.
        ///         Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
        ///                 longer supported.
        public var remoteDebugEnabled: Swift.Bool?
        /// The ARN for the app to be recorded in the remote access session.
        public var remoteRecordAppArn: Swift.String?
        /// This flag is set to true if remote recording is enabled for the remote
        ///             access session.
        public var remoteRecordEnabled: Swift.Bool?
        /// The result of the remote access session. Can be any of the following:
        ///
        ///
        ///                 PENDING.
        ///
        ///
        ///                 PASSED.
        ///
        ///
        ///                 WARNED.
        ///
        ///
        ///                 FAILED.
        ///
        ///
        ///                 SKIPPED.
        ///
        ///
        ///                 ERRORED.
        ///
        ///
        ///                 STOPPED.
        ///
        ///
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public
        ///             devices, Device Farm always signs your apps again.
        ///         For more information about how Device Farm re-signs your apps, see <a href="https://aws.amazon.com/device-farm/faq/">Do you modify my app? in the AWS Device
        ///                 Farm FAQs.
        public var skipAppResign: Swift.Bool?
        /// The date and time the remote access session was started.
        public var started: ClientRuntime.Date?
        /// The status of the remote access session. Can be any of the following:
        ///
        ///
        ///                 PENDING.
        ///
        ///
        ///                 PENDING_CONCURRENCY.
        ///
        ///
        ///                 PENDING_DEVICE.
        ///
        ///
        ///                 PROCESSING.
        ///
        ///
        ///                 SCHEDULING.
        ///
        ///
        ///                 PREPARING.
        ///
        ///
        ///                 RUNNING.
        ///
        ///
        ///                 COMPLETED.
        ///
        ///
        ///                 STOPPING.
        ///
        ///
        public var status: DeviceFarmClientTypes.ExecutionStatus?
        /// The date and time the remote access session was stopped.
        public var stopped: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            billingMethod: DeviceFarmClientTypes.BillingMethod? = nil,
            clientId: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            device: DeviceFarmClientTypes.Device? = nil,
            deviceMinutes: DeviceFarmClientTypes.DeviceMinutes? = nil,
            deviceUdid: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            hostAddress: Swift.String? = nil,
            instanceArn: Swift.String? = nil,
            interactionMode: DeviceFarmClientTypes.InteractionMode? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            remoteDebugEnabled: Swift.Bool? = nil,
            remoteRecordAppArn: Swift.String? = nil,
            remoteRecordEnabled: Swift.Bool? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            skipAppResign: Swift.Bool? = nil,
            started: ClientRuntime.Date? = nil,
            status: DeviceFarmClientTypes.ExecutionStatus? = nil,
            stopped: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.billingMethod = billingMethod
            self.clientId = clientId
            self.created = created
            self.device = device
            self.deviceMinutes = deviceMinutes
            self.deviceUdid = deviceUdid
            self.endpoint = endpoint
            self.hostAddress = hostAddress
            self.instanceArn = instanceArn
            self.interactionMode = interactionMode
            self.message = message
            self.name = name
            self.remoteDebugEnabled = remoteDebugEnabled
            self.remoteRecordAppArn = remoteRecordAppArn
            self.remoteRecordEnabled = remoteRecordEnabled
            self.result = result
            self.skipAppResign = skipAppResign
            self.started = started
            self.status = status
            self.stopped = stopped
        }
    }

}

public struct RenewOfferingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RenewOfferingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RenewOfferingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RenewOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RenewOfferingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RenewOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RenewOfferingOutputError>
}

extension RenewOfferingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RenewOfferingInput(offeringId: \(Swift.String(describing: offeringId)), quantity: \(Swift.String(describing: quantity)))"}
}

extension RenewOfferingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offeringId
        case quantity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offeringId = offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let quantity = quantity {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
    }
}

public struct RenewOfferingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RenewOfferingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RenewOfferingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RenewOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RenewOfferingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RenewOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RenewOfferingOutputError>
}

public struct RenewOfferingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RenewOfferingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RenewOfferingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RenewOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RenewOfferingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RenewOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RenewOfferingOutputError>
}

public struct RenewOfferingInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RenewOfferingInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RenewOfferingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RenewOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RenewOfferingInput
    public typealias MOutput = ClientRuntime.OperationOutput<RenewOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RenewOfferingOutputError>
}

public struct RenewOfferingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RenewOfferingInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RenewOfferingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RenewOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RenewOfferingInput
    public typealias MOutput = ClientRuntime.OperationOutput<RenewOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RenewOfferingOutputError>
}

/// A request that represents an offering renewal.
public struct RenewOfferingInput: Swift.Equatable {
    /// The ID of a request to renew an offering.
    /// This member is required.
    public var offeringId: Swift.String?
    /// The quantity requested in an offering renewal.
    /// This member is required.
    public var quantity: Swift.Int?

    public init (
        offeringId: Swift.String? = nil,
        quantity: Swift.Int? = nil
    )
    {
        self.offeringId = offeringId
        self.quantity = quantity
    }
}

struct RenewOfferingInputBody: Swift.Equatable {
    public let offeringId: Swift.String?
    public let quantity: Swift.Int?
}

extension RenewOfferingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offeringId
        case quantity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
    }
}

extension RenewOfferingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RenewOfferingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RenewOfferingOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RenewOfferingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RenewOfferingOutputResponse(offeringTransaction: \(Swift.String(describing: offeringTransaction)))"}
}

extension RenewOfferingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RenewOfferingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.offeringTransaction = output.offeringTransaction
        } else {
            self.offeringTransaction = nil
        }
    }
}

/// The result of a renewal offering.
public struct RenewOfferingOutputResponse: Swift.Equatable {
    /// Represents the status of the offering transaction for the renewal.
    public var offeringTransaction: DeviceFarmClientTypes.OfferingTransaction?

    public init (
        offeringTransaction: DeviceFarmClientTypes.OfferingTransaction? = nil
    )
    {
        self.offeringTransaction = offeringTransaction
    }
}

struct RenewOfferingOutputResponseBody: Swift.Equatable {
    public let offeringTransaction: DeviceFarmClientTypes.OfferingTransaction?
}

extension RenewOfferingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offeringTransaction
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringTransactionDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.OfferingTransaction.self, forKey: .offeringTransaction)
        offeringTransaction = offeringTransactionDecoded
    }
}

extension DeviceFarmClientTypes.Resolution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case height
        case width
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let height = height {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let width = width {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let widthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .width)
        width = widthDecoded
        let heightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .height)
        height = heightDecoded
    }
}

extension DeviceFarmClientTypes.Resolution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Resolution(height: \(Swift.String(describing: height)), width: \(Swift.String(describing: width)))"}
}

extension DeviceFarmClientTypes {
    /// Represents the screen resolution of a device in height and width, expressed in
    ///             pixels.
    public struct Resolution: Swift.Equatable {
        /// The screen resolution's height, expressed in pixels.
        public var height: Swift.Int?
        /// The screen resolution's width, expressed in pixels.
        public var width: Swift.Int?

        public init (
            height: Swift.Int? = nil,
            width: Swift.Int? = nil
        )
        {
            self.height = height
            self.width = width
        }
    }

}

extension DeviceFarmClientTypes.Rule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case `operator` = "operator"
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.RuleOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DeviceFarmClientTypes.Rule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Rule(attribute: \(Swift.String(describing: attribute)), operator: \(Swift.String(describing: `operator`)), value: \(Swift.String(describing: value)))"}
}

extension DeviceFarmClientTypes {
    /// Represents a condition for a device pool.
    public struct Rule: Swift.Equatable {
        /// Specifies how Device Farm compares the rule's attribute to the value. For the
        ///             operators that are supported by each attribute, see the attribute
        ///             descriptions.
        public var `operator`: DeviceFarmClientTypes.RuleOperator?
        /// The rule's stringified attribute. For example, specify the value as
        ///                 "\"abc\"".
        ///         The supported operators for each attribute are provided in the following
        ///             list.
        ///
        ///             APPIUM_VERSION
        ///
        ///                     The Appium version for the test.
        ///                     Supported operators: CONTAINS
        ///
        ///
        ///             ARN
        ///
        ///                     The Amazon Resource Name (ARN) of the device (for example,
        ///                         arn:aws:devicefarm:us-west-2::device:12345Example.
        ///                     Supported operators: EQUALS,
        ///                             IN, NOT_IN
        ///
        ///
        ///             AVAILABILITY
        ///
        ///                     The current availability of the device. Valid values are AVAILABLE,
        ///                         HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.
        ///                     Supported operators: EQUALS
        ///
        ///
        ///             FLEET_TYPE
        ///
        ///                     The fleet type. Valid values are PUBLIC or PRIVATE.
        ///                     Supported operators: EQUALS
        ///
        ///
        ///             FORM_FACTOR
        ///
        ///                     The device form factor. Valid values are PHONE or TABLET.
        ///                     Supported operators: EQUALS,
        ///                             IN, NOT_IN
        ///
        ///
        ///             INSTANCE_ARN
        ///
        ///                     The Amazon Resource Name (ARN) of the device instance.
        ///                     Supported operators: IN,
        ///                             NOT_IN
        ///
        ///
        ///             INSTANCE_LABELS
        ///
        ///                     The label of the device instance.
        ///                     Supported operators: CONTAINS
        ///
        ///
        ///             MANUFACTURER
        ///
        ///                     The device manufacturer (for example, Apple).
        ///                     Supported operators: EQUALS,
        ///                             IN, NOT_IN
        ///
        ///
        ///             MODEL
        ///
        ///                     The device model, such as Apple iPad Air 2 or Google Pixel.
        ///                     Supported operators: CONTAINS,
        ///                             EQUALS, IN, NOT_IN
        ///
        ///
        ///             OS_VERSION
        ///
        ///                     The operating system version (for example, 10.3.2).
        ///                     Supported operators: EQUALS,
        ///                             GREATER_THAN, GREATER_THAN_OR_EQUALS,
        ///                             IN, LESS_THAN,
        ///                             LESS_THAN_OR_EQUALS, NOT_IN
        ///
        ///
        ///             PLATFORM
        ///
        ///                     The device platform. Valid values are ANDROID or IOS.
        ///                     Supported operators: EQUALS,
        ///                             IN, NOT_IN
        ///
        ///
        ///             REMOTE_ACCESS_ENABLED
        ///
        ///                     Whether the device is enabled for remote access. Valid values are TRUE
        ///                         or FALSE.
        ///                     Supported operators: EQUALS
        ///
        ///
        ///             REMOTE_DEBUG_ENABLED
        ///
        ///                     Whether the device is enabled for remote debugging. Valid values are
        ///                         TRUE or FALSE.
        ///                     Supported operators: EQUALS
        ///
        ///                     Because remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no longer
        ///                             supported, this filter is ignored.
        ///
        ///
        public var attribute: DeviceFarmClientTypes.DeviceAttribute?
        /// The rule's value.
        public var value: Swift.String?

        public init (
            `operator`: DeviceFarmClientTypes.RuleOperator? = nil,
            attribute: DeviceFarmClientTypes.DeviceAttribute? = nil,
            value: Swift.String? = nil
        )
        {
            self.`operator` = `operator`
            self.attribute = attribute
            self.value = value
        }
    }

}

extension DeviceFarmClientTypes {
    public enum RuleOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equals
        case greaterThan
        case greaterThanOrEquals
        case `in`
        case lessThan
        case lessThanOrEquals
        case notIn
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleOperator] {
            return [
                .contains,
                .equals,
                .greaterThan,
                .greaterThanOrEquals,
                .in,
                .lessThan,
                .lessThanOrEquals,
                .notIn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .equals: return "EQUALS"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEquals: return "GREATER_THAN_OR_EQUALS"
            case .in: return "IN"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEquals: return "LESS_THAN_OR_EQUALS"
            case .notIn: return "NOT_IN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleOperator(rawValue: rawValue) ?? RuleOperator.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.Run: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appUpload
        case arn
        case billingMethod
        case completedJobs
        case counters
        case created
        case customerArtifactPaths
        case deviceMinutes
        case devicePoolArn
        case deviceSelectionResult
        case eventCount
        case jobTimeoutMinutes
        case locale
        case location
        case message
        case name
        case networkProfile
        case parsingResultUrl
        case platform
        case radios
        case result
        case resultCode
        case seed
        case skipAppResign
        case started
        case status
        case stopped
        case testSpecArn
        case totalJobs
        case type
        case webUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appUpload = appUpload {
            try encodeContainer.encode(appUpload, forKey: .appUpload)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billingMethod = billingMethod {
            try encodeContainer.encode(billingMethod.rawValue, forKey: .billingMethod)
        }
        if let completedJobs = completedJobs {
            try encodeContainer.encode(completedJobs, forKey: .completedJobs)
        }
        if let counters = counters {
            try encodeContainer.encode(counters, forKey: .counters)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let customerArtifactPaths = customerArtifactPaths {
            try encodeContainer.encode(customerArtifactPaths, forKey: .customerArtifactPaths)
        }
        if let deviceMinutes = deviceMinutes {
            try encodeContainer.encode(deviceMinutes, forKey: .deviceMinutes)
        }
        if let devicePoolArn = devicePoolArn {
            try encodeContainer.encode(devicePoolArn, forKey: .devicePoolArn)
        }
        if let deviceSelectionResult = deviceSelectionResult {
            try encodeContainer.encode(deviceSelectionResult, forKey: .deviceSelectionResult)
        }
        if let eventCount = eventCount {
            try encodeContainer.encode(eventCount, forKey: .eventCount)
        }
        if let jobTimeoutMinutes = jobTimeoutMinutes {
            try encodeContainer.encode(jobTimeoutMinutes, forKey: .jobTimeoutMinutes)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkProfile = networkProfile {
            try encodeContainer.encode(networkProfile, forKey: .networkProfile)
        }
        if let parsingResultUrl = parsingResultUrl {
            try encodeContainer.encode(parsingResultUrl, forKey: .parsingResultUrl)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let radios = radios {
            try encodeContainer.encode(radios, forKey: .radios)
        }
        if let result = result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let resultCode = resultCode {
            try encodeContainer.encode(resultCode.rawValue, forKey: .resultCode)
        }
        if let seed = seed {
            try encodeContainer.encode(seed, forKey: .seed)
        }
        if let skipAppResign = skipAppResign {
            try encodeContainer.encode(skipAppResign, forKey: .skipAppResign)
        }
        if let started = started {
            try encodeContainer.encode(started.timeIntervalSince1970, forKey: .started)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopped = stopped {
            try encodeContainer.encode(stopped.timeIntervalSince1970, forKey: .stopped)
        }
        if let testSpecArn = testSpecArn {
            try encodeContainer.encode(testSpecArn, forKey: .testSpecArn)
        }
        if let totalJobs = totalJobs {
            try encodeContainer.encode(totalJobs, forKey: .totalJobs)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let webUrl = webUrl {
            try encodeContainer.encode(webUrl, forKey: .webUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestType.self, forKey: .type)
        type = typeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePlatform.self, forKey: .platform)
        platform = platformDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let startedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .started)
        started = startedDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopped)
        stopped = stoppedDecoded
        let countersDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Counters.self, forKey: .counters)
        counters = countersDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let totalJobsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalJobs)
        totalJobs = totalJobsDecoded
        let completedJobsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completedJobs)
        completedJobs = completedJobsDecoded
        let billingMethodDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.BillingMethod.self, forKey: .billingMethod)
        billingMethod = billingMethodDecoded
        let deviceMinutesDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceMinutes.self, forKey: .deviceMinutes)
        deviceMinutes = deviceMinutesDecoded
        let networkProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfile.self, forKey: .networkProfile)
        networkProfile = networkProfileDecoded
        let parsingResultUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parsingResultUrl)
        parsingResultUrl = parsingResultUrlDecoded
        let resultCodeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionResultCode.self, forKey: .resultCode)
        resultCode = resultCodeDecoded
        let seedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .seed)
        seed = seedDecoded
        let appUploadDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appUpload)
        appUpload = appUploadDecoded
        let eventCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventCount)
        eventCount = eventCountDecoded
        let jobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .jobTimeoutMinutes)
        jobTimeoutMinutes = jobTimeoutMinutesDecoded
        let devicePoolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devicePoolArn)
        devicePoolArn = devicePoolArnDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let radiosDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Radios.self, forKey: .radios)
        radios = radiosDecoded
        let locationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let customerArtifactPathsDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.CustomerArtifactPaths.self, forKey: .customerArtifactPaths)
        customerArtifactPaths = customerArtifactPathsDecoded
        let webUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webUrl)
        webUrl = webUrlDecoded
        let skipAppResignDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .skipAppResign)
        skipAppResign = skipAppResignDecoded
        let testSpecArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSpecArn)
        testSpecArn = testSpecArnDecoded
        let deviceSelectionResultDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceSelectionResult.self, forKey: .deviceSelectionResult)
        deviceSelectionResult = deviceSelectionResultDecoded
    }
}

extension DeviceFarmClientTypes.Run: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Run(appUpload: \(Swift.String(describing: appUpload)), arn: \(Swift.String(describing: arn)), billingMethod: \(Swift.String(describing: billingMethod)), completedJobs: \(Swift.String(describing: completedJobs)), counters: \(Swift.String(describing: counters)), created: \(Swift.String(describing: created)), customerArtifactPaths: \(Swift.String(describing: customerArtifactPaths)), deviceMinutes: \(Swift.String(describing: deviceMinutes)), devicePoolArn: \(Swift.String(describing: devicePoolArn)), deviceSelectionResult: \(Swift.String(describing: deviceSelectionResult)), eventCount: \(Swift.String(describing: eventCount)), jobTimeoutMinutes: \(Swift.String(describing: jobTimeoutMinutes)), locale: \(Swift.String(describing: locale)), location: \(Swift.String(describing: location)), message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)), networkProfile: \(Swift.String(describing: networkProfile)), parsingResultUrl: \(Swift.String(describing: parsingResultUrl)), platform: \(Swift.String(describing: platform)), radios: \(Swift.String(describing: radios)), result: \(Swift.String(describing: result)), resultCode: \(Swift.String(describing: resultCode)), seed: \(Swift.String(describing: seed)), skipAppResign: \(Swift.String(describing: skipAppResign)), started: \(Swift.String(describing: started)), status: \(Swift.String(describing: status)), stopped: \(Swift.String(describing: stopped)), testSpecArn: \(Swift.String(describing: testSpecArn)), totalJobs: \(Swift.String(describing: totalJobs)), type: \(Swift.String(describing: type)), webUrl: \(Swift.String(describing: webUrl)))"}
}

extension DeviceFarmClientTypes {
    /// Represents a test run on a set of devices with a given app package, test parameters, and so
    ///             on.
    public struct Run: Swift.Equatable {
        /// An app to upload or that has been uploaded.
        public var appUpload: Swift.String?
        /// The run's ARN.
        public var arn: Swift.String?
        /// Specifies the billing method for a test run: metered or
        ///                 unmetered. If the parameter is not specified, the default value is
        ///                 metered.
        ///
        ///             If you have unmetered device slots, you must set this to unmetered to use them.
        ///                 Otherwise, the run is counted toward metered device minutes.
        ///
        public var billingMethod: DeviceFarmClientTypes.BillingMethod?
        /// The total number of completed jobs.
        public var completedJobs: Swift.Int?
        /// The run's result counters.
        public var counters: DeviceFarmClientTypes.Counters?
        /// When the run was created.
        public var created: ClientRuntime.Date?
        /// Output CustomerArtifactPaths object for the test run.
        public var customerArtifactPaths: DeviceFarmClientTypes.CustomerArtifactPaths?
        /// Represents the total (metered or unmetered) minutes used by the test run.
        public var deviceMinutes: DeviceFarmClientTypes.DeviceMinutes?
        /// The ARN of the device pool for the run.
        public var devicePoolArn: Swift.String?
        /// The results of a device filter used to select the devices for a test run.
        public var deviceSelectionResult: DeviceFarmClientTypes.DeviceSelectionResult?
        /// For fuzz tests, this is the number of events, between 1 and 10000, that the UI fuzz
        ///             test should perform.
        public var eventCount: Swift.Int?
        /// The number of minutes the job executes before it times out.
        public var jobTimeoutMinutes: Swift.Int?
        /// Information about the locale that is used for the run.
        public var locale: Swift.String?
        /// Information about the location that is used for the run.
        public var location: DeviceFarmClientTypes.Location?
        /// A message about the run's result.
        public var message: Swift.String?
        /// The run's name.
        public var name: Swift.String?
        /// The network profile being used for a test run.
        public var networkProfile: DeviceFarmClientTypes.NetworkProfile?
        /// Read-only URL for an object in an S3 bucket where you can get the parsing results of the test package.
        ///             If the test package doesn't parse, the reason why it doesn't parse appears in the file that this URL points
        ///             to.
        public var parsingResultUrl: Swift.String?
        /// The run's platform.
        ///         Allowed values include:
        ///
        ///
        ///                 ANDROID
        ///
        ///
        ///                 IOS
        ///
        ///
        public var platform: DeviceFarmClientTypes.DevicePlatform?
        /// Information about the radio states for the run.
        public var radios: DeviceFarmClientTypes.Radios?
        /// The run's result.
        ///         Allowed values include:
        ///
        ///
        ///                 PENDING
        ///
        ///
        ///                 PASSED
        ///
        ///
        ///                 WARNED
        ///
        ///
        ///                 FAILED
        ///
        ///
        ///                 SKIPPED
        ///
        ///
        ///                 ERRORED
        ///
        ///
        ///                 STOPPED
        ///
        ///
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// Supporting field for the result field. Set only if result is SKIPPED.
        ///                 PARSING_FAILED if the result is skipped because of test package parsing failure.
        public var resultCode: DeviceFarmClientTypes.ExecutionResultCode?
        /// For fuzz tests, this is a seed to use for randomizing the UI fuzz test. Using the same
        ///             seed value between tests ensures identical event sequences.
        public var seed: Swift.Int?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public
        ///             devices, Device Farm always signs your apps again.
        ///         For more information about how Device Farm re-signs your apps, see <a href="https://aws.amazon.com/device-farm/faq/">Do you modify my app? in the AWS Device
        ///                 Farm FAQs.
        public var skipAppResign: Swift.Bool?
        /// The run's start time.
        public var started: ClientRuntime.Date?
        /// The run's status.
        ///         Allowed values include:
        ///
        ///
        ///                 PENDING
        ///
        ///
        ///                 PENDING_CONCURRENCY
        ///
        ///
        ///                 PENDING_DEVICE
        ///
        ///
        ///                 PROCESSING
        ///
        ///
        ///                 SCHEDULING
        ///
        ///
        ///                 PREPARING
        ///
        ///
        ///                 RUNNING
        ///
        ///
        ///                 COMPLETED
        ///
        ///
        ///                 STOPPING
        ///
        ///
        public var status: DeviceFarmClientTypes.ExecutionStatus?
        /// The run's stop time.
        public var stopped: ClientRuntime.Date?
        /// The ARN of the YAML-formatted test specification for the run.
        public var testSpecArn: Swift.String?
        /// The total number of jobs for the run.
        public var totalJobs: Swift.Int?
        /// The run's type.
        ///         Must be one of the following values:
        ///
        ///
        ///                 BUILTIN_FUZZ
        ///
        ///
        ///                 BUILTIN_EXPLORER
        ///
        ///                     For Android, an app explorer that traverses an Android app, interacting with it and capturing
        ///                         screenshots at the same time.
        ///
        ///
        ///
        ///                 APPIUM_JAVA_JUNIT
        ///
        ///
        ///                 APPIUM_JAVA_TESTNG
        ///
        ///
        ///                 APPIUM_PYTHON
        ///
        ///
        ///                 APPIUM_NODE
        ///
        ///
        ///                 APPIUM_RUBY
        ///
        ///
        ///                 APPIUM_WEB_JAVA_JUNIT
        ///
        ///
        ///                 APPIUM_WEB_JAVA_TESTNG
        ///
        ///
        ///                 APPIUM_WEB_PYTHON
        ///
        ///
        ///                 APPIUM_WEB_NODE
        ///
        ///
        ///                 APPIUM_WEB_RUBY
        ///
        ///
        ///                 CALABASH
        ///
        ///
        ///                 INSTRUMENTATION
        ///
        ///
        ///                 UIAUTOMATION
        ///
        ///
        ///                 UIAUTOMATOR
        ///
        ///
        ///                 XCTEST
        ///
        ///
        ///                 XCTEST_UI
        ///
        ///
        public var type: DeviceFarmClientTypes.TestType?
        /// The Device Farm console URL for the recording of the run.
        public var webUrl: Swift.String?

        public init (
            appUpload: Swift.String? = nil,
            arn: Swift.String? = nil,
            billingMethod: DeviceFarmClientTypes.BillingMethod? = nil,
            completedJobs: Swift.Int? = nil,
            counters: DeviceFarmClientTypes.Counters? = nil,
            created: ClientRuntime.Date? = nil,
            customerArtifactPaths: DeviceFarmClientTypes.CustomerArtifactPaths? = nil,
            deviceMinutes: DeviceFarmClientTypes.DeviceMinutes? = nil,
            devicePoolArn: Swift.String? = nil,
            deviceSelectionResult: DeviceFarmClientTypes.DeviceSelectionResult? = nil,
            eventCount: Swift.Int? = nil,
            jobTimeoutMinutes: Swift.Int? = nil,
            locale: Swift.String? = nil,
            location: DeviceFarmClientTypes.Location? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            networkProfile: DeviceFarmClientTypes.NetworkProfile? = nil,
            parsingResultUrl: Swift.String? = nil,
            platform: DeviceFarmClientTypes.DevicePlatform? = nil,
            radios: DeviceFarmClientTypes.Radios? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            resultCode: DeviceFarmClientTypes.ExecutionResultCode? = nil,
            seed: Swift.Int? = nil,
            skipAppResign: Swift.Bool? = nil,
            started: ClientRuntime.Date? = nil,
            status: DeviceFarmClientTypes.ExecutionStatus? = nil,
            stopped: ClientRuntime.Date? = nil,
            testSpecArn: Swift.String? = nil,
            totalJobs: Swift.Int? = nil,
            type: DeviceFarmClientTypes.TestType? = nil,
            webUrl: Swift.String? = nil
        )
        {
            self.appUpload = appUpload
            self.arn = arn
            self.billingMethod = billingMethod
            self.completedJobs = completedJobs
            self.counters = counters
            self.created = created
            self.customerArtifactPaths = customerArtifactPaths
            self.deviceMinutes = deviceMinutes
            self.devicePoolArn = devicePoolArn
            self.deviceSelectionResult = deviceSelectionResult
            self.eventCount = eventCount
            self.jobTimeoutMinutes = jobTimeoutMinutes
            self.locale = locale
            self.location = location
            self.message = message
            self.name = name
            self.networkProfile = networkProfile
            self.parsingResultUrl = parsingResultUrl
            self.platform = platform
            self.radios = radios
            self.result = result
            self.resultCode = resultCode
            self.seed = seed
            self.skipAppResign = skipAppResign
            self.started = started
            self.status = status
            self.stopped = stopped
            self.testSpecArn = testSpecArn
            self.totalJobs = totalJobs
            self.type = type
            self.webUrl = webUrl
        }
    }

}

extension DeviceFarmClientTypes.Sample: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case type
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.SampleType.self, forKey: .type)
        type = typeDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension DeviceFarmClientTypes.Sample: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Sample(arn: \(Swift.String(describing: arn)), type: \(Swift.String(describing: type)), url: \(Swift.String(describing: url)))"}
}

extension DeviceFarmClientTypes {
    /// Represents a sample of performance data.
    public struct Sample: Swift.Equatable {
        /// The sample's ARN.
        public var arn: Swift.String?
        /// The sample's type.
        ///         Must be one of the following values:
        ///
        ///
        ///                 CPU: A CPU sample type. This is expressed as the app processing CPU time
        ///                     (including child processes) as reported by process, as a percentage.
        ///
        ///
        ///                 MEMORY: A memory usage sample type. This is expressed as the total
        ///                     proportional set size of an app process, in kilobytes.
        ///
        ///
        ///                 NATIVE_AVG_DRAWTIME
        ///
        ///
        ///                 NATIVE_FPS
        ///
        ///
        ///                 NATIVE_FRAMES
        ///
        ///
        ///                 NATIVE_MAX_DRAWTIME
        ///
        ///
        ///                 NATIVE_MIN_DRAWTIME
        ///
        ///
        ///                 OPENGL_AVG_DRAWTIME
        ///
        ///
        ///                 OPENGL_FPS
        ///
        ///
        ///                 OPENGL_FRAMES
        ///
        ///
        ///                 OPENGL_MAX_DRAWTIME
        ///
        ///
        ///                 OPENGL_MIN_DRAWTIME
        ///
        ///
        ///                 RX
        ///
        ///
        ///                 RX_RATE: The total number of bytes per second (TCP and UDP) that are sent,
        ///                     by app process.
        ///
        ///
        ///                 THREADS: A threads sample type. This is expressed as the total number of
        ///                     threads per app process.
        ///
        ///
        ///                 TX
        ///
        ///
        ///                 TX_RATE: The total number of bytes per second (TCP and UDP) that are
        ///                     received, by app process.
        ///
        ///
        public var type: DeviceFarmClientTypes.SampleType?
        /// The presigned Amazon S3 URL that can be used with a GET request to download the sample's
        ///             file.
        public var url: Swift.String?

        public init (
            arn: Swift.String? = nil,
            type: DeviceFarmClientTypes.SampleType? = nil,
            url: Swift.String? = nil
        )
        {
            self.arn = arn
            self.type = type
            self.url = url
        }
    }

}

extension DeviceFarmClientTypes {
    public enum SampleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cpu
        case memory
        case nativeAvgDrawtime
        case nativeFps
        case nativeFrames
        case nativeMaxDrawtime
        case nativeMinDrawtime
        case openglAvgDrawtime
        case openglFps
        case openglFrames
        case openglMaxDrawtime
        case openglMinDrawtime
        case rx
        case rxRate
        case threads
        case tx
        case txRate
        case sdkUnknown(Swift.String)

        public static var allCases: [SampleType] {
            return [
                .cpu,
                .memory,
                .nativeAvgDrawtime,
                .nativeFps,
                .nativeFrames,
                .nativeMaxDrawtime,
                .nativeMinDrawtime,
                .openglAvgDrawtime,
                .openglFps,
                .openglFrames,
                .openglMaxDrawtime,
                .openglMinDrawtime,
                .rx,
                .rxRate,
                .threads,
                .tx,
                .txRate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cpu: return "CPU"
            case .memory: return "MEMORY"
            case .nativeAvgDrawtime: return "NATIVE_AVG_DRAWTIME"
            case .nativeFps: return "NATIVE_FPS"
            case .nativeFrames: return "NATIVE_FRAMES"
            case .nativeMaxDrawtime: return "NATIVE_MAX_DRAWTIME"
            case .nativeMinDrawtime: return "NATIVE_MIN_DRAWTIME"
            case .openglAvgDrawtime: return "OPENGL_AVG_DRAWTIME"
            case .openglFps: return "OPENGL_FPS"
            case .openglFrames: return "OPENGL_FRAMES"
            case .openglMaxDrawtime: return "OPENGL_MAX_DRAWTIME"
            case .openglMinDrawtime: return "OPENGL_MIN_DRAWTIME"
            case .rx: return "RX"
            case .rxRate: return "RX_RATE"
            case .threads: return "THREADS"
            case .tx: return "TX"
            case .txRate: return "TX_RATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SampleType(rawValue: rawValue) ?? SampleType.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.ScheduleRunConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auxiliaryApps
        case billingMethod
        case customerArtifactPaths
        case extraDataPackageArn
        case locale
        case location
        case networkProfileArn
        case radios
        case vpceConfigurationArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auxiliaryApps = auxiliaryApps {
            var auxiliaryAppsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .auxiliaryApps)
            for amazonresourcenames0 in auxiliaryApps {
                try auxiliaryAppsContainer.encode(amazonresourcenames0)
            }
        }
        if let billingMethod = billingMethod {
            try encodeContainer.encode(billingMethod.rawValue, forKey: .billingMethod)
        }
        if let customerArtifactPaths = customerArtifactPaths {
            try encodeContainer.encode(customerArtifactPaths, forKey: .customerArtifactPaths)
        }
        if let extraDataPackageArn = extraDataPackageArn {
            try encodeContainer.encode(extraDataPackageArn, forKey: .extraDataPackageArn)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
        if let radios = radios {
            try encodeContainer.encode(radios, forKey: .radios)
        }
        if let vpceConfigurationArns = vpceConfigurationArns {
            var vpceConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpceConfigurationArns)
            for amazonresourcenames0 in vpceConfigurationArns {
                try vpceConfigurationArnsContainer.encode(amazonresourcenames0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extraDataPackageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extraDataPackageArn)
        extraDataPackageArn = extraDataPackageArnDecoded
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Location.self, forKey: .location)
        location = locationDecoded
        let vpceConfigurationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpceConfigurationArns)
        var vpceConfigurationArnsDecoded0:[Swift.String]? = nil
        if let vpceConfigurationArnsContainer = vpceConfigurationArnsContainer {
            vpceConfigurationArnsDecoded0 = [Swift.String]()
            for string0 in vpceConfigurationArnsContainer {
                if let string0 = string0 {
                    vpceConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        vpceConfigurationArns = vpceConfigurationArnsDecoded0
        let customerArtifactPathsDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.CustomerArtifactPaths.self, forKey: .customerArtifactPaths)
        customerArtifactPaths = customerArtifactPathsDecoded
        let radiosDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Radios.self, forKey: .radios)
        radios = radiosDecoded
        let auxiliaryAppsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .auxiliaryApps)
        var auxiliaryAppsDecoded0:[Swift.String]? = nil
        if let auxiliaryAppsContainer = auxiliaryAppsContainer {
            auxiliaryAppsDecoded0 = [Swift.String]()
            for string0 in auxiliaryAppsContainer {
                if let string0 = string0 {
                    auxiliaryAppsDecoded0?.append(string0)
                }
            }
        }
        auxiliaryApps = auxiliaryAppsDecoded0
        let billingMethodDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.BillingMethod.self, forKey: .billingMethod)
        billingMethod = billingMethodDecoded
    }
}

extension DeviceFarmClientTypes.ScheduleRunConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduleRunConfiguration(auxiliaryApps: \(Swift.String(describing: auxiliaryApps)), billingMethod: \(Swift.String(describing: billingMethod)), customerArtifactPaths: \(Swift.String(describing: customerArtifactPaths)), extraDataPackageArn: \(Swift.String(describing: extraDataPackageArn)), locale: \(Swift.String(describing: locale)), location: \(Swift.String(describing: location)), networkProfileArn: \(Swift.String(describing: networkProfileArn)), radios: \(Swift.String(describing: radios)), vpceConfigurationArns: \(Swift.String(describing: vpceConfigurationArns)))"}
}

extension DeviceFarmClientTypes {
    /// Represents the settings for a run. Includes things like location, radio states,
    ///             auxiliary apps, and network profiles.
    public struct ScheduleRunConfiguration: Swift.Equatable {
        /// A list of upload ARNs for app packages to be installed with your app.
        public var auxiliaryApps: [Swift.String]?
        /// Specifies the billing method for a test run: metered or
        ///                 unmetered. If the parameter is not specified, the default value is
        ///                 metered.
        ///
        ///             If you have purchased unmetered device slots, you must set this parameter to unmetered to
        ///                 make use of them. Otherwise, your run counts against your metered time.
        ///
        public var billingMethod: DeviceFarmClientTypes.BillingMethod?
        /// Input CustomerArtifactPaths object for the scheduled run
        ///             configuration.
        public var customerArtifactPaths: DeviceFarmClientTypes.CustomerArtifactPaths?
        /// The ARN of the extra data for the run. The extra data is a .zip file that AWS Device Farm extracts to
        ///             external data for Android or the app's sandbox for iOS.
        public var extraDataPackageArn: Swift.String?
        /// Information about the locale that is used for the run.
        public var locale: Swift.String?
        /// Information about the location that is used for the run.
        public var location: DeviceFarmClientTypes.Location?
        /// Reserved for internal use.
        public var networkProfileArn: Swift.String?
        /// Information about the radio states for the run.
        public var radios: DeviceFarmClientTypes.Radios?
        /// An array of ARNs for your VPC endpoint configurations.
        public var vpceConfigurationArns: [Swift.String]?

        public init (
            auxiliaryApps: [Swift.String]? = nil,
            billingMethod: DeviceFarmClientTypes.BillingMethod? = nil,
            customerArtifactPaths: DeviceFarmClientTypes.CustomerArtifactPaths? = nil,
            extraDataPackageArn: Swift.String? = nil,
            locale: Swift.String? = nil,
            location: DeviceFarmClientTypes.Location? = nil,
            networkProfileArn: Swift.String? = nil,
            radios: DeviceFarmClientTypes.Radios? = nil,
            vpceConfigurationArns: [Swift.String]? = nil
        )
        {
            self.auxiliaryApps = auxiliaryApps
            self.billingMethod = billingMethod
            self.customerArtifactPaths = customerArtifactPaths
            self.extraDataPackageArn = extraDataPackageArn
            self.locale = locale
            self.location = location
            self.networkProfileArn = networkProfileArn
            self.radios = radios
            self.vpceConfigurationArns = vpceConfigurationArns
        }
    }

}

public struct ScheduleRunInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ScheduleRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ScheduleRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ScheduleRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ScheduleRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ScheduleRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ScheduleRunOutputError>
}

extension ScheduleRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduleRunInput(appArn: \(Swift.String(describing: appArn)), configuration: \(Swift.String(describing: configuration)), devicePoolArn: \(Swift.String(describing: devicePoolArn)), deviceSelectionConfiguration: \(Swift.String(describing: deviceSelectionConfiguration)), executionConfiguration: \(Swift.String(describing: executionConfiguration)), name: \(Swift.String(describing: name)), projectArn: \(Swift.String(describing: projectArn)), test: \(Swift.String(describing: test)))"}
}

extension ScheduleRunInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case configuration
        case devicePoolArn
        case deviceSelectionConfiguration
        case executionConfiguration
        case name
        case projectArn
        case test
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let devicePoolArn = devicePoolArn {
            try encodeContainer.encode(devicePoolArn, forKey: .devicePoolArn)
        }
        if let deviceSelectionConfiguration = deviceSelectionConfiguration {
            try encodeContainer.encode(deviceSelectionConfiguration, forKey: .deviceSelectionConfiguration)
        }
        if let executionConfiguration = executionConfiguration {
            try encodeContainer.encode(executionConfiguration, forKey: .executionConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let test = test {
            try encodeContainer.encode(test, forKey: .test)
        }
    }
}

public struct ScheduleRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ScheduleRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ScheduleRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ScheduleRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ScheduleRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ScheduleRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ScheduleRunOutputError>
}

public struct ScheduleRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ScheduleRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ScheduleRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ScheduleRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ScheduleRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ScheduleRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ScheduleRunOutputError>
}

public struct ScheduleRunInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ScheduleRunInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ScheduleRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ScheduleRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ScheduleRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<ScheduleRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ScheduleRunOutputError>
}

public struct ScheduleRunInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ScheduleRunInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ScheduleRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ScheduleRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ScheduleRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<ScheduleRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ScheduleRunOutputError>
}

/// Represents a request to the schedule run operation.
public struct ScheduleRunInput: Swift.Equatable {
    /// The ARN of an application package to run tests against, created with CreateUpload.
    ///             See ListUploads.
    public var appArn: Swift.String?
    /// Information about the settings for the run to be scheduled.
    public var configuration: DeviceFarmClientTypes.ScheduleRunConfiguration?
    /// The ARN of the device pool for the run to be scheduled.
    public var devicePoolArn: Swift.String?
    /// The filter criteria used to dynamically select a set of devices for a test run and the maximum number of
    ///             devices to be included in the run.
    ///         Either
    ///                devicePoolArn
    ///              or
    ///                deviceSelectionConfiguration
    ///              is required in a
    ///             request.
    public var deviceSelectionConfiguration: DeviceFarmClientTypes.DeviceSelectionConfiguration?
    /// Specifies configuration information about a test run, such as the execution timeout
    ///             (in minutes).
    public var executionConfiguration: DeviceFarmClientTypes.ExecutionConfiguration?
    /// The name for the run to be scheduled.
    public var name: Swift.String?
    /// The ARN of the project for the run to be scheduled.
    /// This member is required.
    public var projectArn: Swift.String?
    /// Information about the test for the run to be scheduled.
    /// This member is required.
    public var test: DeviceFarmClientTypes.ScheduleRunTest?

    public init (
        appArn: Swift.String? = nil,
        configuration: DeviceFarmClientTypes.ScheduleRunConfiguration? = nil,
        devicePoolArn: Swift.String? = nil,
        deviceSelectionConfiguration: DeviceFarmClientTypes.DeviceSelectionConfiguration? = nil,
        executionConfiguration: DeviceFarmClientTypes.ExecutionConfiguration? = nil,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        test: DeviceFarmClientTypes.ScheduleRunTest? = nil
    )
    {
        self.appArn = appArn
        self.configuration = configuration
        self.devicePoolArn = devicePoolArn
        self.deviceSelectionConfiguration = deviceSelectionConfiguration
        self.executionConfiguration = executionConfiguration
        self.name = name
        self.projectArn = projectArn
        self.test = test
    }
}

struct ScheduleRunInputBody: Swift.Equatable {
    public let projectArn: Swift.String?
    public let appArn: Swift.String?
    public let devicePoolArn: Swift.String?
    public let deviceSelectionConfiguration: DeviceFarmClientTypes.DeviceSelectionConfiguration?
    public let name: Swift.String?
    public let test: DeviceFarmClientTypes.ScheduleRunTest?
    public let configuration: DeviceFarmClientTypes.ScheduleRunConfiguration?
    public let executionConfiguration: DeviceFarmClientTypes.ExecutionConfiguration?
}

extension ScheduleRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case configuration
        case devicePoolArn
        case deviceSelectionConfiguration
        case executionConfiguration
        case name
        case projectArn
        case test
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let devicePoolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devicePoolArn)
        devicePoolArn = devicePoolArnDecoded
        let deviceSelectionConfigurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceSelectionConfiguration.self, forKey: .deviceSelectionConfiguration)
        deviceSelectionConfiguration = deviceSelectionConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let testDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ScheduleRunTest.self, forKey: .test)
        test = testDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ScheduleRunConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let executionConfigurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionConfiguration.self, forKey: .executionConfiguration)
        executionConfiguration = executionConfigurationDecoded
    }
}

extension ScheduleRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ScheduleRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotencyException" : self = .idempotencyException(try IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ScheduleRunOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case idempotencyException(IdempotencyException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ScheduleRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduleRunOutputResponse(run: \(Swift.String(describing: run)))"}
}

extension ScheduleRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ScheduleRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.run = output.run
        } else {
            self.run = nil
        }
    }
}

/// Represents the result of a schedule run request.
public struct ScheduleRunOutputResponse: Swift.Equatable {
    /// Information about the scheduled run.
    public var run: DeviceFarmClientTypes.Run?

    public init (
        run: DeviceFarmClientTypes.Run? = nil
    )
    {
        self.run = run
    }
}

struct ScheduleRunOutputResponseBody: Swift.Equatable {
    public let run: DeviceFarmClientTypes.Run?
}

extension ScheduleRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case run
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Run.self, forKey: .run)
        run = runDecoded
    }
}

extension DeviceFarmClientTypes.ScheduleRunTest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case parameters
        case testPackageArn
        case testSpecArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, testparameters0) in parameters {
                try parametersContainer.encode(testparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let testPackageArn = testPackageArn {
            try encodeContainer.encode(testPackageArn, forKey: .testPackageArn)
        }
        if let testSpecArn = testSpecArn {
            try encodeContainer.encode(testSpecArn, forKey: .testSpecArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestType.self, forKey: .type)
        type = typeDecoded
        let testPackageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testPackageArn)
        testPackageArn = testPackageArnDecoded
        let testSpecArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testSpecArn)
        testSpecArn = testSpecArnDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filter)
        filter = filterDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in parametersContainer {
                if let string0 = string0 {
                    parametersDecoded0?[key0] = string0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension DeviceFarmClientTypes.ScheduleRunTest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScheduleRunTest(filter: \(Swift.String(describing: filter)), parameters: \(Swift.String(describing: parameters)), testPackageArn: \(Swift.String(describing: testPackageArn)), testSpecArn: \(Swift.String(describing: testSpecArn)), type: \(Swift.String(describing: type)))"}
}

extension DeviceFarmClientTypes {
    /// Represents test settings. This data structure is passed in as the test parameter to ScheduleRun. For an
    ///             example of the JSON request syntax, see ScheduleRun.
    public struct ScheduleRunTest: Swift.Equatable {
        /// The test's filter.
        public var filter: Swift.String?
        /// The test's parameters, such as test framework parameters and fixture settings.
        ///             Parameters are represented by name-value pairs of strings.
        ///         For all tests:
        ///
        ///
        ///
        ///                   app_performance_monitoring: Performance monitoring is enabled by default.
        ///                     Set this parameter to false to disable it.
        ///
        ///
        ///         For Calabash tests:
        ///
        ///
        ///                 profile: A cucumber profile (for example, my_profile_name).
        ///
        ///
        ///                 tags: You can limit execution to features or scenarios that have (or don't
        ///                     have) certain tags (for example, @smoke or @smoke,~@wip).
        ///
        ///
        ///         For Appium tests (all types):
        ///
        ///
        ///                 appium_version: The Appium version. Currently supported values are 1.6.5
        ///                     (and later), latest, and default.
        ///
        ///
        ///
        ///                         latest runs the latest Appium version supported by Device
        ///                             Farm (1.9.1).
        ///
        ///
        ///                         For default, Device Farm selects a compatible version of
        ///                             Appium for the device. The current behavior is to run 1.7.2 on Android
        ///                             devices and iOS 9 and earlier and 1.7.2 for iOS 10 and later.
        ///
        ///
        ///                         This behavior is subject to change.
        ///
        ///
        ///
        ///
        ///         For fuzz tests (Android only):
        ///
        ///
        ///                 event_count: The number of events, between 1 and 10000, that the UI fuzz
        ///                     test should perform.
        ///
        ///
        ///                 throttle: The time, in ms, between 0 and 1000, that the UI fuzz test should
        ///                     wait between events.
        ///
        ///
        ///                 seed: A seed to use for randomizing the UI fuzz test. Using the same seed
        ///                     value between tests ensures identical event sequences.
        ///
        ///
        ///         For Explorer tests:
        ///
        ///
        ///                 username: A user name to use if the Explorer encounters a login form. If not supplied, no user
        ///                     name is inserted.
        ///
        ///
        ///                 password: A password to use if the Explorer encounters a login form. If not supplied, no
        ///                     password is inserted.
        ///
        ///
        ///         For Instrumentation:
        ///
        ///
        ///                 filter: A test filter string. Examples:
        ///
        ///
        ///                         Running a single test case: com.android.abc.Test1
        ///
        ///
        ///
        ///                         Running a single test: com.android.abc.Test1#smoke
        ///
        ///
        ///
        ///                         Running multiple tests:
        ///                             com.android.abc.Test1,com.android.abc.Test2
        ///
        ///
        ///
        ///
        ///
        ///         For XCTest and XCTestUI:
        ///
        ///
        ///                 filter: A test filter string. Examples:
        ///
        ///
        ///                         Running a single test class: LoginTests
        ///
        ///
        ///
        ///                         Running a multiple test classes: LoginTests,SmokeTests
        ///
        ///
        ///
        ///                         Running a single test: LoginTests/testValid
        ///
        ///
        ///
        ///                         Running multiple tests:
        ///                             LoginTests/testValid,LoginTests/testInvalid
        ///
        ///
        ///
        ///
        ///
        ///         For UIAutomator:
        ///
        ///
        ///                 filter: A test filter string. Examples:
        ///
        ///
        ///                         Running a single test case: com.android.abc.Test1
        ///
        ///
        ///
        ///                         Running a single test: com.android.abc.Test1#smoke
        ///
        ///
        ///
        ///                         Running multiple tests:
        ///                             com.android.abc.Test1,com.android.abc.Test2
        ///
        ///
        ///
        ///
        ///
        public var parameters: [Swift.String:Swift.String]?
        /// The ARN of the uploaded test to be run.
        public var testPackageArn: Swift.String?
        /// The ARN of the YAML-formatted test specification.
        public var testSpecArn: Swift.String?
        /// The test's type.
        ///         Must be one of the following values:
        ///
        ///
        ///                 BUILTIN_FUZZ
        ///
        ///
        ///                 BUILTIN_EXPLORER. For Android, an app explorer that traverses an
        ///                     Android app, interacting with it and capturing screenshots at the same
        ///                     time.
        ///
        ///
        ///                 APPIUM_JAVA_JUNIT
        ///
        ///
        ///                 APPIUM_JAVA_TESTNG
        ///
        ///
        ///                 APPIUM_PYTHON
        ///
        ///
        ///                 APPIUM_NODE
        ///
        ///
        ///                 APPIUM_RUBY
        ///
        ///
        ///                 APPIUM_WEB_JAVA_JUNIT
        ///
        ///
        ///                 APPIUM_WEB_JAVA_TESTNG
        ///
        ///
        ///                 APPIUM_WEB_PYTHON
        ///
        ///
        ///                 APPIUM_WEB_NODE
        ///
        ///
        ///                 APPIUM_WEB_RUBY
        ///
        ///
        ///                 CALABASH
        ///
        ///
        ///                 INSTRUMENTATION
        ///
        ///
        ///                 UIAUTOMATION
        ///
        ///
        ///                 UIAUTOMATOR
        ///
        ///
        ///                 XCTEST
        ///
        ///
        ///                 XCTEST_UI
        ///
        ///
        /// This member is required.
        public var type: DeviceFarmClientTypes.TestType?

        public init (
            filter: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            testPackageArn: Swift.String? = nil,
            testSpecArn: Swift.String? = nil,
            type: DeviceFarmClientTypes.TestType? = nil
        )
        {
            self.filter = filter
            self.parameters = parameters
            self.testPackageArn = testPackageArn
            self.testSpecArn = testSpecArn
            self.type = type
        }
    }

}

extension ServiceAccountException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceAccountException(message: \(Swift.String(describing: message)))"}
}

extension ServiceAccountException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceAccountExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a problem with the service account.
public struct ServiceAccountException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Any additional information about the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceAccountExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceAccountExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StopJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopJobOutputError>
}

extension StopJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopJobInput(arn: \(Swift.String(describing: arn)))"}
}

extension StopJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct StopJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopJobOutputError>
}

public struct StopJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopJobOutputError>
}

public struct StopJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopJobOutputError>
}

public struct StopJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopJobOutputError>
}

public struct StopJobInput: Swift.Equatable {
    /// Represents the Amazon Resource Name (ARN) of the Device Farm job to stop.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct StopJobInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension StopJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StopJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopJobOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopJobOutputResponse(job: \(Swift.String(describing: job)))"}
}

extension StopJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StopJobOutputResponse: Swift.Equatable {
    /// The job that was stopped.
    public var job: DeviceFarmClientTypes.Job?

    public init (
        job: DeviceFarmClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct StopJobOutputResponseBody: Swift.Equatable {
    public let job: DeviceFarmClientTypes.Job?
}

extension StopJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

public struct StopRemoteAccessSessionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopRemoteAccessSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopRemoteAccessSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopRemoteAccessSessionOutputError>
}

extension StopRemoteAccessSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopRemoteAccessSessionInput(arn: \(Swift.String(describing: arn)))"}
}

extension StopRemoteAccessSessionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct StopRemoteAccessSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopRemoteAccessSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopRemoteAccessSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopRemoteAccessSessionOutputError>
}

public struct StopRemoteAccessSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopRemoteAccessSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopRemoteAccessSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopRemoteAccessSessionOutputError>
}

public struct StopRemoteAccessSessionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopRemoteAccessSessionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopRemoteAccessSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopRemoteAccessSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopRemoteAccessSessionOutputError>
}

public struct StopRemoteAccessSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopRemoteAccessSessionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopRemoteAccessSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopRemoteAccessSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopRemoteAccessSessionOutputError>
}

/// Represents the request to stop the remote access session.
public struct StopRemoteAccessSessionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the remote access session to stop.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct StopRemoteAccessSessionInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension StopRemoteAccessSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StopRemoteAccessSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopRemoteAccessSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopRemoteAccessSessionOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopRemoteAccessSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopRemoteAccessSessionOutputResponse(remoteAccessSession: \(Swift.String(describing: remoteAccessSession)))"}
}

extension StopRemoteAccessSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopRemoteAccessSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.remoteAccessSession = output.remoteAccessSession
        } else {
            self.remoteAccessSession = nil
        }
    }
}

/// Represents the response from the server that describes the remote access session
///             when AWS Device Farm stops the session.
public struct StopRemoteAccessSessionOutputResponse: Swift.Equatable {
    /// A container that represents the metadata from the service about the remote access session you are
    ///             stopping.
    public var remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession?

    public init (
        remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession? = nil
    )
    {
        self.remoteAccessSession = remoteAccessSession
    }
}

struct StopRemoteAccessSessionOutputResponseBody: Swift.Equatable {
    public let remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession?
}

extension StopRemoteAccessSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case remoteAccessSession
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteAccessSessionDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.RemoteAccessSession.self, forKey: .remoteAccessSession)
        remoteAccessSession = remoteAccessSessionDecoded
    }
}

public struct StopRunInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopRunOutputError>
}

extension StopRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopRunInput(arn: \(Swift.String(describing: arn)))"}
}

extension StopRunInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct StopRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopRunOutputError>
}

public struct StopRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopRunOutputError>
}

public struct StopRunInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopRunInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopRunOutputError>
}

public struct StopRunInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopRunInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopRunOutputError>
}

/// Represents the request to stop a specific run.
public struct StopRunInput: Swift.Equatable {
    /// Represents the Amazon Resource Name (ARN) of the Device Farm run to stop.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct StopRunInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension StopRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StopRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopRunOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopRunOutputResponse(run: \(Swift.String(describing: run)))"}
}

extension StopRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.run = output.run
        } else {
            self.run = nil
        }
    }
}

/// Represents the results of your stop run attempt.
public struct StopRunOutputResponse: Swift.Equatable {
    /// The run that was stopped.
    public var run: DeviceFarmClientTypes.Run?

    public init (
        run: DeviceFarmClientTypes.Run? = nil
    )
    {
        self.run = run
    }
}

struct StopRunOutputResponseBody: Swift.Equatable {
    public let run: DeviceFarmClientTypes.Run?
}

extension StopRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case run
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Run.self, forKey: .run)
        run = runDecoded
    }
}

extension DeviceFarmClientTypes.Suite: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case counters
        case created
        case deviceMinutes
        case message
        case name
        case result
        case started
        case status
        case stopped
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let counters = counters {
            try encodeContainer.encode(counters, forKey: .counters)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let deviceMinutes = deviceMinutes {
            try encodeContainer.encode(deviceMinutes, forKey: .deviceMinutes)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let result = result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let started = started {
            try encodeContainer.encode(started.timeIntervalSince1970, forKey: .started)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopped = stopped {
            try encodeContainer.encode(stopped.timeIntervalSince1970, forKey: .stopped)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestType.self, forKey: .type)
        type = typeDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let startedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .started)
        started = startedDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopped)
        stopped = stoppedDecoded
        let countersDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Counters.self, forKey: .counters)
        counters = countersDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let deviceMinutesDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceMinutes.self, forKey: .deviceMinutes)
        deviceMinutes = deviceMinutesDecoded
    }
}

extension DeviceFarmClientTypes.Suite: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Suite(arn: \(Swift.String(describing: arn)), counters: \(Swift.String(describing: counters)), created: \(Swift.String(describing: created)), deviceMinutes: \(Swift.String(describing: deviceMinutes)), message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)), result: \(Swift.String(describing: result)), started: \(Swift.String(describing: started)), status: \(Swift.String(describing: status)), stopped: \(Swift.String(describing: stopped)), type: \(Swift.String(describing: type)))"}
}

extension DeviceFarmClientTypes {
    /// Represents a collection of one or more tests.
    public struct Suite: Swift.Equatable {
        /// The suite's ARN.
        public var arn: Swift.String?
        /// The suite's result counters.
        public var counters: DeviceFarmClientTypes.Counters?
        /// When the suite was created.
        public var created: ClientRuntime.Date?
        /// Represents the total (metered or unmetered) minutes used by the test
        ///             suite.
        public var deviceMinutes: DeviceFarmClientTypes.DeviceMinutes?
        /// A message about the suite's result.
        public var message: Swift.String?
        /// The suite's name.
        public var name: Swift.String?
        /// The suite's result.
        ///         Allowed values include:
        ///
        ///
        ///                 PENDING
        ///
        ///
        ///                 PASSED
        ///
        ///
        ///                 WARNED
        ///
        ///
        ///                 FAILED
        ///
        ///
        ///                 SKIPPED
        ///
        ///
        ///                 ERRORED
        ///
        ///
        ///                 STOPPED
        ///
        ///
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// The suite's start time.
        public var started: ClientRuntime.Date?
        /// The suite's status.
        ///         Allowed values include:
        ///
        ///
        ///                 PENDING
        ///
        ///
        ///                 PENDING_CONCURRENCY
        ///
        ///
        ///                 PENDING_DEVICE
        ///
        ///
        ///                 PROCESSING
        ///
        ///
        ///                 SCHEDULING
        ///
        ///
        ///                 PREPARING
        ///
        ///
        ///                 RUNNING
        ///
        ///
        ///                 COMPLETED
        ///
        ///
        ///                 STOPPING
        ///
        ///
        public var status: DeviceFarmClientTypes.ExecutionStatus?
        /// The suite's stop time.
        public var stopped: ClientRuntime.Date?
        /// The suite's type.
        ///         Must be one of the following values:
        ///
        ///
        ///                 BUILTIN_FUZZ
        ///
        ///
        ///                 BUILTIN_EXPLORER
        ///
        ///                     Only available for Android; an app explorer that traverses an Android app, interacting with it
        ///                         and capturing screenshots at the same time.
        ///
        ///
        ///
        ///                 APPIUM_JAVA_JUNIT
        ///
        ///
        ///                 APPIUM_JAVA_TESTNG
        ///
        ///
        ///                 APPIUM_PYTHON
        ///
        ///
        ///                 APPIUM_NODE
        ///
        ///
        ///                 APPIUM_RUBY
        ///
        ///
        ///                 APPIUM_WEB_JAVA_JUNIT
        ///
        ///
        ///                 APPIUM_WEB_JAVA_TESTNG
        ///
        ///
        ///                 APPIUM_WEB_PYTHON
        ///
        ///
        ///                 APPIUM_WEB_NODE
        ///
        ///
        ///                 APPIUM_WEB_RUBY
        ///
        ///
        ///                 CALABASH
        ///
        ///
        ///                 INSTRUMENTATION
        ///
        ///
        ///                 UIAUTOMATION
        ///
        ///
        ///                 UIAUTOMATOR
        ///
        ///
        ///                 XCTEST
        ///
        ///
        ///                 XCTEST_UI
        ///
        ///
        public var type: DeviceFarmClientTypes.TestType?

        public init (
            arn: Swift.String? = nil,
            counters: DeviceFarmClientTypes.Counters? = nil,
            created: ClientRuntime.Date? = nil,
            deviceMinutes: DeviceFarmClientTypes.DeviceMinutes? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            started: ClientRuntime.Date? = nil,
            status: DeviceFarmClientTypes.ExecutionStatus? = nil,
            stopped: ClientRuntime.Date? = nil,
            type: DeviceFarmClientTypes.TestType? = nil
        )
        {
            self.arn = arn
            self.counters = counters
            self.created = created
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.name = name
            self.result = result
            self.started = started
            self.status = status
            self.stopped = stopped
            self.type = type
        }
    }

}

extension DeviceFarmClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DeviceFarmClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension DeviceFarmClientTypes {
    /// The metadata that you apply to a resource to help you categorize and organize it. Each tag consists of a
    ///             key and an optional value, both of which you define. Tag keys can have a maximum character length of 128
    ///             characters. Tag values can have a maximum length of 256 characters.
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that makes up a tag. A key is a general label that acts like a
        ///             category for more specific tag values.
        /// This member is required.
        public var key: Swift.String?
        /// The optional part of a key-value pair that makes up a tag. A value acts as a descriptor in a
        ///             tag category (key).
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagOperationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagOperationException(message: \(Swift.String(describing: message)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension TagOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation was not successful. Try again.
public struct TagOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TagOperationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceName: Swift.String?
}

extension TagOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension TagPolicyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagPolicyException(message: \(Swift.String(describing: message)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension TagPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request doesn't comply with the AWS Identity and Access Management (IAM) tag
///             policy. Correct your request and then retry it.
public struct TagPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TagPolicyExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceName: Swift.String?
}

extension TagPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource or resources to which to add tags. You can associate tags
    ///             with the following Device Farm resources: PROJECT, RUN,
    ///                 NETWORK_PROFILE, INSTANCE_PROFILE, DEVICE_INSTANCE,
    ///                 SESSION, DEVICE_POOL, DEVICE, and
    ///             VPCE_CONFIGURATION.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum
    ///             character length of 128 characters. Tag values can have a maximum length of 256 characters.
    /// This member is required.
    public var tags: [DeviceFarmClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [DeviceFarmClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tags: [DeviceFarmClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DeviceFarmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DeviceFarmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOperationException" : self = .tagOperationException(try TagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case notFoundException(NotFoundException)
    case tagOperationException(TagOperationException)
    case tagPolicyException(TagPolicyException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeviceFarmClientTypes.Test: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case counters
        case created
        case deviceMinutes
        case message
        case name
        case result
        case started
        case status
        case stopped
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let counters = counters {
            try encodeContainer.encode(counters, forKey: .counters)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let deviceMinutes = deviceMinutes {
            try encodeContainer.encode(deviceMinutes, forKey: .deviceMinutes)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let result = result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let started = started {
            try encodeContainer.encode(started.timeIntervalSince1970, forKey: .started)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopped = stopped {
            try encodeContainer.encode(stopped.timeIntervalSince1970, forKey: .stopped)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestType.self, forKey: .type)
        type = typeDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let startedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .started)
        started = startedDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopped)
        stopped = stoppedDecoded
        let countersDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Counters.self, forKey: .counters)
        counters = countersDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let deviceMinutesDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceMinutes.self, forKey: .deviceMinutes)
        deviceMinutes = deviceMinutesDecoded
    }
}

extension DeviceFarmClientTypes.Test: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Test(arn: \(Swift.String(describing: arn)), counters: \(Swift.String(describing: counters)), created: \(Swift.String(describing: created)), deviceMinutes: \(Swift.String(describing: deviceMinutes)), message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)), result: \(Swift.String(describing: result)), started: \(Swift.String(describing: started)), status: \(Swift.String(describing: status)), stopped: \(Swift.String(describing: stopped)), type: \(Swift.String(describing: type)))"}
}

extension DeviceFarmClientTypes {
    /// Represents a condition that is evaluated.
    public struct Test: Swift.Equatable {
        /// The test's ARN.
        public var arn: Swift.String?
        /// The test's result counters.
        public var counters: DeviceFarmClientTypes.Counters?
        /// When the test was created.
        public var created: ClientRuntime.Date?
        /// Represents the total (metered or unmetered) minutes used by the test.
        public var deviceMinutes: DeviceFarmClientTypes.DeviceMinutes?
        /// A message about the test's result.
        public var message: Swift.String?
        /// The test's name.
        public var name: Swift.String?
        /// The test's result.
        ///         Allowed values include:
        ///
        ///
        ///                 PENDING
        ///
        ///
        ///                 PASSED
        ///
        ///
        ///                 WARNED
        ///
        ///
        ///                 FAILED
        ///
        ///
        ///                 SKIPPED
        ///
        ///
        ///                 ERRORED
        ///
        ///
        ///                 STOPPED
        ///
        ///
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// The test's start time.
        public var started: ClientRuntime.Date?
        /// The test's status.
        ///         Allowed values include:
        ///
        ///
        ///                 PENDING
        ///
        ///
        ///                 PENDING_CONCURRENCY
        ///
        ///
        ///                 PENDING_DEVICE
        ///
        ///
        ///                 PROCESSING
        ///
        ///
        ///                 SCHEDULING
        ///
        ///
        ///                 PREPARING
        ///
        ///
        ///                 RUNNING
        ///
        ///
        ///                 COMPLETED
        ///
        ///
        ///                 STOPPING
        ///
        ///
        public var status: DeviceFarmClientTypes.ExecutionStatus?
        /// The test's stop time.
        public var stopped: ClientRuntime.Date?
        /// The test's type.
        ///         Must be one of the following values:
        ///
        ///
        ///                 BUILTIN_FUZZ
        ///
        ///
        ///                 BUILTIN_EXPLORER
        ///
        ///                     For Android, an app explorer that traverses an Android app, interacting with it and capturing
        ///                         screenshots at the same time.
        ///
        ///
        ///
        ///                 APPIUM_JAVA_JUNIT
        ///
        ///
        ///                 APPIUM_JAVA_TESTNG
        ///
        ///
        ///                 APPIUM_PYTHON
        ///
        ///
        ///                 APPIUM_NODE
        ///
        ///
        ///                 APPIUM_RUBY
        ///
        ///
        ///                 APPIUM_WEB_JAVA_JUNIT
        ///
        ///
        ///                 APPIUM_WEB_JAVA_TESTNG
        ///
        ///
        ///                 APPIUM_WEB_PYTHON
        ///
        ///
        ///                 APPIUM_WEB_NODE
        ///
        ///
        ///                 APPIUM_WEB_RUBY
        ///
        ///
        ///                 CALABASH
        ///
        ///
        ///                 INSTRUMENTATION
        ///
        ///
        ///                 UIAUTOMATION
        ///
        ///
        ///                 UIAUTOMATOR
        ///
        ///
        ///                 XCTEST
        ///
        ///
        ///                 XCTEST_UI
        ///
        ///
        public var type: DeviceFarmClientTypes.TestType?

        public init (
            arn: Swift.String? = nil,
            counters: DeviceFarmClientTypes.Counters? = nil,
            created: ClientRuntime.Date? = nil,
            deviceMinutes: DeviceFarmClientTypes.DeviceMinutes? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            started: ClientRuntime.Date? = nil,
            status: DeviceFarmClientTypes.ExecutionStatus? = nil,
            stopped: ClientRuntime.Date? = nil,
            type: DeviceFarmClientTypes.TestType? = nil
        )
        {
            self.arn = arn
            self.counters = counters
            self.created = created
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.name = name
            self.result = result
            self.started = started
            self.status = status
            self.stopped = stopped
            self.type = type
        }
    }

}

extension DeviceFarmClientTypes.TestGridProject: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case created
        case description
        case name
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridVpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
    }
}

extension DeviceFarmClientTypes.TestGridProject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestGridProject(arn: \(Swift.String(describing: arn)), created: \(Swift.String(describing: created)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension DeviceFarmClientTypes {
    /// A Selenium testing project. Projects are used to collect and collate sessions.
    public struct TestGridProject: Swift.Equatable {
        /// The ARN for the project.
        public var arn: Swift.String?
        /// When the project was created.
        public var created: ClientRuntime.Date?
        /// A human-readable description for the project.
        public var description: Swift.String?
        /// A human-readable name for the project.
        public var name: Swift.String?
        /// The VPC security groups and subnets that are attached to a project.
        public var vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig?

        public init (
            arn: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig? = nil
        )
        {
            self.arn = arn
            self.created = created
            self.description = description
            self.name = name
            self.vpcConfig = vpcConfig
        }
    }

}

extension DeviceFarmClientTypes.TestGridSession: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case billingMinutes
        case created
        case ended
        case seleniumProperties
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billingMinutes = billingMinutes {
            try encodeContainer.encode(billingMinutes, forKey: .billingMinutes)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let ended = ended {
            try encodeContainer.encode(ended.timeIntervalSince1970, forKey: .ended)
        }
        if let seleniumProperties = seleniumProperties {
            try encodeContainer.encode(seleniumProperties, forKey: .seleniumProperties)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridSessionStatus.self, forKey: .status)
        status = statusDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let endedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .ended)
        ended = endedDecoded
        let billingMinutesDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .billingMinutes)
        billingMinutes = billingMinutesDecoded
        let seleniumPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .seleniumProperties)
        seleniumProperties = seleniumPropertiesDecoded
    }
}

extension DeviceFarmClientTypes.TestGridSession: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestGridSession(arn: \(Swift.String(describing: arn)), billingMinutes: \(Swift.String(describing: billingMinutes)), created: \(Swift.String(describing: created)), ended: \(Swift.String(describing: ended)), seleniumProperties: \(Swift.String(describing: seleniumProperties)), status: \(Swift.String(describing: status)))"}
}

extension DeviceFarmClientTypes {
    /// A TestGridSession is a single instance of a browser launched from the URL provided by a
    ///          call to CreateTestGridUrl.
    public struct TestGridSession: Swift.Equatable {
        /// The ARN of the session.
        public var arn: Swift.String?
        /// The number of billed minutes that were used for this session.
        public var billingMinutes: Swift.Double?
        /// The time that the session was started.
        public var created: ClientRuntime.Date?
        /// The time the session ended.
        public var ended: ClientRuntime.Date?
        /// A JSON object of options and parameters passed to the Selenium WebDriver.
        public var seleniumProperties: Swift.String?
        /// The state of the session.
        public var status: DeviceFarmClientTypes.TestGridSessionStatus?

        public init (
            arn: Swift.String? = nil,
            billingMinutes: Swift.Double? = nil,
            created: ClientRuntime.Date? = nil,
            ended: ClientRuntime.Date? = nil,
            seleniumProperties: Swift.String? = nil,
            status: DeviceFarmClientTypes.TestGridSessionStatus? = nil
        )
        {
            self.arn = arn
            self.billingMinutes = billingMinutes
            self.created = created
            self.ended = ended
            self.seleniumProperties = seleniumProperties
            self.status = status
        }
    }

}

extension DeviceFarmClientTypes.TestGridSessionAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case duration
        case requestMethod
        case started
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let requestMethod = requestMethod {
            try encodeContainer.encode(requestMethod, forKey: .requestMethod)
        }
        if let started = started {
            try encodeContainer.encode(started.timeIntervalSince1970, forKey: .started)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let startedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .started)
        started = startedDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let requestMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestMethod)
        requestMethod = requestMethodDecoded
    }
}

extension DeviceFarmClientTypes.TestGridSessionAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestGridSessionAction(action: \(Swift.String(describing: action)), duration: \(Swift.String(describing: duration)), requestMethod: \(Swift.String(describing: requestMethod)), started: \(Swift.String(describing: started)), statusCode: \(Swift.String(describing: statusCode)))"}
}

extension DeviceFarmClientTypes {
    /// An action taken by a TestGridSession browser instance.
    public struct TestGridSessionAction: Swift.Equatable {
        /// The action taken by the session.
        public var action: Swift.String?
        /// The time, in milliseconds, that the action took to complete in the browser.
        public var duration: Swift.Int?
        /// HTTP method that the browser used to make the request.
        public var requestMethod: Swift.String?
        /// The time that the session invoked the action.
        public var started: ClientRuntime.Date?
        /// HTTP status code returned to the browser when the action was taken.
        public var statusCode: Swift.String?

        public init (
            action: Swift.String? = nil,
            duration: Swift.Int? = nil,
            requestMethod: Swift.String? = nil,
            started: ClientRuntime.Date? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.action = action
            self.duration = duration
            self.requestMethod = requestMethod
            self.started = started
            self.statusCode = statusCode
        }
    }

}

extension DeviceFarmClientTypes.TestGridSessionArtifact: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filename
        case type
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filename = filename {
            try encodeContainer.encode(filename, forKey: .filename)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filenameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filename)
        filename = filenameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridSessionArtifactType.self, forKey: .type)
        type = typeDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension DeviceFarmClientTypes.TestGridSessionArtifact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestGridSessionArtifact(filename: \(Swift.String(describing: filename)), type: \(Swift.String(describing: type)), url: \(Swift.String(describing: url)))"}
}

extension DeviceFarmClientTypes {
    /// Artifacts are video and other files that are produced in the process of running a browser in an automated
    ///          context.
    ///
    ///             Video elements might be broken up into multiple artifacts as they grow in size during creation.
    ///
    public struct TestGridSessionArtifact: Swift.Equatable {
        /// The file name of the artifact.
        public var filename: Swift.String?
        /// The kind of artifact.
        public var type: DeviceFarmClientTypes.TestGridSessionArtifactType?
        /// A semi-stable URL to the content of the object.
        public var url: Swift.String?

        public init (
            filename: Swift.String? = nil,
            type: DeviceFarmClientTypes.TestGridSessionArtifactType? = nil,
            url: Swift.String? = nil
        )
        {
            self.filename = filename
            self.type = type
            self.url = url
        }
    }

}

extension DeviceFarmClientTypes {
    public enum TestGridSessionArtifactCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case log
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [TestGridSessionArtifactCategory] {
            return [
                .log,
                .video,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .log: return "LOG"
            case .video: return "VIDEO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestGridSessionArtifactCategory(rawValue: rawValue) ?? TestGridSessionArtifactCategory.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum TestGridSessionArtifactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case seleniumLog
        case unknown
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [TestGridSessionArtifactType] {
            return [
                .seleniumLog,
                .unknown,
                .video,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .seleniumLog: return "SELENIUM_LOG"
            case .unknown: return "UNKNOWN"
            case .video: return "VIDEO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestGridSessionArtifactType(rawValue: rawValue) ?? TestGridSessionArtifactType.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum TestGridSessionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case closed
        case errored
        case sdkUnknown(Swift.String)

        public static var allCases: [TestGridSessionStatus] {
            return [
                .active,
                .closed,
                .errored,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .closed: return "CLOSED"
            case .errored: return "ERRORED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestGridSessionStatus(rawValue: rawValue) ?? TestGridSessionStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.TestGridVpcConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension DeviceFarmClientTypes.TestGridVpcConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestGridVpcConfig(securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension DeviceFarmClientTypes {
    /// The VPC security groups and subnets that are attached to a project.
    public struct TestGridVpcConfig: Swift.Equatable {
        /// A list of VPC security group IDs in your Amazon VPC.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs in your Amazon VPC.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// The ID of the Amazon VPC.
        /// This member is required.
        public var vpcId: Swift.String?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension DeviceFarmClientTypes {
    public enum TestType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appiumJavaJunit
        case appiumJavaTestng
        case appiumNode
        case appiumPython
        case appiumRuby
        case appiumWebJavaJunit
        case appiumWebJavaTestng
        case appiumWebNode
        case appiumWebPython
        case appiumWebRuby
        case builtinExplorer
        case builtinFuzz
        case calabash
        case instrumentation
        case remoteAccessRecord
        case remoteAccessReplay
        case uiautomation
        case uiautomator
        case webPerformanceProfile
        case xctest
        case xctestUi
        case sdkUnknown(Swift.String)

        public static var allCases: [TestType] {
            return [
                .appiumJavaJunit,
                .appiumJavaTestng,
                .appiumNode,
                .appiumPython,
                .appiumRuby,
                .appiumWebJavaJunit,
                .appiumWebJavaTestng,
                .appiumWebNode,
                .appiumWebPython,
                .appiumWebRuby,
                .builtinExplorer,
                .builtinFuzz,
                .calabash,
                .instrumentation,
                .remoteAccessRecord,
                .remoteAccessReplay,
                .uiautomation,
                .uiautomator,
                .webPerformanceProfile,
                .xctest,
                .xctestUi,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appiumJavaJunit: return "APPIUM_JAVA_JUNIT"
            case .appiumJavaTestng: return "APPIUM_JAVA_TESTNG"
            case .appiumNode: return "APPIUM_NODE"
            case .appiumPython: return "APPIUM_PYTHON"
            case .appiumRuby: return "APPIUM_RUBY"
            case .appiumWebJavaJunit: return "APPIUM_WEB_JAVA_JUNIT"
            case .appiumWebJavaTestng: return "APPIUM_WEB_JAVA_TESTNG"
            case .appiumWebNode: return "APPIUM_WEB_NODE"
            case .appiumWebPython: return "APPIUM_WEB_PYTHON"
            case .appiumWebRuby: return "APPIUM_WEB_RUBY"
            case .builtinExplorer: return "BUILTIN_EXPLORER"
            case .builtinFuzz: return "BUILTIN_FUZZ"
            case .calabash: return "CALABASH"
            case .instrumentation: return "INSTRUMENTATION"
            case .remoteAccessRecord: return "REMOTE_ACCESS_RECORD"
            case .remoteAccessReplay: return "REMOTE_ACCESS_REPLAY"
            case .uiautomation: return "UIAUTOMATION"
            case .uiautomator: return "UIAUTOMATOR"
            case .webPerformanceProfile: return "WEB_PERFORMANCE_PROFILE"
            case .xctest: return "XCTEST"
            case .xctestUi: return "XCTEST_UI"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestType(rawValue: rawValue) ?? TestType.sdkUnknown(rawValue)
        }
    }
}

extension TooManyTagsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTagsException(message: \(Swift.String(describing: message)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The list of tags on the repository is over the limit. The maximum number of tags that
///             can be applied to a repository is 50.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension DeviceFarmClientTypes.TrialMinutes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case remaining
        case total
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let remaining = remaining {
            try encodeContainer.encode(remaining, forKey: .remaining)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .total)
        total = totalDecoded
        let remainingDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .remaining)
        remaining = remainingDecoded
    }
}

extension DeviceFarmClientTypes.TrialMinutes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrialMinutes(remaining: \(Swift.String(describing: remaining)), total: \(Swift.String(describing: total)))"}
}

extension DeviceFarmClientTypes {
    /// Represents information about free trial device minutes for an AWS
    ///             account.
    public struct TrialMinutes: Swift.Equatable {
        /// The number of free trial minutes remaining in the account.
        public var remaining: Swift.Double?
        /// The total number of free trial minutes that the account started with.
        public var total: Swift.Double?

        public init (
            remaining: Swift.Double? = nil,
            total: Swift.Double? = nil
        )
        {
            self.remaining = remaining
            self.total = total
        }
    }

}

extension DeviceFarmClientTypes.UniqueProblem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case problems
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let problems = problems {
            var problemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .problems)
            for problems0 in problems {
                try problemsContainer.encode(problems0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let problemsContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Problem?].self, forKey: .problems)
        var problemsDecoded0:[DeviceFarmClientTypes.Problem]? = nil
        if let problemsContainer = problemsContainer {
            problemsDecoded0 = [DeviceFarmClientTypes.Problem]()
            for structure0 in problemsContainer {
                if let structure0 = structure0 {
                    problemsDecoded0?.append(structure0)
                }
            }
        }
        problems = problemsDecoded0
    }
}

extension DeviceFarmClientTypes.UniqueProblem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UniqueProblem(message: \(Swift.String(describing: message)), problems: \(Swift.String(describing: problems)))"}
}

extension DeviceFarmClientTypes {
    /// A collection of one or more problems, grouped by their result.
    public struct UniqueProblem: Swift.Equatable {
        /// A message about the unique problems' result.
        public var message: Swift.String?
        /// Information about the problems.
        public var problems: [DeviceFarmClientTypes.Problem]?

        public init (
            message: Swift.String? = nil,
            problems: [DeviceFarmClientTypes.Problem]? = nil
        )
        {
            self.message = message
            self.problems = problems
        }
    }

}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource or resources from which to delete tags. You can associate
    ///             tags with the following Device Farm resources: PROJECT, RUN,
    ///                 NETWORK_PROFILE, INSTANCE_PROFILE, DEVICE_INSTANCE,
    ///                 SESSION, DEVICE_POOL, DEVICE, and
    ///             VPCE_CONFIGURATION.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOperationException" : self = .tagOperationException(try TagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case notFoundException(NotFoundException)
    case tagOperationException(TagOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDeviceInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDeviceInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDeviceInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceInstanceOutputError>
}

extension UpdateDeviceInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDeviceInstanceInput(arn: \(Swift.String(describing: arn)), labels: \(Swift.String(describing: labels)), profileArn: \(Swift.String(describing: profileArn)))"}
}

extension UpdateDeviceInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case labels
        case profileArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for instancelabels0 in labels {
                try labelsContainer.encode(instancelabels0)
            }
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
    }
}

public struct UpdateDeviceInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDeviceInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDeviceInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceInstanceOutputError>
}

public struct UpdateDeviceInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDeviceInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDeviceInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceInstanceOutputError>
}

public struct UpdateDeviceInstanceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceInstanceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateDeviceInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDeviceInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceInstanceOutputError>
}

public struct UpdateDeviceInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceInstanceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateDeviceInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDeviceInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceInstanceOutputError>
}

public struct UpdateDeviceInstanceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the device instance.
    /// This member is required.
    public var arn: Swift.String?
    /// An array of strings that you want to associate with the device instance.
    public var labels: [Swift.String]?
    /// The ARN of the profile that you want to associate with the device instance.
    public var profileArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        labels: [Swift.String]? = nil,
        profileArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.labels = labels
        self.profileArn = profileArn
    }
}

struct UpdateDeviceInstanceInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let profileArn: Swift.String?
    public let labels: [Swift.String]?
}

extension UpdateDeviceInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case labels
        case profileArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension UpdateDeviceInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeviceInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeviceInstanceOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeviceInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDeviceInstanceOutputResponse(deviceInstance: \(Swift.String(describing: deviceInstance)))"}
}

extension UpdateDeviceInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDeviceInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceInstance = output.deviceInstance
        } else {
            self.deviceInstance = nil
        }
    }
}

public struct UpdateDeviceInstanceOutputResponse: Swift.Equatable {
    /// An object that contains information about your device instance.
    public var deviceInstance: DeviceFarmClientTypes.DeviceInstance?

    public init (
        deviceInstance: DeviceFarmClientTypes.DeviceInstance? = nil
    )
    {
        self.deviceInstance = deviceInstance
    }
}

struct UpdateDeviceInstanceOutputResponseBody: Swift.Equatable {
    public let deviceInstance: DeviceFarmClientTypes.DeviceInstance?
}

extension UpdateDeviceInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceInstance
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceInstanceDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DeviceInstance.self, forKey: .deviceInstance)
        deviceInstance = deviceInstanceDecoded
    }
}

public struct UpdateDevicePoolInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDevicePoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDevicePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDevicePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDevicePoolOutputError>
}

extension UpdateDevicePoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDevicePoolInput(arn: \(Swift.String(describing: arn)), clearMaxDevices: \(Swift.String(describing: clearMaxDevices)), description: \(Swift.String(describing: description)), maxDevices: \(Swift.String(describing: maxDevices)), name: \(Swift.String(describing: name)), rules: \(Swift.String(describing: rules)))"}
}

extension UpdateDevicePoolInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clearMaxDevices
        case description
        case maxDevices
        case name
        case rules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clearMaxDevices = clearMaxDevices {
            try encodeContainer.encode(clearMaxDevices, forKey: .clearMaxDevices)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let maxDevices = maxDevices {
            try encodeContainer.encode(maxDevices, forKey: .maxDevices)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rules0 in rules {
                try rulesContainer.encode(rules0)
            }
        }
    }
}

public struct UpdateDevicePoolInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDevicePoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDevicePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDevicePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDevicePoolOutputError>
}

public struct UpdateDevicePoolInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDevicePoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDevicePoolInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDevicePoolInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDevicePoolOutputError>
}

public struct UpdateDevicePoolInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDevicePoolInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateDevicePoolInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDevicePoolInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDevicePoolOutputError>
}

public struct UpdateDevicePoolInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDevicePoolInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateDevicePoolInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDevicePoolInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDevicePoolOutputError>
}

/// Represents a request to the update device pool operation.
public struct UpdateDevicePoolInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Device Farm device pool to update.
    /// This member is required.
    public var arn: Swift.String?
    /// Sets whether the maxDevices parameter applies to your device pool. If you set this parameter
    ///             to true, the maxDevices parameter does not apply, and Device Farm does not limit
    ///             the number of devices that it adds to your device pool. In this case, Device Farm adds all available devices
    ///             that meet the criteria specified in the rules parameter.
    ///         If you use this parameter in your request, you cannot use the maxDevices
    ///             parameter in the same request.
    public var clearMaxDevices: Swift.Bool?
    /// A description of the device pool to update.
    public var description: Swift.String?
    /// The number of devices that Device Farm can add to your device pool. Device Farm adds
    ///             devices that are available and that meet the criteria that you assign for the
    ///                 rules parameter. Depending on how many devices meet these constraints,
    ///             your device pool might contain fewer devices than the value for this parameter.
    ///         By specifying the maximum number of devices, you can control the costs that you incur
    ///             by running tests.
    ///         If you use this parameter in your request, you cannot use the
    ///                 clearMaxDevices parameter in the same request.
    public var maxDevices: Swift.Int?
    /// A string that represents the name of the device pool to update.
    public var name: Swift.String?
    /// Represents the rules to modify for the device pool. Updating rules is optional. If you update rules for
    ///             your request, the update replaces the existing rules.
    public var rules: [DeviceFarmClientTypes.Rule]?

    public init (
        arn: Swift.String? = nil,
        clearMaxDevices: Swift.Bool? = nil,
        description: Swift.String? = nil,
        maxDevices: Swift.Int? = nil,
        name: Swift.String? = nil,
        rules: [DeviceFarmClientTypes.Rule]? = nil
    )
    {
        self.arn = arn
        self.clearMaxDevices = clearMaxDevices
        self.description = description
        self.maxDevices = maxDevices
        self.name = name
        self.rules = rules
    }
}

struct UpdateDevicePoolInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let rules: [DeviceFarmClientTypes.Rule]?
    public let maxDevices: Swift.Int?
    public let clearMaxDevices: Swift.Bool?
}

extension UpdateDevicePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clearMaxDevices
        case description
        case maxDevices
        case name
        case rules
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([DeviceFarmClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[DeviceFarmClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [DeviceFarmClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let maxDevicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDevices)
        maxDevices = maxDevicesDecoded
        let clearMaxDevicesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clearMaxDevices)
        clearMaxDevices = clearMaxDevicesDecoded
    }
}

extension UpdateDevicePoolOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDevicePoolOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDevicePoolOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDevicePoolOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDevicePoolOutputResponse(devicePool: \(Swift.String(describing: devicePool)))"}
}

extension UpdateDevicePoolOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDevicePoolOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devicePool = output.devicePool
        } else {
            self.devicePool = nil
        }
    }
}

/// Represents the result of an update device pool request.
public struct UpdateDevicePoolOutputResponse: Swift.Equatable {
    /// The device pool you just updated.
    public var devicePool: DeviceFarmClientTypes.DevicePool?

    public init (
        devicePool: DeviceFarmClientTypes.DevicePool? = nil
    )
    {
        self.devicePool = devicePool
    }
}

struct UpdateDevicePoolOutputResponseBody: Swift.Equatable {
    public let devicePool: DeviceFarmClientTypes.DevicePool?
}

extension UpdateDevicePoolOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePool
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePoolDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.DevicePool.self, forKey: .devicePool)
        devicePool = devicePoolDecoded
    }
}

public struct UpdateInstanceProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInstanceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInstanceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInstanceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInstanceProfileOutputError>
}

extension UpdateInstanceProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateInstanceProfileInput(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), excludeAppPackagesFromCleanup: \(Swift.String(describing: excludeAppPackagesFromCleanup)), name: \(Swift.String(describing: name)), packageCleanup: \(Swift.String(describing: packageCleanup)), rebootAfterUse: \(Swift.String(describing: rebootAfterUse)))"}
}

extension UpdateInstanceProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case excludeAppPackagesFromCleanup
        case name
        case packageCleanup
        case rebootAfterUse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup {
            var excludeAppPackagesFromCleanupContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeAppPackagesFromCleanup)
            for packageids0 in excludeAppPackagesFromCleanup {
                try excludeAppPackagesFromCleanupContainer.encode(packageids0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageCleanup = packageCleanup {
            try encodeContainer.encode(packageCleanup, forKey: .packageCleanup)
        }
        if let rebootAfterUse = rebootAfterUse {
            try encodeContainer.encode(rebootAfterUse, forKey: .rebootAfterUse)
        }
    }
}

public struct UpdateInstanceProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInstanceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInstanceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInstanceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInstanceProfileOutputError>
}

public struct UpdateInstanceProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInstanceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInstanceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInstanceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInstanceProfileOutputError>
}

public struct UpdateInstanceProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInstanceProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateInstanceProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateInstanceProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInstanceProfileOutputError>
}

public struct UpdateInstanceProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInstanceProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateInstanceProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateInstanceProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInstanceProfileOutputError>
}

public struct UpdateInstanceProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the instance profile.
    /// This member is required.
    public var arn: Swift.String?
    /// The updated description for your instance profile.
    public var description: Swift.String?
    /// An array of strings that specifies the list of app packages that should not be cleaned up from the device
    ///             after a test run is over.
    ///         The list of packages is only considered if you set packageCleanup to
    ///                 true.
    public var excludeAppPackagesFromCleanup: [Swift.String]?
    /// The updated name for your instance profile.
    public var name: Swift.String?
    /// The updated choice for whether you want to specify package cleanup. The default value
    ///             is false for private devices.
    public var packageCleanup: Swift.Bool?
    /// The updated choice for whether you want to reboot the device after use. The default
    ///             value is true.
    public var rebootAfterUse: Swift.Bool?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        excludeAppPackagesFromCleanup: [Swift.String]? = nil,
        name: Swift.String? = nil,
        packageCleanup: Swift.Bool? = nil,
        rebootAfterUse: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
        self.name = name
        self.packageCleanup = packageCleanup
        self.rebootAfterUse = rebootAfterUse
    }
}

struct UpdateInstanceProfileInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let packageCleanup: Swift.Bool?
    public let excludeAppPackagesFromCleanup: [Swift.String]?
    public let rebootAfterUse: Swift.Bool?
}

extension UpdateInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case excludeAppPackagesFromCleanup
        case name
        case packageCleanup
        case rebootAfterUse
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let packageCleanupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .packageCleanup)
        packageCleanup = packageCleanupDecoded
        let excludeAppPackagesFromCleanupContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeAppPackagesFromCleanup)
        var excludeAppPackagesFromCleanupDecoded0:[Swift.String]? = nil
        if let excludeAppPackagesFromCleanupContainer = excludeAppPackagesFromCleanupContainer {
            excludeAppPackagesFromCleanupDecoded0 = [Swift.String]()
            for string0 in excludeAppPackagesFromCleanupContainer {
                if let string0 = string0 {
                    excludeAppPackagesFromCleanupDecoded0?.append(string0)
                }
            }
        }
        excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanupDecoded0
        let rebootAfterUseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rebootAfterUse)
        rebootAfterUse = rebootAfterUseDecoded
    }
}

extension UpdateInstanceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInstanceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInstanceProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInstanceProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateInstanceProfileOutputResponse(instanceProfile: \(Swift.String(describing: instanceProfile)))"}
}

extension UpdateInstanceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateInstanceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

public struct UpdateInstanceProfileOutputResponse: Swift.Equatable {
    /// An object that contains information about your instance profile.
    public var instanceProfile: DeviceFarmClientTypes.InstanceProfile?

    public init (
        instanceProfile: DeviceFarmClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct UpdateInstanceProfileOutputResponseBody: Swift.Equatable {
    public let instanceProfile: DeviceFarmClientTypes.InstanceProfile?
}

extension UpdateInstanceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

public struct UpdateNetworkProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNetworkProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNetworkProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNetworkProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNetworkProfileOutputError>
}

extension UpdateNetworkProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNetworkProfileInput(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), downlinkBandwidthBits: \(Swift.String(describing: downlinkBandwidthBits)), downlinkDelayMs: \(Swift.String(describing: downlinkDelayMs)), downlinkJitterMs: \(Swift.String(describing: downlinkJitterMs)), downlinkLossPercent: \(Swift.String(describing: downlinkLossPercent)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)), uplinkBandwidthBits: \(Swift.String(describing: uplinkBandwidthBits)), uplinkDelayMs: \(Swift.String(describing: uplinkDelayMs)), uplinkJitterMs: \(Swift.String(describing: uplinkJitterMs)), uplinkLossPercent: \(Swift.String(describing: uplinkLossPercent)))"}
}

extension UpdateNetworkProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case downlinkBandwidthBits
        case downlinkDelayMs
        case downlinkJitterMs
        case downlinkLossPercent
        case name
        case type
        case uplinkBandwidthBits
        case uplinkDelayMs
        case uplinkJitterMs
        case uplinkLossPercent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let downlinkBandwidthBits = downlinkBandwidthBits {
            try encodeContainer.encode(downlinkBandwidthBits, forKey: .downlinkBandwidthBits)
        }
        if let downlinkDelayMs = downlinkDelayMs {
            try encodeContainer.encode(downlinkDelayMs, forKey: .downlinkDelayMs)
        }
        if let downlinkJitterMs = downlinkJitterMs {
            try encodeContainer.encode(downlinkJitterMs, forKey: .downlinkJitterMs)
        }
        if downlinkLossPercent != 0 {
            try encodeContainer.encode(downlinkLossPercent, forKey: .downlinkLossPercent)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uplinkBandwidthBits = uplinkBandwidthBits {
            try encodeContainer.encode(uplinkBandwidthBits, forKey: .uplinkBandwidthBits)
        }
        if let uplinkDelayMs = uplinkDelayMs {
            try encodeContainer.encode(uplinkDelayMs, forKey: .uplinkDelayMs)
        }
        if let uplinkJitterMs = uplinkJitterMs {
            try encodeContainer.encode(uplinkJitterMs, forKey: .uplinkJitterMs)
        }
        if uplinkLossPercent != 0 {
            try encodeContainer.encode(uplinkLossPercent, forKey: .uplinkLossPercent)
        }
    }
}

public struct UpdateNetworkProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNetworkProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNetworkProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNetworkProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNetworkProfileOutputError>
}

public struct UpdateNetworkProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNetworkProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNetworkProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNetworkProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNetworkProfileOutputError>
}

public struct UpdateNetworkProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNetworkProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateNetworkProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateNetworkProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNetworkProfileOutputError>
}

public struct UpdateNetworkProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNetworkProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateNetworkProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateNetworkProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNetworkProfileOutputError>
}

public struct UpdateNetworkProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project for which you want to update network
    ///             profile settings.
    /// This member is required.
    public var arn: Swift.String?
    /// The description of the network profile about which you are returning
    ///             information.
    public var description: Swift.String?
    /// The data throughput rate in bits per second, as an integer from 0 to
    ///             104857600.
    public var downlinkBandwidthBits: Swift.Int?
    /// Delay time for all packets to destination in milliseconds as an integer from 0 to
    ///             2000.
    public var downlinkDelayMs: Swift.Int?
    /// Time variation in the delay of received packets in milliseconds as an integer from
    ///             0 to 2000.
    public var downlinkJitterMs: Swift.Int?
    /// Proportion of received packets that fail to arrive from 0 to 100 percent.
    public var downlinkLossPercent: Swift.Int
    /// The name of the network profile about which you are returning
    ///             information.
    public var name: Swift.String?
    /// The type of network profile to return information about. Valid values are listed here.
    public var type: DeviceFarmClientTypes.NetworkProfileType?
    /// The data throughput rate in bits per second, as an integer from 0 to
    ///             104857600.
    public var uplinkBandwidthBits: Swift.Int?
    /// Delay time for all packets to destination in milliseconds as an integer from 0 to
    ///             2000.
    public var uplinkDelayMs: Swift.Int?
    /// Time variation in the delay of received packets in milliseconds as an integer from
    ///             0 to 2000.
    public var uplinkJitterMs: Swift.Int?
    /// Proportion of transmitted packets that fail to arrive from 0 to 100
    ///             percent.
    public var uplinkLossPercent: Swift.Int

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        downlinkBandwidthBits: Swift.Int? = nil,
        downlinkDelayMs: Swift.Int? = nil,
        downlinkJitterMs: Swift.Int? = nil,
        downlinkLossPercent: Swift.Int = 0,
        name: Swift.String? = nil,
        type: DeviceFarmClientTypes.NetworkProfileType? = nil,
        uplinkBandwidthBits: Swift.Int? = nil,
        uplinkDelayMs: Swift.Int? = nil,
        uplinkJitterMs: Swift.Int? = nil,
        uplinkLossPercent: Swift.Int = 0
    )
    {
        self.arn = arn
        self.description = description
        self.downlinkBandwidthBits = downlinkBandwidthBits
        self.downlinkDelayMs = downlinkDelayMs
        self.downlinkJitterMs = downlinkJitterMs
        self.downlinkLossPercent = downlinkLossPercent
        self.name = name
        self.type = type
        self.uplinkBandwidthBits = uplinkBandwidthBits
        self.uplinkDelayMs = uplinkDelayMs
        self.uplinkJitterMs = uplinkJitterMs
        self.uplinkLossPercent = uplinkLossPercent
    }
}

struct UpdateNetworkProfileInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let type: DeviceFarmClientTypes.NetworkProfileType?
    public let uplinkBandwidthBits: Swift.Int?
    public let downlinkBandwidthBits: Swift.Int?
    public let uplinkDelayMs: Swift.Int?
    public let downlinkDelayMs: Swift.Int?
    public let uplinkJitterMs: Swift.Int?
    public let downlinkJitterMs: Swift.Int?
    public let uplinkLossPercent: Swift.Int
    public let downlinkLossPercent: Swift.Int
}

extension UpdateNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case downlinkBandwidthBits
        case downlinkDelayMs
        case downlinkJitterMs
        case downlinkLossPercent
        case name
        case type
        case uplinkBandwidthBits
        case uplinkDelayMs
        case uplinkJitterMs
        case uplinkLossPercent
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfileType.self, forKey: .type)
        type = typeDecoded
        let uplinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkBandwidthBits)
        uplinkBandwidthBits = uplinkBandwidthBitsDecoded
        let downlinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkBandwidthBits)
        downlinkBandwidthBits = downlinkBandwidthBitsDecoded
        let uplinkDelayMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkDelayMs)
        uplinkDelayMs = uplinkDelayMsDecoded
        let downlinkDelayMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkDelayMs)
        downlinkDelayMs = downlinkDelayMsDecoded
        let uplinkJitterMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uplinkJitterMs)
        uplinkJitterMs = uplinkJitterMsDecoded
        let downlinkJitterMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .downlinkJitterMs)
        downlinkJitterMs = downlinkJitterMsDecoded
        let uplinkLossPercentDecoded = try containerValues.decode(Swift.Int.self, forKey: .uplinkLossPercent)
        uplinkLossPercent = uplinkLossPercentDecoded
        let downlinkLossPercentDecoded = try containerValues.decode(Swift.Int.self, forKey: .downlinkLossPercent)
        downlinkLossPercent = downlinkLossPercentDecoded
    }
}

extension UpdateNetworkProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNetworkProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNetworkProfileOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNetworkProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNetworkProfileOutputResponse(networkProfile: \(Swift.String(describing: networkProfile)))"}
}

extension UpdateNetworkProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateNetworkProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkProfile = output.networkProfile
        } else {
            self.networkProfile = nil
        }
    }
}

public struct UpdateNetworkProfileOutputResponse: Swift.Equatable {
    /// A list of the available network profiles.
    public var networkProfile: DeviceFarmClientTypes.NetworkProfile?

    public init (
        networkProfile: DeviceFarmClientTypes.NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

struct UpdateNetworkProfileOutputResponseBody: Swift.Equatable {
    public let networkProfile: DeviceFarmClientTypes.NetworkProfile?
}

extension UpdateNetworkProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.NetworkProfile.self, forKey: .networkProfile)
        networkProfile = networkProfileDecoded
    }
}

public struct UpdateProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

extension UpdateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectInput(arn: \(Swift.String(describing: arn)), defaultJobTimeoutMinutes: \(Swift.String(describing: defaultJobTimeoutMinutes)), name: \(Swift.String(describing: name)))"}
}

extension UpdateProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case defaultJobTimeoutMinutes
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let defaultJobTimeoutMinutes = defaultJobTimeoutMinutes {
            try encodeContainer.encode(defaultJobTimeoutMinutes, forKey: .defaultJobTimeoutMinutes)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

/// Represents a request to the update project operation.
public struct UpdateProjectInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the project whose name to update.
    /// This member is required.
    public var arn: Swift.String?
    /// The number of minutes a test run in the project executes before it times out.
    public var defaultJobTimeoutMinutes: Swift.Int?
    /// A string that represents the new name of the project that you are updating.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        defaultJobTimeoutMinutes: Swift.Int? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
        self.name = name
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let defaultJobTimeoutMinutes: Swift.Int?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case defaultJobTimeoutMinutes
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultJobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultJobTimeoutMinutes)
        defaultJobTimeoutMinutes = defaultJobTimeoutMinutesDecoded
    }
}

extension UpdateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectOutputResponse(project: \(Swift.String(describing: project)))"}
}

extension UpdateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

/// Represents the result of an update project request.
public struct UpdateProjectOutputResponse: Swift.Equatable {
    /// The project to update.
    public var project: DeviceFarmClientTypes.Project?

    public init (
        project: DeviceFarmClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

struct UpdateProjectOutputResponseBody: Swift.Equatable {
    public let project: DeviceFarmClientTypes.Project?
}

extension UpdateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case project
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Project.self, forKey: .project)
        project = projectDecoded
    }
}

public struct UpdateTestGridProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTestGridProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTestGridProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTestGridProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTestGridProjectOutputError>
}

extension UpdateTestGridProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTestGridProjectInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), projectArn: \(Swift.String(describing: projectArn)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension UpdateTestGridProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case projectArn
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct UpdateTestGridProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTestGridProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTestGridProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTestGridProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTestGridProjectOutputError>
}

public struct UpdateTestGridProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTestGridProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTestGridProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTestGridProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTestGridProjectOutputError>
}

public struct UpdateTestGridProjectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTestGridProjectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateTestGridProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateTestGridProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTestGridProjectOutputError>
}

public struct UpdateTestGridProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTestGridProjectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateTestGridProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateTestGridProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTestGridProjectOutputError>
}

public struct UpdateTestGridProjectInput: Swift.Equatable {
    /// Human-readable description for the project.
    public var description: Swift.String?
    /// Human-readable name for the project.
    public var name: Swift.String?
    /// ARN of the project to update.
    /// This member is required.
    public var projectArn: Swift.String?
    /// The VPC security groups and subnets that are attached to a project.
    public var vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig? = nil
    )
    {
        self.description = description
        self.name = name
        self.projectArn = projectArn
        self.vpcConfig = vpcConfig
    }
}

struct UpdateTestGridProjectInputBody: Swift.Equatable {
    public let projectArn: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig?
}

extension UpdateTestGridProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case projectArn
        case vpcConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridVpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension UpdateTestGridProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTestGridProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTestGridProjectOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTestGridProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTestGridProjectOutputResponse(testGridProject: \(Swift.String(describing: testGridProject)))"}
}

extension UpdateTestGridProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateTestGridProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.testGridProject = output.testGridProject
        } else {
            self.testGridProject = nil
        }
    }
}

public struct UpdateTestGridProjectOutputResponse: Swift.Equatable {
    /// The project, including updated information.
    public var testGridProject: DeviceFarmClientTypes.TestGridProject?

    public init (
        testGridProject: DeviceFarmClientTypes.TestGridProject? = nil
    )
    {
        self.testGridProject = testGridProject
    }
}

struct UpdateTestGridProjectOutputResponseBody: Swift.Equatable {
    public let testGridProject: DeviceFarmClientTypes.TestGridProject?
}

extension UpdateTestGridProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case testGridProject
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridProjectDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.TestGridProject.self, forKey: .testGridProject)
        testGridProject = testGridProjectDecoded
    }
}

public struct UpdateUploadInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUploadOutputError>
}

extension UpdateUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUploadInput(arn: \(Swift.String(describing: arn)), contentType: \(Swift.String(describing: contentType)), editContent: \(Swift.String(describing: editContent)), name: \(Swift.String(describing: name)))"}
}

extension UpdateUploadInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case contentType
        case editContent
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let editContent = editContent {
            try encodeContainer.encode(editContent, forKey: .editContent)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateUploadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUploadOutputError>
}

public struct UpdateUploadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUploadOutputError>
}

public struct UpdateUploadInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUploadInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUploadOutputError>
}

public struct UpdateUploadInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUploadInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUploadOutputError>
}

public struct UpdateUploadInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the uploaded test spec.
    /// This member is required.
    public var arn: Swift.String?
    /// The upload's content type (for example, application/x-yaml).
    public var contentType: Swift.String?
    /// Set to true if the YAML file has changed and must be updated. Otherwise, set to false.
    public var editContent: Swift.Bool?
    /// The upload's test spec file name. The name must not contain any forward slashes (/). The test spec file
    ///             name must end with the .yaml or .yml file extension.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        contentType: Swift.String? = nil,
        editContent: Swift.Bool? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.contentType = contentType
        self.editContent = editContent
        self.name = name
    }
}

struct UpdateUploadInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let contentType: Swift.String?
    public let editContent: Swift.Bool?
}

extension UpdateUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case contentType
        case editContent
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let editContentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .editContent)
        editContent = editContentDecoded
    }
}

extension UpdateUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUploadOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUploadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUploadOutputResponse(upload: \(Swift.String(describing: upload)))"}
}

extension UpdateUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.upload = output.upload
        } else {
            self.upload = nil
        }
    }
}

public struct UpdateUploadOutputResponse: Swift.Equatable {
    /// A test spec uploaded to Device Farm.
    public var upload: DeviceFarmClientTypes.Upload?

    public init (
        upload: DeviceFarmClientTypes.Upload? = nil
    )
    {
        self.upload = upload
    }
}

struct UpdateUploadOutputResponseBody: Swift.Equatable {
    public let upload: DeviceFarmClientTypes.Upload?
}

extension UpdateUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case upload
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.Upload.self, forKey: .upload)
        upload = uploadDecoded
    }
}

public struct UpdateVPCEConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVPCEConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVPCEConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVPCEConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVPCEConfigurationOutputError>
}

extension UpdateVPCEConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVPCEConfigurationInput(arn: \(Swift.String(describing: arn)), serviceDnsName: \(Swift.String(describing: serviceDnsName)), vpceConfigurationDescription: \(Swift.String(describing: vpceConfigurationDescription)), vpceConfigurationName: \(Swift.String(describing: vpceConfigurationName)), vpceServiceName: \(Swift.String(describing: vpceServiceName)))"}
}

extension UpdateVPCEConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case serviceDnsName
        case vpceConfigurationDescription
        case vpceConfigurationName
        case vpceServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let serviceDnsName = serviceDnsName {
            try encodeContainer.encode(serviceDnsName, forKey: .serviceDnsName)
        }
        if let vpceConfigurationDescription = vpceConfigurationDescription {
            try encodeContainer.encode(vpceConfigurationDescription, forKey: .vpceConfigurationDescription)
        }
        if let vpceConfigurationName = vpceConfigurationName {
            try encodeContainer.encode(vpceConfigurationName, forKey: .vpceConfigurationName)
        }
        if let vpceServiceName = vpceServiceName {
            try encodeContainer.encode(vpceServiceName, forKey: .vpceServiceName)
        }
    }
}

public struct UpdateVPCEConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVPCEConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVPCEConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVPCEConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVPCEConfigurationOutputError>
}

public struct UpdateVPCEConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVPCEConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVPCEConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVPCEConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVPCEConfigurationOutputError>
}

public struct UpdateVPCEConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVPCEConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateVPCEConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateVPCEConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVPCEConfigurationOutputError>
}

public struct UpdateVPCEConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVPCEConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateVPCEConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateVPCEConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVPCEConfigurationOutputError>
}

public struct UpdateVPCEConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to
    ///             update.
    /// This member is required.
    public var arn: Swift.String?
    /// The DNS (domain) name used to connect to your private service in your VPC. The DNS name must not already
    ///             be in use on the internet.
    public var serviceDnsName: Swift.String?
    /// An optional description that provides details about your VPC endpoint configuration.
    public var vpceConfigurationDescription: Swift.String?
    /// The friendly name you give to your VPC endpoint configuration to manage your configurations more
    ///             easily.
    public var vpceConfigurationName: Swift.String?
    /// The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.
    public var vpceServiceName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        serviceDnsName: Swift.String? = nil,
        vpceConfigurationDescription: Swift.String? = nil,
        vpceConfigurationName: Swift.String? = nil,
        vpceServiceName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.serviceDnsName = serviceDnsName
        self.vpceConfigurationDescription = vpceConfigurationDescription
        self.vpceConfigurationName = vpceConfigurationName
        self.vpceServiceName = vpceServiceName
    }
}

struct UpdateVPCEConfigurationInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let vpceConfigurationName: Swift.String?
    public let vpceServiceName: Swift.String?
    public let serviceDnsName: Swift.String?
    public let vpceConfigurationDescription: Swift.String?
}

extension UpdateVPCEConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case serviceDnsName
        case vpceConfigurationDescription
        case vpceConfigurationName
        case vpceServiceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let vpceConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceConfigurationName)
        vpceConfigurationName = vpceConfigurationNameDecoded
        let vpceServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceServiceName)
        vpceServiceName = vpceServiceNameDecoded
        let serviceDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceDnsName)
        serviceDnsName = serviceDnsNameDecoded
        let vpceConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceConfigurationDescription)
        vpceConfigurationDescription = vpceConfigurationDescriptionDecoded
    }
}

extension UpdateVPCEConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVPCEConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVPCEConfigurationOutputError: Swift.Error, Swift.Equatable {
    case argumentException(ArgumentException)
    case invalidOperationException(InvalidOperationException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVPCEConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVPCEConfigurationOutputResponse(vpceConfiguration: \(Swift.String(describing: vpceConfiguration)))"}
}

extension UpdateVPCEConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateVPCEConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpceConfiguration = output.vpceConfiguration
        } else {
            self.vpceConfiguration = nil
        }
    }
}

public struct UpdateVPCEConfigurationOutputResponse: Swift.Equatable {
    /// An object that contains information about your VPC endpoint configuration.
    public var vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration?

    public init (
        vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration? = nil
    )
    {
        self.vpceConfiguration = vpceConfiguration
    }
}

struct UpdateVPCEConfigurationOutputResponseBody: Swift.Equatable {
    public let vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration?
}

extension UpdateVPCEConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpceConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpceConfigurationDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.VPCEConfiguration.self, forKey: .vpceConfiguration)
        vpceConfiguration = vpceConfigurationDecoded
    }
}

extension DeviceFarmClientTypes.Upload: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case category
        case contentType
        case created
        case message
        case metadata
        case name
        case status
        case type
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.UploadType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.UploadStatus.self, forKey: .status)
        status = statusDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(DeviceFarmClientTypes.UploadCategory.self, forKey: .category)
        category = categoryDecoded
    }
}

extension DeviceFarmClientTypes.Upload: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Upload(arn: \(Swift.String(describing: arn)), category: \(Swift.String(describing: category)), contentType: \(Swift.String(describing: contentType)), created: \(Swift.String(describing: created)), message: \(Swift.String(describing: message)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), url: \(Swift.String(describing: url)))"}
}

extension DeviceFarmClientTypes {
    /// An app or a set of one or more tests to upload or that have been
    ///             uploaded.
    public struct Upload: Swift.Equatable {
        /// The upload's ARN.
        public var arn: Swift.String?
        /// The upload's category. Allowed values include:
        ///
        ///
        ///                 CURATED: An upload managed by AWS Device Farm.
        ///
        ///
        ///                 PRIVATE: An upload managed by the AWS Device Farm customer.
        ///
        ///
        public var category: DeviceFarmClientTypes.UploadCategory?
        /// The upload's content type (for example, application/octet-stream).
        public var contentType: Swift.String?
        /// When the upload was created.
        public var created: ClientRuntime.Date?
        /// A message about the upload's result.
        public var message: Swift.String?
        /// The upload's metadata. For example, for Android, this contains information that is
        ///             parsed from the manifest and is displayed in the AWS Device Farm console after the
        ///             associated app is uploaded.
        public var metadata: Swift.String?
        /// The upload's file name.
        public var name: Swift.String?
        /// The upload's status.
        ///         Must be one of the following values:
        ///
        ///
        ///                 FAILED
        ///
        ///
        ///                 INITIALIZED
        ///
        ///
        ///                 PROCESSING
        ///
        ///
        ///                 SUCCEEDED
        ///
        ///
        public var status: DeviceFarmClientTypes.UploadStatus?
        /// The upload's type.
        ///         Must be one of the following values:
        ///
        ///
        ///                 ANDROID_APP
        ///
        ///
        ///                 IOS_APP
        ///
        ///
        ///                 WEB_APP
        ///
        ///
        ///                 EXTERNAL_DATA
        ///
        ///
        ///                 APPIUM_JAVA_JUNIT_TEST_PACKAGE
        ///
        ///
        ///                 APPIUM_JAVA_TESTNG_TEST_PACKAGE
        ///
        ///
        ///                 APPIUM_PYTHON_TEST_PACKAGE
        ///
        ///
        ///                 APPIUM_NODE_TEST_PACKAGE
        ///
        ///
        ///                 APPIUM_RUBY_TEST_PACKAGE
        ///
        ///
        ///                 APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE
        ///
        ///
        ///                 APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE
        ///
        ///
        ///                 APPIUM_WEB_PYTHON_TEST_PACKAGE
        ///
        ///
        ///                 APPIUM_WEB_NODE_TEST_PACKAGE
        ///
        ///
        ///                 APPIUM_WEB_RUBY_TEST_PACKAGE
        ///
        ///
        ///                 CALABASH_TEST_PACKAGE
        ///
        ///
        ///                 INSTRUMENTATION_TEST_PACKAGE
        ///
        ///
        ///                 UIAUTOMATION_TEST_PACKAGE
        ///
        ///
        ///                 UIAUTOMATOR_TEST_PACKAGE
        ///
        ///
        ///                 XCTEST_TEST_PACKAGE
        ///
        ///
        ///                 XCTEST_UI_TEST_PACKAGE
        ///
        ///
        ///                 APPIUM_JAVA_JUNIT_TEST_SPEC
        ///
        ///
        ///                 APPIUM_JAVA_TESTNG_TEST_SPEC
        ///
        ///
        ///                 APPIUM_PYTHON_TEST_SPEC
        ///
        ///
        ///                 APPIUM_NODE_TEST_SPEC
        ///
        ///
        ///                 APPIUM_RUBY_TEST_SPEC
        ///
        ///
        ///                 APPIUM_WEB_JAVA_JUNIT_TEST_SPEC
        ///
        ///
        ///                 APPIUM_WEB_JAVA_TESTNG_TEST_SPEC
        ///
        ///
        ///                 APPIUM_WEB_PYTHON_TEST_SPEC
        ///
        ///
        ///                 APPIUM_WEB_NODE_TEST_SPEC
        ///
        ///
        ///                 APPIUM_WEB_RUBY_TEST_SPEC
        ///
        ///
        ///                 INSTRUMENTATION_TEST_SPEC
        ///
        ///
        ///                 XCTEST_UI_TEST_SPEC
        ///
        ///
        public var type: DeviceFarmClientTypes.UploadType?
        /// The presigned Amazon S3 URL that was used to store a file using a PUT request.
        public var url: Swift.String?

        public init (
            arn: Swift.String? = nil,
            category: DeviceFarmClientTypes.UploadCategory? = nil,
            contentType: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil,
            status: DeviceFarmClientTypes.UploadStatus? = nil,
            type: DeviceFarmClientTypes.UploadType? = nil,
            url: Swift.String? = nil
        )
        {
            self.arn = arn
            self.category = category
            self.contentType = contentType
            self.created = created
            self.message = message
            self.metadata = metadata
            self.name = name
            self.status = status
            self.type = type
            self.url = url
        }
    }

}

extension DeviceFarmClientTypes {
    public enum UploadCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case curated
        case `private`
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadCategory] {
            return [
                .curated,
                .private,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .curated: return "CURATED"
            case .private: return "PRIVATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UploadCategory(rawValue: rawValue) ?? UploadCategory.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum UploadStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case initialized
        case processing
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadStatus] {
            return [
                .failed,
                .initialized,
                .processing,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .initialized: return "INITIALIZED"
            case .processing: return "PROCESSING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UploadStatus(rawValue: rawValue) ?? UploadStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes {
    public enum UploadType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case androidApp
        case appiumJavaJunitTestPackage
        case appiumJavaJunitTestSpec
        case appiumJavaTestngTestPackage
        case appiumJavaTestngTestSpec
        case appiumNodeTestPackage
        case appiumNodeTestSpec
        case appiumPythonTestPackage
        case appiumPythonTestSpec
        case appiumRubyTestPackage
        case appiumRubyTestSpec
        case appiumWebJavaJunitTestPackage
        case appiumWebJavaJunitTestSpec
        case appiumWebJavaTestngTestPackage
        case appiumWebJavaTestngTestSpec
        case appiumWebNodeTestPackage
        case appiumWebNodeTestSpec
        case appiumWebPythonTestPackage
        case appiumWebPythonTestSpec
        case appiumWebRubyTestPackage
        case appiumWebRubyTestSpec
        case calabashTestPackage
        case externalData
        case instrumentationTestPackage
        case instrumentationTestSpec
        case iosApp
        case uiautomationTestPackage
        case uiautomatorTestPackage
        case webApp
        case xctestTestPackage
        case xctestUiTestPackage
        case xctestUiTestSpec
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadType] {
            return [
                .androidApp,
                .appiumJavaJunitTestPackage,
                .appiumJavaJunitTestSpec,
                .appiumJavaTestngTestPackage,
                .appiumJavaTestngTestSpec,
                .appiumNodeTestPackage,
                .appiumNodeTestSpec,
                .appiumPythonTestPackage,
                .appiumPythonTestSpec,
                .appiumRubyTestPackage,
                .appiumRubyTestSpec,
                .appiumWebJavaJunitTestPackage,
                .appiumWebJavaJunitTestSpec,
                .appiumWebJavaTestngTestPackage,
                .appiumWebJavaTestngTestSpec,
                .appiumWebNodeTestPackage,
                .appiumWebNodeTestSpec,
                .appiumWebPythonTestPackage,
                .appiumWebPythonTestSpec,
                .appiumWebRubyTestPackage,
                .appiumWebRubyTestSpec,
                .calabashTestPackage,
                .externalData,
                .instrumentationTestPackage,
                .instrumentationTestSpec,
                .iosApp,
                .uiautomationTestPackage,
                .uiautomatorTestPackage,
                .webApp,
                .xctestTestPackage,
                .xctestUiTestPackage,
                .xctestUiTestSpec,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .androidApp: return "ANDROID_APP"
            case .appiumJavaJunitTestPackage: return "APPIUM_JAVA_JUNIT_TEST_PACKAGE"
            case .appiumJavaJunitTestSpec: return "APPIUM_JAVA_JUNIT_TEST_SPEC"
            case .appiumJavaTestngTestPackage: return "APPIUM_JAVA_TESTNG_TEST_PACKAGE"
            case .appiumJavaTestngTestSpec: return "APPIUM_JAVA_TESTNG_TEST_SPEC"
            case .appiumNodeTestPackage: return "APPIUM_NODE_TEST_PACKAGE"
            case .appiumNodeTestSpec: return "APPIUM_NODE_TEST_SPEC"
            case .appiumPythonTestPackage: return "APPIUM_PYTHON_TEST_PACKAGE"
            case .appiumPythonTestSpec: return "APPIUM_PYTHON_TEST_SPEC"
            case .appiumRubyTestPackage: return "APPIUM_RUBY_TEST_PACKAGE"
            case .appiumRubyTestSpec: return "APPIUM_RUBY_TEST_SPEC"
            case .appiumWebJavaJunitTestPackage: return "APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE"
            case .appiumWebJavaJunitTestSpec: return "APPIUM_WEB_JAVA_JUNIT_TEST_SPEC"
            case .appiumWebJavaTestngTestPackage: return "APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE"
            case .appiumWebJavaTestngTestSpec: return "APPIUM_WEB_JAVA_TESTNG_TEST_SPEC"
            case .appiumWebNodeTestPackage: return "APPIUM_WEB_NODE_TEST_PACKAGE"
            case .appiumWebNodeTestSpec: return "APPIUM_WEB_NODE_TEST_SPEC"
            case .appiumWebPythonTestPackage: return "APPIUM_WEB_PYTHON_TEST_PACKAGE"
            case .appiumWebPythonTestSpec: return "APPIUM_WEB_PYTHON_TEST_SPEC"
            case .appiumWebRubyTestPackage: return "APPIUM_WEB_RUBY_TEST_PACKAGE"
            case .appiumWebRubyTestSpec: return "APPIUM_WEB_RUBY_TEST_SPEC"
            case .calabashTestPackage: return "CALABASH_TEST_PACKAGE"
            case .externalData: return "EXTERNAL_DATA"
            case .instrumentationTestPackage: return "INSTRUMENTATION_TEST_PACKAGE"
            case .instrumentationTestSpec: return "INSTRUMENTATION_TEST_SPEC"
            case .iosApp: return "IOS_APP"
            case .uiautomationTestPackage: return "UIAUTOMATION_TEST_PACKAGE"
            case .uiautomatorTestPackage: return "UIAUTOMATOR_TEST_PACKAGE"
            case .webApp: return "WEB_APP"
            case .xctestTestPackage: return "XCTEST_TEST_PACKAGE"
            case .xctestUiTestPackage: return "XCTEST_UI_TEST_PACKAGE"
            case .xctestUiTestSpec: return "XCTEST_UI_TEST_SPEC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UploadType(rawValue: rawValue) ?? UploadType.sdkUnknown(rawValue)
        }
    }
}

extension DeviceFarmClientTypes.VPCEConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case serviceDnsName
        case vpceConfigurationDescription
        case vpceConfigurationName
        case vpceServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let serviceDnsName = serviceDnsName {
            try encodeContainer.encode(serviceDnsName, forKey: .serviceDnsName)
        }
        if let vpceConfigurationDescription = vpceConfigurationDescription {
            try encodeContainer.encode(vpceConfigurationDescription, forKey: .vpceConfigurationDescription)
        }
        if let vpceConfigurationName = vpceConfigurationName {
            try encodeContainer.encode(vpceConfigurationName, forKey: .vpceConfigurationName)
        }
        if let vpceServiceName = vpceServiceName {
            try encodeContainer.encode(vpceServiceName, forKey: .vpceServiceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let vpceConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceConfigurationName)
        vpceConfigurationName = vpceConfigurationNameDecoded
        let vpceServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceServiceName)
        vpceServiceName = vpceServiceNameDecoded
        let serviceDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceDnsName)
        serviceDnsName = serviceDnsNameDecoded
        let vpceConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceConfigurationDescription)
        vpceConfigurationDescription = vpceConfigurationDescriptionDecoded
    }
}

extension DeviceFarmClientTypes.VPCEConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VPCEConfiguration(arn: \(Swift.String(describing: arn)), serviceDnsName: \(Swift.String(describing: serviceDnsName)), vpceConfigurationDescription: \(Swift.String(describing: vpceConfigurationDescription)), vpceConfigurationName: \(Swift.String(describing: vpceConfigurationName)), vpceServiceName: \(Swift.String(describing: vpceServiceName)))"}
}

extension DeviceFarmClientTypes {
    /// Represents an Amazon Virtual Private Cloud (VPC) endpoint configuration.
    public struct VPCEConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the VPC endpoint configuration.
        public var arn: Swift.String?
        /// The DNS name that maps to the private IP address of the service you want to
        ///             access.
        public var serviceDnsName: Swift.String?
        /// An optional description that provides details about your VPC endpoint configuration.
        public var vpceConfigurationDescription: Swift.String?
        /// The friendly name you give to your VPC endpoint configuration to manage your configurations more
        ///             easily.
        public var vpceConfigurationName: Swift.String?
        /// The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.
        public var vpceServiceName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            serviceDnsName: Swift.String? = nil,
            vpceConfigurationDescription: Swift.String? = nil,
            vpceConfigurationName: Swift.String? = nil,
            vpceServiceName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.serviceDnsName = serviceDnsName
            self.vpceConfigurationDescription = vpceConfigurationDescription
            self.vpceConfigurationName = vpceConfigurationName
            self.vpceServiceName = vpceServiceName
        }
    }

}
