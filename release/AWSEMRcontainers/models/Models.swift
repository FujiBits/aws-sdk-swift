// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CancelJobRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelJobRunInput(id: \(Swift.String(describing: id)), virtualClusterId: \(Swift.String(describing: virtualClusterId)))"}
}

extension CancelJobRunInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct CancelJobRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelJobRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelJobRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelJobRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelJobRunOutputError>
}

public struct CancelJobRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelJobRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelJobRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelJobRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelJobRunOutputError>
}

public struct CancelJobRunInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelJobRunInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CancelJobRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let virtualClusterId = input.virtualClusterId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("virtualClusterId is nil and needs a value for the path of this operation"))))
        }
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/jobruns/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelJobRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelJobRunOutputError>
}

public struct CancelJobRunInput: Swift.Equatable {
    /// The ID of the job run to cancel.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the virtual cluster for which the job run will be canceled.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct CancelJobRunInputBody: Swift.Equatable {
}

extension CancelJobRunInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelJobRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelJobRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelJobRunOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelJobRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelJobRunOutputResponse(id: \(Swift.String(describing: id)), virtualClusterId: \(Swift.String(describing: virtualClusterId)))"}
}

extension CancelJobRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelJobRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.id = nil
            self.virtualClusterId = nil
        }
    }
}

public struct CancelJobRunOutputResponse: Swift.Equatable {
    /// The output contains the ID of the cancelled job run.
    public var id: Swift.String?
    /// The output contains the virtual cluster ID for which the job run is cancelled.
    public var virtualClusterId: Swift.String?

    public init (
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct CancelJobRunOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let virtualClusterId: Swift.String?
}

extension CancelJobRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case virtualClusterId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

extension EmrContainersClientTypes.CloudWatchMonitoringConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName
        case logStreamNamePrefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let logStreamNamePrefix = logStreamNamePrefix {
            try encodeContainer.encode(logStreamNamePrefix, forKey: .logStreamNamePrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let logStreamNamePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logStreamNamePrefix)
        logStreamNamePrefix = logStreamNamePrefixDecoded
    }
}

extension EmrContainersClientTypes.CloudWatchMonitoringConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudWatchMonitoringConfiguration(logGroupName: \(Swift.String(describing: logGroupName)), logStreamNamePrefix: \(Swift.String(describing: logStreamNamePrefix)))"}
}

extension EmrContainersClientTypes {
    /// A configuration for CloudWatch monitoring. You can configure your jobs to send log information to CloudWatch Logs.
    public struct CloudWatchMonitoringConfiguration: Swift.Equatable {
        /// The name of the log group for log publishing.
        /// This member is required.
        public var logGroupName: Swift.String?
        /// The specified name prefix for log streams.
        public var logStreamNamePrefix: Swift.String?

        public init (
            logGroupName: Swift.String? = nil,
            logStreamNamePrefix: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
            self.logStreamNamePrefix = logStreamNamePrefix
        }
    }

}

extension EmrContainersClientTypes.Configuration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classification
        case configurations
        case properties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classification = classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurations)
            for configurationlist0 in configurations {
                try configurationsContainer.encode(configurationlist0)
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, sensitivepropertiesmap0) in properties {
                try propertiesContainer.encode(sensitivepropertiesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let classificationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .classification)
        classification = classificationDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string10240) in propertiesContainer {
                if let string10240 = string10240 {
                    propertiesDecoded0?[key0] = string10240
                }
            }
        }
        properties = propertiesDecoded0
        let configurationsContainer = try containerValues.decodeIfPresent([EmrContainersClientTypes.Configuration?].self, forKey: .configurations)
        var configurationsDecoded0:[EmrContainersClientTypes.Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [EmrContainersClientTypes.Configuration]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
    }
}

extension EmrContainersClientTypes.Configuration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Configuration(classification: \(Swift.String(describing: classification)), configurations: \(Swift.String(describing: configurations)), properties: \(Swift.String(describing: properties)))"}
}

extension EmrContainersClientTypes {
    /// A configuration specification to be used when provisioning virtual clusters, which can include configurations for applications and software bundled with Amazon EMR on EKS. A configuration consists of a classification, properties, and optional nested configurations. A classification refers to an application-specific configuration file. Properties are the settings you want to change in that file.
    public struct Configuration: Swift.Equatable {
        /// The classification within a configuration.
        /// This member is required.
        public var classification: Swift.String?
        /// A list of additional configurations to apply within a configuration object.
        public var configurations: [EmrContainersClientTypes.Configuration]?
        /// A set of properties specified within a configuration classification.
        public var properties: [Swift.String:Swift.String]?

        public init (
            classification: Swift.String? = nil,
            configurations: [EmrContainersClientTypes.Configuration]? = nil,
            properties: [Swift.String:Swift.String]? = nil
        )
        {
            self.classification = classification
            self.configurations = configurations
            self.properties = properties
        }
    }

}

extension EmrContainersClientTypes.ConfigurationOverrides: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfiguration
        case monitoringConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfiguration = applicationConfiguration {
            var applicationConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationConfiguration)
            for configurationlist0 in applicationConfiguration {
                try applicationConfigurationContainer.encode(configurationlist0)
            }
        }
        if let monitoringConfiguration = monitoringConfiguration {
            try encodeContainer.encode(monitoringConfiguration, forKey: .monitoringConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationConfigurationContainer = try containerValues.decodeIfPresent([EmrContainersClientTypes.Configuration?].self, forKey: .applicationConfiguration)
        var applicationConfigurationDecoded0:[EmrContainersClientTypes.Configuration]? = nil
        if let applicationConfigurationContainer = applicationConfigurationContainer {
            applicationConfigurationDecoded0 = [EmrContainersClientTypes.Configuration]()
            for structure0 in applicationConfigurationContainer {
                if let structure0 = structure0 {
                    applicationConfigurationDecoded0?.append(structure0)
                }
            }
        }
        applicationConfiguration = applicationConfigurationDecoded0
        let monitoringConfigurationDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.MonitoringConfiguration.self, forKey: .monitoringConfiguration)
        monitoringConfiguration = monitoringConfigurationDecoded
    }
}

extension EmrContainersClientTypes.ConfigurationOverrides: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigurationOverrides(applicationConfiguration: \(Swift.String(describing: applicationConfiguration)), monitoringConfiguration: \(Swift.String(describing: monitoringConfiguration)))"}
}

extension EmrContainersClientTypes {
    /// A configuration specification to be used to override existing configurations.
    public struct ConfigurationOverrides: Swift.Equatable {
        /// The configurations for the application running by the job run.
        public var applicationConfiguration: [EmrContainersClientTypes.Configuration]?
        /// The configurations for monitoring.
        public var monitoringConfiguration: EmrContainersClientTypes.MonitoringConfiguration?

        public init (
            applicationConfiguration: [EmrContainersClientTypes.Configuration]? = nil,
            monitoringConfiguration: EmrContainersClientTypes.MonitoringConfiguration? = nil
        )
        {
            self.applicationConfiguration = applicationConfiguration
            self.monitoringConfiguration = monitoringConfiguration
        }
    }

}

extension EmrContainersClientTypes.ContainerInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eksinfo = "eksInfo"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .eksinfo(eksinfo):
                try container.encode(eksinfo, forKey: .eksinfo)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let eksinfoDecoded = try values.decodeIfPresent(EmrContainersClientTypes.EksInfo.self, forKey: .eksinfo)
        if let eksinfo = eksinfoDecoded {
            self = .eksinfo(eksinfo)
            return
        }
        self = .sdkUnknown("")
    }
}

extension EmrContainersClientTypes {
    /// The information about the container used for a job run or a managed endpoint.
    public enum ContainerInfo: Swift.Equatable {
        /// The information about the EKS cluster.
        case eksinfo(EmrContainersClientTypes.EksInfo)
        case sdkUnknown(Swift.String)
    }

}

extension EmrContainersClientTypes.ContainerProvider: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case info
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let info = info {
            try encodeContainer.encode(info, forKey: .info)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ContainerProviderType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let infoDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ContainerInfo.self, forKey: .info)
        info = infoDecoded
    }
}

extension EmrContainersClientTypes.ContainerProvider: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContainerProvider(id: \(Swift.String(describing: id)), info: \(Swift.String(describing: info)), type: \(Swift.String(describing: type)))"}
}

extension EmrContainersClientTypes {
    /// The information about the container provider.
    public struct ContainerProvider: Swift.Equatable {
        /// The ID of the container cluster.
        /// This member is required.
        public var id: Swift.String?
        /// The information about the container cluster.
        public var info: EmrContainersClientTypes.ContainerInfo?
        /// The type of the container provider. EKS is the only supported type as of now.
        /// This member is required.
        public var type: EmrContainersClientTypes.ContainerProviderType?

        public init (
            id: Swift.String? = nil,
            info: EmrContainersClientTypes.ContainerInfo? = nil,
            type: EmrContainersClientTypes.ContainerProviderType? = nil
        )
        {
            self.id = id
            self.info = info
            self.type = type
        }
    }

}

extension EmrContainersClientTypes {
    public enum ContainerProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eks
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerProviderType] {
            return [
                .eks,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eks: return "EKS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerProviderType(rawValue: rawValue) ?? ContainerProviderType.sdkUnknown(rawValue)
        }
    }
}

public struct CreateManagedEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateManagedEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateManagedEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateManagedEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateManagedEndpointOutputError>
}

extension CreateManagedEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateManagedEndpointInput(certificateArn: \(Swift.String(describing: certificateArn)), clientToken: \(Swift.String(describing: clientToken)), configurationOverrides: \(Swift.String(describing: configurationOverrides)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), name: \(Swift.String(describing: name)), releaseLabel: \(Swift.String(describing: releaseLabel)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), virtualClusterId: \(Swift.String(describing: virtualClusterId)))"}
}

extension CreateManagedEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case name
        case releaseLabel
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationOverrides = configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

public struct CreateManagedEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateManagedEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateManagedEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateManagedEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateManagedEndpointOutputError>
}

public struct CreateManagedEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateManagedEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateManagedEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateManagedEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateManagedEndpointOutputError>
}

public struct CreateManagedEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateManagedEndpointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateManagedEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let virtualClusterId = input.virtualClusterId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("virtualClusterId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/endpoints"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateManagedEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateManagedEndpointOutputError>
}

public struct CreateManagedEndpointInput: Swift.Equatable {
    /// The certificate ARN of the managed endpoint.
    /// This member is required.
    public var certificateArn: Swift.String?
    /// The client idempotency token for this create call.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The configuration settings that will be used to override existing configurations.
    public var configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides?
    /// The ARN of the execution role.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The name of the managed endpoint.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon EMR release version.
    /// This member is required.
    public var releaseLabel: Swift.String?
    /// The tags of the managed endpoint.
    ///
    public var tags: [Swift.String:Swift.String]?
    /// The type of the managed endpoint.
    /// This member is required.
    public var type: Swift.String?
    /// The ID of the virtual cluster for which a managed endpoint is created.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        certificateArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides? = nil,
        executionRoleArn: Swift.String? = nil,
        name: Swift.String? = nil,
        releaseLabel: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.clientToken = clientToken
        self.configurationOverrides = configurationOverrides
        self.executionRoleArn = executionRoleArn
        self.name = name
        self.releaseLabel = releaseLabel
        self.tags = tags
        self.type = type
        self.virtualClusterId = virtualClusterId
    }
}

struct CreateManagedEndpointInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let type: Swift.String?
    public let releaseLabel: Swift.String?
    public let executionRoleArn: Swift.String?
    public let certificateArn: Swift.String?
    public let configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides?
    public let clientToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateManagedEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case name
        case releaseLabel
        case tags
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateManagedEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateManagedEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateManagedEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateManagedEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateManagedEndpointOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), virtualClusterId: \(Swift.String(describing: virtualClusterId)))"}
}

extension CreateManagedEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateManagedEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
            self.virtualClusterId = nil
        }
    }
}

public struct CreateManagedEndpointOutputResponse: Swift.Equatable {
    /// The output contains the ARN of the managed endpoint.
    public var arn: Swift.String?
    /// The output contains the ID of the managed endpoint.
    public var id: Swift.String?
    /// The output contains the name of the managed endpoint.
    public var name: Swift.String?
    /// The output contains the ID of the virtual cluster.
    public var virtualClusterId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.virtualClusterId = virtualClusterId
    }
}

struct CreateManagedEndpointOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let name: Swift.String?
    public let arn: Swift.String?
    public let virtualClusterId: Swift.String?
}

extension CreateManagedEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case name
        case virtualClusterId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

public struct CreateVirtualClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVirtualClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVirtualClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVirtualClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVirtualClusterOutputError>
}

extension CreateVirtualClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVirtualClusterInput(clientToken: \(Swift.String(describing: clientToken)), containerProvider: \(Swift.String(describing: containerProvider)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateVirtualClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerProvider
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerProvider = containerProvider {
            try encodeContainer.encode(containerProvider, forKey: .containerProvider)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateVirtualClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVirtualClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVirtualClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVirtualClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVirtualClusterOutputError>
}

public struct CreateVirtualClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVirtualClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVirtualClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVirtualClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVirtualClusterOutputError>
}

public struct CreateVirtualClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVirtualClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateVirtualClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/virtualclusters"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateVirtualClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVirtualClusterOutputError>
}

public struct CreateVirtualClusterInput: Swift.Equatable {
    /// The client token of the virtual cluster.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The container provider of the virtual cluster.
    /// This member is required.
    public var containerProvider: EmrContainersClientTypes.ContainerProvider?
    /// The specified name of the virtual cluster.
    /// This member is required.
    public var name: Swift.String?
    /// The tags assigned to the virtual cluster.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        containerProvider: EmrContainersClientTypes.ContainerProvider? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.containerProvider = containerProvider
        self.name = name
        self.tags = tags
    }
}

struct CreateVirtualClusterInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let containerProvider: EmrContainersClientTypes.ContainerProvider?
    public let clientToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateVirtualClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerProvider
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let containerProviderDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ContainerProvider.self, forKey: .containerProvider)
        containerProvider = containerProviderDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVirtualClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVirtualClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVirtualClusterOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVirtualClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVirtualClusterOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension CreateVirtualClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateVirtualClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct CreateVirtualClusterOutputResponse: Swift.Equatable {
    /// This output contains the ARN of virtual cluster.
    public var arn: Swift.String?
    /// This output contains the virtual cluster ID.
    public var id: Swift.String?
    /// This output contains the name of the virtual cluster.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
    }
}

struct CreateVirtualClusterOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let name: Swift.String?
    public let arn: Swift.String?
}

extension CreateVirtualClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteManagedEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteManagedEndpointInput(id: \(Swift.String(describing: id)), virtualClusterId: \(Swift.String(describing: virtualClusterId)))"}
}

extension DeleteManagedEndpointInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteManagedEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteManagedEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteManagedEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteManagedEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteManagedEndpointOutputError>
}

public struct DeleteManagedEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteManagedEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteManagedEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteManagedEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteManagedEndpointOutputError>
}

public struct DeleteManagedEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteManagedEndpointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteManagedEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let virtualClusterId = input.virtualClusterId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("virtualClusterId is nil and needs a value for the path of this operation"))))
        }
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/endpoints/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteManagedEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteManagedEndpointOutputError>
}

public struct DeleteManagedEndpointInput: Swift.Equatable {
    /// The ID of the managed endpoint.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the endpoint's virtual cluster.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DeleteManagedEndpointInputBody: Swift.Equatable {
}

extension DeleteManagedEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteManagedEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteManagedEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteManagedEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteManagedEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteManagedEndpointOutputResponse(id: \(Swift.String(describing: id)), virtualClusterId: \(Swift.String(describing: virtualClusterId)))"}
}

extension DeleteManagedEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteManagedEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.id = nil
            self.virtualClusterId = nil
        }
    }
}

public struct DeleteManagedEndpointOutputResponse: Swift.Equatable {
    /// The output displays the ID of the managed endpoint.
    public var id: Swift.String?
    /// The output displays the ID of the endpoint's virtual cluster.
    public var virtualClusterId: Swift.String?

    public init (
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DeleteManagedEndpointOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let virtualClusterId: Swift.String?
}

extension DeleteManagedEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case virtualClusterId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

extension DeleteVirtualClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVirtualClusterInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteVirtualClusterInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteVirtualClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVirtualClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVirtualClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVirtualClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVirtualClusterOutputError>
}

public struct DeleteVirtualClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVirtualClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVirtualClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVirtualClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVirtualClusterOutputError>
}

public struct DeleteVirtualClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVirtualClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteVirtualClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/virtualclusters/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVirtualClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVirtualClusterOutputError>
}

public struct DeleteVirtualClusterInput: Swift.Equatable {
    /// The ID of the virtual cluster that will be deleted.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteVirtualClusterInputBody: Swift.Equatable {
}

extension DeleteVirtualClusterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVirtualClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVirtualClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVirtualClusterOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVirtualClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVirtualClusterOutputResponse(id: \(Swift.String(describing: id)))"}
}

extension DeleteVirtualClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteVirtualClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct DeleteVirtualClusterOutputResponse: Swift.Equatable {
    /// This output contains the ID of the virtual cluster that will be deleted.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteVirtualClusterOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
}

extension DeleteVirtualClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeJobRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeJobRunInput(id: \(Swift.String(describing: id)), virtualClusterId: \(Swift.String(describing: virtualClusterId)))"}
}

extension DescribeJobRunInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeJobRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeJobRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeJobRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeJobRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeJobRunOutputError>
}

public struct DescribeJobRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeJobRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeJobRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeJobRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeJobRunOutputError>
}

public struct DescribeJobRunInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeJobRunInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeJobRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let virtualClusterId = input.virtualClusterId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("virtualClusterId is nil and needs a value for the path of this operation"))))
        }
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/jobruns/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeJobRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeJobRunOutputError>
}

public struct DescribeJobRunInput: Swift.Equatable {
    /// The ID of the job run request.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the virtual cluster for which the job run is submitted.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DescribeJobRunInputBody: Swift.Equatable {
}

extension DescribeJobRunInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeJobRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobRunOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeJobRunOutputResponse(jobRun: \(Swift.String(describing: jobRun)))"}
}

extension DescribeJobRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeJobRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobRun = output.jobRun
        } else {
            self.jobRun = nil
        }
    }
}

public struct DescribeJobRunOutputResponse: Swift.Equatable {
    /// The output displays information about a job run.
    public var jobRun: EmrContainersClientTypes.JobRun?

    public init (
        jobRun: EmrContainersClientTypes.JobRun? = nil
    )
    {
        self.jobRun = jobRun
    }
}

struct DescribeJobRunOutputResponseBody: Swift.Equatable {
    public let jobRun: EmrContainersClientTypes.JobRun?
}

extension DescribeJobRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobRun
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.JobRun.self, forKey: .jobRun)
        jobRun = jobRunDecoded
    }
}

extension DescribeManagedEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeManagedEndpointInput(id: \(Swift.String(describing: id)), virtualClusterId: \(Swift.String(describing: virtualClusterId)))"}
}

extension DescribeManagedEndpointInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeManagedEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeManagedEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeManagedEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeManagedEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeManagedEndpointOutputError>
}

public struct DescribeManagedEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeManagedEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeManagedEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeManagedEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeManagedEndpointOutputError>
}

public struct DescribeManagedEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeManagedEndpointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeManagedEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeManagedEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let virtualClusterId = input.virtualClusterId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("virtualClusterId is nil and needs a value for the path of this operation"))))
        }
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/endpoints/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeManagedEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeManagedEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeManagedEndpointOutputError>
}

public struct DescribeManagedEndpointInput: Swift.Equatable {
    /// This output displays ID of the managed endpoint.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the endpoint's virtual cluster.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DescribeManagedEndpointInputBody: Swift.Equatable {
}

extension DescribeManagedEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeManagedEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeManagedEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeManagedEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeManagedEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeManagedEndpointOutputResponse(endpoint: \(Swift.String(describing: endpoint)))"}
}

extension DescribeManagedEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeManagedEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct DescribeManagedEndpointOutputResponse: Swift.Equatable {
    /// This output displays information about a managed endpoint.
    public var endpoint: EmrContainersClientTypes.Endpoint?

    public init (
        endpoint: EmrContainersClientTypes.Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct DescribeManagedEndpointOutputResponseBody: Swift.Equatable {
    public let endpoint: EmrContainersClientTypes.Endpoint?
}

extension DescribeManagedEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension DescribeVirtualClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeVirtualClusterInput(id: \(Swift.String(describing: id)))"}
}

extension DescribeVirtualClusterInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeVirtualClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVirtualClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeVirtualClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeVirtualClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVirtualClusterOutputError>
}

public struct DescribeVirtualClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVirtualClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeVirtualClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeVirtualClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVirtualClusterOutputError>
}

public struct DescribeVirtualClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeVirtualClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeVirtualClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVirtualClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/virtualclusters/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeVirtualClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeVirtualClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeVirtualClusterOutputError>
}

public struct DescribeVirtualClusterInput: Swift.Equatable {
    /// The ID of the virtual cluster that will be described.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeVirtualClusterInputBody: Swift.Equatable {
}

extension DescribeVirtualClusterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVirtualClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVirtualClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVirtualClusterOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVirtualClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeVirtualClusterOutputResponse(virtualCluster: \(Swift.String(describing: virtualCluster)))"}
}

extension DescribeVirtualClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeVirtualClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.virtualCluster = output.virtualCluster
        } else {
            self.virtualCluster = nil
        }
    }
}

public struct DescribeVirtualClusterOutputResponse: Swift.Equatable {
    /// This output displays information about the specified virtual cluster.
    public var virtualCluster: EmrContainersClientTypes.VirtualCluster?

    public init (
        virtualCluster: EmrContainersClientTypes.VirtualCluster? = nil
    )
    {
        self.virtualCluster = virtualCluster
    }
}

struct DescribeVirtualClusterOutputResponseBody: Swift.Equatable {
    public let virtualCluster: EmrContainersClientTypes.VirtualCluster?
}

extension DescribeVirtualClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualCluster
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualClusterDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.VirtualCluster.self, forKey: .virtualCluster)
        virtualCluster = virtualClusterDecoded
    }
}

extension EmrContainersClientTypes.EksInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension EmrContainersClientTypes.EksInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EksInfo(namespace: \(Swift.String(describing: namespace)))"}
}

extension EmrContainersClientTypes {
    /// The information about the EKS cluster.
    public struct EksInfo: Swift.Equatable {
        /// The namespaces of the EKS cluster.
        public var namespace: Swift.String?

        public init (
            namespace: Swift.String? = nil
        )
        {
            self.namespace = namespace
        }
    }

}

extension EmrContainersClientTypes.Endpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case certificateArn
        case configurationOverrides
        case createdAt
        case executionRoleArn
        case failureReason
        case id
        case name
        case releaseLabel
        case securityGroup
        case serverUrl
        case state
        case stateDetails
        case subnetIds
        case tags
        case type
        case virtualClusterId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let configurationOverrides = configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason.rawValue, forKey: .failureReason)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let securityGroup = securityGroup {
            try encodeContainer.encode(securityGroup, forKey: .securityGroup)
        }
        if let serverUrl = serverUrl {
            try encodeContainer.encode(serverUrl, forKey: .serverUrl)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateDetails = stateDetails {
            try encodeContainer.encode(stateDetails, forKey: .stateDetails)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let virtualClusterId = virtualClusterId {
            try encodeContainer.encode(virtualClusterId, forKey: .virtualClusterId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.EndpointState.self, forKey: .state)
        state = stateDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let serverUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverUrl)
        serverUrl = serverUrlDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let securityGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroup)
        securityGroup = securityGroupDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let stateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateDetails)
        stateDetails = stateDetailsDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.FailureReason.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EmrContainersClientTypes.Endpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Endpoint(arn: \(Swift.String(describing: arn)), certificateArn: \(Swift.String(describing: certificateArn)), configurationOverrides: \(Swift.String(describing: configurationOverrides)), createdAt: \(Swift.String(describing: createdAt)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), failureReason: \(Swift.String(describing: failureReason)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), releaseLabel: \(Swift.String(describing: releaseLabel)), securityGroup: \(Swift.String(describing: securityGroup)), serverUrl: \(Swift.String(describing: serverUrl)), state: \(Swift.String(describing: state)), stateDetails: \(Swift.String(describing: stateDetails)), subnetIds: \(Swift.String(describing: subnetIds)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), virtualClusterId: \(Swift.String(describing: virtualClusterId)))"}
}

extension EmrContainersClientTypes {
    /// This entity represents the endpoint that is managed by Amazon EMR on EKS.
    public struct Endpoint: Swift.Equatable {
        /// The ARN of the endpoint.
        public var arn: Swift.String?
        /// The certificate ARN of the endpoint.
        public var certificateArn: Swift.String?
        /// The configuration settings that are used to override existing configurations for endpoints.
        public var configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides?
        /// The date and time when the endpoint was created.
        public var createdAt: ClientRuntime.Date?
        /// The execution role ARN of the endpoint.
        public var executionRoleArn: Swift.String?
        ///
        ///          The reasons why the endpoint has failed.
        ///
        public var failureReason: EmrContainersClientTypes.FailureReason?
        /// The ID of the endpoint.
        public var id: Swift.String?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The EMR release version to be used for the endpoint.
        public var releaseLabel: Swift.String?
        /// The security group configuration of the endpoint.
        ///
        public var securityGroup: Swift.String?
        /// The server URL of the endpoint.
        public var serverUrl: Swift.String?
        /// The state of the endpoint.
        public var state: EmrContainersClientTypes.EndpointState?
        ///
        ///          Additional details of the endpoint state.
        ///
        public var stateDetails: Swift.String?
        /// The subnet IDs of the endpoint.
        ///
        public var subnetIds: [Swift.String]?
        /// The tags of the endpoint.
        ///
        public var tags: [Swift.String:Swift.String]?
        /// The type of the endpoint.
        public var type: Swift.String?
        /// The ID of the endpoint's virtual cluster.
        public var virtualClusterId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            certificateArn: Swift.String? = nil,
            configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides? = nil,
            createdAt: ClientRuntime.Date? = nil,
            executionRoleArn: Swift.String? = nil,
            failureReason: EmrContainersClientTypes.FailureReason? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            releaseLabel: Swift.String? = nil,
            securityGroup: Swift.String? = nil,
            serverUrl: Swift.String? = nil,
            state: EmrContainersClientTypes.EndpointState? = nil,
            stateDetails: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: Swift.String? = nil,
            virtualClusterId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.certificateArn = certificateArn
            self.configurationOverrides = configurationOverrides
            self.createdAt = createdAt
            self.executionRoleArn = executionRoleArn
            self.failureReason = failureReason
            self.id = id
            self.name = name
            self.releaseLabel = releaseLabel
            self.securityGroup = securityGroup
            self.serverUrl = serverUrl
            self.state = state
            self.stateDetails = stateDetails
            self.subnetIds = subnetIds
            self.tags = tags
            self.type = type
            self.virtualClusterId = virtualClusterId
        }
    }

}

extension EmrContainersClientTypes {
    public enum EndpointState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case terminated
        case terminatedWithErrors
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointState] {
            return [
                .active,
                .creating,
                .terminated,
                .terminatedWithErrors,
                .terminating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .terminated: return "TERMINATED"
            case .terminatedWithErrors: return "TERMINATED_WITH_ERRORS"
            case .terminating: return "TERMINATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointState(rawValue: rawValue) ?? EndpointState.sdkUnknown(rawValue)
        }
    }
}

extension EmrContainersClientTypes {
    public enum FailureReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clusterUnavailable
        case internalError
        case userError
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureReason] {
            return [
                .clusterUnavailable,
                .internalError,
                .userError,
                .validationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clusterUnavailable: return "CLUSTER_UNAVAILABLE"
            case .internalError: return "INTERNAL_ERROR"
            case .userError: return "USER_ERROR"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailureReason(rawValue: rawValue) ?? FailureReason.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This is an internal server exception.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EmrContainersClientTypes.JobDriver: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sparkSubmitJobDriver
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sparkSubmitJobDriver = sparkSubmitJobDriver {
            try encodeContainer.encode(sparkSubmitJobDriver, forKey: .sparkSubmitJobDriver)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sparkSubmitJobDriverDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.SparkSubmitJobDriver.self, forKey: .sparkSubmitJobDriver)
        sparkSubmitJobDriver = sparkSubmitJobDriverDecoded
    }
}

extension EmrContainersClientTypes.JobDriver: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobDriver(sparkSubmitJobDriver: \(Swift.String(describing: sparkSubmitJobDriver)))"}
}

extension EmrContainersClientTypes {
    /// Specify the driver that the job runs on.
    public struct JobDriver: Swift.Equatable {
        /// The job driver parameters specified for spark submit.
        public var sparkSubmitJobDriver: EmrContainersClientTypes.SparkSubmitJobDriver?

        public init (
            sparkSubmitJobDriver: EmrContainersClientTypes.SparkSubmitJobDriver? = nil
        )
        {
            self.sparkSubmitJobDriver = sparkSubmitJobDriver
        }
    }

}

extension EmrContainersClientTypes.JobRun: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientToken
        case configurationOverrides
        case createdAt
        case createdBy
        case executionRoleArn
        case failureReason
        case finishedAt
        case id
        case jobDriver
        case name
        case releaseLabel
        case state
        case stateDetails
        case tags
        case virtualClusterId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationOverrides = configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason.rawValue, forKey: .failureReason)
        }
        if let finishedAt = finishedAt {
            try encodeContainer.encode(finishedAt.timeIntervalSince1970, forKey: .finishedAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let jobDriver = jobDriver {
            try encodeContainer.encode(jobDriver, forKey: .jobDriver)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateDetails = stateDetails {
            try encodeContainer.encode(stateDetails, forKey: .stateDetails)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let virtualClusterId = virtualClusterId {
            try encodeContainer.encode(virtualClusterId, forKey: .virtualClusterId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.JobRunState.self, forKey: .state)
        state = stateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let jobDriverDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.JobDriver.self, forKey: .jobDriver)
        jobDriver = jobDriverDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let finishedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .finishedAt)
        finishedAt = finishedAtDecoded
        let stateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateDetails)
        stateDetails = stateDetailsDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.FailureReason.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EmrContainersClientTypes.JobRun: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobRun(arn: \(Swift.String(describing: arn)), clientToken: \(Swift.String(describing: clientToken)), configurationOverrides: \(Swift.String(describing: configurationOverrides)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), failureReason: \(Swift.String(describing: failureReason)), finishedAt: \(Swift.String(describing: finishedAt)), id: \(Swift.String(describing: id)), jobDriver: \(Swift.String(describing: jobDriver)), name: \(Swift.String(describing: name)), releaseLabel: \(Swift.String(describing: releaseLabel)), state: \(Swift.String(describing: state)), stateDetails: \(Swift.String(describing: stateDetails)), tags: \(Swift.String(describing: tags)), virtualClusterId: \(Swift.String(describing: virtualClusterId)))"}
}

extension EmrContainersClientTypes {
    /// This entity describes a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
    public struct JobRun: Swift.Equatable {
        /// The ARN of job run.
        public var arn: Swift.String?
        /// The client token used to start a job run.
        public var clientToken: Swift.String?
        /// The configuration settings that are used to override default configuration.
        public var configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides?
        /// The date and time when the job run was created.
        public var createdAt: ClientRuntime.Date?
        /// The user who created the job run.
        public var createdBy: Swift.String?
        /// The execution role ARN of the job run.
        public var executionRoleArn: Swift.String?
        /// The reasons why the job run has failed.
        public var failureReason: EmrContainersClientTypes.FailureReason?
        /// The date and time when the job run has finished.
        public var finishedAt: ClientRuntime.Date?
        /// The ID of the job run.
        public var id: Swift.String?
        /// Parameters of job driver for the job run.
        public var jobDriver: EmrContainersClientTypes.JobDriver?
        /// The name of the job run.
        public var name: Swift.String?
        /// The release version of Amazon EMR.
        public var releaseLabel: Swift.String?
        /// The state of the job run.
        public var state: EmrContainersClientTypes.JobRunState?
        /// Additional details of the job run state.
        public var stateDetails: Swift.String?
        /// The assigned tags of the job run.
        public var tags: [Swift.String:Swift.String]?
        /// The ID of the job run's virtual cluster.
        public var virtualClusterId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            executionRoleArn: Swift.String? = nil,
            failureReason: EmrContainersClientTypes.FailureReason? = nil,
            finishedAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            jobDriver: EmrContainersClientTypes.JobDriver? = nil,
            name: Swift.String? = nil,
            releaseLabel: Swift.String? = nil,
            state: EmrContainersClientTypes.JobRunState? = nil,
            stateDetails: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            virtualClusterId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.clientToken = clientToken
            self.configurationOverrides = configurationOverrides
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.executionRoleArn = executionRoleArn
            self.failureReason = failureReason
            self.finishedAt = finishedAt
            self.id = id
            self.jobDriver = jobDriver
            self.name = name
            self.releaseLabel = releaseLabel
            self.state = state
            self.stateDetails = stateDetails
            self.tags = tags
            self.virtualClusterId = virtualClusterId
        }
    }

}

extension EmrContainersClientTypes {
    public enum JobRunState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelPending
        case completed
        case failed
        case pending
        case running
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobRunState] {
            return [
                .cancelled,
                .cancelPending,
                .completed,
                .failed,
                .pending,
                .running,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelPending: return "CANCEL_PENDING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobRunState(rawValue: rawValue) ?? JobRunState.sdkUnknown(rawValue)
        }
    }
}

extension ListJobRunsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListJobRunsInput(createdAfter: \(Swift.String(describing: createdAfter)), createdBefore: \(Swift.String(describing: createdBefore)), maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), states: \(Swift.String(describing: states)), virtualClusterId: \(Swift.String(describing: virtualClusterId)))"}
}

extension ListJobRunsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListJobRunsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobRunsOutputError>
}

public struct ListJobRunsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let name = input.operationInput.name {
            let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            input.builder.withQueryItem(nameQueryItem)
        }
        if let createdBefore = input.operationInput.createdBefore {
            let createdBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(createdBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(createdBeforeQueryItem)
        }
        if let createdAfter = input.operationInput.createdAfter {
            let createdAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(createdAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(createdAfterQueryItem)
        }
        if let states = input.operationInput.states {
            states.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobRunsOutputError>
}

public struct ListJobRunsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobRunsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListJobRunsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let virtualClusterId = input.virtualClusterId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("virtualClusterId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/jobruns"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListJobRunsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobRunsOutputError>
}

public struct ListJobRunsInput: Swift.Equatable {
    /// The date and time after which the job runs were submitted.
    public var createdAfter: ClientRuntime.Date?
    /// The date and time before which the job runs were submitted.
    public var createdBefore: ClientRuntime.Date?
    /// The maximum number of job runs that can be listed.
    public var maxResults: Swift.Int?
    /// The name of the job run.
    public var name: Swift.String?
    /// The token for the next set of job runs to return.
    public var nextToken: Swift.String?
    /// The states of the job run.
    public var states: [EmrContainersClientTypes.JobRunState]?
    /// The ID of the virtual cluster for which to list the job run.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        createdAfter: ClientRuntime.Date? = nil,
        createdBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        states: [EmrContainersClientTypes.JobRunState]? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.states = states
        self.virtualClusterId = virtualClusterId
    }
}

struct ListJobRunsInputBody: Swift.Equatable {
}

extension ListJobRunsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListJobRunsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobRunsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobRunsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobRunsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListJobRunsOutputResponse(jobRuns: \(Swift.String(describing: jobRuns)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListJobRunsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListJobRunsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobRuns = output.jobRuns
            self.nextToken = output.nextToken
        } else {
            self.jobRuns = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobRunsOutputResponse: Swift.Equatable {
    /// This output lists information about the specified job runs.
    public var jobRuns: [EmrContainersClientTypes.JobRun]?
    /// This output displays the token for the next set of job runs.
    public var nextToken: Swift.String?

    public init (
        jobRuns: [EmrContainersClientTypes.JobRun]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobRuns = jobRuns
        self.nextToken = nextToken
    }
}

struct ListJobRunsOutputResponseBody: Swift.Equatable {
    public let jobRuns: [EmrContainersClientTypes.JobRun]?
    public let nextToken: Swift.String?
}

extension ListJobRunsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobRuns
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunsContainer = try containerValues.decodeIfPresent([EmrContainersClientTypes.JobRun?].self, forKey: .jobRuns)
        var jobRunsDecoded0:[EmrContainersClientTypes.JobRun]? = nil
        if let jobRunsContainer = jobRunsContainer {
            jobRunsDecoded0 = [EmrContainersClientTypes.JobRun]()
            for structure0 in jobRunsContainer {
                if let structure0 = structure0 {
                    jobRunsDecoded0?.append(structure0)
                }
            }
        }
        jobRuns = jobRunsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListManagedEndpointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListManagedEndpointsInput(createdAfter: \(Swift.String(describing: createdAfter)), createdBefore: \(Swift.String(describing: createdBefore)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), states: \(Swift.String(describing: states)), types: \(Swift.String(describing: types)), virtualClusterId: \(Swift.String(describing: virtualClusterId)))"}
}

extension ListManagedEndpointsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListManagedEndpointsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListManagedEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListManagedEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListManagedEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListManagedEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListManagedEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListManagedEndpointsOutputError>
}

public struct ListManagedEndpointsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListManagedEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListManagedEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListManagedEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let types = input.operationInput.types {
            types.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "types".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let createdBefore = input.operationInput.createdBefore {
            let createdBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(createdBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(createdBeforeQueryItem)
        }
        if let createdAfter = input.operationInput.createdAfter {
            let createdAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(createdAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(createdAfterQueryItem)
        }
        if let states = input.operationInput.states {
            states.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListManagedEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListManagedEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListManagedEndpointsOutputError>
}

public struct ListManagedEndpointsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListManagedEndpointsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListManagedEndpointsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListManagedEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let virtualClusterId = input.virtualClusterId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("virtualClusterId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/endpoints"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListManagedEndpointsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListManagedEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListManagedEndpointsOutputError>
}

public struct ListManagedEndpointsInput: Swift.Equatable {
    ///  The date and time after which the endpoints are created.
    public var createdAfter: ClientRuntime.Date?
    /// The date and time before which the endpoints are created.
    public var createdBefore: ClientRuntime.Date?
    /// The maximum number of managed endpoints that can be listed.
    public var maxResults: Swift.Int?
    ///  The token for the next set of managed endpoints to return.
    public var nextToken: Swift.String?
    /// The states of the managed endpoints.
    public var states: [EmrContainersClientTypes.EndpointState]?
    /// The types of the managed endpoints.
    public var types: [Swift.String]?
    /// The ID of the virtual cluster.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        createdAfter: ClientRuntime.Date? = nil,
        createdBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        states: [EmrContainersClientTypes.EndpointState]? = nil,
        types: [Swift.String]? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
        self.types = types
        self.virtualClusterId = virtualClusterId
    }
}

struct ListManagedEndpointsInputBody: Swift.Equatable {
}

extension ListManagedEndpointsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListManagedEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListManagedEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListManagedEndpointsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListManagedEndpointsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListManagedEndpointsOutputResponse(endpoints: \(Swift.String(describing: endpoints)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListManagedEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListManagedEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
            self.nextToken = output.nextToken
        } else {
            self.endpoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListManagedEndpointsOutputResponse: Swift.Equatable {
    /// The managed endpoints to be listed.
    public var endpoints: [EmrContainersClientTypes.Endpoint]?
    ///  The token for the next set of endpoints to return.
    public var nextToken: Swift.String?

    public init (
        endpoints: [EmrContainersClientTypes.Endpoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

struct ListManagedEndpointsOutputResponseBody: Swift.Equatable {
    public let endpoints: [EmrContainersClientTypes.Endpoint]?
    public let nextToken: Swift.String?
}

extension ListManagedEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([EmrContainersClientTypes.Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[EmrContainersClientTypes.Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [EmrContainersClientTypes.Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of tagged resources.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags assigned to resources.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVirtualClustersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVirtualClustersInput(containerProviderId: \(Swift.String(describing: containerProviderId)), containerProviderType: \(Swift.String(describing: containerProviderType)), createdAfter: \(Swift.String(describing: createdAfter)), createdBefore: \(Swift.String(describing: createdBefore)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), states: \(Swift.String(describing: states)))"}
}

extension ListVirtualClustersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListVirtualClustersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVirtualClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVirtualClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVirtualClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVirtualClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVirtualClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVirtualClustersOutputError>
}

public struct ListVirtualClustersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVirtualClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVirtualClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVirtualClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let containerProviderId = input.operationInput.containerProviderId {
            let containerProviderIdQueryItem = ClientRuntime.URLQueryItem(name: "containerProviderId".urlPercentEncoding(), value: Swift.String(containerProviderId).urlPercentEncoding())
            input.builder.withQueryItem(containerProviderIdQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let containerProviderType = input.operationInput.containerProviderType {
            let containerProviderTypeQueryItem = ClientRuntime.URLQueryItem(name: "containerProviderType".urlPercentEncoding(), value: Swift.String(containerProviderType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(containerProviderTypeQueryItem)
        }
        if let createdBefore = input.operationInput.createdBefore {
            let createdBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(createdBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(createdBeforeQueryItem)
        }
        if let createdAfter = input.operationInput.createdAfter {
            let createdAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(createdAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(createdAfterQueryItem)
        }
        if let states = input.operationInput.states {
            states.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVirtualClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVirtualClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVirtualClustersOutputError>
}

public struct ListVirtualClustersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVirtualClustersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListVirtualClustersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVirtualClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/virtualclusters"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVirtualClustersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVirtualClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVirtualClustersOutputError>
}

public struct ListVirtualClustersInput: Swift.Equatable {
    /// The container provider ID of the virtual cluster.
    public var containerProviderId: Swift.String?
    /// The container provider type of the virtual cluster. EKS is the only supported type as of now.
    public var containerProviderType: EmrContainersClientTypes.ContainerProviderType?
    /// The date and time after which the virtual clusters are created.
    public var createdAfter: ClientRuntime.Date?
    /// The date and time before which the virtual clusters are created.
    public var createdBefore: ClientRuntime.Date?
    /// The maximum number of virtual clusters that can be listed.
    public var maxResults: Swift.Int?
    /// The token for the next set of virtual clusters to return.
    public var nextToken: Swift.String?
    /// The states of the requested virtual clusters.
    public var states: [EmrContainersClientTypes.VirtualClusterState]?

    public init (
        containerProviderId: Swift.String? = nil,
        containerProviderType: EmrContainersClientTypes.ContainerProviderType? = nil,
        createdAfter: ClientRuntime.Date? = nil,
        createdBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        states: [EmrContainersClientTypes.VirtualClusterState]? = nil
    )
    {
        self.containerProviderId = containerProviderId
        self.containerProviderType = containerProviderType
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
    }
}

struct ListVirtualClustersInputBody: Swift.Equatable {
}

extension ListVirtualClustersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVirtualClustersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVirtualClustersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVirtualClustersOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualClustersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVirtualClustersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), virtualClusters: \(Swift.String(describing: virtualClusters)))"}
}

extension ListVirtualClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListVirtualClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.virtualClusters = output.virtualClusters
        } else {
            self.nextToken = nil
            self.virtualClusters = nil
        }
    }
}

public struct ListVirtualClustersOutputResponse: Swift.Equatable {
    /// This output displays the token for the next set of virtual clusters.
    public var nextToken: Swift.String?
    /// This output lists the specified virtual clusters.
    public var virtualClusters: [EmrContainersClientTypes.VirtualCluster]?

    public init (
        nextToken: Swift.String? = nil,
        virtualClusters: [EmrContainersClientTypes.VirtualCluster]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualClusters = virtualClusters
    }
}

struct ListVirtualClustersOutputResponseBody: Swift.Equatable {
    public let virtualClusters: [EmrContainersClientTypes.VirtualCluster]?
    public let nextToken: Swift.String?
}

extension ListVirtualClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case virtualClusters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualClustersContainer = try containerValues.decodeIfPresent([EmrContainersClientTypes.VirtualCluster?].self, forKey: .virtualClusters)
        var virtualClustersDecoded0:[EmrContainersClientTypes.VirtualCluster]? = nil
        if let virtualClustersContainer = virtualClustersContainer {
            virtualClustersDecoded0 = [EmrContainersClientTypes.VirtualCluster]()
            for structure0 in virtualClustersContainer {
                if let structure0 = structure0 {
                    virtualClustersDecoded0?.append(structure0)
                }
            }
        }
        virtualClusters = virtualClustersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension EmrContainersClientTypes.MonitoringConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchMonitoringConfiguration
        case persistentAppUI
        case s3MonitoringConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchMonitoringConfiguration = cloudWatchMonitoringConfiguration {
            try encodeContainer.encode(cloudWatchMonitoringConfiguration, forKey: .cloudWatchMonitoringConfiguration)
        }
        if let persistentAppUI = persistentAppUI {
            try encodeContainer.encode(persistentAppUI.rawValue, forKey: .persistentAppUI)
        }
        if let s3MonitoringConfiguration = s3MonitoringConfiguration {
            try encodeContainer.encode(s3MonitoringConfiguration, forKey: .s3MonitoringConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let persistentAppUIDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.PersistentAppUI.self, forKey: .persistentAppUI)
        persistentAppUI = persistentAppUIDecoded
        let cloudWatchMonitoringConfigurationDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.CloudWatchMonitoringConfiguration.self, forKey: .cloudWatchMonitoringConfiguration)
        cloudWatchMonitoringConfiguration = cloudWatchMonitoringConfigurationDecoded
        let s3MonitoringConfigurationDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.S3MonitoringConfiguration.self, forKey: .s3MonitoringConfiguration)
        s3MonitoringConfiguration = s3MonitoringConfigurationDecoded
    }
}

extension EmrContainersClientTypes.MonitoringConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MonitoringConfiguration(cloudWatchMonitoringConfiguration: \(Swift.String(describing: cloudWatchMonitoringConfiguration)), persistentAppUI: \(Swift.String(describing: persistentAppUI)), s3MonitoringConfiguration: \(Swift.String(describing: s3MonitoringConfiguration)))"}
}

extension EmrContainersClientTypes {
    /// Configuration setting for monitoring.
    public struct MonitoringConfiguration: Swift.Equatable {
        /// Monitoring configurations for CloudWatch.
        public var cloudWatchMonitoringConfiguration: EmrContainersClientTypes.CloudWatchMonitoringConfiguration?
        /// Monitoring configurations for the persistent application UI.
        public var persistentAppUI: EmrContainersClientTypes.PersistentAppUI?
        /// Amazon S3 configuration for monitoring log publishing.
        public var s3MonitoringConfiguration: EmrContainersClientTypes.S3MonitoringConfiguration?

        public init (
            cloudWatchMonitoringConfiguration: EmrContainersClientTypes.CloudWatchMonitoringConfiguration? = nil,
            persistentAppUI: EmrContainersClientTypes.PersistentAppUI? = nil,
            s3MonitoringConfiguration: EmrContainersClientTypes.S3MonitoringConfiguration? = nil
        )
        {
            self.cloudWatchMonitoringConfiguration = cloudWatchMonitoringConfiguration
            self.persistentAppUI = persistentAppUI
            self.s3MonitoringConfiguration = s3MonitoringConfiguration
        }
    }

}

extension EmrContainersClientTypes {
    public enum PersistentAppUI: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PersistentAppUI] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PersistentAppUI(rawValue: rawValue) ?? PersistentAppUI.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EmrContainersClientTypes.S3MonitoringConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logUri = logUri {
            try encodeContainer.encode(logUri, forKey: .logUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logUri)
        logUri = logUriDecoded
    }
}

extension EmrContainersClientTypes.S3MonitoringConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3MonitoringConfiguration(logUri: \(Swift.String(describing: logUri)))"}
}

extension EmrContainersClientTypes {
    ///  Amazon S3 configuration for monitoring log publishing. You can configure your jobs to send log information to Amazon S3.
    public struct S3MonitoringConfiguration: Swift.Equatable {
        /// Amazon S3 destination URI for log publishing.
        /// This member is required.
        public var logUri: Swift.String?

        public init (
            logUri: Swift.String? = nil
        )
        {
            self.logUri = logUri
        }
    }

}

extension EmrContainersClientTypes.SparkSubmitJobDriver: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryPoint
        case entryPointArguments
        case sparkSubmitParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryPoint = entryPoint {
            try encodeContainer.encode(entryPoint, forKey: .entryPoint)
        }
        if let entryPointArguments = entryPointArguments {
            var entryPointArgumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entryPointArguments)
            for entrypointarguments0 in entryPointArguments {
                try entryPointArgumentsContainer.encode(entrypointarguments0)
            }
        }
        if let sparkSubmitParameters = sparkSubmitParameters {
            try encodeContainer.encode(sparkSubmitParameters, forKey: .sparkSubmitParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryPoint)
        entryPoint = entryPointDecoded
        let entryPointArgumentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entryPointArguments)
        var entryPointArgumentsDecoded0:[Swift.String]? = nil
        if let entryPointArgumentsContainer = entryPointArgumentsContainer {
            entryPointArgumentsDecoded0 = [Swift.String]()
            for string0 in entryPointArgumentsContainer {
                if let string0 = string0 {
                    entryPointArgumentsDecoded0?.append(string0)
                }
            }
        }
        entryPointArguments = entryPointArgumentsDecoded0
        let sparkSubmitParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sparkSubmitParameters)
        sparkSubmitParameters = sparkSubmitParametersDecoded
    }
}

extension EmrContainersClientTypes.SparkSubmitJobDriver: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SparkSubmitJobDriver(entryPoint: \(Swift.String(describing: entryPoint)), entryPointArguments: \(Swift.String(describing: entryPointArguments)), sparkSubmitParameters: \(Swift.String(describing: sparkSubmitParameters)))"}
}

extension EmrContainersClientTypes {
    /// The information about job driver for Spark submit.
    public struct SparkSubmitJobDriver: Swift.Equatable {
        /// The entry point of job application.
        /// This member is required.
        public var entryPoint: Swift.String?
        /// The arguments for job application.
        public var entryPointArguments: [Swift.String]?
        /// The Spark submit parameters that are used for job runs.
        public var sparkSubmitParameters: Swift.String?

        public init (
            entryPoint: Swift.String? = nil,
            entryPointArguments: [Swift.String]? = nil,
            sparkSubmitParameters: Swift.String? = nil
        )
        {
            self.entryPoint = entryPoint
            self.entryPointArguments = entryPointArguments
            self.sparkSubmitParameters = sparkSubmitParameters
        }
    }

}

public struct StartJobRunInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartJobRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartJobRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartJobRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartJobRunOutputError>
}

extension StartJobRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartJobRunInput(clientToken: \(Swift.String(describing: clientToken)), configurationOverrides: \(Swift.String(describing: configurationOverrides)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), jobDriver: \(Swift.String(describing: jobDriver)), name: \(Swift.String(describing: name)), releaseLabel: \(Swift.String(describing: releaseLabel)), tags: \(Swift.String(describing: tags)), virtualClusterId: \(Swift.String(describing: virtualClusterId)))"}
}

extension StartJobRunInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case jobDriver
        case name
        case releaseLabel
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationOverrides = configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let jobDriver = jobDriver {
            try encodeContainer.encode(jobDriver, forKey: .jobDriver)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StartJobRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartJobRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartJobRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartJobRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartJobRunOutputError>
}

public struct StartJobRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartJobRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartJobRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartJobRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartJobRunOutputError>
}

public struct StartJobRunInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartJobRunInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartJobRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let virtualClusterId = input.virtualClusterId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("virtualClusterId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/jobruns"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartJobRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartJobRunOutputError>
}

public struct StartJobRunInput: Swift.Equatable {
    /// The client idempotency token of the job run request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The configuration overrides for the job run.
    public var configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides?
    /// The execution role ARN for the job run.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The job driver for the job run.
    /// This member is required.
    public var jobDriver: EmrContainersClientTypes.JobDriver?
    /// The name of the job run.
    public var name: Swift.String?
    /// The Amazon EMR release version to use for the job run.
    /// This member is required.
    public var releaseLabel: Swift.String?
    /// The tags assigned to job runs.
    public var tags: [Swift.String:Swift.String]?
    /// The virtual cluster ID for which the job run request is submitted.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides? = nil,
        executionRoleArn: Swift.String? = nil,
        jobDriver: EmrContainersClientTypes.JobDriver? = nil,
        name: Swift.String? = nil,
        releaseLabel: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.configurationOverrides = configurationOverrides
        self.executionRoleArn = executionRoleArn
        self.jobDriver = jobDriver
        self.name = name
        self.releaseLabel = releaseLabel
        self.tags = tags
        self.virtualClusterId = virtualClusterId
    }
}

struct StartJobRunInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let clientToken: Swift.String?
    public let executionRoleArn: Swift.String?
    public let releaseLabel: Swift.String?
    public let jobDriver: EmrContainersClientTypes.JobDriver?
    public let configurationOverrides: EmrContainersClientTypes.ConfigurationOverrides?
    public let tags: [Swift.String:Swift.String]?
}

extension StartJobRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case jobDriver
        case name
        case releaseLabel
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let jobDriverDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.JobDriver.self, forKey: .jobDriver)
        jobDriver = jobDriverDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartJobRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartJobRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartJobRunOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartJobRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartJobRunOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), virtualClusterId: \(Swift.String(describing: virtualClusterId)))"}
}

extension StartJobRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartJobRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
            self.virtualClusterId = nil
        }
    }
}

public struct StartJobRunOutputResponse: Swift.Equatable {
    /// This output lists the ARN of job run.
    public var arn: Swift.String?
    /// This output displays the started job run ID.
    public var id: Swift.String?
    /// This output displays the name of the started job run.
    public var name: Swift.String?
    /// This output displays the virtual cluster ID for which the job run was submitted.
    public var virtualClusterId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.virtualClusterId = virtualClusterId
    }
}

struct StartJobRunOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let name: Swift.String?
    public let arn: Swift.String?
    public let virtualClusterId: Swift.String?
}

extension StartJobRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case name
        case virtualClusterId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of resources.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags assigned to resources.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of resources.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the resources.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are invalid parameters in the client request.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EmrContainersClientTypes.VirtualCluster: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case containerProvider
        case createdAt
        case id
        case name
        case state
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containerProvider = containerProvider {
            try encodeContainer.encode(containerProvider, forKey: .containerProvider)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.VirtualClusterState.self, forKey: .state)
        state = stateDecoded
        let containerProviderDecoded = try containerValues.decodeIfPresent(EmrContainersClientTypes.ContainerProvider.self, forKey: .containerProvider)
        containerProvider = containerProviderDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EmrContainersClientTypes.VirtualCluster: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VirtualCluster(arn: \(Swift.String(describing: arn)), containerProvider: \(Swift.String(describing: containerProvider)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension EmrContainersClientTypes {
    /// This entity describes a virtual cluster. A virtual cluster is a Kubernetes namespace that Amazon EMR is registered with. Amazon EMR uses virtual clusters to run jobs and host endpoints. Multiple virtual clusters can be backed by the same physical cluster. However, each virtual cluster maps to one namespace on an EKS cluster. Virtual clusters do not create any active resources that contribute to your bill or that require lifecycle management outside the service.
    public struct VirtualCluster: Swift.Equatable {
        /// The ARN of the virtual cluster.
        public var arn: Swift.String?
        /// The container provider of the virtual cluster.
        public var containerProvider: EmrContainersClientTypes.ContainerProvider?
        /// The date and time when the virtual cluster is created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the virtual cluster.
        public var id: Swift.String?
        /// The name of the virtual cluster.
        public var name: Swift.String?
        /// The state of the virtual cluster.
        public var state: EmrContainersClientTypes.VirtualClusterState?
        /// The assigned tags of the virtual cluster.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            containerProvider: EmrContainersClientTypes.ContainerProvider? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: EmrContainersClientTypes.VirtualClusterState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.containerProvider = containerProvider
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension EmrContainersClientTypes {
    public enum VirtualClusterState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arrested
        case running
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualClusterState] {
            return [
                .arrested,
                .running,
                .terminated,
                .terminating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arrested: return "ARRESTED"
            case .running: return "RUNNING"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VirtualClusterState(rawValue: rawValue) ?? VirtualClusterState.sdkUnknown(rawValue)
        }
    }
}
