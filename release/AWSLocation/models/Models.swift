// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied because of insufficient access or permissions. Check with an
///       administrator to verify your permissions.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AssociateTrackerConsumerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTrackerConsumerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTrackerConsumerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTrackerConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTrackerConsumerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTrackerConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTrackerConsumerOutputError>
}

extension AssociateTrackerConsumerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateTrackerConsumerInput(consumerArn: \(Swift.String(describing: consumerArn)), trackerName: \(Swift.String(describing: trackerName)))"}
}

extension AssociateTrackerConsumerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerArn = "ConsumerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerArn = consumerArn {
            try encodeContainer.encode(consumerArn, forKey: .consumerArn)
        }
    }
}

public struct AssociateTrackerConsumerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTrackerConsumerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTrackerConsumerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTrackerConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTrackerConsumerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTrackerConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTrackerConsumerOutputError>
}

public struct AssociateTrackerConsumerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTrackerConsumerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTrackerConsumerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTrackerConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTrackerConsumerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTrackerConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTrackerConsumerOutputError>
}

public struct AssociateTrackerConsumerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTrackerConsumerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateTrackerConsumerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTrackerConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "tracking.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateTrackerConsumerInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTrackerConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTrackerConsumerOutputError>
}

public struct AssociateTrackerConsumerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTrackerConsumerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateTrackerConsumerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTrackerConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trackerName = input.trackerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trackerName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/consumers"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateTrackerConsumerInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTrackerConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTrackerConsumerOutputError>
}

public struct AssociateTrackerConsumerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the geofence collection to be associated to tracker
    ///             resource. Used when you need to specify a resource across all AWS.
    ///
    ///
    ///                Format example:
    ///                         arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
    ///
    ///
    ///
    /// This member is required.
    public var consumerArn: Swift.String?
    /// The name of the tracker resource to be associated with a geofence collection.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        consumerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.consumerArn = consumerArn
        self.trackerName = trackerName
    }
}

struct AssociateTrackerConsumerInputBody: Swift.Equatable {
    public let consumerArn: Swift.String?
}

extension AssociateTrackerConsumerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerArn = "ConsumerArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumerArn)
        consumerArn = consumerArnDecoded
    }
}

extension AssociateTrackerConsumerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateTrackerConsumerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateTrackerConsumerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateTrackerConsumerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateTrackerConsumerOutputResponse()"}
}

extension AssociateTrackerConsumerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateTrackerConsumerOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateTrackerConsumerOutputResponseBody: Swift.Equatable {
}

extension AssociateTrackerConsumerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension LocationClientTypes.BatchDeleteDevicePositionHistoryError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case error = "Error"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes.BatchDeleteDevicePositionHistoryError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteDevicePositionHistoryError(deviceId: \(Swift.String(describing: deviceId)), error: \(Swift.String(describing: error)))"}
}

extension LocationClientTypes {
    /// Contains the tracker resource details.
    public struct BatchDeleteDevicePositionHistoryError: Swift.Equatable {
        /// The ID of the device for this position.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains the batch request error details associated with the request.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?

        public init (
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
        }
    }

}

public struct BatchDeleteDevicePositionHistoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteDevicePositionHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteDevicePositionHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteDevicePositionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteDevicePositionHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteDevicePositionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteDevicePositionHistoryOutputError>
}

extension BatchDeleteDevicePositionHistoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteDevicePositionHistoryInput(deviceIds: \(Swift.String(describing: deviceIds)), trackerName: \(Swift.String(describing: trackerName)))"}
}

extension BatchDeleteDevicePositionHistoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceIds = deviceIds {
            var deviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceIds)
            for deviceidslist0 in deviceIds {
                try deviceIdsContainer.encode(deviceidslist0)
            }
        }
    }
}

public struct BatchDeleteDevicePositionHistoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteDevicePositionHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteDevicePositionHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteDevicePositionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteDevicePositionHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteDevicePositionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteDevicePositionHistoryOutputError>
}

public struct BatchDeleteDevicePositionHistoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteDevicePositionHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteDevicePositionHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteDevicePositionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteDevicePositionHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteDevicePositionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteDevicePositionHistoryOutputError>
}

public struct BatchDeleteDevicePositionHistoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteDevicePositionHistoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchDeleteDevicePositionHistoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteDevicePositionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "tracking.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDeleteDevicePositionHistoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteDevicePositionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteDevicePositionHistoryOutputError>
}

public struct BatchDeleteDevicePositionHistoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteDevicePositionHistoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchDeleteDevicePositionHistoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteDevicePositionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trackerName = input.trackerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trackerName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/delete-positions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDeleteDevicePositionHistoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteDevicePositionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteDevicePositionHistoryOutputError>
}

public struct BatchDeleteDevicePositionHistoryInput: Swift.Equatable {
    /// Devices whose position history you want to delete.
    ///
    ///
    ///                For example, for two devices:
    ///                    “DeviceIds” : [DeviceId1,DeviceId2]
    ///
    ///
    ///
    /// This member is required.
    public var deviceIds: [Swift.String]?
    /// The name of the tracker resource to delete the device position history from.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        deviceIds: [Swift.String]? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceIds = deviceIds
        self.trackerName = trackerName
    }
}

struct BatchDeleteDevicePositionHistoryInputBody: Swift.Equatable {
    public let deviceIds: [Swift.String]?
}

extension BatchDeleteDevicePositionHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceIds)
        var deviceIdsDecoded0:[Swift.String]? = nil
        if let deviceIdsContainer = deviceIdsContainer {
            deviceIdsDecoded0 = [Swift.String]()
            for string0 in deviceIdsContainer {
                if let string0 = string0 {
                    deviceIdsDecoded0?.append(string0)
                }
            }
        }
        deviceIds = deviceIdsDecoded0
    }
}

extension BatchDeleteDevicePositionHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteDevicePositionHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteDevicePositionHistoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteDevicePositionHistoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteDevicePositionHistoryOutputResponse(errors: \(Swift.String(describing: errors)))"}
}

extension BatchDeleteDevicePositionHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDeleteDevicePositionHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteDevicePositionHistoryOutputResponse: Swift.Equatable {
    /// Contains error details for each device history that failed to delete.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchDeleteDevicePositionHistoryError]?

    public init (
        errors: [LocationClientTypes.BatchDeleteDevicePositionHistoryError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteDevicePositionHistoryOutputResponseBody: Swift.Equatable {
    public let errors: [LocationClientTypes.BatchDeleteDevicePositionHistoryError]?
}

extension BatchDeleteDevicePositionHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchDeleteDevicePositionHistoryError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchDeleteDevicePositionHistoryError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchDeleteDevicePositionHistoryError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension LocationClientTypes.BatchDeleteGeofenceError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case geofenceId = "GeofenceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let geofenceId = geofenceId {
            try encodeContainer.encode(geofenceId, forKey: .geofenceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes.BatchDeleteGeofenceError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteGeofenceError(error: \(Swift.String(describing: error)), geofenceId: \(Swift.String(describing: geofenceId)))"}
}

extension LocationClientTypes {
    /// Contains error details for each geofence that failed to delete from the geofence
    ///             collection.
    public struct BatchDeleteGeofenceError: Swift.Equatable {
        /// Contains details associated to the batch error.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// The geofence associated with the error message.
        /// This member is required.
        public var geofenceId: Swift.String?

        public init (
            error: LocationClientTypes.BatchItemError? = nil,
            geofenceId: Swift.String? = nil
        )
        {
            self.error = error
            self.geofenceId = geofenceId
        }
    }

}

public struct BatchDeleteGeofenceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteGeofenceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteGeofenceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteGeofenceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteGeofenceOutputError>
}

extension BatchDeleteGeofenceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteGeofenceInput(collectionName: \(Swift.String(describing: collectionName)), geofenceIds: \(Swift.String(describing: geofenceIds)))"}
}

extension BatchDeleteGeofenceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geofenceIds = "GeofenceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geofenceIds = geofenceIds {
            var geofenceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .geofenceIds)
            for idlist0 in geofenceIds {
                try geofenceIdsContainer.encode(idlist0)
            }
        }
    }
}

public struct BatchDeleteGeofenceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteGeofenceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteGeofenceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteGeofenceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteGeofenceOutputError>
}

public struct BatchDeleteGeofenceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteGeofenceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteGeofenceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteGeofenceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteGeofenceOutputError>
}

public struct BatchDeleteGeofenceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteGeofenceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchDeleteGeofenceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "geofencing.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDeleteGeofenceInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteGeofenceOutputError>
}

public struct BatchDeleteGeofenceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteGeofenceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchDeleteGeofenceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let collectionName = input.collectionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("collectionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/delete-geofences"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDeleteGeofenceInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteGeofenceOutputError>
}

public struct BatchDeleteGeofenceInput: Swift.Equatable {
    /// The geofence collection storing the geofences to be deleted.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The batch of geofences to be deleted.
    /// This member is required.
    public var geofenceIds: [Swift.String]?

    public init (
        collectionName: Swift.String? = nil,
        geofenceIds: [Swift.String]? = nil
    )
    {
        self.collectionName = collectionName
        self.geofenceIds = geofenceIds
    }
}

struct BatchDeleteGeofenceInputBody: Swift.Equatable {
    public let geofenceIds: [Swift.String]?
}

extension BatchDeleteGeofenceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geofenceIds = "GeofenceIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .geofenceIds)
        var geofenceIdsDecoded0:[Swift.String]? = nil
        if let geofenceIdsContainer = geofenceIdsContainer {
            geofenceIdsDecoded0 = [Swift.String]()
            for string0 in geofenceIdsContainer {
                if let string0 = string0 {
                    geofenceIdsDecoded0?.append(string0)
                }
            }
        }
        geofenceIds = geofenceIdsDecoded0
    }
}

extension BatchDeleteGeofenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteGeofenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteGeofenceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteGeofenceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteGeofenceOutputResponse(errors: \(Swift.String(describing: errors)))"}
}

extension BatchDeleteGeofenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDeleteGeofenceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteGeofenceOutputResponse: Swift.Equatable {
    /// Contains error details for each geofence that failed to delete.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchDeleteGeofenceError]?

    public init (
        errors: [LocationClientTypes.BatchDeleteGeofenceError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteGeofenceOutputResponseBody: Swift.Equatable {
    public let errors: [LocationClientTypes.BatchDeleteGeofenceError]?
}

extension BatchDeleteGeofenceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchDeleteGeofenceError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchDeleteGeofenceError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchDeleteGeofenceError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension LocationClientTypes.BatchEvaluateGeofencesError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case error = "Error"
        case sampleTime = "SampleTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let sampleTime = sampleTime {
            try encodeContainer.encode(sampleTime.timeIntervalSince1970, forKey: .sampleTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes.BatchEvaluateGeofencesError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchEvaluateGeofencesError(deviceId: \(Swift.String(describing: deviceId)), error: \(Swift.String(describing: error)), sampleTime: \(Swift.String(describing: sampleTime)))"}
}

extension LocationClientTypes {
    /// Contains error details for each device that failed to evaluate its position against
    ///             the geofences in a given geofence collection.
    public struct BatchEvaluateGeofencesError: Swift.Equatable {
        /// The device associated with the position evaluation error.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains details associated to the batch error.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// Specifies a timestamp for when the error occurred in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ
        ///
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init (
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }
    }

}

public struct BatchEvaluateGeofencesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchEvaluateGeofencesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchEvaluateGeofencesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchEvaluateGeofencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchEvaluateGeofencesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchEvaluateGeofencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchEvaluateGeofencesOutputError>
}

extension BatchEvaluateGeofencesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchEvaluateGeofencesInput(collectionName: \(Swift.String(describing: collectionName)), devicePositionUpdates: \(Swift.String(describing: devicePositionUpdates)))"}
}

extension BatchEvaluateGeofencesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePositionUpdates = "DevicePositionUpdates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devicePositionUpdates = devicePositionUpdates {
            var devicePositionUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devicePositionUpdates)
            for devicepositionupdatelist0 in devicePositionUpdates {
                try devicePositionUpdatesContainer.encode(devicepositionupdatelist0)
            }
        }
    }
}

public struct BatchEvaluateGeofencesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchEvaluateGeofencesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchEvaluateGeofencesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchEvaluateGeofencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchEvaluateGeofencesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchEvaluateGeofencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchEvaluateGeofencesOutputError>
}

public struct BatchEvaluateGeofencesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchEvaluateGeofencesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchEvaluateGeofencesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchEvaluateGeofencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchEvaluateGeofencesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchEvaluateGeofencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchEvaluateGeofencesOutputError>
}

public struct BatchEvaluateGeofencesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchEvaluateGeofencesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchEvaluateGeofencesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchEvaluateGeofencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "geofencing.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchEvaluateGeofencesInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchEvaluateGeofencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchEvaluateGeofencesOutputError>
}

public struct BatchEvaluateGeofencesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchEvaluateGeofencesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchEvaluateGeofencesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchEvaluateGeofencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let collectionName = input.collectionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("collectionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/positions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchEvaluateGeofencesInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchEvaluateGeofencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchEvaluateGeofencesOutputError>
}

public struct BatchEvaluateGeofencesInput: Swift.Equatable {
    /// The geofence collection used in evaluating the position of devices against its
    ///             geofences.
    /// This member is required.
    public var collectionName: Swift.String?
    /// Contains device details for each device to be evaluated against the given geofence
    ///             collection.
    /// This member is required.
    public var devicePositionUpdates: [LocationClientTypes.DevicePositionUpdate]?

    public init (
        collectionName: Swift.String? = nil,
        devicePositionUpdates: [LocationClientTypes.DevicePositionUpdate]? = nil
    )
    {
        self.collectionName = collectionName
        self.devicePositionUpdates = devicePositionUpdates
    }
}

struct BatchEvaluateGeofencesInputBody: Swift.Equatable {
    public let devicePositionUpdates: [LocationClientTypes.DevicePositionUpdate]?
}

extension BatchEvaluateGeofencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePositionUpdates = "DevicePositionUpdates"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePositionUpdatesContainer = try containerValues.decodeIfPresent([LocationClientTypes.DevicePositionUpdate?].self, forKey: .devicePositionUpdates)
        var devicePositionUpdatesDecoded0:[LocationClientTypes.DevicePositionUpdate]? = nil
        if let devicePositionUpdatesContainer = devicePositionUpdatesContainer {
            devicePositionUpdatesDecoded0 = [LocationClientTypes.DevicePositionUpdate]()
            for structure0 in devicePositionUpdatesContainer {
                if let structure0 = structure0 {
                    devicePositionUpdatesDecoded0?.append(structure0)
                }
            }
        }
        devicePositionUpdates = devicePositionUpdatesDecoded0
    }
}

extension BatchEvaluateGeofencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchEvaluateGeofencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchEvaluateGeofencesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchEvaluateGeofencesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchEvaluateGeofencesOutputResponse(errors: \(Swift.String(describing: errors)))"}
}

extension BatchEvaluateGeofencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchEvaluateGeofencesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchEvaluateGeofencesOutputResponse: Swift.Equatable {
    /// Contains error details for each device that failed to evaluate its position against
    ///             the given geofence collection.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchEvaluateGeofencesError]?

    public init (
        errors: [LocationClientTypes.BatchEvaluateGeofencesError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchEvaluateGeofencesOutputResponseBody: Swift.Equatable {
    public let errors: [LocationClientTypes.BatchEvaluateGeofencesError]?
}

extension BatchEvaluateGeofencesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchEvaluateGeofencesError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchEvaluateGeofencesError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchEvaluateGeofencesError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension LocationClientTypes.BatchGetDevicePositionError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case error = "Error"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes.BatchGetDevicePositionError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetDevicePositionError(deviceId: \(Swift.String(describing: deviceId)), error: \(Swift.String(describing: error)))"}
}

extension LocationClientTypes {
    /// Contains error details for each device that didn't return a position.
    public struct BatchGetDevicePositionError: Swift.Equatable {
        /// The ID of the device that didn't return a position.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains details related to the error code.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?

        public init (
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
        }
    }

}

public struct BatchGetDevicePositionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetDevicePositionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetDevicePositionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetDevicePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetDevicePositionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetDevicePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetDevicePositionOutputError>
}

extension BatchGetDevicePositionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetDevicePositionInput(deviceIds: \(Swift.String(describing: deviceIds)), trackerName: \(Swift.String(describing: trackerName)))"}
}

extension BatchGetDevicePositionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceIds = deviceIds {
            var deviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceIds)
            for idlist0 in deviceIds {
                try deviceIdsContainer.encode(idlist0)
            }
        }
    }
}

public struct BatchGetDevicePositionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetDevicePositionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetDevicePositionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetDevicePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetDevicePositionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetDevicePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetDevicePositionOutputError>
}

public struct BatchGetDevicePositionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetDevicePositionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetDevicePositionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetDevicePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetDevicePositionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetDevicePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetDevicePositionOutputError>
}

public struct BatchGetDevicePositionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetDevicePositionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchGetDevicePositionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetDevicePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "tracking.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchGetDevicePositionInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetDevicePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetDevicePositionOutputError>
}

public struct BatchGetDevicePositionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetDevicePositionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchGetDevicePositionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetDevicePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trackerName = input.trackerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trackerName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/get-positions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchGetDevicePositionInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetDevicePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetDevicePositionOutputError>
}

public struct BatchGetDevicePositionInput: Swift.Equatable {
    /// Devices whose position you want to retrieve.
    ///
    ///
    ///                For example, for two devices:
    ///                    device-ids=DeviceId1&amp;device-ids=DeviceId2
    ///
    ///
    ///
    /// This member is required.
    public var deviceIds: [Swift.String]?
    /// The tracker resource retrieving the device position.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        deviceIds: [Swift.String]? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceIds = deviceIds
        self.trackerName = trackerName
    }
}

struct BatchGetDevicePositionInputBody: Swift.Equatable {
    public let deviceIds: [Swift.String]?
}

extension BatchGetDevicePositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceIds)
        var deviceIdsDecoded0:[Swift.String]? = nil
        if let deviceIdsContainer = deviceIdsContainer {
            deviceIdsDecoded0 = [Swift.String]()
            for string0 in deviceIdsContainer {
                if let string0 = string0 {
                    deviceIdsDecoded0?.append(string0)
                }
            }
        }
        deviceIds = deviceIdsDecoded0
    }
}

extension BatchGetDevicePositionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetDevicePositionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetDevicePositionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetDevicePositionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetDevicePositionOutputResponse(devicePositions: \(Swift.String(describing: devicePositions)), errors: \(Swift.String(describing: errors)))"}
}

extension BatchGetDevicePositionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchGetDevicePositionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devicePositions = output.devicePositions
            self.errors = output.errors
        } else {
            self.devicePositions = nil
            self.errors = nil
        }
    }
}

public struct BatchGetDevicePositionOutputResponse: Swift.Equatable {
    /// Contains device position details such as the device ID, position, and timestamps for
    ///             when the position was received and sampled.
    /// This member is required.
    public var devicePositions: [LocationClientTypes.DevicePosition]?
    /// Contains  error details for each device that failed to send its position to the tracker
    ///             resource.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchGetDevicePositionError]?

    public init (
        devicePositions: [LocationClientTypes.DevicePosition]? = nil,
        errors: [LocationClientTypes.BatchGetDevicePositionError]? = nil
    )
    {
        self.devicePositions = devicePositions
        self.errors = errors
    }
}

struct BatchGetDevicePositionOutputResponseBody: Swift.Equatable {
    public let errors: [LocationClientTypes.BatchGetDevicePositionError]?
    public let devicePositions: [LocationClientTypes.DevicePosition]?
}

extension BatchGetDevicePositionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePositions = "DevicePositions"
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchGetDevicePositionError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchGetDevicePositionError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchGetDevicePositionError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let devicePositionsContainer = try containerValues.decodeIfPresent([LocationClientTypes.DevicePosition?].self, forKey: .devicePositions)
        var devicePositionsDecoded0:[LocationClientTypes.DevicePosition]? = nil
        if let devicePositionsContainer = devicePositionsContainer {
            devicePositionsDecoded0 = [LocationClientTypes.DevicePosition]()
            for structure0 in devicePositionsContainer {
                if let structure0 = structure0 {
                    devicePositionsDecoded0?.append(structure0)
                }
            }
        }
        devicePositions = devicePositionsDecoded0
    }
}

extension LocationClientTypes.BatchItemError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes.BatchItemError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchItemError(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension LocationClientTypes {
    /// Contains the batch request error details associated with the request.
    public struct BatchItemError: Swift.Equatable {
        /// The error code associated with the batch request error.
        public var code: LocationClientTypes.BatchItemErrorCode?
        /// A message with the reason for the batch request error.
        public var message: Swift.String?

        public init (
            code: LocationClientTypes.BatchItemErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension LocationClientTypes {
    public enum BatchItemErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Access to the resource was denied.
        case accessdeniederror
        /// The target resource already exists.
        case conflicterror
        /// Internal server error.
        case internalservererror
        /// The target resource does not exist.
        case resourcenotfounderror
        /// Too many requests.
        case throttlingerror
        /// Input fails to satisfy the constraints specified by the service.
        case validationerror
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchItemErrorCode] {
            return [
                .accessdeniederror,
                .conflicterror,
                .internalservererror,
                .resourcenotfounderror,
                .throttlingerror,
                .validationerror,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniederror: return "AccessDeniedError"
            case .conflicterror: return "ConflictError"
            case .internalservererror: return "InternalServerError"
            case .resourcenotfounderror: return "ResourceNotFoundError"
            case .throttlingerror: return "ThrottlingError"
            case .validationerror: return "ValidationError"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchItemErrorCode(rawValue: rawValue) ?? BatchItemErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes.BatchPutGeofenceError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case geofenceId = "GeofenceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let geofenceId = geofenceId {
            try encodeContainer.encode(geofenceId, forKey: .geofenceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes.BatchPutGeofenceError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutGeofenceError(error: \(Swift.String(describing: error)), geofenceId: \(Swift.String(describing: geofenceId)))"}
}

extension LocationClientTypes {
    /// Contains error details for each geofence that failed to be stored in a given geofence
    ///             collection.
    public struct BatchPutGeofenceError: Swift.Equatable {
        /// Contains details associated to the batch error.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// The geofence associated with the error message.
        /// This member is required.
        public var geofenceId: Swift.String?

        public init (
            error: LocationClientTypes.BatchItemError? = nil,
            geofenceId: Swift.String? = nil
        )
        {
            self.error = error
            self.geofenceId = geofenceId
        }
    }

}

public struct BatchPutGeofenceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutGeofenceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchPutGeofenceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchPutGeofenceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutGeofenceOutputError>
}

extension BatchPutGeofenceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutGeofenceInput(collectionName: \(Swift.String(describing: collectionName)), entries: \(Swift.String(describing: entries)))"}
}

extension BatchPutGeofenceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for batchputgeofencerequestentrylist0 in entries {
                try entriesContainer.encode(batchputgeofencerequestentrylist0)
            }
        }
    }
}

public struct BatchPutGeofenceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutGeofenceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchPutGeofenceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchPutGeofenceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutGeofenceOutputError>
}

public struct BatchPutGeofenceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutGeofenceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchPutGeofenceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchPutGeofenceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutGeofenceOutputError>
}

public struct BatchPutGeofenceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutGeofenceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchPutGeofenceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "geofencing.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchPutGeofenceInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutGeofenceOutputError>
}

public struct BatchPutGeofenceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutGeofenceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchPutGeofenceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let collectionName = input.collectionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("collectionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/put-geofences"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchPutGeofenceInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutGeofenceOutputError>
}

public struct BatchPutGeofenceInput: Swift.Equatable {
    /// The geofence collection storing the geofences.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The batch of geofences to be stored in a geofence collection.
    /// This member is required.
    public var entries: [LocationClientTypes.BatchPutGeofenceRequestEntry]?

    public init (
        collectionName: Swift.String? = nil,
        entries: [LocationClientTypes.BatchPutGeofenceRequestEntry]? = nil
    )
    {
        self.collectionName = collectionName
        self.entries = entries
    }
}

struct BatchPutGeofenceInputBody: Swift.Equatable {
    public let entries: [LocationClientTypes.BatchPutGeofenceRequestEntry]?
}

extension BatchPutGeofenceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchPutGeofenceRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.BatchPutGeofenceRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.BatchPutGeofenceRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchPutGeofenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchPutGeofenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchPutGeofenceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchPutGeofenceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutGeofenceOutputResponse(errors: \(Swift.String(describing: errors)), successes: \(Swift.String(describing: successes)))"}
}

extension BatchPutGeofenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchPutGeofenceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.successes = output.successes
        } else {
            self.errors = nil
            self.successes = nil
        }
    }
}

public struct BatchPutGeofenceOutputResponse: Swift.Equatable {
    /// Contains additional error details for each geofence that failed to be stored in a
    ///             geofence collection.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchPutGeofenceError]?
    /// Contains each geofence that was successfully stored in a geofence collection.
    /// This member is required.
    public var successes: [LocationClientTypes.BatchPutGeofenceSuccess]?

    public init (
        errors: [LocationClientTypes.BatchPutGeofenceError]? = nil,
        successes: [LocationClientTypes.BatchPutGeofenceSuccess]? = nil
    )
    {
        self.errors = errors
        self.successes = successes
    }
}

struct BatchPutGeofenceOutputResponseBody: Swift.Equatable {
    public let successes: [LocationClientTypes.BatchPutGeofenceSuccess]?
    public let errors: [LocationClientTypes.BatchPutGeofenceError]?
}

extension BatchPutGeofenceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
        case successes = "Successes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successesContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchPutGeofenceSuccess?].self, forKey: .successes)
        var successesDecoded0:[LocationClientTypes.BatchPutGeofenceSuccess]? = nil
        if let successesContainer = successesContainer {
            successesDecoded0 = [LocationClientTypes.BatchPutGeofenceSuccess]()
            for structure0 in successesContainer {
                if let structure0 = structure0 {
                    successesDecoded0?.append(structure0)
                }
            }
        }
        successes = successesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchPutGeofenceError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchPutGeofenceError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchPutGeofenceError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension LocationClientTypes.BatchPutGeofenceRequestEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geofenceId = "GeofenceId"
        case geometry = "Geometry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geofenceId = geofenceId {
            try encodeContainer.encode(geofenceId, forKey: .geofenceId)
        }
        if let geometry = geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.GeofenceGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
    }
}

extension LocationClientTypes.BatchPutGeofenceRequestEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutGeofenceRequestEntry(geofenceId: \(Swift.String(describing: geofenceId)), geometry: \(Swift.String(describing: geometry)))"}
}

extension LocationClientTypes {
    /// Contains geofence geometry details.
    public struct BatchPutGeofenceRequestEntry: Swift.Equatable {
        /// The identifier for the geofence to be stored in a given geofence collection.
        /// This member is required.
        public var geofenceId: Swift.String?
        /// Contains the polygon details to specify the position of the geofence.
        ///
        ///             Each <a href="https://docs.aws.amazon.com/location-geofences/latest/APIReference/API_GeofenceGeometry.html">geofence polygon can have a maximum of 1,000 vertices.
        ///
        /// This member is required.
        public var geometry: LocationClientTypes.GeofenceGeometry?

        public init (
            geofenceId: Swift.String? = nil,
            geometry: LocationClientTypes.GeofenceGeometry? = nil
        )
        {
            self.geofenceId = geofenceId
            self.geometry = geometry
        }
    }

}

extension LocationClientTypes.BatchPutGeofenceSuccess: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case geofenceId = "GeofenceId"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let geofenceId = geofenceId {
            try encodeContainer.encode(geofenceId, forKey: .geofenceId)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes.BatchPutGeofenceSuccess: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutGeofenceSuccess(createTime: \(Swift.String(describing: createTime)), geofenceId: \(Swift.String(describing: geofenceId)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension LocationClientTypes {
    /// Contains a summary of each geofence that was successfully stored in a given geofence
    ///             collection.
    public struct BatchPutGeofenceSuccess: Swift.Equatable {
        /// The timestamp for when the geofence was stored in a geofence collection in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ
        ///
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The geofence successfully stored in a geofence collection.
        /// This member is required.
        public var geofenceId: Swift.String?
        /// The timestamp for when the geofence was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ
        ///
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            createTime: ClientRuntime.Date? = nil,
            geofenceId: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.updateTime = updateTime
        }
    }

}

extension LocationClientTypes.BatchUpdateDevicePositionError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case error = "Error"
        case sampleTime = "SampleTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let sampleTime = sampleTime {
            try encodeContainer.encode(sampleTime.timeIntervalSince1970, forKey: .sampleTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(LocationClientTypes.BatchItemError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LocationClientTypes.BatchUpdateDevicePositionError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUpdateDevicePositionError(deviceId: \(Swift.String(describing: deviceId)), error: \(Swift.String(describing: error)), sampleTime: \(Swift.String(describing: sampleTime)))"}
}

extension LocationClientTypes {
    /// Contains  error details for each device that failed to update its position.
    public struct BatchUpdateDevicePositionError: Swift.Equatable {
        /// The device associated with the failed location update.
        /// This member is required.
        public var deviceId: Swift.String?
        /// Contains details related to the error code such as the error code and error
        ///             message.
        /// This member is required.
        public var error: LocationClientTypes.BatchItemError?
        /// The timestamp at which the device position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init (
            deviceId: Swift.String? = nil,
            error: LocationClientTypes.BatchItemError? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.deviceId = deviceId
            self.error = error
            self.sampleTime = sampleTime
        }
    }

}

public struct BatchUpdateDevicePositionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdateDevicePositionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchUpdateDevicePositionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdateDevicePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchUpdateDevicePositionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdateDevicePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdateDevicePositionOutputError>
}

extension BatchUpdateDevicePositionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUpdateDevicePositionInput(trackerName: \(Swift.String(describing: trackerName)), updates: \(Swift.String(describing: updates)))"}
}

extension BatchUpdateDevicePositionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updates = "Updates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updates = updates {
            var updatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updates)
            for devicepositionupdatelist0 in updates {
                try updatesContainer.encode(devicepositionupdatelist0)
            }
        }
    }
}

public struct BatchUpdateDevicePositionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdateDevicePositionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchUpdateDevicePositionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdateDevicePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchUpdateDevicePositionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdateDevicePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdateDevicePositionOutputError>
}

public struct BatchUpdateDevicePositionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdateDevicePositionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchUpdateDevicePositionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdateDevicePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchUpdateDevicePositionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdateDevicePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdateDevicePositionOutputError>
}

public struct BatchUpdateDevicePositionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdateDevicePositionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchUpdateDevicePositionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdateDevicePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "tracking.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchUpdateDevicePositionInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdateDevicePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdateDevicePositionOutputError>
}

public struct BatchUpdateDevicePositionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdateDevicePositionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchUpdateDevicePositionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdateDevicePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trackerName = input.trackerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trackerName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/positions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchUpdateDevicePositionInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdateDevicePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdateDevicePositionOutputError>
}

public struct BatchUpdateDevicePositionInput: Swift.Equatable {
    /// The name of the tracker resource to update.
    /// This member is required.
    public var trackerName: Swift.String?
    /// Contains the position update details for each device.
    /// This member is required.
    public var updates: [LocationClientTypes.DevicePositionUpdate]?

    public init (
        trackerName: Swift.String? = nil,
        updates: [LocationClientTypes.DevicePositionUpdate]? = nil
    )
    {
        self.trackerName = trackerName
        self.updates = updates
    }
}

struct BatchUpdateDevicePositionInputBody: Swift.Equatable {
    public let updates: [LocationClientTypes.DevicePositionUpdate]?
}

extension BatchUpdateDevicePositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updates = "Updates"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatesContainer = try containerValues.decodeIfPresent([LocationClientTypes.DevicePositionUpdate?].self, forKey: .updates)
        var updatesDecoded0:[LocationClientTypes.DevicePositionUpdate]? = nil
        if let updatesContainer = updatesContainer {
            updatesDecoded0 = [LocationClientTypes.DevicePositionUpdate]()
            for structure0 in updatesContainer {
                if let structure0 = structure0 {
                    updatesDecoded0?.append(structure0)
                }
            }
        }
        updates = updatesDecoded0
    }
}

extension BatchUpdateDevicePositionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchUpdateDevicePositionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchUpdateDevicePositionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchUpdateDevicePositionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUpdateDevicePositionOutputResponse(errors: \(Swift.String(describing: errors)))"}
}

extension BatchUpdateDevicePositionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchUpdateDevicePositionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchUpdateDevicePositionOutputResponse: Swift.Equatable {
    /// Contains  error details for each device that failed to update its position.
    /// This member is required.
    public var errors: [LocationClientTypes.BatchUpdateDevicePositionError]?

    public init (
        errors: [LocationClientTypes.BatchUpdateDevicePositionError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchUpdateDevicePositionOutputResponseBody: Swift.Equatable {
    public let errors: [LocationClientTypes.BatchUpdateDevicePositionError]?
}

extension BatchUpdateDevicePositionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([LocationClientTypes.BatchUpdateDevicePositionError?].self, forKey: .errors)
        var errorsDecoded0:[LocationClientTypes.BatchUpdateDevicePositionError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [LocationClientTypes.BatchUpdateDevicePositionError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension LocationClientTypes.CalculateRouteCarModeOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avoidFerries = "AvoidFerries"
        case avoidTolls = "AvoidTolls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let avoidFerries = avoidFerries {
            try encodeContainer.encode(avoidFerries, forKey: .avoidFerries)
        }
        if let avoidTolls = avoidTolls {
            try encodeContainer.encode(avoidTolls, forKey: .avoidTolls)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let avoidFerriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .avoidFerries)
        avoidFerries = avoidFerriesDecoded
        let avoidTollsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .avoidTolls)
        avoidTolls = avoidTollsDecoded
    }
}

extension LocationClientTypes.CalculateRouteCarModeOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRouteCarModeOptions(avoidFerries: \(Swift.String(describing: avoidFerries)), avoidTolls: \(Swift.String(describing: avoidTolls)))"}
}

extension LocationClientTypes {
    /// Contains details about additional route preferences for requests that specify
    ///                 TravelMode as Car.
    public struct CalculateRouteCarModeOptions: Swift.Equatable {
        /// Avoids ferries when calculating routes.
        ///         Default Value: false
        ///
        ///         Valid Values: false | true
        ///
        public var avoidFerries: Swift.Bool?
        /// Avoids tolls when calculating routes.
        ///         Default Value: false
        ///
        ///         Valid Values: false | true
        ///
        public var avoidTolls: Swift.Bool?

        public init (
            avoidFerries: Swift.Bool? = nil,
            avoidTolls: Swift.Bool? = nil
        )
        {
            self.avoidFerries = avoidFerries
            self.avoidTolls = avoidTolls
        }
    }

}

public struct CalculateRouteInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CalculateRouteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CalculateRouteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CalculateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CalculateRouteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CalculateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CalculateRouteOutputError>
}

extension CalculateRouteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRouteInput(calculatorName: \(Swift.String(describing: calculatorName)), carModeOptions: \(Swift.String(describing: carModeOptions)), departNow: \(Swift.String(describing: departNow)), departurePosition: \(Swift.String(describing: departurePosition)), departureTime: \(Swift.String(describing: departureTime)), destinationPosition: \(Swift.String(describing: destinationPosition)), distanceUnit: \(Swift.String(describing: distanceUnit)), includeLegGeometry: \(Swift.String(describing: includeLegGeometry)), travelMode: \(Swift.String(describing: travelMode)), truckModeOptions: \(Swift.String(describing: truckModeOptions)), waypointPositions: \(Swift.String(describing: waypointPositions)))"}
}

extension CalculateRouteInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case carModeOptions = "CarModeOptions"
        case departNow = "DepartNow"
        case departurePosition = "DeparturePosition"
        case departureTime = "DepartureTime"
        case destinationPosition = "DestinationPosition"
        case distanceUnit = "DistanceUnit"
        case includeLegGeometry = "IncludeLegGeometry"
        case travelMode = "TravelMode"
        case truckModeOptions = "TruckModeOptions"
        case waypointPositions = "WaypointPositions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let carModeOptions = carModeOptions {
            try encodeContainer.encode(carModeOptions, forKey: .carModeOptions)
        }
        if let departNow = departNow {
            try encodeContainer.encode(departNow, forKey: .departNow)
        }
        if let departurePosition = departurePosition {
            var departurePositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .departurePosition)
            for position0 in departurePosition {
                try departurePositionContainer.encode(position0)
            }
        }
        if let departureTime = departureTime {
            try encodeContainer.encode(departureTime.timeIntervalSince1970, forKey: .departureTime)
        }
        if let destinationPosition = destinationPosition {
            var destinationPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPosition)
            for position0 in destinationPosition {
                try destinationPositionContainer.encode(position0)
            }
        }
        if let distanceUnit = distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let includeLegGeometry = includeLegGeometry {
            try encodeContainer.encode(includeLegGeometry, forKey: .includeLegGeometry)
        }
        if let travelMode = travelMode {
            try encodeContainer.encode(travelMode.rawValue, forKey: .travelMode)
        }
        if let truckModeOptions = truckModeOptions {
            try encodeContainer.encode(truckModeOptions, forKey: .truckModeOptions)
        }
        if let waypointPositions = waypointPositions {
            var waypointPositionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .waypointPositions)
            for waypointpositionlist0 in waypointPositions {
                var waypointpositionlist0Container = waypointPositionsContainer.nestedUnkeyedContainer()
                for position1 in waypointpositionlist0 {
                    try waypointpositionlist0Container.encode(position1)
                }
            }
        }
    }
}

public struct CalculateRouteInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CalculateRouteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CalculateRouteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CalculateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CalculateRouteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CalculateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CalculateRouteOutputError>
}

public struct CalculateRouteInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CalculateRouteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CalculateRouteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CalculateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CalculateRouteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CalculateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CalculateRouteOutputError>
}

public struct CalculateRouteInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CalculateRouteInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CalculateRouteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CalculateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "routes.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CalculateRouteInput
    public typealias MOutput = ClientRuntime.OperationOutput<CalculateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CalculateRouteOutputError>
}

public struct CalculateRouteInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CalculateRouteInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CalculateRouteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CalculateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let calculatorName = input.calculatorName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("calculatorName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())/calculate/route"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CalculateRouteInput
    public typealias MOutput = ClientRuntime.OperationOutput<CalculateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CalculateRouteOutputError>
}

public struct CalculateRouteInput: Swift.Equatable {
    /// The name of the route calculator resource that you want to use to calculate a route.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// Specifies route preferences when traveling by Car, such as avoiding
    ///             routes that use ferries or tolls.
    ///         Requirements: TravelMode must be specified as Car.
    public var carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions?
    /// Sets the time of departure as the current time. Uses the current time to calculate a
    ///             route. Otherwise, the best time of day to travel with the best traffic conditions is
    ///             used to calculate the route.
    ///         Default Value: false
    ///
    ///         Valid Values: false | true
    ///
    public var departNow: Swift.Bool?
    /// The start position for the route. Defined in <a href="https://earth-info.nga.mil/GandG/wgs84/index.html">WGS 84 format:
    ///                 [longitude, latitude].
    ///
    ///
    ///                 For example, [-123.115, 49.285]
    ///
    ///
    ///
    ///
    ///             If you specify a departure that's not located on a road, Amazon Location <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">moves the
    ///                 position to the nearest road.
    ///
    ///         Valid Values: [-180 to 180,-90 to 90]
    ///
    /// This member is required.
    public var departurePosition: [Swift.Double]?
    /// Specifies the desired time of departure. Uses the given time to calculate a route.
    ///             Otherwise, the best time of day to travel with the best traffic conditions is used to
    ///             calculate the route.
    ///
    ///             Setting a departure time in the past returns a 400
    ///                     ValidationException error.
    ///
    ///
    ///
    ///                 In <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO
    ///                         8601 format: YYYY-MM-DDThh:mm:ss.sssZ. For example,
    ///                         2020–07-2T12:15:20.000Z+01:00
    ///
    ///
    ///
    public var departureTime: ClientRuntime.Date?
    /// The finish position for the route. Defined in <a href="https://earth-info.nga.mil/GandG/wgs84/index.html">WGS 84 format:
    ///                 [longitude, latitude].
    ///
    ///
    ///                  For example, [-122.339, 47.615]
    ///
    ///
    ///
    ///
    ///             If you specify a destination that's not located on a road, Amazon Location <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">moves the position to the nearest road.
    ///
    ///         Valid Values: [-180 to 180,-90 to 90]
    ///
    /// This member is required.
    public var destinationPosition: [Swift.Double]?
    /// Set the unit system to specify the distance.
    ///         Default Value: Kilometers
    ///
    public var distanceUnit: LocationClientTypes.DistanceUnit?
    /// Set to include the geometry details in the result for each path between a pair of
    ///             positions.
    ///         Default Value: false
    ///
    ///         Valid Values: false | true
    ///
    public var includeLegGeometry: Swift.Bool?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed
    ///             of travel and road compatibility.
    ///         The TravelMode you specify determines how you specify route preferences:
    ///
    ///
    ///                 If traveling by Car use the CarModeOptions
    ///                     parameter.
    ///
    ///
    ///                 If traveling by Truck use the TruckModeOptions
    ///                     parameter.
    ///
    ///
    ///         Default Value: Car
    ///
    public var travelMode: LocationClientTypes.TravelMode?
    /// Specifies route preferences when traveling by Truck, such as avoiding
    ///             routes that use ferries or tolls, and truck specifications to consider when choosing an
    ///             optimal road.
    ///         Requirements: TravelMode must be specified as Truck.
    public var truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions?
    /// Specifies an ordered list of up to 23 intermediate positions to include along a route
    ///             between the departure position and destination position.
    ///
    ///
    ///                 For example, from the DeparturePosition
    ///                     [-123.115, 49.285], the route follows the order that the waypoint
    ///                     positions are given [[-122.757, 49.0021],[-122.349, 47.620]]
    ///
    ///
    ///
    ///
    ///             If you specify a waypoint position that's not located on a road, Amazon Location <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">moves the position to the nearest road.
    ///             Specifying more than 23 waypoints returns a 400 ValidationException
    ///                 error.
    ///
    ///         Valid Values: [-180 to 180,-90 to 90]
    ///
    public var waypointPositions: [[Swift.Double]]?

    public init (
        calculatorName: Swift.String? = nil,
        carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions? = nil,
        departNow: Swift.Bool? = nil,
        departurePosition: [Swift.Double]? = nil,
        departureTime: ClientRuntime.Date? = nil,
        destinationPosition: [Swift.Double]? = nil,
        distanceUnit: LocationClientTypes.DistanceUnit? = nil,
        includeLegGeometry: Swift.Bool? = nil,
        travelMode: LocationClientTypes.TravelMode? = nil,
        truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions? = nil,
        waypointPositions: [[Swift.Double]]? = nil
    )
    {
        self.calculatorName = calculatorName
        self.carModeOptions = carModeOptions
        self.departNow = departNow
        self.departurePosition = departurePosition
        self.departureTime = departureTime
        self.destinationPosition = destinationPosition
        self.distanceUnit = distanceUnit
        self.includeLegGeometry = includeLegGeometry
        self.travelMode = travelMode
        self.truckModeOptions = truckModeOptions
        self.waypointPositions = waypointPositions
    }
}

struct CalculateRouteInputBody: Swift.Equatable {
    public let departurePosition: [Swift.Double]?
    public let destinationPosition: [Swift.Double]?
    public let waypointPositions: [[Swift.Double]]?
    public let travelMode: LocationClientTypes.TravelMode?
    public let departureTime: ClientRuntime.Date?
    public let departNow: Swift.Bool?
    public let distanceUnit: LocationClientTypes.DistanceUnit?
    public let includeLegGeometry: Swift.Bool?
    public let carModeOptions: LocationClientTypes.CalculateRouteCarModeOptions?
    public let truckModeOptions: LocationClientTypes.CalculateRouteTruckModeOptions?
}

extension CalculateRouteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case carModeOptions = "CarModeOptions"
        case departNow = "DepartNow"
        case departurePosition = "DeparturePosition"
        case departureTime = "DepartureTime"
        case destinationPosition = "DestinationPosition"
        case distanceUnit = "DistanceUnit"
        case includeLegGeometry = "IncludeLegGeometry"
        case travelMode = "TravelMode"
        case truckModeOptions = "TruckModeOptions"
        case waypointPositions = "WaypointPositions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let departurePositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .departurePosition)
        var departurePositionDecoded0:[Swift.Double]? = nil
        if let departurePositionContainer = departurePositionContainer {
            departurePositionDecoded0 = [Swift.Double]()
            for double0 in departurePositionContainer {
                if let double0 = double0 {
                    departurePositionDecoded0?.append(double0)
                }
            }
        }
        departurePosition = departurePositionDecoded0
        let destinationPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .destinationPosition)
        var destinationPositionDecoded0:[Swift.Double]? = nil
        if let destinationPositionContainer = destinationPositionContainer {
            destinationPositionDecoded0 = [Swift.Double]()
            for double0 in destinationPositionContainer {
                if let double0 = double0 {
                    destinationPositionDecoded0?.append(double0)
                }
            }
        }
        destinationPosition = destinationPositionDecoded0
        let waypointPositionsContainer = try containerValues.decodeIfPresent([[Swift.Double?]?].self, forKey: .waypointPositions)
        var waypointPositionsDecoded0:[[Swift.Double]]? = nil
        if let waypointPositionsContainer = waypointPositionsContainer {
            waypointPositionsDecoded0 = [[Swift.Double]]()
            for list0 in waypointPositionsContainer {
                var list0Decoded0: [Swift.Double]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.Double]()
                    for double1 in list0 {
                        if let double1 = double1 {
                            list0Decoded0?.append(double1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    waypointPositionsDecoded0?.append(list0Decoded0)
                }
            }
        }
        waypointPositions = waypointPositionsDecoded0
        let travelModeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.TravelMode.self, forKey: .travelMode)
        travelMode = travelModeDecoded
        let departureTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .departureTime)
        departureTime = departureTimeDecoded
        let departNowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .departNow)
        departNow = departNowDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let includeLegGeometryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeLegGeometry)
        includeLegGeometry = includeLegGeometryDecoded
        let carModeOptionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.CalculateRouteCarModeOptions.self, forKey: .carModeOptions)
        carModeOptions = carModeOptionsDecoded
        let truckModeOptionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.CalculateRouteTruckModeOptions.self, forKey: .truckModeOptions)
        truckModeOptions = truckModeOptionsDecoded
    }
}

extension CalculateRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CalculateRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CalculateRouteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CalculateRouteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRouteOutputResponse(legs: \(Swift.String(describing: legs)), summary: \(Swift.String(describing: summary)))"}
}

extension CalculateRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CalculateRouteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.legs = output.legs
            self.summary = output.summary
        } else {
            self.legs = nil
            self.summary = nil
        }
    }
}

/// Returns the result of the route calculation. Metadata includes legs and route
///             summary.
public struct CalculateRouteOutputResponse: Swift.Equatable {
    /// Contains details about each path between a pair of positions included along a route
    ///             such as: StartPosition, EndPosition, Distance,
    ///                 DurationSeconds, Geometry, and Steps. The
    ///             number of legs returned corresponds to one fewer than the total number of positions in
    ///             the request.
    ///         For example, a route with a departure position and destination position returns one
    ///             leg with the positions <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">snapped to a nearby road:
    ///
    ///
    ///                 The StartPosition is the departure position.
    ///
    ///
    ///                 The EndPosition is the destination position.
    ///
    ///
    ///         A route with a waypoint between the departure and destination position returns two
    ///             legs with the positions snapped to a nearby road:
    ///
    ///
    ///                 Leg 1: The StartPosition is the departure position . The
    ///                         EndPosition is the waypoint positon.
    ///
    ///
    ///                 Leg 2: The StartPosition is the waypoint position. The
    ///                         EndPosition is the destination position.
    ///
    ///
    /// This member is required.
    public var legs: [LocationClientTypes.Leg]?
    /// Contains information about the whole route, such as: RouteBBox,
    ///                 DataSource, Distance, DistanceUnit, and
    ///                 DurationSeconds.
    /// This member is required.
    public var summary: LocationClientTypes.CalculateRouteSummary?

    public init (
        legs: [LocationClientTypes.Leg]? = nil,
        summary: LocationClientTypes.CalculateRouteSummary? = nil
    )
    {
        self.legs = legs
        self.summary = summary
    }
}

struct CalculateRouteOutputResponseBody: Swift.Equatable {
    public let legs: [LocationClientTypes.Leg]?
    public let summary: LocationClientTypes.CalculateRouteSummary?
}

extension CalculateRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case legs = "Legs"
        case summary = "Summary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let legsContainer = try containerValues.decodeIfPresent([LocationClientTypes.Leg?].self, forKey: .legs)
        var legsDecoded0:[LocationClientTypes.Leg]? = nil
        if let legsContainer = legsContainer {
            legsDecoded0 = [LocationClientTypes.Leg]()
            for structure0 in legsContainer {
                if let structure0 = structure0 {
                    legsDecoded0?.append(structure0)
                }
            }
        }
        legs = legsDecoded0
        let summaryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.CalculateRouteSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension LocationClientTypes.CalculateRouteSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case distance = "Distance"
        case distanceUnit = "DistanceUnit"
        case durationSeconds = "DurationSeconds"
        case routeBBox = "RouteBBox"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let distance = distance {
            try encodeContainer.encode(distance, forKey: .distance)
        }
        if let distanceUnit = distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let durationSeconds = durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let routeBBox = routeBBox {
            var routeBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routeBBox)
            for boundingbox0 in routeBBox {
                try routeBBoxContainer.encode(boundingbox0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .routeBBox)
        var routeBBoxDecoded0:[Swift.Double]? = nil
        if let routeBBoxContainer = routeBBoxContainer {
            routeBBoxDecoded0 = [Swift.Double]()
            for double0 in routeBBoxContainer {
                if let double0 = double0 {
                    routeBBoxDecoded0?.append(double0)
                }
            }
        }
        routeBBox = routeBBoxDecoded0
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let distanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .distance)
        distance = distanceDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
    }
}

extension LocationClientTypes.CalculateRouteSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRouteSummary(dataSource: \(Swift.String(describing: dataSource)), distance: \(Swift.String(describing: distance)), distanceUnit: \(Swift.String(describing: distanceUnit)), durationSeconds: \(Swift.String(describing: durationSeconds)), routeBBox: \(Swift.String(describing: routeBBox)))"}
}

extension LocationClientTypes {
    /// A summary of the calculated route.
    public struct CalculateRouteSummary: Swift.Equatable {
        /// The data provider of traffic and road network data used to calculate the route.
        ///             Indicates one of the available providers:
        ///
        ///
        ///
        ///                   Esri
        ///
        ///
        ///
        ///
        ///                   Here
        ///
        ///
        ///
        ///         For more information about data providers, see <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers.
        /// This member is required.
        public var dataSource: Swift.String?
        /// The total distance covered by the route. The sum of the distance travelled between
        ///             every stop on the route.
        ///
        ///             The route distance can't be greater than 250 km. If the route exceeds
        ///                 250 km, the response returns a 400 RoutesValidationException
        ///                 error.
        ///
        /// This member is required.
        public var distance: Swift.Double?
        /// The unit of measurement for the distance.
        /// This member is required.
        public var distanceUnit: LocationClientTypes.DistanceUnit?
        /// The total travel time for the route measured in seconds. The sum of the travel time
        ///             between every stop on the
        ///             route.
        /// This member is required.
        public var durationSeconds: Swift.Double?
        /// Specifies a geographical box surrounding a route. Used to zoom into a route when
        ///             displaying it in a map. For example, [min x, min y, max x, max y].
        ///         The first 2 bbox parameters describe the lower southwest corner:
        ///
        ///
        ///                 The first bbox position is the X coordinate or longitude of the
        ///                     lower southwest corner.
        ///
        ///
        ///                 The second bbox position is the Y coordinate or latitude of the
        ///                     lower southwest corner.
        ///
        ///
        ///         The next 2 bbox parameters describe the upper northeast corner:
        ///
        ///
        ///                 The third bbox position is the X coordinate, or longitude of the
        ///                     upper northeast corner.
        ///
        ///
        ///                 The fourth bbox position is the Y coordinate, or longitude of the
        ///                     upper northeast corner.
        ///
        ///
        /// This member is required.
        public var routeBBox: [Swift.Double]?

        public init (
            dataSource: Swift.String? = nil,
            distance: Swift.Double? = nil,
            distanceUnit: LocationClientTypes.DistanceUnit? = nil,
            durationSeconds: Swift.Double? = nil,
            routeBBox: [Swift.Double]? = nil
        )
        {
            self.dataSource = dataSource
            self.distance = distance
            self.distanceUnit = distanceUnit
            self.durationSeconds = durationSeconds
            self.routeBBox = routeBBox
        }
    }

}

extension LocationClientTypes.CalculateRouteTruckModeOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avoidFerries = "AvoidFerries"
        case avoidTolls = "AvoidTolls"
        case dimensions = "Dimensions"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let avoidFerries = avoidFerries {
            try encodeContainer.encode(avoidFerries, forKey: .avoidFerries)
        }
        if let avoidTolls = avoidTolls {
            try encodeContainer.encode(avoidTolls, forKey: .avoidTolls)
        }
        if let dimensions = dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
        if let weight = weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let avoidFerriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .avoidFerries)
        avoidFerries = avoidFerriesDecoded
        let avoidTollsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .avoidTolls)
        avoidTolls = avoidTollsDecoded
        let dimensionsDecoded = try containerValues.decodeIfPresent(LocationClientTypes.TruckDimensions.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let weightDecoded = try containerValues.decodeIfPresent(LocationClientTypes.TruckWeight.self, forKey: .weight)
        weight = weightDecoded
    }
}

extension LocationClientTypes.CalculateRouteTruckModeOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRouteTruckModeOptions(avoidFerries: \(Swift.String(describing: avoidFerries)), avoidTolls: \(Swift.String(describing: avoidTolls)), dimensions: \(Swift.String(describing: dimensions)), weight: \(Swift.String(describing: weight)))"}
}

extension LocationClientTypes {
    /// Contains details about additional route preferences for requests that specify
    ///                 TravelMode as Truck.
    public struct CalculateRouteTruckModeOptions: Swift.Equatable {
        /// Avoids ferries when calculating routes.
        ///         Default Value: false
        ///
        ///         Valid Values: false | true
        ///
        public var avoidFerries: Swift.Bool?
        /// Avoids ferries when calculating routes.
        ///         Default Value: false
        ///
        ///         Valid Values: false | true
        ///
        public var avoidTolls: Swift.Bool?
        /// Specifies the truck's dimension specifications including length, height, width, and
        ///             unit of measurement. Used to avoid roads that can't support the truck's
        ///             dimensions.
        public var dimensions: LocationClientTypes.TruckDimensions?
        /// Specifies the truck's weight specifications including total weight and unit of
        ///             measurement. Used to avoid roads that can't support the truck's weight.
        public var weight: LocationClientTypes.TruckWeight?

        public init (
            avoidFerries: Swift.Bool? = nil,
            avoidTolls: Swift.Bool? = nil,
            dimensions: LocationClientTypes.TruckDimensions? = nil,
            weight: LocationClientTypes.TruckWeight? = nil
        )
        {
            self.avoidFerries = avoidFerries
            self.avoidTolls = avoidTolls
            self.dimensions = dimensions
            self.weight = weight
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was unsuccessful because of a conflict.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateGeofenceCollectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGeofenceCollectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGeofenceCollectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGeofenceCollectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGeofenceCollectionOutputError>
}

extension CreateGeofenceCollectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGeofenceCollectionInput(collectionName: \(Swift.String(describing: collectionName)), description: \(Swift.String(describing: description)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), pricingPlan: \(Swift.String(describing: pricingPlan)), pricingPlanDataSource: \(Swift.String(describing: pricingPlanDataSource)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateGeofenceCollectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionName = "CollectionName"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectionName = collectionName {
            try encodeContainer.encode(collectionName, forKey: .collectionName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let pricingPlan = pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateGeofenceCollectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGeofenceCollectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGeofenceCollectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGeofenceCollectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGeofenceCollectionOutputError>
}

public struct CreateGeofenceCollectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGeofenceCollectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGeofenceCollectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGeofenceCollectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGeofenceCollectionOutputError>
}

public struct CreateGeofenceCollectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGeofenceCollectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateGeofenceCollectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "geofencing.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGeofenceCollectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGeofenceCollectionOutputError>
}

public struct CreateGeofenceCollectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGeofenceCollectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateGeofenceCollectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/geofencing/v0/collections"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGeofenceCollectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGeofenceCollectionOutputError>
}

public struct CreateGeofenceCollectionInput: Swift.Equatable {
    /// A custom name for the geofence collection.
    ///         Requirements:
    ///
    ///
    ///                 Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods
    ///                     (.), and underscores (_).
    ///
    ///
    ///                 Must be a unique geofence collection name.
    ///
    ///
    ///                 No spaces allowed. For example, ExampleGeofenceCollection.
    ///
    ///
    /// This member is required.
    public var collectionName: Swift.String?
    /// An optional description for the geofence collection.
    public var description: Swift.String?
    /// A key identifier for an <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html">AWS KMS customer managed key. Enter a key ID, key ARN, alias name, or alias ARN.
    /// 	
    public var kmsKeyId: Swift.String?
    /// Specifies the pricing plan for the geofence collection.
    ///         For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
    ///             page.
    /// This member is required.
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Specifies the data provider for the geofence collection.
    ///
    ///
    ///                 Required value for the following pricing plans: MobileAssetTracking
    ///                     | MobileAssetManagement
    ///
    ///
    ///
    ///         For more information about <a href="https://aws.amazon.com/location/data-providers/">Data Providers, and <a href="https://aws.amazon.com/location/pricing/">Pricing plans, see the Amazon Location
    ///             Service product page.
    /// 	
    /// 	           Amazon Location Service only uses PricingPlanDataSource to calculate billing for
    ///                 your geofence collection. Your data won't be shared with the data provider, and will
    ///                 remain in your AWS account or Region unless you move it.
    /// 	
    ///         Valid Values: Esri | Here
    ///
    public var pricingPlanDataSource: Swift.String?
    /// Applies one or more tags to the geofence collection. A tag is a key-value pair helps
    ///             manage, identify, search, and filter your resources by labelling them.
    ///         Format: "key" : "value"
    ///
    ///         Restrictions:
    ///
    ///
    ///                 Maximum 50 tags per resource
    ///
    ///
    ///                 Each resource tag must be unique with a maximum of one value.
    ///
    ///
    ///                 Maximum key length: 128 Unicode characters in UTF-8
    ///
    ///
    ///                 Maximum value length: 256 Unicode characters in UTF-8
    ///
    ///
    ///                 Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters:
    ///                     + - = . _ : / @.
    ///
    ///
    public var tags: [Swift.String:Swift.String]?

    public init (
        collectionName: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.collectionName = collectionName
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
    }
}

struct CreateGeofenceCollectionInputBody: Swift.Equatable {
    public let collectionName: Swift.String?
    public let pricingPlan: LocationClientTypes.PricingPlan?
    public let pricingPlanDataSource: Swift.String?
    public let description: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let kmsKeyId: Swift.String?
}

extension CreateGeofenceCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionName = "CollectionName"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension CreateGeofenceCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGeofenceCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGeofenceCollectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGeofenceCollectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGeofenceCollectionOutputResponse(collectionArn: \(Swift.String(describing: collectionArn)), collectionName: \(Swift.String(describing: collectionName)), createTime: \(Swift.String(describing: createTime)))"}
}

extension CreateGeofenceCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateGeofenceCollectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.collectionArn = output.collectionArn
            self.collectionName = output.collectionName
            self.createTime = output.createTime
        } else {
            self.collectionArn = nil
            self.collectionName = nil
            self.createTime = nil
        }
    }
}

public struct CreateGeofenceCollectionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you
    ///             need to specify a resource across all AWS.
    ///
    ///
    ///                 Format example:
    ///                         arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
    ///
    ///
    ///
    /// This member is required.
    public var collectionArn: Swift.String?
    /// The name for the geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The timestamp for when the geofence collection was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ
    ///
    /// This member is required.
    public var createTime: ClientRuntime.Date?

    public init (
        collectionArn: Swift.String? = nil,
        collectionName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil
    )
    {
        self.collectionArn = collectionArn
        self.collectionName = collectionName
        self.createTime = createTime
    }
}

struct CreateGeofenceCollectionOutputResponseBody: Swift.Equatable {
    public let collectionName: Swift.String?
    public let collectionArn: Swift.String?
    public let createTime: ClientRuntime.Date?
}

extension CreateGeofenceCollectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionArn = "CollectionArn"
        case collectionName = "CollectionName"
        case createTime = "CreateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let collectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionArn)
        collectionArn = collectionArnDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

public struct CreateMapInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMapInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMapOutputError>
}

extension CreateMapInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMapInput(configuration: \(Swift.String(describing: configuration)), description: \(Swift.String(describing: description)), mapName: \(Swift.String(describing: mapName)), pricingPlan: \(Swift.String(describing: pricingPlan)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateMapInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case mapName = "MapName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mapName = mapName {
            try encodeContainer.encode(mapName, forKey: .mapName)
        }
        if let pricingPlan = pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateMapInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMapInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMapOutputError>
}

public struct CreateMapInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMapInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMapOutputError>
}

public struct CreateMapInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMapInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateMapInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "maps.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMapInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMapOutputError>
}

public struct CreateMapInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMapInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateMapInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/maps/v0/maps"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMapInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMapOutputError>
}

public struct CreateMapInput: Swift.Equatable {
    /// Specifies the map style selected from an available data provider.
    /// This member is required.
    public var configuration: LocationClientTypes.MapConfiguration?
    /// An optional description for the map resource.
    public var description: Swift.String?
    /// The name for the map resource.
    ///         Requirements:
    ///
    ///
    ///                Must contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_).
    ///
    ///
    ///                Must be a unique map resource name.
    ///
    ///
    ///                 No spaces allowed. For example, ExampleMap.
    ///
    ///
    /// This member is required.
    public var mapName: Swift.String?
    /// Specifies the pricing plan for your map resource.
    ///         For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
    ///                 page.
    /// This member is required.
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Applies one or more tags to the map resource. A tag is a key-value pair helps manage,
    ///             identify, search, and filter your resources by labelling them.
    ///          Format: "key" : "value"
    ///
    ///          Restrictions:
    ///
    ///
    ///                Maximum 50 tags per resource
    ///
    ///
    ///                Each resource tag must be unique with a maximum of one value.
    ///
    ///
    ///                Maximum key length: 128 Unicode characters in UTF-8
    ///
    ///
    ///                Maximum value length:  256 Unicode characters in UTF-8
    ///
    ///
    ///                Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : /
    ///                     @.
    ///
    ///
    public var tags: [Swift.String:Swift.String]?

    public init (
        configuration: LocationClientTypes.MapConfiguration? = nil,
        description: Swift.String? = nil,
        mapName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.configuration = configuration
        self.description = description
        self.mapName = mapName
        self.pricingPlan = pricingPlan
        self.tags = tags
    }
}

struct CreateMapInputBody: Swift.Equatable {
    public let mapName: Swift.String?
    public let configuration: LocationClientTypes.MapConfiguration?
    public let pricingPlan: LocationClientTypes.PricingPlan?
    public let description: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateMapInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case mapName = "MapName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapName)
        mapName = mapNameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(LocationClientTypes.MapConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMapOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMapOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMapOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMapOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMapOutputResponse(createTime: \(Swift.String(describing: createTime)), mapArn: \(Swift.String(describing: mapArn)), mapName: \(Swift.String(describing: mapName)))"}
}

extension CreateMapOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMapOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.mapArn = output.mapArn
            self.mapName = output.mapName
        } else {
            self.createTime = nil
            self.mapArn = nil
            self.mapName = nil
        }
    }
}

public struct CreateMapOutputResponse: Swift.Equatable {
    /// The timestamp for when the map resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the map resource. Used to specify a resource across
    ///             all AWS.
    ///
    ///
    ///                 Format example:
    ///                     arn:aws:geo:region:account-id:maps/ExampleMap
    ///
    ///
    ///
    /// This member is required.
    public var mapArn: Swift.String?
    /// The name of the map resource.
    /// This member is required.
    public var mapName: Swift.String?

    public init (
        createTime: ClientRuntime.Date? = nil,
        mapArn: Swift.String? = nil,
        mapName: Swift.String? = nil
    )
    {
        self.createTime = createTime
        self.mapArn = mapArn
        self.mapName = mapName
    }
}

struct CreateMapOutputResponseBody: Swift.Equatable {
    public let mapName: Swift.String?
    public let mapArn: Swift.String?
    public let createTime: ClientRuntime.Date?
}

extension CreateMapOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case mapArn = "MapArn"
        case mapName = "MapName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapName)
        mapName = mapNameDecoded
        let mapArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapArn)
        mapArn = mapArnDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

public struct CreatePlaceIndexInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlaceIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePlaceIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePlaceIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlaceIndexOutputError>
}

extension CreatePlaceIndexInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePlaceIndexInput(dataSource: \(Swift.String(describing: dataSource)), dataSourceConfiguration: \(Swift.String(describing: dataSourceConfiguration)), description: \(Swift.String(describing: description)), indexName: \(Swift.String(describing: indexName)), pricingPlan: \(Swift.String(describing: pricingPlan)), tags: \(Swift.String(describing: tags)))"}
}

extension CreatePlaceIndexInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case dataSourceConfiguration = "DataSourceConfiguration"
        case description = "Description"
        case indexName = "IndexName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let dataSourceConfiguration = dataSourceConfiguration {
            try encodeContainer.encode(dataSourceConfiguration, forKey: .dataSourceConfiguration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let indexName = indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let pricingPlan = pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreatePlaceIndexInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlaceIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePlaceIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePlaceIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlaceIndexOutputError>
}

public struct CreatePlaceIndexInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlaceIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePlaceIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePlaceIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlaceIndexOutputError>
}

public struct CreatePlaceIndexInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlaceIndexInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreatePlaceIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "places.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePlaceIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlaceIndexOutputError>
}

public struct CreatePlaceIndexInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePlaceIndexInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreatePlaceIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/places/v0/indexes"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePlaceIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePlaceIndexOutputError>
}

public struct CreatePlaceIndexInput: Swift.Equatable {
    /// Specifies the data provider of geospatial data.
    ///
    ///             This field is case-sensitive. Enter the valid values as shown. For example, entering
    ///                HERE returns an error.
    ///
    ///          Valid values include:
    ///
    ///
    ///
    ///                   Esri – For additional information about <a href="https://docs.aws.amazon.com/location/latest/developerguide/esri.html">Esri's coverage in your
    ///                region of interest, see <a href="https://developers.arcgis.com/rest/geocode/api-reference/geocode-coverage.htm">Esri details on geocoding coverage.
    ///
    ///
    ///
    ///                   Here – For additional information about <a href="https://docs.aws.amazon.com/location/latest/developerguide/HERE.html">HERE Technologies's
    ///                coverage in your region of interest, see <a href="https://developer.here.com/documentation/geocoder/dev_guide/topics/coverage-geocoder.html">HERE details on goecoding coverage.
    ///
    ///                   Place index resources using HERE Technologies as a data provider can't <a href="https://docs.aws.amazon.com/location-places/latest/APIReference/API_DataSourceConfiguration.html">store results for locations in Japan. For more information, see the
    ///                      <a href="https://aws.amazon.com/service-terms/">AWS Service Terms
    ///                   for Amazon Location Service.
    ///
    ///
    ///
    ///          For additional information , see <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Data providers
    ///          on the Amazon Location Service Developer Guide.
    /// This member is required.
    public var dataSource: Swift.String?
    /// Specifies the data storage option requesting Places.
    public var dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    /// The optional description for the place index resource.
    public var description: Swift.String?
    /// The name of the place index resource.
    ///          Requirements:
    ///
    ///
    ///                Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and
    ///                underscores (_).
    ///
    ///
    ///                Must be a unique place index resource name.
    ///
    ///
    ///                No spaces allowed. For example, ExamplePlaceIndex.
    ///
    ///
    /// This member is required.
    public var indexName: Swift.String?
    /// Specifies the pricing plan for your place index resource.
    ///          For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
    ///          page.
    /// This member is required.
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Applies one or more tags to the place index resource. A tag is a key-value pair helps
    ///          manage, identify, search, and filter your resources by labelling them.
    ///          Format: "key" : "value"
    ///
    ///          Restrictions:
    ///
    ///
    ///                Maximum 50 tags per resource
    ///
    ///
    ///                Each resource tag must be unique with a maximum of one value.
    ///
    ///
    ///                Maximum key length: 128 Unicode characters in UTF-8
    ///
    ///
    ///                Maximum value length: 256 Unicode characters in UTF-8
    ///
    ///
    ///                Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + -
    ///                = . _ : / @.
    ///
    ///
    public var tags: [Swift.String:Swift.String]?

    public init (
        dataSource: Swift.String? = nil,
        dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        indexName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dataSource = dataSource
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.indexName = indexName
        self.pricingPlan = pricingPlan
        self.tags = tags
    }
}

struct CreatePlaceIndexInputBody: Swift.Equatable {
    public let indexName: Swift.String?
    public let dataSource: Swift.String?
    public let pricingPlan: LocationClientTypes.PricingPlan?
    public let description: Swift.String?
    public let dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    public let tags: [Swift.String:Swift.String]?
}

extension CreatePlaceIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case dataSourceConfiguration = "DataSourceConfiguration"
        case description = "Description"
        case indexName = "IndexName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePlaceIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePlaceIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePlaceIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePlaceIndexOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePlaceIndexOutputResponse(createTime: \(Swift.String(describing: createTime)), indexArn: \(Swift.String(describing: indexArn)), indexName: \(Swift.String(describing: indexName)))"}
}

extension CreatePlaceIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePlaceIndexOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.indexArn = output.indexArn
            self.indexName = output.indexName
        } else {
            self.createTime = nil
            self.indexArn = nil
            self.indexName = nil
        }
    }
}

public struct CreatePlaceIndexOutputResponse: Swift.Equatable {
    /// The timestamp for when the place index resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format:
    ///             YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the place index resource. Used to specify a resource
    ///          across AWS.
    ///
    ///
    ///                Format example:
    ///                   arn:aws:geo:region:account-id:place-index/ExamplePlaceIndex
    ///
    ///
    ///
    /// This member is required.
    public var indexArn: Swift.String?
    /// The name for the place index resource.
    /// This member is required.
    public var indexName: Swift.String?

    public init (
        createTime: ClientRuntime.Date? = nil,
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil
    )
    {
        self.createTime = createTime
        self.indexArn = indexArn
        self.indexName = indexName
    }
}

struct CreatePlaceIndexOutputResponseBody: Swift.Equatable {
    public let indexName: Swift.String?
    public let indexArn: Swift.String?
    public let createTime: ClientRuntime.Date?
}

extension CreatePlaceIndexOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case indexArn = "IndexArn"
        case indexName = "IndexName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let indexArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexArn)
        indexArn = indexArnDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

public struct CreateRouteCalculatorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRouteCalculatorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRouteCalculatorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRouteCalculatorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRouteCalculatorOutputError>
}

extension CreateRouteCalculatorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRouteCalculatorInput(calculatorName: \(Swift.String(describing: calculatorName)), dataSource: \(Swift.String(describing: dataSource)), description: \(Swift.String(describing: description)), pricingPlan: \(Swift.String(describing: pricingPlan)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateRouteCalculatorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorName = "CalculatorName"
        case dataSource = "DataSource"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculatorName = calculatorName {
            try encodeContainer.encode(calculatorName, forKey: .calculatorName)
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRouteCalculatorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRouteCalculatorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRouteCalculatorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRouteCalculatorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRouteCalculatorOutputError>
}

public struct CreateRouteCalculatorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRouteCalculatorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRouteCalculatorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRouteCalculatorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRouteCalculatorOutputError>
}

public struct CreateRouteCalculatorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRouteCalculatorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateRouteCalculatorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "routes.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRouteCalculatorInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRouteCalculatorOutputError>
}

public struct CreateRouteCalculatorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRouteCalculatorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateRouteCalculatorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/routes/v0/calculators"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRouteCalculatorInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRouteCalculatorOutputError>
}

public struct CreateRouteCalculatorInput: Swift.Equatable {
    /// The name of the route calculator resource.
    ///         Requirements:
    ///
    ///
    ///                Can use alphanumeric characters (A–Z, a–z, 0–9) , hyphens (-), periods (.), and underscores
    ///                     (_).
    ///
    ///
    ///                Must be a unique Route calculator resource name.
    ///
    ///
    ///                 No spaces allowed. For example, ExampleRouteCalculator.
    ///
    ///
    /// This member is required.
    public var calculatorName: Swift.String?
    /// Specifies the data provider of traffic and road network data.
    ///
    ///             This field is case-sensitive. Enter the valid values as shown. For example,
    ///                 entering HERE returns an error.
    ///
    ///         Valid values include:
    ///
    ///
    ///
    ///                   Esri – For additional information about <a href="https://docs.aws.amazon.com/location/latest/developerguide/esri.html">Esri's coverage in your region of interest, see <a href="https://doc.arcgis.com/en/arcgis-online/reference/network-coverage.htm">Esri details on street networks and traffic coverage.
    ///
    ///
    ///
    ///                   Here – For additional information about <a href="https://docs.aws.amazon.com/location/latest/developerguide/HERE.html">HERE
    ///                         Technologies's coverage in your region of interest, see <a href="https://developer.here.com/documentation/routing-api/dev_guide/topics/coverage/car-routing.html">HERE car routing coverage and <a href="https://developer.here.com/documentation/routing-api/dev_guide/topics/coverage/truck-routing.html">HERE truck routing coverage.
    ///
    ///
    ///         For additional information , see <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Data
    ///                 providers on the Amazon Location Service Developer Guide.
    /// This member is required.
    public var dataSource: Swift.String?
    /// The optional description for the route calculator resource.
    public var description: Swift.String?
    /// Specifies the pricing plan for your route calculator resource.
    ///         For additional details and restrictions on each pricing plan option, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing.
    /// This member is required.
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Applies one or more tags to the route calculator resource. A tag is a key-value pair
    ///             helps manage, identify, search, and filter your resources by labelling them.
    ///
    ///
    ///                 For example: { "tag1" : "value1", "tag2" :
    ///                     "value2"}
    ///
    ///
    ///         Format: "key" : "value"
    ///
    ///         Restrictions:
    ///
    ///
    ///                 Maximum 50 tags per resource
    ///
    ///
    ///                 Each resource tag must be unique with a maximum of one value.
    ///
    ///
    ///                 Maximum key length: 128 Unicode characters in UTF-8
    ///
    ///
    ///                 Maximum value length: 256 Unicode characters in UTF-8
    ///
    ///
    ///                 Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters:
    ///                     + - = . _ : / @.
    ///
    ///
    public var tags: [Swift.String:Swift.String]?

    public init (
        calculatorName: Swift.String? = nil,
        dataSource: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.calculatorName = calculatorName
        self.dataSource = dataSource
        self.description = description
        self.pricingPlan = pricingPlan
        self.tags = tags
    }
}

struct CreateRouteCalculatorInputBody: Swift.Equatable {
    public let calculatorName: Swift.String?
    public let dataSource: Swift.String?
    public let pricingPlan: LocationClientTypes.PricingPlan?
    public let description: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateRouteCalculatorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorName = "CalculatorName"
        case dataSource = "DataSource"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorName)
        calculatorName = calculatorNameDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRouteCalculatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRouteCalculatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRouteCalculatorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRouteCalculatorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRouteCalculatorOutputResponse(calculatorArn: \(Swift.String(describing: calculatorArn)), calculatorName: \(Swift.String(describing: calculatorName)), createTime: \(Swift.String(describing: createTime)))"}
}

extension CreateRouteCalculatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRouteCalculatorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.calculatorArn = output.calculatorArn
            self.calculatorName = output.calculatorName
            self.createTime = output.createTime
        } else {
            self.calculatorArn = nil
            self.calculatorName = nil
            self.createTime = nil
        }
    }
}

public struct CreateRouteCalculatorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the route calculator resource. Use the ARN when you
    ///             specify a resource across all AWS.
    ///
    ///
    ///                 Format example:
    ///                         arn:aws:geo:region:account-id:route-calculator/ExampleCalculator
    ///
    ///
    ///
    /// This member is required.
    public var calculatorArn: Swift.String?
    /// The name of the route calculator resource.
    ///
    ///
    ///                 For example, ExampleRouteCalculator.
    ///
    ///
    /// This member is required.
    public var calculatorName: Swift.String?
    /// The timestamp when the route calculator resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
    ///
    ///
    ///                 For example, 2020–07-2T12:15:20.000Z+01:00
    ///
    ///
    ///
    /// This member is required.
    public var createTime: ClientRuntime.Date?

    public init (
        calculatorArn: Swift.String? = nil,
        calculatorName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil
    )
    {
        self.calculatorArn = calculatorArn
        self.calculatorName = calculatorName
        self.createTime = createTime
    }
}

struct CreateRouteCalculatorOutputResponseBody: Swift.Equatable {
    public let calculatorName: Swift.String?
    public let calculatorArn: Swift.String?
    public let createTime: ClientRuntime.Date?
}

extension CreateRouteCalculatorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorArn = "CalculatorArn"
        case calculatorName = "CalculatorName"
        case createTime = "CreateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorName)
        calculatorName = calculatorNameDecoded
        let calculatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorArn)
        calculatorArn = calculatorArnDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

public struct CreateTrackerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTrackerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTrackerOutputError>
}

extension CreateTrackerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTrackerInput(description: \(Swift.String(describing: description)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), pricingPlan: \(Swift.String(describing: pricingPlan)), pricingPlanDataSource: \(Swift.String(describing: pricingPlanDataSource)), tags: \(Swift.String(describing: tags)), trackerName: \(Swift.String(describing: trackerName)))"}
}

extension CreateTrackerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
        case trackerName = "TrackerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let pricingPlan = pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let trackerName = trackerName {
            try encodeContainer.encode(trackerName, forKey: .trackerName)
        }
    }
}

public struct CreateTrackerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTrackerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTrackerOutputError>
}

public struct CreateTrackerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTrackerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTrackerOutputError>
}

public struct CreateTrackerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTrackerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateTrackerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "tracking.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTrackerInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTrackerOutputError>
}

public struct CreateTrackerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTrackerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateTrackerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/tracking/v0/trackers"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTrackerInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTrackerOutputError>
}

public struct CreateTrackerInput: Swift.Equatable {
    /// An optional description for the tracker resource.
    public var description: Swift.String?
    /// A key identifier for an <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html">AWS KMS customer managed key. Enter a key ID, key ARN, alias name, or alias ARN.
    public var kmsKeyId: Swift.String?
    /// Specifies the pricing plan for the tracker resource.
    ///          For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
    ///            page.
    /// This member is required.
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Specifies the data provider for the tracker resource.
    ///
    ///
    ///                Required value for the following pricing plans: MobileAssetTracking
    ///                | MobileAssetManagement
    ///
    ///
    ///
    ///          For more information about <a href="https://aws.amazon.com/location/data-providers/">Data Providers, and <a href="https://aws.amazon.com/location/pricing/">Pricing plans, see the Amazon Location
    ///            Service product page.
    /// 	
    /// 	           Amazon Location Service only uses PricingPlanDataSource to calculate billing for your tracker resource. Your data will not be shared with the data provider, and will remain in your AWS account or Region unless you move it.
    /// 	
    ///         Valid Values: Esri | Here
    ///
    public var pricingPlanDataSource: Swift.String?
    /// Applies one or more tags to the tracker resource. A tag is a key-value pair helps
    ///             manage, identify, search, and filter your resources by labelling them.
    ///         Format: "key" : "value"
    ///
    ///         Restrictions:
    ///
    ///
    ///                 Maximum 50 tags per resource
    ///
    ///
    ///                 Each resource tag must be unique with a maximum of one value.
    ///
    ///
    ///                 Maximum key length: 128 Unicode characters in UTF-8
    ///
    ///
    ///                 Maximum value length: 256 Unicode characters in UTF-8
    ///
    ///
    ///                 Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters:
    ///                     + - = . _ : / @.
    ///
    ///
    public var tags: [Swift.String:Swift.String]?
    /// The name for the tracker resource.
    ///          Requirements:
    ///
    ///
    ///                Contain only alphanumeric characters (A-Z, a-z, 0-9) , hyphens (-), periods (.), and underscores (_).
    ///
    ///
    ///                Must be a unique tracker resource name.
    ///
    ///
    ///                 No spaces allowed. For example, ExampleTracker.
    ///
    ///
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
        self.trackerName = trackerName
    }
}

struct CreateTrackerInputBody: Swift.Equatable {
    public let trackerName: Swift.String?
    public let pricingPlan: LocationClientTypes.PricingPlan?
    public let kmsKeyId: Swift.String?
    public let pricingPlanDataSource: Swift.String?
    public let description: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateTrackerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
        case trackerName = "TrackerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTrackerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTrackerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTrackerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTrackerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTrackerOutputResponse(createTime: \(Swift.String(describing: createTime)), trackerArn: \(Swift.String(describing: trackerArn)), trackerName: \(Swift.String(describing: trackerName)))"}
}

extension CreateTrackerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTrackerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.trackerArn = output.trackerArn
            self.trackerName = output.trackerName
        } else {
            self.createTime = nil
            self.trackerArn = nil
            self.trackerName = nil
        }
    }
}

public struct CreateTrackerOutputResponse: Swift.Equatable {
    /// The timestamp for when the tracker resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify
    ///             a resource across all AWS.
    ///
    ///
    ///                 Format example:
    ///                         arn:aws:geo:region:account-id:tracker/ExampleTracker
    ///
    ///
    ///
    /// This member is required.
    public var trackerArn: Swift.String?
    /// The name of the tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        createTime: ClientRuntime.Date? = nil,
        trackerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.createTime = createTime
        self.trackerArn = trackerArn
        self.trackerName = trackerName
    }
}

struct CreateTrackerOutputResponseBody: Swift.Equatable {
    public let trackerName: Swift.String?
    public let trackerArn: Swift.String?
    public let createTime: ClientRuntime.Date?
}

extension CreateTrackerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case trackerArn = "TrackerArn"
        case trackerName = "TrackerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let trackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerArn)
        trackerArn = trackerArnDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

extension LocationClientTypes.DataSourceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intendedUse = "IntendedUse"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intendedUse = intendedUse {
            try encodeContainer.encode(intendedUse.rawValue, forKey: .intendedUse)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intendedUseDecoded = try containerValues.decodeIfPresent(LocationClientTypes.IntendedUse.self, forKey: .intendedUse)
        intendedUse = intendedUseDecoded
    }
}

extension LocationClientTypes.DataSourceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSourceConfiguration(intendedUse: \(Swift.String(describing: intendedUse)))"}
}

extension LocationClientTypes {
    /// Specifies the data storage option chosen for requesting Places.
    ///
    ///             When using Amazon Location Places:
    ///
    ///
    ///                   If using HERE Technologies as a data provider, you can't store results for
    ///                   locations in Japan by setting IntendedUse to Storage.
    ///                   parameter.
    ///
    ///
    ///                   Under the MobileAssetTracking or MobilAssetManagement
    ///                   pricing plan, you can't store results from your place index resources by setting IntendedUse to Storage. This
    ///                   returns a validation exception error.
    ///
    ///
    ///             For more information, see the <a href="https://aws.amazon.com/service-terms/">AWS Service Terms for
    ///             Amazon Location Service.
    ///
    public struct DataSourceConfiguration: Swift.Equatable {
        /// Specifies how the results of an operation will be stored by the caller.
        ///          Valid values include:
        ///
        ///
        ///
        ///                   SingleUse specifies that the results won't be stored.
        ///
        ///
        ///
        ///                   Storage specifies that the result can be cached or stored in a database.
        ///
        ///
        ///          Default value:  SingleUse
        ///
        public var intendedUse: LocationClientTypes.IntendedUse?

        public init (
            intendedUse: LocationClientTypes.IntendedUse? = nil
        )
        {
            self.intendedUse = intendedUse
        }
    }

}

extension DeleteGeofenceCollectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGeofenceCollectionInput(collectionName: \(Swift.String(describing: collectionName)))"}
}

extension DeleteGeofenceCollectionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteGeofenceCollectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGeofenceCollectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGeofenceCollectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGeofenceCollectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGeofenceCollectionOutputError>
}

public struct DeleteGeofenceCollectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGeofenceCollectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGeofenceCollectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGeofenceCollectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGeofenceCollectionOutputError>
}

public struct DeleteGeofenceCollectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGeofenceCollectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteGeofenceCollectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "geofencing.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteGeofenceCollectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGeofenceCollectionOutputError>
}

public struct DeleteGeofenceCollectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGeofenceCollectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteGeofenceCollectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let collectionName = input.collectionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("collectionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteGeofenceCollectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGeofenceCollectionOutputError>
}

public struct DeleteGeofenceCollectionInput: Swift.Equatable {
    /// The name of the geofence collection to be deleted.
    /// This member is required.
    public var collectionName: Swift.String?

    public init (
        collectionName: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
    }
}

struct DeleteGeofenceCollectionInputBody: Swift.Equatable {
}

extension DeleteGeofenceCollectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGeofenceCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGeofenceCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGeofenceCollectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGeofenceCollectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGeofenceCollectionOutputResponse()"}
}

extension DeleteGeofenceCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGeofenceCollectionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteGeofenceCollectionOutputResponseBody: Swift.Equatable {
}

extension DeleteGeofenceCollectionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMapInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMapInput(mapName: \(Swift.String(describing: mapName)))"}
}

extension DeleteMapInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteMapInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMapInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMapOutputError>
}

public struct DeleteMapInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMapInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMapOutputError>
}

public struct DeleteMapInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMapInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteMapInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "maps.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMapInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMapOutputError>
}

public struct DeleteMapInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMapInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteMapInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let mapName = input.mapName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("mapName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/maps/v0/maps/\(mapName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMapInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMapOutputError>
}

public struct DeleteMapInput: Swift.Equatable {
    /// The name of the map resource to be deleted.
    /// This member is required.
    public var mapName: Swift.String?

    public init (
        mapName: Swift.String? = nil
    )
    {
        self.mapName = mapName
    }
}

struct DeleteMapInputBody: Swift.Equatable {
}

extension DeleteMapInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMapOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMapOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMapOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMapOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMapOutputResponse()"}
}

extension DeleteMapOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMapOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteMapOutputResponseBody: Swift.Equatable {
}

extension DeleteMapOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePlaceIndexInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePlaceIndexInput(indexName: \(Swift.String(describing: indexName)))"}
}

extension DeletePlaceIndexInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeletePlaceIndexInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlaceIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePlaceIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePlaceIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlaceIndexOutputError>
}

public struct DeletePlaceIndexInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlaceIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePlaceIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePlaceIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlaceIndexOutputError>
}

public struct DeletePlaceIndexInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlaceIndexInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeletePlaceIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "places.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePlaceIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlaceIndexOutputError>
}

public struct DeletePlaceIndexInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlaceIndexInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeletePlaceIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let indexName = input.indexName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("indexName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/places/v0/indexes/\(indexName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePlaceIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlaceIndexOutputError>
}

public struct DeletePlaceIndexInput: Swift.Equatable {
    /// The name of the place index resource to be deleted.
    /// This member is required.
    public var indexName: Swift.String?

    public init (
        indexName: Swift.String? = nil
    )
    {
        self.indexName = indexName
    }
}

struct DeletePlaceIndexInputBody: Swift.Equatable {
}

extension DeletePlaceIndexInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePlaceIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePlaceIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePlaceIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePlaceIndexOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePlaceIndexOutputResponse()"}
}

extension DeletePlaceIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePlaceIndexOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePlaceIndexOutputResponseBody: Swift.Equatable {
}

extension DeletePlaceIndexOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRouteCalculatorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRouteCalculatorInput(calculatorName: \(Swift.String(describing: calculatorName)))"}
}

extension DeleteRouteCalculatorInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteRouteCalculatorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRouteCalculatorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRouteCalculatorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRouteCalculatorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRouteCalculatorOutputError>
}

public struct DeleteRouteCalculatorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRouteCalculatorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRouteCalculatorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRouteCalculatorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRouteCalculatorOutputError>
}

public struct DeleteRouteCalculatorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRouteCalculatorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteRouteCalculatorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "routes.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRouteCalculatorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRouteCalculatorOutputError>
}

public struct DeleteRouteCalculatorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRouteCalculatorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteRouteCalculatorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let calculatorName = input.calculatorName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("calculatorName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRouteCalculatorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRouteCalculatorOutputError>
}

public struct DeleteRouteCalculatorInput: Swift.Equatable {
    /// The name of the route calculator resource to be deleted.
    /// This member is required.
    public var calculatorName: Swift.String?

    public init (
        calculatorName: Swift.String? = nil
    )
    {
        self.calculatorName = calculatorName
    }
}

struct DeleteRouteCalculatorInputBody: Swift.Equatable {
}

extension DeleteRouteCalculatorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRouteCalculatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRouteCalculatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRouteCalculatorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRouteCalculatorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRouteCalculatorOutputResponse()"}
}

extension DeleteRouteCalculatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRouteCalculatorOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRouteCalculatorOutputResponseBody: Swift.Equatable {
}

extension DeleteRouteCalculatorOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTrackerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTrackerInput(trackerName: \(Swift.String(describing: trackerName)))"}
}

extension DeleteTrackerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteTrackerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTrackerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTrackerOutputError>
}

public struct DeleteTrackerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTrackerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTrackerOutputError>
}

public struct DeleteTrackerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTrackerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteTrackerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "tracking.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTrackerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTrackerOutputError>
}

public struct DeleteTrackerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTrackerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteTrackerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trackerName = input.trackerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trackerName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTrackerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTrackerOutputError>
}

public struct DeleteTrackerInput: Swift.Equatable {
    /// The name of the tracker resource to be deleted.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        trackerName: Swift.String? = nil
    )
    {
        self.trackerName = trackerName
    }
}

struct DeleteTrackerInputBody: Swift.Equatable {
}

extension DeleteTrackerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTrackerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTrackerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTrackerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTrackerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTrackerOutputResponse()"}
}

extension DeleteTrackerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTrackerOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteTrackerOutputResponseBody: Swift.Equatable {
}

extension DeleteTrackerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGeofenceCollectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGeofenceCollectionInput(collectionName: \(Swift.String(describing: collectionName)))"}
}

extension DescribeGeofenceCollectionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeGeofenceCollectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGeofenceCollectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGeofenceCollectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGeofenceCollectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGeofenceCollectionOutputError>
}

public struct DescribeGeofenceCollectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGeofenceCollectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGeofenceCollectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGeofenceCollectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGeofenceCollectionOutputError>
}

public struct DescribeGeofenceCollectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGeofenceCollectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeGeofenceCollectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "geofencing.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeGeofenceCollectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGeofenceCollectionOutputError>
}

public struct DescribeGeofenceCollectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGeofenceCollectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeGeofenceCollectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let collectionName = input.collectionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("collectionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeGeofenceCollectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGeofenceCollectionOutputError>
}

public struct DescribeGeofenceCollectionInput: Swift.Equatable {
    /// The name of the geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?

    public init (
        collectionName: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
    }
}

struct DescribeGeofenceCollectionInputBody: Swift.Equatable {
}

extension DescribeGeofenceCollectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGeofenceCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGeofenceCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGeofenceCollectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGeofenceCollectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGeofenceCollectionOutputResponse(collectionArn: \(Swift.String(describing: collectionArn)), collectionName: \(Swift.String(describing: collectionName)), createTime: \(Swift.String(describing: createTime)), description: \(Swift.String(describing: description)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), pricingPlan: \(Swift.String(describing: pricingPlan)), pricingPlanDataSource: \(Swift.String(describing: pricingPlanDataSource)), tags: \(Swift.String(describing: tags)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension DescribeGeofenceCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeGeofenceCollectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.collectionArn = output.collectionArn
            self.collectionName = output.collectionName
            self.createTime = output.createTime
            self.description = output.description
            self.kmsKeyId = output.kmsKeyId
            self.pricingPlan = output.pricingPlan
            self.pricingPlanDataSource = output.pricingPlanDataSource
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.collectionArn = nil
            self.collectionName = nil
            self.createTime = nil
            self.description = nil
            self.kmsKeyId = nil
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct DescribeGeofenceCollectionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the geofence collection resource. Used when you
    ///             need to specify a resource across all AWS.
    ///
    ///
    ///                 Format example:
    ///                         arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
    ///
    ///
    ///
    /// This member is required.
    public var collectionArn: Swift.String?
    /// The name of the geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The timestamp for when the geofence resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ
    ///
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The optional description for the geofence collection.
    /// This member is required.
    public var description: Swift.String?
    /// A key identifier for an <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html">AWS KMS customer managed key assigned to the Amazon Location resource
    public var kmsKeyId: Swift.String?
    /// The pricing plan selected for the specified geofence collection.
    ///         For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
    ///                 page.
    /// This member is required.
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// The specified data provider for the geofence collection.
    public var pricingPlanDataSource: Swift.String?
    /// Displays the key, value pairs of tags associated with this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp for when the geofence collection was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ
    ///
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        collectionArn: Swift.String? = nil,
        collectionName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.collectionArn = collectionArn
        self.collectionName = collectionName
        self.createTime = createTime
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct DescribeGeofenceCollectionOutputResponseBody: Swift.Equatable {
    public let collectionName: Swift.String?
    public let collectionArn: Swift.String?
    public let description: Swift.String?
    public let pricingPlan: LocationClientTypes.PricingPlan?
    public let pricingPlanDataSource: Swift.String?
    public let kmsKeyId: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let createTime: ClientRuntime.Date?
    public let updateTime: ClientRuntime.Date?
}

extension DescribeGeofenceCollectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionArn = "CollectionArn"
        case collectionName = "CollectionName"
        case createTime = "CreateTime"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let collectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionArn)
        collectionArn = collectionArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension DescribeMapInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMapInput(mapName: \(Swift.String(describing: mapName)))"}
}

extension DescribeMapInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeMapInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMapInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMapOutputError>
}

public struct DescribeMapInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMapInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMapOutputError>
}

public struct DescribeMapInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMapInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeMapInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "maps.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMapInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMapOutputError>
}

public struct DescribeMapInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMapInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeMapInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let mapName = input.mapName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("mapName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/maps/v0/maps/\(mapName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMapInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMapOutputError>
}

public struct DescribeMapInput: Swift.Equatable {
    /// The name of the map resource.
    /// This member is required.
    public var mapName: Swift.String?

    public init (
        mapName: Swift.String? = nil
    )
    {
        self.mapName = mapName
    }
}

struct DescribeMapInputBody: Swift.Equatable {
}

extension DescribeMapInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeMapOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMapOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMapOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMapOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMapOutputResponse(configuration: \(Swift.String(describing: configuration)), createTime: \(Swift.String(describing: createTime)), dataSource: \(Swift.String(describing: dataSource)), description: \(Swift.String(describing: description)), mapArn: \(Swift.String(describing: mapArn)), mapName: \(Swift.String(describing: mapName)), pricingPlan: \(Swift.String(describing: pricingPlan)), tags: \(Swift.String(describing: tags)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension DescribeMapOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMapOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configuration = output.configuration
            self.createTime = output.createTime
            self.dataSource = output.dataSource
            self.description = output.description
            self.mapArn = output.mapArn
            self.mapName = output.mapName
            self.pricingPlan = output.pricingPlan
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.configuration = nil
            self.createTime = nil
            self.dataSource = nil
            self.description = nil
            self.mapArn = nil
            self.mapName = nil
            self.pricingPlan = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct DescribeMapOutputResponse: Swift.Equatable {
    /// Specifies the map tile style selected from a partner data provider.
    /// This member is required.
    public var configuration: LocationClientTypes.MapConfiguration?
    /// The timestamp for when the map resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// Specifies the data provider for the associated map tiles.
    /// This member is required.
    public var dataSource: Swift.String?
    /// The optional description for the map resource.
    /// This member is required.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) for the map resource. Used to specify a resource across
    ///             all AWS.
    ///
    ///
    ///                 Format example:
    ///                     arn:aws:geo:region:account-id:maps/ExampleMap
    ///
    ///
    ///
    /// This member is required.
    public var mapArn: Swift.String?
    /// The map style selected from an available provider.
    /// This member is required.
    public var mapName: Swift.String?
    /// The pricing plan selected for the specified map resource.
    ///
    ///         For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
    ///                 page.
    /// This member is required.
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Tags associated with the map resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp for when the map resource was last update in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        configuration: LocationClientTypes.MapConfiguration? = nil,
        createTime: ClientRuntime.Date? = nil,
        dataSource: Swift.String? = nil,
        description: Swift.String? = nil,
        mapArn: Swift.String? = nil,
        mapName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.configuration = configuration
        self.createTime = createTime
        self.dataSource = dataSource
        self.description = description
        self.mapArn = mapArn
        self.mapName = mapName
        self.pricingPlan = pricingPlan
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct DescribeMapOutputResponseBody: Swift.Equatable {
    public let mapName: Swift.String?
    public let mapArn: Swift.String?
    public let pricingPlan: LocationClientTypes.PricingPlan?
    public let dataSource: Swift.String?
    public let configuration: LocationClientTypes.MapConfiguration?
    public let description: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let createTime: ClientRuntime.Date?
    public let updateTime: ClientRuntime.Date?
}

extension DescribeMapOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case description = "Description"
        case mapArn = "MapArn"
        case mapName = "MapName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapName)
        mapName = mapNameDecoded
        let mapArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapArn)
        mapArn = mapArnDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(LocationClientTypes.MapConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension DescribePlaceIndexInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePlaceIndexInput(indexName: \(Swift.String(describing: indexName)))"}
}

extension DescribePlaceIndexInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribePlaceIndexInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePlaceIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePlaceIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePlaceIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePlaceIndexOutputError>
}

public struct DescribePlaceIndexInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePlaceIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePlaceIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePlaceIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePlaceIndexOutputError>
}

public struct DescribePlaceIndexInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePlaceIndexInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribePlaceIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "places.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePlaceIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePlaceIndexOutputError>
}

public struct DescribePlaceIndexInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePlaceIndexInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribePlaceIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let indexName = input.indexName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("indexName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/places/v0/indexes/\(indexName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePlaceIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePlaceIndexOutputError>
}

public struct DescribePlaceIndexInput: Swift.Equatable {
    /// The name of the place index resource.
    /// This member is required.
    public var indexName: Swift.String?

    public init (
        indexName: Swift.String? = nil
    )
    {
        self.indexName = indexName
    }
}

struct DescribePlaceIndexInputBody: Swift.Equatable {
}

extension DescribePlaceIndexInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePlaceIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePlaceIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePlaceIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePlaceIndexOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePlaceIndexOutputResponse(createTime: \(Swift.String(describing: createTime)), dataSource: \(Swift.String(describing: dataSource)), dataSourceConfiguration: \(Swift.String(describing: dataSourceConfiguration)), description: \(Swift.String(describing: description)), indexArn: \(Swift.String(describing: indexArn)), indexName: \(Swift.String(describing: indexName)), pricingPlan: \(Swift.String(describing: pricingPlan)), tags: \(Swift.String(describing: tags)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension DescribePlaceIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePlaceIndexOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.dataSource = output.dataSource
            self.dataSourceConfiguration = output.dataSourceConfiguration
            self.description = output.description
            self.indexArn = output.indexArn
            self.indexName = output.indexName
            self.pricingPlan = output.pricingPlan
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.createTime = nil
            self.dataSource = nil
            self.dataSourceConfiguration = nil
            self.description = nil
            self.indexArn = nil
            self.indexName = nil
            self.pricingPlan = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct DescribePlaceIndexOutputResponse: Swift.Equatable {
    /// The timestamp for when the place index resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format:
    ///             YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The data provider of geospatial data. Indicates one of the available providers:
    ///
    ///
    ///
    ///                   Esri
    ///
    ///
    ///
    ///
    ///                   Here
    ///
    ///
    ///
    ///          For additional details on data providers, see the <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers
    ///          page.
    /// This member is required.
    public var dataSource: Swift.String?
    /// The specified data storage option for requesting Places.
    /// This member is required.
    public var dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    /// The optional description for the place index resource.
    /// This member is required.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) for the place index resource. Used to specify a resource
    ///          across AWS.
    ///
    ///
    ///                Format example:
    ///                   arn:aws:geo:region:account-id:place-index/ExamplePlaceIndex
    ///
    ///
    ///
    /// This member is required.
    public var indexArn: Swift.String?
    /// The name of the place index resource being described.
    /// This member is required.
    public var indexName: Swift.String?
    /// The pricing plan selected for the specified place index resource.
    ///          For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
    ///             page.
    /// This member is required.
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Tags associated with place index resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp for when the place index resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format:
    ///             YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        createTime: ClientRuntime.Date? = nil,
        dataSource: Swift.String? = nil,
        dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.dataSource = dataSource
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.indexArn = indexArn
        self.indexName = indexName
        self.pricingPlan = pricingPlan
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct DescribePlaceIndexOutputResponseBody: Swift.Equatable {
    public let indexName: Swift.String?
    public let indexArn: Swift.String?
    public let pricingPlan: LocationClientTypes.PricingPlan?
    public let description: Swift.String?
    public let createTime: ClientRuntime.Date?
    public let updateTime: ClientRuntime.Date?
    public let dataSource: Swift.String?
    public let dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    public let tags: [Swift.String:Swift.String]?
}

extension DescribePlaceIndexOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case dataSourceConfiguration = "DataSourceConfiguration"
        case description = "Description"
        case indexArn = "IndexArn"
        case indexName = "IndexName"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let indexArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexArn)
        indexArn = indexArnDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeRouteCalculatorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRouteCalculatorInput(calculatorName: \(Swift.String(describing: calculatorName)))"}
}

extension DescribeRouteCalculatorInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeRouteCalculatorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRouteCalculatorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRouteCalculatorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRouteCalculatorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRouteCalculatorOutputError>
}

public struct DescribeRouteCalculatorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRouteCalculatorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRouteCalculatorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRouteCalculatorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRouteCalculatorOutputError>
}

public struct DescribeRouteCalculatorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRouteCalculatorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeRouteCalculatorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "routes.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRouteCalculatorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRouteCalculatorOutputError>
}

public struct DescribeRouteCalculatorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRouteCalculatorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeRouteCalculatorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let calculatorName = input.calculatorName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("calculatorName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRouteCalculatorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRouteCalculatorOutputError>
}

public struct DescribeRouteCalculatorInput: Swift.Equatable {
    /// The name of the route calculator resource.
    /// This member is required.
    public var calculatorName: Swift.String?

    public init (
        calculatorName: Swift.String? = nil
    )
    {
        self.calculatorName = calculatorName
    }
}

struct DescribeRouteCalculatorInputBody: Swift.Equatable {
}

extension DescribeRouteCalculatorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRouteCalculatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRouteCalculatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRouteCalculatorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRouteCalculatorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRouteCalculatorOutputResponse(calculatorArn: \(Swift.String(describing: calculatorArn)), calculatorName: \(Swift.String(describing: calculatorName)), createTime: \(Swift.String(describing: createTime)), dataSource: \(Swift.String(describing: dataSource)), description: \(Swift.String(describing: description)), pricingPlan: \(Swift.String(describing: pricingPlan)), tags: \(Swift.String(describing: tags)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension DescribeRouteCalculatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRouteCalculatorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.calculatorArn = output.calculatorArn
            self.calculatorName = output.calculatorName
            self.createTime = output.createTime
            self.dataSource = output.dataSource
            self.description = output.description
            self.pricingPlan = output.pricingPlan
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.calculatorArn = nil
            self.calculatorName = nil
            self.createTime = nil
            self.dataSource = nil
            self.description = nil
            self.pricingPlan = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct DescribeRouteCalculatorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the Route calculator resource. Use the ARN when you
    ///             specify a resource across AWS.
    ///
    ///
    ///                 Format example:
    ///                         arn:aws:geo:region:account-id:route-calculator/ExampleCalculator
    ///
    ///
    ///
    /// This member is required.
    public var calculatorArn: Swift.String?
    /// The name of the route calculator resource being described.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// The timestamp when the route calculator resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
    ///
    ///
    ///                 For example, 2020–07-2T12:15:20.000Z+01:00
    ///
    ///
    ///
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The data provider of traffic and road network data. Indicates one of the available
    ///             providers:
    ///
    ///
    ///
    ///                   Esri
    ///
    ///
    ///
    ///
    ///                   Here
    ///
    ///
    ///
    ///         For more information about data providers, see <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers.
    /// This member is required.
    public var dataSource: Swift.String?
    /// The optional description of the route calculator resource.
    /// This member is required.
    public var description: Swift.String?
    /// The pricing plan selected for the specified route calculator resource.
    ///         For additional details and restrictions on each pricing plan option, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing.
    /// This member is required.
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Tags associated with route calculator resource.
    public var tags: [Swift.String:Swift.String]?
    /// The timestamp when the route calculator resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
    ///
    ///
    ///                 For example, 2020–07-2T12:15:20.000Z+01:00
    ///
    ///
    ///
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        calculatorArn: Swift.String? = nil,
        calculatorName: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        dataSource: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.calculatorArn = calculatorArn
        self.calculatorName = calculatorName
        self.createTime = createTime
        self.dataSource = dataSource
        self.description = description
        self.pricingPlan = pricingPlan
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct DescribeRouteCalculatorOutputResponseBody: Swift.Equatable {
    public let calculatorName: Swift.String?
    public let calculatorArn: Swift.String?
    public let pricingPlan: LocationClientTypes.PricingPlan?
    public let description: Swift.String?
    public let createTime: ClientRuntime.Date?
    public let updateTime: ClientRuntime.Date?
    public let dataSource: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension DescribeRouteCalculatorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorArn = "CalculatorArn"
        case calculatorName = "CalculatorName"
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case tags = "Tags"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorName)
        calculatorName = calculatorNameDecoded
        let calculatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorArn)
        calculatorArn = calculatorArnDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeTrackerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrackerInput(trackerName: \(Swift.String(describing: trackerName)))"}
}

extension DescribeTrackerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeTrackerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrackerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrackerOutputError>
}

public struct DescribeTrackerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrackerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrackerOutputError>
}

public struct DescribeTrackerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrackerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeTrackerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "tracking.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTrackerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrackerOutputError>
}

public struct DescribeTrackerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrackerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeTrackerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trackerName = input.trackerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trackerName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTrackerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrackerOutputError>
}

public struct DescribeTrackerInput: Swift.Equatable {
    /// The name of the tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        trackerName: Swift.String? = nil
    )
    {
        self.trackerName = trackerName
    }
}

struct DescribeTrackerInputBody: Swift.Equatable {
}

extension DescribeTrackerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTrackerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrackerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrackerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrackerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrackerOutputResponse(createTime: \(Swift.String(describing: createTime)), description: \(Swift.String(describing: description)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), pricingPlan: \(Swift.String(describing: pricingPlan)), pricingPlanDataSource: \(Swift.String(describing: pricingPlanDataSource)), tags: \(Swift.String(describing: tags)), trackerArn: \(Swift.String(describing: trackerArn)), trackerName: \(Swift.String(describing: trackerName)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension DescribeTrackerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTrackerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.description = output.description
            self.kmsKeyId = output.kmsKeyId
            self.pricingPlan = output.pricingPlan
            self.pricingPlanDataSource = output.pricingPlanDataSource
            self.tags = output.tags
            self.trackerArn = output.trackerArn
            self.trackerName = output.trackerName
            self.updateTime = output.updateTime
        } else {
            self.createTime = nil
            self.description = nil
            self.kmsKeyId = nil
            self.pricingPlan = nil
            self.pricingPlanDataSource = nil
            self.tags = nil
            self.trackerArn = nil
            self.trackerName = nil
            self.updateTime = nil
        }
    }
}

public struct DescribeTrackerOutputResponse: Swift.Equatable {
    /// The timestamp for when the tracker resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The optional description for the tracker resource.
    /// This member is required.
    public var description: Swift.String?
    /// A key identifier for an <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html">AWS KMS customer managed key assigned to the Amazon Location resource.
    public var kmsKeyId: Swift.String?
    /// The pricing plan selected for the specified tracker resource.
    ///         For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
    ///                 page.
    /// This member is required.
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// The specified data provider for the tracker resource.
    public var pricingPlanDataSource: Swift.String?
    /// The tags associated with the tracker resource.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (ARN) for the tracker resource. Used when you need to specify
    ///             a resource across all AWS.
    ///
    ///
    ///                 Format example:
    ///                         arn:aws:geo:region:account-id:tracker/ExampleTracker
    ///
    ///
    ///
    /// This member is required.
    public var trackerArn: Swift.String?
    /// The name of the tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?
    /// The timestamp for when the tracker resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        createTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.tags = tags
        self.trackerArn = trackerArn
        self.trackerName = trackerName
        self.updateTime = updateTime
    }
}

struct DescribeTrackerOutputResponseBody: Swift.Equatable {
    public let trackerName: Swift.String?
    public let trackerArn: Swift.String?
    public let description: Swift.String?
    public let pricingPlan: LocationClientTypes.PricingPlan?
    public let pricingPlanDataSource: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let createTime: ClientRuntime.Date?
    public let updateTime: ClientRuntime.Date?
    public let kmsKeyId: Swift.String?
}

extension DescribeTrackerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case tags = "Tags"
        case trackerArn = "TrackerArn"
        case trackerName = "TrackerName"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let trackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerArn)
        trackerArn = trackerArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension LocationClientTypes.DevicePosition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case position = "Position"
        case receivedTime = "ReceivedTime"
        case sampleTime = "SampleTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for position0 in position {
                try positionContainer.encode(position0)
            }
        }
        if let receivedTime = receivedTime {
            try encodeContainer.encode(receivedTime.timeIntervalSince1970, forKey: .receivedTime)
        }
        if let sampleTime = sampleTime {
            try encodeContainer.encode(sampleTime.timeIntervalSince1970, forKey: .sampleTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let receivedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .receivedTime)
        receivedTime = receivedTimeDecoded
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
    }
}

extension LocationClientTypes.DevicePosition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DevicePosition(deviceId: \(Swift.String(describing: deviceId)), position: \(Swift.String(describing: position)), receivedTime: \(Swift.String(describing: receivedTime)), sampleTime: \(Swift.String(describing: sampleTime)))"}
}

extension LocationClientTypes {
    /// Contains the device position details.
    public struct DevicePosition: Swift.Equatable {
        /// The device whose position you retrieved.
        public var deviceId: Swift.String?
        /// The last known device position.
        /// This member is required.
        public var position: [Swift.Double]?
        /// The timestamp for when the tracker resource received the device position in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var receivedTime: ClientRuntime.Date?
        /// The timestamp at which the device's position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init (
            deviceId: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            receivedTime: ClientRuntime.Date? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.deviceId = deviceId
            self.position = position
            self.receivedTime = receivedTime
            self.sampleTime = sampleTime
        }
    }

}

extension LocationClientTypes.DevicePositionUpdate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case position = "Position"
        case sampleTime = "SampleTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for position0 in position {
                try positionContainer.encode(position0)
            }
        }
        if let sampleTime = sampleTime {
            try encodeContainer.encode(sampleTime.timeIntervalSince1970, forKey: .sampleTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
    }
}

extension LocationClientTypes.DevicePositionUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DevicePositionUpdate(deviceId: \(Swift.String(describing: deviceId)), position: \(Swift.String(describing: position)), sampleTime: \(Swift.String(describing: sampleTime)))"}
}

extension LocationClientTypes {
    /// Contains the position update details for a device.
    public struct DevicePositionUpdate: Swift.Equatable {
        /// The device associated to the position update.
        /// This member is required.
        public var deviceId: Swift.String?
        /// The latest device position defined in <a href="https://earth-info.nga.mil/GandG/wgs84/index.html">WGS 84 format:
        ///                 [X or longitude, Y or latitude].
        /// This member is required.
        public var position: [Swift.Double]?
        /// The timestamp at which the device's position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ
        ///
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init (
            deviceId: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.deviceId = deviceId
            self.position = position
            self.sampleTime = sampleTime
        }
    }

}

extension LocationClientTypes {
    public enum DimensionUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case feet
        case meters
        case sdkUnknown(Swift.String)

        public static var allCases: [DimensionUnit] {
            return [
                .feet,
                .meters,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .feet: return "Feet"
            case .meters: return "Meters"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DimensionUnit(rawValue: rawValue) ?? DimensionUnit.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateTrackerConsumerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateTrackerConsumerInput(consumerArn: \(Swift.String(describing: consumerArn)), trackerName: \(Swift.String(describing: trackerName)))"}
}

extension DisassociateTrackerConsumerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateTrackerConsumerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTrackerConsumerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateTrackerConsumerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTrackerConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateTrackerConsumerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTrackerConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTrackerConsumerOutputError>
}

public struct DisassociateTrackerConsumerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTrackerConsumerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateTrackerConsumerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTrackerConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateTrackerConsumerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTrackerConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTrackerConsumerOutputError>
}

public struct DisassociateTrackerConsumerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTrackerConsumerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateTrackerConsumerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTrackerConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "tracking.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateTrackerConsumerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTrackerConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTrackerConsumerOutputError>
}

public struct DisassociateTrackerConsumerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTrackerConsumerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateTrackerConsumerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTrackerConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trackerName = input.trackerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trackerName is nil and needs a value for the path of this operation"))))
        }
        guard let consumerArn = input.consumerArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("consumerArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/consumers/\(consumerArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateTrackerConsumerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTrackerConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTrackerConsumerOutputError>
}

public struct DisassociateTrackerConsumerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the geofence collection to be disassociated from
    ///             the tracker resource. Used when you need to specify a resource across all AWS.
    ///
    ///
    ///                 Format example:
    ///                         arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer
    ///
    ///
    ///
    /// This member is required.
    public var consumerArn: Swift.String?
    /// The name of the tracker resource to be dissociated from the consumer.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        consumerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.consumerArn = consumerArn
        self.trackerName = trackerName
    }
}

struct DisassociateTrackerConsumerInputBody: Swift.Equatable {
}

extension DisassociateTrackerConsumerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateTrackerConsumerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateTrackerConsumerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateTrackerConsumerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateTrackerConsumerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateTrackerConsumerOutputResponse()"}
}

extension DisassociateTrackerConsumerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateTrackerConsumerOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateTrackerConsumerOutputResponseBody: Swift.Equatable {
}

extension DisassociateTrackerConsumerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension LocationClientTypes {
    public enum DistanceUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kilometers
        case miles
        case sdkUnknown(Swift.String)

        public static var allCases: [DistanceUnit] {
            return [
                .kilometers,
                .miles,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kilometers: return "Kilometers"
            case .miles: return "Miles"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DistanceUnit(rawValue: rawValue) ?? DistanceUnit.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes.GeofenceGeometry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case polygon = "Polygon"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let polygon = polygon {
            var polygonContainer = encodeContainer.nestedUnkeyedContainer(forKey: .polygon)
            for linearrings0 in polygon {
                var linearrings0Container = polygonContainer.nestedUnkeyedContainer()
                for linearring1 in linearrings0 {
                    var linearring1Container = linearrings0Container.nestedUnkeyedContainer()
                    for position2 in linearring1 {
                        try linearring1Container.encode(position2)
                    }
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let polygonContainer = try containerValues.decodeIfPresent([[[Swift.Double?]?]?].self, forKey: .polygon)
        var polygonDecoded0:[[[Swift.Double]]]? = nil
        if let polygonContainer = polygonContainer {
            polygonDecoded0 = [[[Swift.Double]]]()
            for list0 in polygonContainer {
                var list0Decoded0: [[Swift.Double]]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [[Swift.Double]]()
                    for list1 in list0 {
                        var list1Decoded1: [Swift.Double]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [Swift.Double]()
                            for double2 in list1 {
                                if let double2 = double2 {
                                    list1Decoded1?.append(double2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            list0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    polygonDecoded0?.append(list0Decoded0)
                }
            }
        }
        polygon = polygonDecoded0
    }
}

extension LocationClientTypes.GeofenceGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeofenceGeometry(polygon: \(Swift.String(describing: polygon)))"}
}

extension LocationClientTypes {
    /// Contains the geofence geometry details.
    ///
    ///             Amazon Location doesn't currently support polygons with holes, multipolygons, polygons
    ///                 that are wound clockwise, or that cross the antimeridian.
    ///
    public struct GeofenceGeometry: Swift.Equatable {
        /// An array of 1 or more linear rings. A linear ring is an array of 4 or more vertices,
        ///             where the first and last vertex are the same to form a closed boundary. Each vertex is a
        ///             2-dimensional point of the form: [longitude, latitude].
        ///         The first linear ring is an outer ring, describing the polygon's boundary. Subsequent
        ///             linear rings may be inner or outer rings to describe holes and islands. Outer rings must
        ///             list their vertices in counter-clockwise order around the ring's center, where the left
        ///             side is the polygon's exterior. Inner rings must list their vertices in clockwise order,
        ///             where the left side is the polygon's interior.
        public var polygon: [[[Swift.Double]]]?

        public init (
            polygon: [[[Swift.Double]]]? = nil
        )
        {
            self.polygon = polygon
        }
    }

}

public struct GetDevicePositionHistoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePositionHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicePositionHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePositionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicePositionHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePositionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePositionHistoryOutputError>
}

extension GetDevicePositionHistoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicePositionHistoryInput(deviceId: \(Swift.String(describing: deviceId)), endTimeExclusive: \(Swift.String(describing: endTimeExclusive)), nextToken: \(Swift.String(describing: nextToken)), startTimeInclusive: \(Swift.String(describing: startTimeInclusive)), trackerName: \(Swift.String(describing: trackerName)))"}
}

extension GetDevicePositionHistoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTimeExclusive = "EndTimeExclusive"
        case nextToken = "NextToken"
        case startTimeInclusive = "StartTimeInclusive"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTimeExclusive = endTimeExclusive {
            try encodeContainer.encode(endTimeExclusive.timeIntervalSince1970, forKey: .endTimeExclusive)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTimeInclusive = startTimeInclusive {
            try encodeContainer.encode(startTimeInclusive.timeIntervalSince1970, forKey: .startTimeInclusive)
        }
    }
}

public struct GetDevicePositionHistoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePositionHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicePositionHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePositionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicePositionHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePositionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePositionHistoryOutputError>
}

public struct GetDevicePositionHistoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePositionHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicePositionHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePositionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicePositionHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePositionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePositionHistoryOutputError>
}

public struct GetDevicePositionHistoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePositionHistoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDevicePositionHistoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePositionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "tracking.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDevicePositionHistoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePositionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePositionHistoryOutputError>
}

public struct GetDevicePositionHistoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePositionHistoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDevicePositionHistoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePositionHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trackerName = input.trackerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trackerName is nil and needs a value for the path of this operation"))))
        }
        guard let deviceId = input.deviceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("deviceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())/list-positions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDevicePositionHistoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePositionHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePositionHistoryOutputError>
}

public struct GetDevicePositionHistoryInput: Swift.Equatable {
    /// The device whose position history you want to retrieve.
    /// This member is required.
    public var deviceId: Swift.String?
    /// Specify the end time for the position history in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be the time
    ///             that the request is made.
    ///         Requirement:
    ///
    ///
    ///                The time specified for EndTimeExclusive must be after the time for
    ///                         StartTimeInclusive.
    ///
    ///
    public var endTimeExclusive: ClientRuntime.Date?
    /// The pagination token specifying which page of results to return in the response. If no
    ///             token is provided, the default page is the first page.
    ///          Default value: null
    ///
    public var nextToken: Swift.String?
    /// Specify the start time for the position history in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ. By default, the value will be 24 hours
    ///             prior to the time that the request is made.
    ///         Requirement:
    ///
    ///
    ///                The time specified for StartTimeInclusive must be before
    ///                         EndTimeExclusive.
    ///
    ///
    public var startTimeInclusive: ClientRuntime.Date?
    /// The tracker resource receiving the request for the device position history.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        endTimeExclusive: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        startTimeInclusive: ClientRuntime.Date? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.endTimeExclusive = endTimeExclusive
        self.nextToken = nextToken
        self.startTimeInclusive = startTimeInclusive
        self.trackerName = trackerName
    }
}

struct GetDevicePositionHistoryInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let startTimeInclusive: ClientRuntime.Date?
    public let endTimeExclusive: ClientRuntime.Date?
}

extension GetDevicePositionHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTimeExclusive = "EndTimeExclusive"
        case nextToken = "NextToken"
        case startTimeInclusive = "StartTimeInclusive"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let startTimeInclusiveDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTimeInclusive)
        startTimeInclusive = startTimeInclusiveDecoded
        let endTimeExclusiveDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTimeExclusive)
        endTimeExclusive = endTimeExclusiveDecoded
    }
}

extension GetDevicePositionHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicePositionHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDevicePositionHistoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicePositionHistoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicePositionHistoryOutputResponse(devicePositions: \(Swift.String(describing: devicePositions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetDevicePositionHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDevicePositionHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devicePositions = output.devicePositions
            self.nextToken = output.nextToken
        } else {
            self.devicePositions = nil
            self.nextToken = nil
        }
    }
}

public struct GetDevicePositionHistoryOutputResponse: Swift.Equatable {
    /// Contains the position history details for the requested device.
    /// This member is required.
    public var devicePositions: [LocationClientTypes.DevicePosition]?
    /// A pagination token indicating there are additional pages available. You can use the
    ///             token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        devicePositions: [LocationClientTypes.DevicePosition]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devicePositions = devicePositions
        self.nextToken = nextToken
    }
}

struct GetDevicePositionHistoryOutputResponseBody: Swift.Equatable {
    public let devicePositions: [LocationClientTypes.DevicePosition]?
    public let nextToken: Swift.String?
}

extension GetDevicePositionHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePositions = "DevicePositions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePositionsContainer = try containerValues.decodeIfPresent([LocationClientTypes.DevicePosition?].self, forKey: .devicePositions)
        var devicePositionsDecoded0:[LocationClientTypes.DevicePosition]? = nil
        if let devicePositionsContainer = devicePositionsContainer {
            devicePositionsDecoded0 = [LocationClientTypes.DevicePosition]()
            for structure0 in devicePositionsContainer {
                if let structure0 = structure0 {
                    devicePositionsDecoded0?.append(structure0)
                }
            }
        }
        devicePositions = devicePositionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDevicePositionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicePositionInput(deviceId: \(Swift.String(describing: deviceId)), trackerName: \(Swift.String(describing: trackerName)))"}
}

extension GetDevicePositionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDevicePositionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePositionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicePositionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicePositionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePositionOutputError>
}

public struct GetDevicePositionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePositionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDevicePositionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDevicePositionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePositionOutputError>
}

public struct GetDevicePositionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePositionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDevicePositionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "tracking.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDevicePositionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePositionOutputError>
}

public struct GetDevicePositionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDevicePositionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDevicePositionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDevicePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trackerName = input.trackerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trackerName is nil and needs a value for the path of this operation"))))
        }
        guard let deviceId = input.deviceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("deviceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())/positions/latest"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDevicePositionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDevicePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDevicePositionOutputError>
}

public struct GetDevicePositionInput: Swift.Equatable {
    /// The device whose position you want to retrieve.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The tracker resource receiving the position update.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.trackerName = trackerName
    }
}

struct GetDevicePositionInputBody: Swift.Equatable {
}

extension GetDevicePositionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDevicePositionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicePositionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDevicePositionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicePositionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDevicePositionOutputResponse(deviceId: \(Swift.String(describing: deviceId)), position: \(Swift.String(describing: position)), receivedTime: \(Swift.String(describing: receivedTime)), sampleTime: \(Swift.String(describing: sampleTime)))"}
}

extension GetDevicePositionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDevicePositionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceId = output.deviceId
            self.position = output.position
            self.receivedTime = output.receivedTime
            self.sampleTime = output.sampleTime
        } else {
            self.deviceId = nil
            self.position = nil
            self.receivedTime = nil
            self.sampleTime = nil
        }
    }
}

public struct GetDevicePositionOutputResponse: Swift.Equatable {
    /// The device whose position you retrieved.
    public var deviceId: Swift.String?
    /// The last known device position.
    /// This member is required.
    public var position: [Swift.Double]?
    /// The timestamp for when the tracker resource received the device position in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var receivedTime: ClientRuntime.Date?
    /// The timestamp at which the device's position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var sampleTime: ClientRuntime.Date?

    public init (
        deviceId: Swift.String? = nil,
        position: [Swift.Double]? = nil,
        receivedTime: ClientRuntime.Date? = nil,
        sampleTime: ClientRuntime.Date? = nil
    )
    {
        self.deviceId = deviceId
        self.position = position
        self.receivedTime = receivedTime
        self.sampleTime = sampleTime
    }
}

struct GetDevicePositionOutputResponseBody: Swift.Equatable {
    public let deviceId: Swift.String?
    public let sampleTime: ClientRuntime.Date?
    public let receivedTime: ClientRuntime.Date?
    public let position: [Swift.Double]?
}

extension GetDevicePositionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case position = "Position"
        case receivedTime = "ReceivedTime"
        case sampleTime = "SampleTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let receivedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .receivedTime)
        receivedTime = receivedTimeDecoded
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
    }
}

extension GetGeofenceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGeofenceInput(collectionName: \(Swift.String(describing: collectionName)), geofenceId: \(Swift.String(describing: geofenceId)))"}
}

extension GetGeofenceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetGeofenceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGeofenceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetGeofenceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetGeofenceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGeofenceOutputError>
}

public struct GetGeofenceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGeofenceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetGeofenceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetGeofenceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGeofenceOutputError>
}

public struct GetGeofenceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGeofenceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetGeofenceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "geofencing.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetGeofenceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGeofenceOutputError>
}

public struct GetGeofenceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGeofenceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetGeofenceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let collectionName = input.collectionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("collectionName is nil and needs a value for the path of this operation"))))
        }
        guard let geofenceId = input.geofenceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("geofenceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/geofences/\(geofenceId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetGeofenceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGeofenceOutputError>
}

public struct GetGeofenceInput: Swift.Equatable {
    /// The geofence collection storing the target geofence.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The geofence you're retrieving details for.
    /// This member is required.
    public var geofenceId: Swift.String?

    public init (
        collectionName: Swift.String? = nil,
        geofenceId: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
        self.geofenceId = geofenceId
    }
}

struct GetGeofenceInputBody: Swift.Equatable {
}

extension GetGeofenceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGeofenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGeofenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGeofenceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGeofenceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGeofenceOutputResponse(createTime: \(Swift.String(describing: createTime)), geofenceId: \(Swift.String(describing: geofenceId)), geometry: \(Swift.String(describing: geometry)), status: \(Swift.String(describing: status)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension GetGeofenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetGeofenceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.geofenceId = output.geofenceId
            self.geometry = output.geometry
            self.status = output.status
            self.updateTime = output.updateTime
        } else {
            self.createTime = nil
            self.geofenceId = nil
            self.geometry = nil
            self.status = nil
            self.updateTime = nil
        }
    }
}

public struct GetGeofenceOutputResponse: Swift.Equatable {
    /// The timestamp for when the geofence collection was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ
    ///
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The geofence identifier.
    /// This member is required.
    public var geofenceId: Swift.String?
    /// Contains the geofence geometry details describing a polygon.
    /// This member is required.
    public var geometry: LocationClientTypes.GeofenceGeometry?
    /// Identifies the state of the geofence. A geofence will hold one of the following
    ///             states:
    ///
    ///
    ///
    ///                   ACTIVE — The geofence has been indexed by the system.
    ///
    ///
    ///
    ///                   PENDING — The geofence is being processed by the system.
    ///
    ///
    ///
    ///                   FAILED — The geofence failed to be indexed by the system.
    ///
    ///
    ///
    ///                   DELETED — The geofence has been deleted from the system
    ///                     index.
    ///
    ///
    ///
    ///                   DELETING — The geofence is being deleted from the system
    ///                     index.
    ///
    ///
    /// This member is required.
    public var status: Swift.String?
    /// The timestamp for when the geofence collection was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ
    ///
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        createTime: ClientRuntime.Date? = nil,
        geofenceId: Swift.String? = nil,
        geometry: LocationClientTypes.GeofenceGeometry? = nil,
        status: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.geofenceId = geofenceId
        self.geometry = geometry
        self.status = status
        self.updateTime = updateTime
    }
}

struct GetGeofenceOutputResponseBody: Swift.Equatable {
    public let geofenceId: Swift.String?
    public let geometry: LocationClientTypes.GeofenceGeometry?
    public let status: Swift.String?
    public let createTime: ClientRuntime.Date?
    public let updateTime: ClientRuntime.Date?
}

extension GetGeofenceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case geofenceId = "GeofenceId"
        case geometry = "Geometry"
        case status = "Status"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.GeofenceGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension GetMapGlyphsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapGlyphsInput(fontStack: \(Swift.String(describing: fontStack)), fontUnicodeRange: \(Swift.String(describing: fontUnicodeRange)), mapName: \(Swift.String(describing: mapName)))"}
}

extension GetMapGlyphsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetMapGlyphsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapGlyphsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMapGlyphsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapGlyphsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMapGlyphsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapGlyphsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapGlyphsOutputError>
}

public struct GetMapGlyphsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapGlyphsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMapGlyphsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapGlyphsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMapGlyphsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapGlyphsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapGlyphsOutputError>
}

public struct GetMapGlyphsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapGlyphsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMapGlyphsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapGlyphsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "maps.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMapGlyphsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapGlyphsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapGlyphsOutputError>
}

public struct GetMapGlyphsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapGlyphsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMapGlyphsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapGlyphsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let mapName = input.mapName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("mapName is nil and needs a value for the path of this operation"))))
        }
        guard let fontStack = input.fontStack else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("fontStack is nil and needs a value for the path of this operation"))))
        }
        guard let fontUnicodeRange = input.fontUnicodeRange else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("fontUnicodeRange is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/maps/v0/maps/\(mapName.urlPercentEncoding())/glyphs/\(fontStack.urlPercentEncoding())/\(fontUnicodeRange.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMapGlyphsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapGlyphsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapGlyphsOutputError>
}

public struct GetMapGlyphsInput: Swift.Equatable {
    /// A comma-separated list of fonts to load glyphs from in order of preference. For
    ///             example, Noto Sans Regular, Arial Unicode.
    ///         Valid fonts for <a href="https://docs.aws.amazon.com/location/latest/developerguide/esri.html">Esri styles:
    ///
    ///
    ///                 VectorEsriDarkGrayCanvas – Ubuntu Medium Italic | Ubuntu
    ///                         Medium | Ubuntu Italic | Ubuntu Regular |
    ///                         Ubuntu Bold
    ///
    ///
    ///
    ///                 VectorEsriLightGrayCanvas – Ubuntu Italic | Ubuntu
    ///                         Regular | Ubuntu Light | Ubuntu Bold
    ///
    ///
    ///
    ///                 VectorEsriTopographic – Noto Sans Italic | Noto Sans
    ///                         Regular | Noto Sans Bold | Noto Serif
    ///                         Regular | Roboto Condensed Light Italic
    ///
    ///
    ///
    ///                 VectorEsriStreets – Arial Regular | Arial Italic |
    ///                         Arial Bold
    ///
    ///
    ///
    ///                 VectorEsriNavigation – Arial Regular | Arial Italic
    ///                     | Arial Bold
    ///
    ///
    ///
    ///         Valid fonts for <a href="https://docs.aws.amazon.com/location/latest/developerguide/HERE.html">HERE Technologies styles:
    ///
    ///
    ///
    ///                   VectorHereBerlin – Fira GO Regular | Fira GO
    ///                         Bold
    ///
    ///
    ///
    /// This member is required.
    public var fontStack: Swift.String?
    /// A Unicode range of characters to download glyphs for. Each response will contain 256
    ///             characters. For example, 0–255 includes all characters from range U+0000 to
    ///                 00FF. Must be aligned to multiples of 256.
    /// This member is required.
    public var fontUnicodeRange: Swift.String?
    /// The map resource associated with the glyph ﬁle.
    /// This member is required.
    public var mapName: Swift.String?

    public init (
        fontStack: Swift.String? = nil,
        fontUnicodeRange: Swift.String? = nil,
        mapName: Swift.String? = nil
    )
    {
        self.fontStack = fontStack
        self.fontUnicodeRange = fontUnicodeRange
        self.mapName = mapName
    }
}

struct GetMapGlyphsInputBody: Swift.Equatable {
}

extension GetMapGlyphsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMapGlyphsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMapGlyphsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMapGlyphsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMapGlyphsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapGlyphsOutputResponse(blob: \(Swift.String(describing: blob)), contentType: \(Swift.String(describing: contentType)))"}
}

extension GetMapGlyphsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.blob = data
        } else {
            self.blob = nil
        }
    }
}

public struct GetMapGlyphsOutputResponse: Swift.Equatable {
    /// The blob's content type.
    public var blob: ClientRuntime.Data?
    /// The map glyph content type. For example, application/octet-stream.
    public var contentType: Swift.String?

    public init (
        blob: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.contentType = contentType
    }
}

struct GetMapGlyphsOutputResponseBody: Swift.Equatable {
    public let blob: ClientRuntime.Data?
}

extension GetMapGlyphsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blob = "Blob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .blob)
        blob = blobDecoded
    }
}

extension GetMapSpritesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapSpritesInput(fileName: \(Swift.String(describing: fileName)), mapName: \(Swift.String(describing: mapName)))"}
}

extension GetMapSpritesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetMapSpritesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapSpritesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMapSpritesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapSpritesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMapSpritesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapSpritesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapSpritesOutputError>
}

public struct GetMapSpritesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapSpritesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMapSpritesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapSpritesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMapSpritesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapSpritesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapSpritesOutputError>
}

public struct GetMapSpritesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapSpritesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMapSpritesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapSpritesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "maps.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMapSpritesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapSpritesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapSpritesOutputError>
}

public struct GetMapSpritesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapSpritesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMapSpritesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapSpritesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let mapName = input.mapName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("mapName is nil and needs a value for the path of this operation"))))
        }
        guard let fileName = input.fileName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("fileName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/maps/v0/maps/\(mapName.urlPercentEncoding())/sprites/\(fileName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMapSpritesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapSpritesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapSpritesOutputError>
}

public struct GetMapSpritesInput: Swift.Equatable {
    /// The name of the sprite ﬁle. Use the following ﬁle names for the sprite sheet:
    ///
    ///
    ///
    ///                   sprites.png
    ///
    ///
    ///
    ///
    ///                   sprites@2x.png for high pixel density displays
    ///
    ///
    ///         For the JSON document contain image offsets. Use the following ﬁle names:
    ///
    ///
    ///
    ///                   sprites.json
    ///
    ///
    ///
    ///
    ///                   sprites@2x.json for high pixel density displays
    ///
    ///
    /// This member is required.
    public var fileName: Swift.String?
    /// The map resource associated with the sprite ﬁle.
    /// This member is required.
    public var mapName: Swift.String?

    public init (
        fileName: Swift.String? = nil,
        mapName: Swift.String? = nil
    )
    {
        self.fileName = fileName
        self.mapName = mapName
    }
}

struct GetMapSpritesInputBody: Swift.Equatable {
}

extension GetMapSpritesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMapSpritesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMapSpritesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMapSpritesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMapSpritesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapSpritesOutputResponse(blob: \(Swift.String(describing: blob)), contentType: \(Swift.String(describing: contentType)))"}
}

extension GetMapSpritesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.blob = data
        } else {
            self.blob = nil
        }
    }
}

public struct GetMapSpritesOutputResponse: Swift.Equatable {
    /// Contains the body of the sprite sheet or JSON offset ﬁle.
    public var blob: ClientRuntime.Data?
    /// The content type of the sprite sheet and offsets. For example, the sprite sheet
    ///             content type is image/png, and the sprite offset JSON document is
    ///                 application/json.
    public var contentType: Swift.String?

    public init (
        blob: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.contentType = contentType
    }
}

struct GetMapSpritesOutputResponseBody: Swift.Equatable {
    public let blob: ClientRuntime.Data?
}

extension GetMapSpritesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blob = "Blob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .blob)
        blob = blobDecoded
    }
}

extension GetMapStyleDescriptorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapStyleDescriptorInput(mapName: \(Swift.String(describing: mapName)))"}
}

extension GetMapStyleDescriptorInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetMapStyleDescriptorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapStyleDescriptorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMapStyleDescriptorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapStyleDescriptorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMapStyleDescriptorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapStyleDescriptorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapStyleDescriptorOutputError>
}

public struct GetMapStyleDescriptorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapStyleDescriptorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMapStyleDescriptorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapStyleDescriptorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMapStyleDescriptorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapStyleDescriptorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapStyleDescriptorOutputError>
}

public struct GetMapStyleDescriptorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapStyleDescriptorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMapStyleDescriptorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapStyleDescriptorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "maps.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMapStyleDescriptorInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapStyleDescriptorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapStyleDescriptorOutputError>
}

public struct GetMapStyleDescriptorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapStyleDescriptorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMapStyleDescriptorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapStyleDescriptorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let mapName = input.mapName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("mapName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/maps/v0/maps/\(mapName.urlPercentEncoding())/style-descriptor"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMapStyleDescriptorInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapStyleDescriptorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapStyleDescriptorOutputError>
}

public struct GetMapStyleDescriptorInput: Swift.Equatable {
    /// The map resource to retrieve the style descriptor from.
    /// This member is required.
    public var mapName: Swift.String?

    public init (
        mapName: Swift.String? = nil
    )
    {
        self.mapName = mapName
    }
}

struct GetMapStyleDescriptorInputBody: Swift.Equatable {
}

extension GetMapStyleDescriptorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMapStyleDescriptorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMapStyleDescriptorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMapStyleDescriptorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMapStyleDescriptorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapStyleDescriptorOutputResponse(blob: \(Swift.String(describing: blob)), contentType: \(Swift.String(describing: contentType)))"}
}

extension GetMapStyleDescriptorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.blob = data
        } else {
            self.blob = nil
        }
    }
}

public struct GetMapStyleDescriptorOutputResponse: Swift.Equatable {
    /// Contains the body of the style descriptor.
    public var blob: ClientRuntime.Data?
    /// The style descriptor's content type. For example,
    ///             application/json.
    public var contentType: Swift.String?

    public init (
        blob: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.contentType = contentType
    }
}

struct GetMapStyleDescriptorOutputResponseBody: Swift.Equatable {
    public let blob: ClientRuntime.Data?
}

extension GetMapStyleDescriptorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blob = "Blob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .blob)
        blob = blobDecoded
    }
}

extension GetMapTileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapTileInput(mapName: \(Swift.String(describing: mapName)), x: \(Swift.String(describing: x)), y: \(Swift.String(describing: y)), z: \(Swift.String(describing: z)))"}
}

extension GetMapTileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetMapTileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapTileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMapTileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapTileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMapTileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapTileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapTileOutputError>
}

public struct GetMapTileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapTileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMapTileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapTileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMapTileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapTileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapTileOutputError>
}

public struct GetMapTileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapTileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMapTileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapTileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "maps.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMapTileInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapTileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapTileOutputError>
}

public struct GetMapTileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMapTileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMapTileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMapTileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let mapName = input.mapName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("mapName is nil and needs a value for the path of this operation"))))
        }
        guard let z = input.z else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("z is nil and needs a value for the path of this operation"))))
        }
        guard let x = input.x else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("x is nil and needs a value for the path of this operation"))))
        }
        guard let y = input.y else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("y is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/maps/v0/maps/\(mapName.urlPercentEncoding())/tiles/\(z.urlPercentEncoding())/\(x.urlPercentEncoding())/\(y.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMapTileInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMapTileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMapTileOutputError>
}

public struct GetMapTileInput: Swift.Equatable {
    /// The map resource to retrieve the map tiles from.
    /// This member is required.
    public var mapName: Swift.String?
    /// The X axis value for the map tile.
    /// This member is required.
    public var x: Swift.String?
    /// The Y axis value for the map tile.
    /// This member is required.
    public var y: Swift.String?
    /// The zoom value for the map tile.
    /// This member is required.
    public var z: Swift.String?

    public init (
        mapName: Swift.String? = nil,
        x: Swift.String? = nil,
        y: Swift.String? = nil,
        z: Swift.String? = nil
    )
    {
        self.mapName = mapName
        self.x = x
        self.y = y
        self.z = z
    }
}

struct GetMapTileInputBody: Swift.Equatable {
}

extension GetMapTileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMapTileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMapTileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMapTileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMapTileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMapTileOutputResponse(blob: \(Swift.String(describing: blob)), contentType: \(Swift.String(describing: contentType)))"}
}

extension GetMapTileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.blob = data
        } else {
            self.blob = nil
        }
    }
}

public struct GetMapTileOutputResponse: Swift.Equatable {
    /// Contains Mapbox Vector Tile (MVT) data.
    public var blob: ClientRuntime.Data?
    /// The map tile's content type. For example,
    ///                 application/vnd.mapbox-vector-tile.
    public var contentType: Swift.String?

    public init (
        blob: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.blob = blob
        self.contentType = contentType
    }
}

struct GetMapTileOutputResponseBody: Swift.Equatable {
    public let blob: ClientRuntime.Data?
}

extension GetMapTileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blob = "Blob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .blob)
        blob = blobDecoded
    }
}

extension LocationClientTypes {
    public enum IntendedUse: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleuse
        /// Indicates that results of the operation may be stored locally.
        case storage
        case sdkUnknown(Swift.String)

        public static var allCases: [IntendedUse] {
            return [
                .singleuse,
                .storage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .singleuse: return "SingleUse"
            case .storage: return "Storage"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntendedUse(rawValue: rawValue) ?? IntendedUse.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has failed to process because of an unknown server error, exception, or failure.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes.Leg: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distance = "Distance"
        case durationSeconds = "DurationSeconds"
        case endPosition = "EndPosition"
        case geometry = "Geometry"
        case startPosition = "StartPosition"
        case steps = "Steps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distance = distance {
            try encodeContainer.encode(distance, forKey: .distance)
        }
        if let durationSeconds = durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let endPosition = endPosition {
            var endPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endPosition)
            for position0 in endPosition {
                try endPositionContainer.encode(position0)
            }
        }
        if let geometry = geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
        if let startPosition = startPosition {
            var startPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startPosition)
            for position0 in startPosition {
                try startPositionContainer.encode(position0)
            }
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for steplist0 in steps {
                try stepsContainer.encode(steplist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .startPosition)
        var startPositionDecoded0:[Swift.Double]? = nil
        if let startPositionContainer = startPositionContainer {
            startPositionDecoded0 = [Swift.Double]()
            for double0 in startPositionContainer {
                if let double0 = double0 {
                    startPositionDecoded0?.append(double0)
                }
            }
        }
        startPosition = startPositionDecoded0
        let endPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .endPosition)
        var endPositionDecoded0:[Swift.Double]? = nil
        if let endPositionContainer = endPositionContainer {
            endPositionDecoded0 = [Swift.Double]()
            for double0 in endPositionContainer {
                if let double0 = double0 {
                    endPositionDecoded0?.append(double0)
                }
            }
        }
        endPosition = endPositionDecoded0
        let distanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .distance)
        distance = distanceDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.LegGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let stepsContainer = try containerValues.decodeIfPresent([LocationClientTypes.Step?].self, forKey: .steps)
        var stepsDecoded0:[LocationClientTypes.Step]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [LocationClientTypes.Step]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension LocationClientTypes.Leg: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Leg(distance: \(Swift.String(describing: distance)), durationSeconds: \(Swift.String(describing: durationSeconds)), endPosition: \(Swift.String(describing: endPosition)), geometry: \(Swift.String(describing: geometry)), startPosition: \(Swift.String(describing: startPosition)), steps: \(Swift.String(describing: steps)))"}
}

extension LocationClientTypes {
    /// Contains the calculated route's details for each path between a pair of positions. The
    ///             number of legs returned corresponds to one fewer than the total number of positions in
    ///             the request.
    ///         For example, a route with a departure position and destination position returns one
    ///             leg with the positions <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">snapped to a nearby road:
    ///
    ///
    ///                 The StartPosition is the departure position.
    ///
    ///
    ///                 The EndPosition is the destination position.
    ///
    ///
    ///         A route with a waypoint between the departure and destination position returns two
    ///             legs with the positions snapped to a nearby road:
    ///
    ///
    ///                 Leg 1: The StartPosition is the departure position . The
    ///                         EndPosition is the waypoint positon.
    ///
    ///
    ///                 Leg 2: The StartPosition is the waypoint position. The
    ///                         EndPosition is the destination position.
    ///
    ///
    public struct Leg: Swift.Equatable {
        /// The distance between the leg's StartPosition and EndPosition
        ///             along a calculated route.
        ///
        ///
        ///                 The default measurement is Kilometers unless the request
        ///                     specifies a DistanceUnit of Miles.
        ///
        ///
        /// This member is required.
        public var distance: Swift.Double?
        /// The estimated travel time between the leg's StartPosition and
        ///                 EndPosition. The travel mode and departure time that you specify in the
        ///             request determines the calculated time.
        /// This member is required.
        public var durationSeconds: Swift.Double?
        /// The terminating position of the leg. Follows the format
        ///                 [longitude,latitude].
        ///
        ///             If the EndPosition isn't located on a road, it's <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">snapped to a nearby road.
        ///
        /// This member is required.
        public var endPosition: [Swift.Double]?
        /// Contains the calculated route's path as a linestring geometry.
        public var geometry: LocationClientTypes.LegGeometry?
        /// The starting position of the leg. Follows the format
        ///             [longitude,latitude].
        ///
        ///             If the StartPosition isn't located on a road, it's <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">snapped to a nearby road.
        ///
        /// This member is required.
        public var startPosition: [Swift.Double]?
        /// Contains a list of steps, which represent subsections of a leg. Each step provides
        ///             instructions for how to move to the next step in the leg such as the step's start
        ///             position, end position, travel distance, travel duration, and geometry offset.
        /// This member is required.
        public var steps: [LocationClientTypes.Step]?

        public init (
            distance: Swift.Double? = nil,
            durationSeconds: Swift.Double? = nil,
            endPosition: [Swift.Double]? = nil,
            geometry: LocationClientTypes.LegGeometry? = nil,
            startPosition: [Swift.Double]? = nil,
            steps: [LocationClientTypes.Step]? = nil
        )
        {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.endPosition = endPosition
            self.geometry = geometry
            self.startPosition = startPosition
            self.steps = steps
        }
    }

}

extension LocationClientTypes.LegGeometry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lineString = "LineString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lineString = lineString {
            var lineStringContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineString)
            for linestring0 in lineString {
                var linestring0Container = lineStringContainer.nestedUnkeyedContainer()
                for position1 in linestring0 {
                    try linestring0Container.encode(position1)
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineStringContainer = try containerValues.decodeIfPresent([[Swift.Double?]?].self, forKey: .lineString)
        var lineStringDecoded0:[[Swift.Double]]? = nil
        if let lineStringContainer = lineStringContainer {
            lineStringDecoded0 = [[Swift.Double]]()
            for list0 in lineStringContainer {
                var list0Decoded0: [Swift.Double]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.Double]()
                    for double1 in list0 {
                        if let double1 = double1 {
                            list0Decoded0?.append(double1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    lineStringDecoded0?.append(list0Decoded0)
                }
            }
        }
        lineString = lineStringDecoded0
    }
}

extension LocationClientTypes.LegGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LegGeometry(lineString: \(Swift.String(describing: lineString)))"}
}

extension LocationClientTypes {
    /// Contains the geometry details for each path between a pair of positions. Used in
    ///             plotting a route leg on a map.
    public struct LegGeometry: Swift.Equatable {
        /// An ordered list of positions used to plot a route on a map.
        ///         The first position is closest to the start position for the leg, and the last position
        ///             is the closest to the end position for the leg.
        ///
        ///
        ///                 For example, [[-123.117, 49.284],[-123.115, 49.285],[-123.115,
        ///                         49.285]]
        ///
        ///
        ///
        public var lineString: [[Swift.Double]]?

        public init (
            lineString: [[Swift.Double]]? = nil
        )
        {
            self.lineString = lineString
        }
    }

}

public struct ListDevicePositionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicePositionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevicePositionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicePositionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevicePositionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicePositionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicePositionsOutputError>
}

extension ListDevicePositionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevicePositionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), trackerName: \(Swift.String(describing: trackerName)))"}
}

extension ListDevicePositionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDevicePositionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicePositionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevicePositionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicePositionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevicePositionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicePositionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicePositionsOutputError>
}

public struct ListDevicePositionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicePositionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevicePositionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicePositionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevicePositionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicePositionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicePositionsOutputError>
}

public struct ListDevicePositionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicePositionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDevicePositionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicePositionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "tracking.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDevicePositionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicePositionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicePositionsOutputError>
}

public struct ListDevicePositionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicePositionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDevicePositionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicePositionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trackerName = input.trackerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trackerName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/list-positions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDevicePositionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicePositionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicePositionsOutputError>
}

public struct ListDevicePositionsInput: Swift.Equatable {
    /// An optional limit for the number of entries returned in a single call.
    ///         Default value: 100
    ///
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no
    ///             token is provided, the default page is the first page.
    ///          Default value: null
    ///
    public var nextToken: Swift.String?
    /// The tracker resource containing the requested devices.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trackerName = trackerName
    }
}

struct ListDevicePositionsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListDevicePositionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDevicePositionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicePositionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDevicePositionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicePositionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevicePositionsOutputResponse(entries: \(Swift.String(describing: entries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDevicePositionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDevicePositionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevicePositionsOutputResponse: Swift.Equatable {
    /// Contains details about each device's last known position. These details includes the device ID,
    ///             the time when the position was sampled on the device, the time that the service received the update, and the most recent coordinates.
    /// This member is required.
    public var entries: [LocationClientTypes.ListDevicePositionsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the
    ///             token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        entries: [LocationClientTypes.ListDevicePositionsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListDevicePositionsOutputResponseBody: Swift.Equatable {
    public let entries: [LocationClientTypes.ListDevicePositionsResponseEntry]?
    public let nextToken: Swift.String?
}

extension ListDevicePositionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListDevicePositionsResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListDevicePositionsResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListDevicePositionsResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LocationClientTypes.ListDevicePositionsResponseEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case position = "Position"
        case sampleTime = "SampleTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for position0 in position {
                try positionContainer.encode(position0)
            }
        }
        if let sampleTime = sampleTime {
            try encodeContainer.encode(sampleTime.timeIntervalSince1970, forKey: .sampleTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let sampleTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .sampleTime)
        sampleTime = sampleTimeDecoded
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
    }
}

extension LocationClientTypes.ListDevicePositionsResponseEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevicePositionsResponseEntry(deviceId: \(Swift.String(describing: deviceId)), position: \(Swift.String(describing: position)), sampleTime: \(Swift.String(describing: sampleTime)))"}
}

extension LocationClientTypes {
    /// Contains the tracker resource details.
    public struct ListDevicePositionsResponseEntry: Swift.Equatable {
        /// The ID of the device for this position.
        /// This member is required.
        public var deviceId: Swift.String?
        /// The last known device position. Empty if no positions currently stored.
        /// This member is required.
        public var position: [Swift.Double]?
        /// The timestamp at which the device position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var sampleTime: ClientRuntime.Date?

        public init (
            deviceId: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            sampleTime: ClientRuntime.Date? = nil
        )
        {
            self.deviceId = deviceId
            self.position = position
            self.sampleTime = sampleTime
        }
    }

}

public struct ListGeofenceCollectionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGeofenceCollectionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGeofenceCollectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGeofenceCollectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGeofenceCollectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGeofenceCollectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGeofenceCollectionsOutputError>
}

extension ListGeofenceCollectionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGeofenceCollectionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListGeofenceCollectionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListGeofenceCollectionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGeofenceCollectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGeofenceCollectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGeofenceCollectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGeofenceCollectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGeofenceCollectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGeofenceCollectionsOutputError>
}

public struct ListGeofenceCollectionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGeofenceCollectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGeofenceCollectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGeofenceCollectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGeofenceCollectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGeofenceCollectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGeofenceCollectionsOutputError>
}

public struct ListGeofenceCollectionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGeofenceCollectionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListGeofenceCollectionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGeofenceCollectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "geofencing.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListGeofenceCollectionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListGeofenceCollectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGeofenceCollectionsOutputError>
}

public struct ListGeofenceCollectionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGeofenceCollectionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListGeofenceCollectionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGeofenceCollectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/geofencing/v0/list-collections"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListGeofenceCollectionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListGeofenceCollectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGeofenceCollectionsOutputError>
}

public struct ListGeofenceCollectionsInput: Swift.Equatable {
    /// An optional limit for the number of resources returned in a single call.
    ///         Default value: 100
    ///
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no
    ///             token is provided, the default page is the first page.
    ///         Default value: null
    ///
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGeofenceCollectionsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListGeofenceCollectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGeofenceCollectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGeofenceCollectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGeofenceCollectionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGeofenceCollectionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGeofenceCollectionsOutputResponse(entries: \(Swift.String(describing: entries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListGeofenceCollectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGeofenceCollectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListGeofenceCollectionsOutputResponse: Swift.Equatable {
    /// Lists the geofence collections that exist in your AWS account.
    /// This member is required.
    public var entries: [LocationClientTypes.ListGeofenceCollectionsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the
    ///             token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        entries: [LocationClientTypes.ListGeofenceCollectionsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListGeofenceCollectionsOutputResponseBody: Swift.Equatable {
    public let entries: [LocationClientTypes.ListGeofenceCollectionsResponseEntry]?
    public let nextToken: Swift.String?
}

extension ListGeofenceCollectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListGeofenceCollectionsResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListGeofenceCollectionsResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListGeofenceCollectionsResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LocationClientTypes.ListGeofenceCollectionsResponseEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionName = "CollectionName"
        case createTime = "CreateTime"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectionName = collectionName {
            try encodeContainer.encode(collectionName, forKey: .collectionName)
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes.ListGeofenceCollectionsResponseEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGeofenceCollectionsResponseEntry(collectionName: \(Swift.String(describing: collectionName)), createTime: \(Swift.String(describing: createTime)), description: \(Swift.String(describing: description)), pricingPlan: \(Swift.String(describing: pricingPlan)), pricingPlanDataSource: \(Swift.String(describing: pricingPlanDataSource)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension LocationClientTypes {
    /// Contains the geofence collection details.
    public struct ListGeofenceCollectionsResponseEntry: Swift.Equatable {
        /// The name of the geofence collection.
        /// This member is required.
        public var collectionName: Swift.String?
        /// The timestamp for when the geofence collection was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ
        ///
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description for the geofence collection
        /// This member is required.
        public var description: Swift.String?
        /// The pricing plan for the specified geofence collection.
        ///         For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        ///             page.
        /// This member is required.
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// The specified data provider for the geofence collection.
        public var pricingPlanDataSource: Swift.String?
        /// Specifies a timestamp for when the resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ
        ///
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            collectionName: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            pricingPlanDataSource: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.collectionName = collectionName
            self.createTime = createTime
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.updateTime = updateTime
        }
    }

}

extension LocationClientTypes.ListGeofenceResponseEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case geofenceId = "GeofenceId"
        case geometry = "Geometry"
        case status = "Status"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let geofenceId = geofenceId {
            try encodeContainer.encode(geofenceId, forKey: .geofenceId)
        }
        if let geometry = geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.GeofenceGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes.ListGeofenceResponseEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGeofenceResponseEntry(createTime: \(Swift.String(describing: createTime)), geofenceId: \(Swift.String(describing: geofenceId)), geometry: \(Swift.String(describing: geometry)), status: \(Swift.String(describing: status)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension LocationClientTypes {
    /// Contains a list of geofences stored in a given geofence collection.
    public struct ListGeofenceResponseEntry: Swift.Equatable {
        /// The timestamp for when the geofence was stored in a geofence collection in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ
        ///
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The geofence identifier.
        /// This member is required.
        public var geofenceId: Swift.String?
        /// Contains the geofence geometry details describing a polygon.
        /// This member is required.
        public var geometry: LocationClientTypes.GeofenceGeometry?
        /// Identifies the state of the geofence. A geofence will hold one of the following
        ///             states:
        ///
        ///
        ///
        ///                   ACTIVE — The geofence has been indexed by the system.
        ///
        ///
        ///
        ///                   PENDING — The geofence is being processed by the system.
        ///
        ///
        ///
        ///                   FAILED — The geofence failed to be indexed by the system.
        ///
        ///
        ///
        ///                   DELETED — The geofence has been deleted from the system
        ///                     index.
        ///
        ///
        ///
        ///                   DELETING — The geofence is being deleted from the system
        ///                     index.
        ///
        ///
        /// This member is required.
        public var status: Swift.String?
        /// The timestamp for when the geofence was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ
        ///
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            createTime: ClientRuntime.Date? = nil,
            geofenceId: Swift.String? = nil,
            geometry: LocationClientTypes.GeofenceGeometry? = nil,
            status: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.geofenceId = geofenceId
            self.geometry = geometry
            self.status = status
            self.updateTime = updateTime
        }
    }

}

public struct ListGeofencesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGeofencesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGeofencesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGeofencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGeofencesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGeofencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGeofencesOutputError>
}

extension ListGeofencesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGeofencesInput(collectionName: \(Swift.String(describing: collectionName)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListGeofencesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListGeofencesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGeofencesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGeofencesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGeofencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGeofencesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGeofencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGeofencesOutputError>
}

public struct ListGeofencesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGeofencesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGeofencesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGeofencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGeofencesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGeofencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGeofencesOutputError>
}

public struct ListGeofencesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGeofencesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListGeofencesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGeofencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "geofencing.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListGeofencesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListGeofencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGeofencesOutputError>
}

public struct ListGeofencesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGeofencesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListGeofencesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGeofencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let collectionName = input.collectionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("collectionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/list-geofences"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListGeofencesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListGeofencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGeofencesOutputError>
}

public struct ListGeofencesInput: Swift.Equatable {
    /// The name of the geofence collection storing the list of geofences.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The pagination token specifying which page of results to return in the response. If no
    ///             token is provided, the default page is the first page.
    ///         Default value: null
    ///
    public var nextToken: Swift.String?

    public init (
        collectionName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
        self.nextToken = nextToken
    }
}

struct ListGeofencesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
}

extension ListGeofencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGeofencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGeofencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGeofencesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGeofencesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGeofencesOutputResponse(entries: \(Swift.String(describing: entries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListGeofencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGeofencesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListGeofencesOutputResponse: Swift.Equatable {
    /// Contains a list of geofences stored in the geofence collection.
    /// This member is required.
    public var entries: [LocationClientTypes.ListGeofenceResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the
    ///             token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        entries: [LocationClientTypes.ListGeofenceResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListGeofencesOutputResponseBody: Swift.Equatable {
    public let entries: [LocationClientTypes.ListGeofenceResponseEntry]?
    public let nextToken: Swift.String?
}

extension ListGeofencesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListGeofenceResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListGeofenceResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListGeofenceResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListMapsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMapsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMapsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMapsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMapsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMapsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMapsOutputError>
}

extension ListMapsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMapsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListMapsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListMapsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMapsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMapsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMapsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMapsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMapsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMapsOutputError>
}

public struct ListMapsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMapsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMapsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMapsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMapsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMapsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMapsOutputError>
}

public struct ListMapsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMapsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListMapsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMapsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "maps.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMapsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMapsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMapsOutputError>
}

public struct ListMapsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMapsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListMapsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMapsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/maps/v0/list-maps"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMapsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMapsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMapsOutputError>
}

public struct ListMapsInput: Swift.Equatable {
    /// An optional limit for the number of resources returned in a single call.
    ///         Default value: 100
    ///
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no
    ///             token is provided, the default page is the first page.
    ///         Default value: null
    ///
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMapsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListMapsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMapsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMapsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMapsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMapsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMapsOutputResponse(entries: \(Swift.String(describing: entries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListMapsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMapsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListMapsOutputResponse: Swift.Equatable {
    /// Contains a list of maps in your AWS account
    /// This member is required.
    public var entries: [LocationClientTypes.ListMapsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        entries: [LocationClientTypes.ListMapsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListMapsOutputResponseBody: Swift.Equatable {
    public let entries: [LocationClientTypes.ListMapsResponseEntry]?
    public let nextToken: Swift.String?
}

extension ListMapsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListMapsResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListMapsResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListMapsResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LocationClientTypes.ListMapsResponseEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case description = "Description"
        case mapName = "MapName"
        case pricingPlan = "PricingPlan"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mapName = mapName {
            try encodeContainer.encode(mapName, forKey: .mapName)
        }
        if let pricingPlan = pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapName)
        mapName = mapNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes.ListMapsResponseEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMapsResponseEntry(createTime: \(Swift.String(describing: createTime)), dataSource: \(Swift.String(describing: dataSource)), description: \(Swift.String(describing: description)), mapName: \(Swift.String(describing: mapName)), pricingPlan: \(Swift.String(describing: pricingPlan)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension LocationClientTypes {
    /// Contains details of an existing map resource in your AWS account.
    public struct ListMapsResponseEntry: Swift.Equatable {
        /// The timestamp for when the map resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// Specifies the data provider for the associated map tiles.
        /// This member is required.
        public var dataSource: Swift.String?
        /// The description for the map resource.
        /// This member is required.
        public var description: Swift.String?
        /// The name of the associated map resource.
        /// This member is required.
        public var mapName: Swift.String?
        /// The pricing plan for the specified map resource.
        ///         For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        ///             page.
        /// This member is required.
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// The timestamp for when the map resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            createTime: ClientRuntime.Date? = nil,
            dataSource: Swift.String? = nil,
            description: Swift.String? = nil,
            mapName: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.mapName = mapName
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }
    }

}

public struct ListPlaceIndexesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlaceIndexesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPlaceIndexesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlaceIndexesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPlaceIndexesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlaceIndexesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlaceIndexesOutputError>
}

extension ListPlaceIndexesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPlaceIndexesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPlaceIndexesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPlaceIndexesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlaceIndexesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPlaceIndexesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlaceIndexesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPlaceIndexesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlaceIndexesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlaceIndexesOutputError>
}

public struct ListPlaceIndexesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlaceIndexesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPlaceIndexesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlaceIndexesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPlaceIndexesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlaceIndexesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlaceIndexesOutputError>
}

public struct ListPlaceIndexesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlaceIndexesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListPlaceIndexesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlaceIndexesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "places.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPlaceIndexesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlaceIndexesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlaceIndexesOutputError>
}

public struct ListPlaceIndexesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlaceIndexesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListPlaceIndexesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlaceIndexesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/places/v0/list-indexes"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPlaceIndexesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlaceIndexesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlaceIndexesOutputError>
}

public struct ListPlaceIndexesInput: Swift.Equatable {
    /// An optional limit for the maximum number of results returned in a single call.
    ///          Default value: 100
    ///
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no
    ///          token is provided, the default page is the first page.
    ///          Default value: null
    ///
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPlaceIndexesInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListPlaceIndexesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPlaceIndexesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPlaceIndexesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPlaceIndexesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPlaceIndexesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPlaceIndexesOutputResponse(entries: \(Swift.String(describing: entries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPlaceIndexesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPlaceIndexesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListPlaceIndexesOutputResponse: Swift.Equatable {
    /// Lists the place index resources that exist in your AWS account
    /// This member is required.
    public var entries: [LocationClientTypes.ListPlaceIndexesResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the
    ///          token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        entries: [LocationClientTypes.ListPlaceIndexesResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListPlaceIndexesOutputResponseBody: Swift.Equatable {
    public let entries: [LocationClientTypes.ListPlaceIndexesResponseEntry]?
    public let nextToken: Swift.String?
}

extension ListPlaceIndexesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListPlaceIndexesResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListPlaceIndexesResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListPlaceIndexesResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LocationClientTypes.ListPlaceIndexesResponseEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case description = "Description"
        case indexName = "IndexName"
        case pricingPlan = "PricingPlan"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let indexName = indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let pricingPlan = pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes.ListPlaceIndexesResponseEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPlaceIndexesResponseEntry(createTime: \(Swift.String(describing: createTime)), dataSource: \(Swift.String(describing: dataSource)), description: \(Swift.String(describing: description)), indexName: \(Swift.String(describing: indexName)), pricingPlan: \(Swift.String(describing: pricingPlan)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension LocationClientTypes {
    /// A place index resource listed in your AWS account.
    public struct ListPlaceIndexesResponseEntry: Swift.Equatable {
        /// The timestamp for when the place index resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format:
        ///             YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The data provider of geospatial data. Indicates one of the available providers:
        ///
        ///
        ///
        ///                   Esri
        ///
        ///
        ///
        ///
        ///                   Here
        ///
        ///
        ///
        ///          For additional details on data providers, see the <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers page.
        /// This member is required.
        public var dataSource: Swift.String?
        /// The optional description for the place index resource.
        /// This member is required.
        public var description: Swift.String?
        /// The name of the place index resource.
        /// This member is required.
        public var indexName: Swift.String?
        /// The pricing plan for the specified place index resource.
        ///          For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        ///          page.
        /// This member is required.
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// The timestamp for when the place index resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format:
        ///             YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            createTime: ClientRuntime.Date? = nil,
            dataSource: Swift.String? = nil,
            description: Swift.String? = nil,
            indexName: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.indexName = indexName
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }
    }

}

public struct ListRouteCalculatorsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRouteCalculatorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRouteCalculatorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRouteCalculatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRouteCalculatorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRouteCalculatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRouteCalculatorsOutputError>
}

extension ListRouteCalculatorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRouteCalculatorsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRouteCalculatorsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRouteCalculatorsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRouteCalculatorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRouteCalculatorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRouteCalculatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRouteCalculatorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRouteCalculatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRouteCalculatorsOutputError>
}

public struct ListRouteCalculatorsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRouteCalculatorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRouteCalculatorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRouteCalculatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRouteCalculatorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRouteCalculatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRouteCalculatorsOutputError>
}

public struct ListRouteCalculatorsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRouteCalculatorsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListRouteCalculatorsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRouteCalculatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "routes.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRouteCalculatorsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRouteCalculatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRouteCalculatorsOutputError>
}

public struct ListRouteCalculatorsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRouteCalculatorsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListRouteCalculatorsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRouteCalculatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/routes/v0/list-calculators"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRouteCalculatorsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRouteCalculatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRouteCalculatorsOutputError>
}

public struct ListRouteCalculatorsInput: Swift.Equatable {
    /// An optional maximum number of results returned in a single call.
    ///         Default Value: 100
    ///
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no
    ///             token is provided, the default page is the first page.
    ///         Default Value: null
    ///
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRouteCalculatorsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListRouteCalculatorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRouteCalculatorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRouteCalculatorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRouteCalculatorsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRouteCalculatorsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRouteCalculatorsOutputResponse(entries: \(Swift.String(describing: entries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRouteCalculatorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRouteCalculatorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListRouteCalculatorsOutputResponse: Swift.Equatable {
    /// Lists the route calculator resources that exist in your AWS account
    /// This member is required.
    public var entries: [LocationClientTypes.ListRouteCalculatorsResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the
    ///             token in a subsequent request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        entries: [LocationClientTypes.ListRouteCalculatorsResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListRouteCalculatorsOutputResponseBody: Swift.Equatable {
    public let entries: [LocationClientTypes.ListRouteCalculatorsResponseEntry]?
    public let nextToken: Swift.String?
}

extension ListRouteCalculatorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListRouteCalculatorsResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListRouteCalculatorsResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListRouteCalculatorsResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LocationClientTypes.ListRouteCalculatorsResponseEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorName = "CalculatorName"
        case createTime = "CreateTime"
        case dataSource = "DataSource"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculatorName = calculatorName {
            try encodeContainer.encode(calculatorName, forKey: .calculatorName)
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorName)
        calculatorName = calculatorNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes.ListRouteCalculatorsResponseEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRouteCalculatorsResponseEntry(calculatorName: \(Swift.String(describing: calculatorName)), createTime: \(Swift.String(describing: createTime)), dataSource: \(Swift.String(describing: dataSource)), description: \(Swift.String(describing: description)), pricingPlan: \(Swift.String(describing: pricingPlan)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension LocationClientTypes {
    /// A route calculator resource listed in your AWS account.
    public struct ListRouteCalculatorsResponseEntry: Swift.Equatable {
        /// The name of the route calculator resource.
        /// This member is required.
        public var calculatorName: Swift.String?
        /// The timestamp when the route calculator resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
        ///
        ///
        ///                 For example, 2020–07-2T12:15:20.000Z+01:00
        ///
        ///
        ///
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The data provider of traffic and road network data. Indicates one of the available
        ///             providers:
        ///
        ///
        ///
        ///                   Esri
        ///
        ///
        ///
        ///
        ///                   Here
        ///
        ///
        ///
        ///         For more information about data providers, see <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers.
        /// This member is required.
        public var dataSource: Swift.String?
        /// The optional description of the route calculator resource.
        /// This member is required.
        public var description: Swift.String?
        /// The pricing plan for the specified route calculator resource.
        ///         For additional details and restrictions on each pricing plan option, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing.
        /// This member is required.
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// The timestamp when the route calculator resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
        ///
        ///
        ///                 For example, 2020–07-2T12:15:20.000Z+01:00
        ///
        ///
        ///
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            calculatorName: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            dataSource: Swift.String? = nil,
            description: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.calculatorName = calculatorName
            self.createTime = createTime
            self.dataSource = dataSource
            self.description = description
            self.pricingPlan = pricingPlan
            self.updateTime = updateTime
        }
    }

}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "metadata.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
    /// 	
    ///
    ///                Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
    ///
    ///
    ///
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Tags that have been applied to the specified resource. Tags are mapped from the tag key to the tag value: "TagKey" : "TagValue".
    /// 	
    ///
    ///                Format example: {"tag1" : "value1", "tag2" : "value2"}
    ///
    ///
    ///
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListTrackerConsumersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrackerConsumersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTrackerConsumersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrackerConsumersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTrackerConsumersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrackerConsumersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrackerConsumersOutputError>
}

extension ListTrackerConsumersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTrackerConsumersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), trackerName: \(Swift.String(describing: trackerName)))"}
}

extension ListTrackerConsumersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTrackerConsumersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrackerConsumersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTrackerConsumersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrackerConsumersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTrackerConsumersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrackerConsumersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrackerConsumersOutputError>
}

public struct ListTrackerConsumersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrackerConsumersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTrackerConsumersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrackerConsumersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTrackerConsumersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrackerConsumersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrackerConsumersOutputError>
}

public struct ListTrackerConsumersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrackerConsumersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTrackerConsumersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrackerConsumersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "tracking.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTrackerConsumersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrackerConsumersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrackerConsumersOutputError>
}

public struct ListTrackerConsumersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrackerConsumersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTrackerConsumersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrackerConsumersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trackerName = input.trackerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trackerName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())/list-consumers"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTrackerConsumersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrackerConsumersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrackerConsumersOutputError>
}

public struct ListTrackerConsumersInput: Swift.Equatable {
    /// An optional limit for the number of resources returned in a single call.
    ///         Default value: 100
    ///
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no
    ///             token is provided, the default page is the first page.
    ///          Default value: null
    ///
    public var nextToken: Swift.String?
    /// The tracker resource whose associated geofence collections you want to list.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trackerName = trackerName
    }
}

struct ListTrackerConsumersInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListTrackerConsumersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrackerConsumersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTrackerConsumersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTrackerConsumersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTrackerConsumersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTrackerConsumersOutputResponse(consumerArns: \(Swift.String(describing: consumerArns)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTrackerConsumersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTrackerConsumersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.consumerArns = output.consumerArns
            self.nextToken = output.nextToken
        } else {
            self.consumerArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListTrackerConsumersOutputResponse: Swift.Equatable {
    /// Contains the list of geofence collection ARNs associated to the tracker resource.
    /// This member is required.
    public var consumerArns: [Swift.String]?
    /// A pagination token indicating there are additional pages available. You can use the
    ///             token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        consumerArns: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.consumerArns = consumerArns
        self.nextToken = nextToken
    }
}

struct ListTrackerConsumersOutputResponseBody: Swift.Equatable {
    public let consumerArns: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListTrackerConsumersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerArns = "ConsumerArns"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .consumerArns)
        var consumerArnsDecoded0:[Swift.String]? = nil
        if let consumerArnsContainer = consumerArnsContainer {
            consumerArnsDecoded0 = [Swift.String]()
            for string0 in consumerArnsContainer {
                if let string0 = string0 {
                    consumerArnsDecoded0?.append(string0)
                }
            }
        }
        consumerArns = consumerArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTrackersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrackersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTrackersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrackersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTrackersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrackersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrackersOutputError>
}

extension ListTrackersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTrackersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTrackersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTrackersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrackersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTrackersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrackersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTrackersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrackersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrackersOutputError>
}

public struct ListTrackersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrackersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTrackersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrackersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTrackersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrackersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrackersOutputError>
}

public struct ListTrackersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrackersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTrackersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrackersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "tracking.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTrackersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrackersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrackersOutputError>
}

public struct ListTrackersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrackersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTrackersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrackersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/tracking/v0/list-trackers"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTrackersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrackersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrackersOutputError>
}

public struct ListTrackersInput: Swift.Equatable {
    /// An optional limit for the number of resources returned in a single call.
    ///         Default value: 100
    ///
    public var maxResults: Swift.Int?
    /// The pagination token specifying which page of results to return in the response. If no
    ///             token is provided, the default page is the first page.
    ///         Default value: null
    ///
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTrackersInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListTrackersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrackersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTrackersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTrackersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTrackersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTrackersOutputResponse(entries: \(Swift.String(describing: entries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTrackersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTrackersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entries = output.entries
            self.nextToken = output.nextToken
        } else {
            self.entries = nil
            self.nextToken = nil
        }
    }
}

public struct ListTrackersOutputResponse: Swift.Equatable {
    /// Contains tracker resources in your AWS account. Details include tracker name,
    ///             description and timestamps for when the tracker was created and last updated.
    /// This member is required.
    public var entries: [LocationClientTypes.ListTrackersResponseEntry]?
    /// A pagination token indicating there are additional pages available. You can use the
    ///             token in a following request to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        entries: [LocationClientTypes.ListTrackersResponseEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct ListTrackersOutputResponseBody: Swift.Equatable {
    public let entries: [LocationClientTypes.ListTrackersResponseEntry]?
    public let nextToken: Swift.String?
}

extension ListTrackersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries = "Entries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([LocationClientTypes.ListTrackersResponseEntry?].self, forKey: .entries)
        var entriesDecoded0:[LocationClientTypes.ListTrackersResponseEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [LocationClientTypes.ListTrackersResponseEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LocationClientTypes.ListTrackersResponseEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
        case trackerName = "TrackerName"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
        if let trackerName = trackerName {
            try encodeContainer.encode(trackerName, forKey: .trackerName)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension LocationClientTypes.ListTrackersResponseEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTrackersResponseEntry(createTime: \(Swift.String(describing: createTime)), description: \(Swift.String(describing: description)), pricingPlan: \(Swift.String(describing: pricingPlan)), pricingPlanDataSource: \(Swift.String(describing: pricingPlanDataSource)), trackerName: \(Swift.String(describing: trackerName)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension LocationClientTypes {
    /// Contains the tracker resource details.
    public struct ListTrackersResponseEntry: Swift.Equatable {
        /// The timestamp for when the tracker resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description for the tracker resource.
        /// This member is required.
        public var description: Swift.String?
        /// The pricing plan for the specified tracker resource.
        ///         For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        ///             page.
        /// This member is required.
        public var pricingPlan: LocationClientTypes.PricingPlan?
        /// The specified data provider for the tracker resource.
        public var pricingPlanDataSource: Swift.String?
        /// The name of the tracker resource.
        /// This member is required.
        public var trackerName: Swift.String?
        /// The timestamp at which the device's position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
        ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            pricingPlan: LocationClientTypes.PricingPlan? = nil,
            pricingPlanDataSource: Swift.String? = nil,
            trackerName: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.description = description
            self.pricingPlan = pricingPlan
            self.pricingPlanDataSource = pricingPlanDataSource
            self.trackerName = trackerName
            self.updateTime = updateTime
        }
    }

}

extension LocationClientTypes.MapConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case style = "Style"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let style = style {
            try encodeContainer.encode(style, forKey: .style)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let styleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .style)
        style = styleDecoded
    }
}

extension LocationClientTypes.MapConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MapConfiguration(style: \(Swift.String(describing: style)))"}
}

extension LocationClientTypes {
    /// Specifies the map tile style selected from an available provider.
    public struct MapConfiguration: Swift.Equatable {
        /// Specifies the map style selected from an available data provider. For additional
        ///             information on each map style and to preview each map style, see <a href="location/latest/developerguide/esri.html#esri-map-styles">Esri map
        ///                 styles and <a href="location/latest/developerguide/HERE.html#HERE-map-styles">HERE map
        ///                 styles.
        ///         Valid <a href="https://docs.aws.amazon.com/location/latest/developerguide/esri.html">Esri styles:
        ///
        ///
        ///
        ///                   VectorEsriDarkGrayCanvas – The Esri Dark Gray Canvas map style. A
        ///                     vector basemap with a dark gray, neutral background with minimal colors, labels,
        ///                     and features that's designed to draw attention to your thematic content.
        ///
        ///
        ///
        ///                   RasterEsriImagery – The Esri Imagery map style. A raster basemap
        ///                     that provides one meter or better satellite and aerial imagery in many parts of
        ///                     the world and lower resolution satellite imagery worldwide.
        ///
        ///
        ///
        ///                   VectorEsriLightGrayCanvas – The Esri Light Gray Canvas map style,
        ///                     which provides a detailed vector basemap with a light gray, neutral background
        ///                     style with minimal colors, labels, and features that's designed to draw
        ///                     attention to your thematic content.
        ///
        ///
        ///
        ///                   VectorEsriTopographic – The Esri Light map style, which provides
        ///                     a detailed vector basemap with a classic Esri map style.
        ///
        ///
        ///
        ///                   VectorEsriStreets – The Esri World Streets map style, which
        ///                     provides a detailed vector basemap for the world symbolized with a classic Esri
        ///                     street map style. The vector tile layer is similar in content and style to the
        ///                     World Street Map raster map.
        ///
        ///
        ///
        ///                   VectorEsriNavigation – The Esri World Navigation map style, which
        ///                     provides a detailed basemap for the world symbolized with a custom navigation
        ///                     map style that's designed for use during the day in mobile devices.
        ///
        ///
        ///         Valid <a href="https://docs.aws.amazon.com/location/latest/developerguide/HERE.html">HERE
        ///                 Technologies styles:
        ///
        ///
        ///
        ///                   VectorHereBerlin – The HERE Berlin map style is a high contrast
        ///                     detailed base map of the world that blends 3D and 2D rendering.
        ///
        ///                     When using HERE as your data provider, and selecting the Style
        ///                             VectorHereBerlin, you may not use HERE Technologies maps
        ///                         for Asset Management. See the <a href="https://aws.amazon.com/service-terms/">AWS Service Terms
        ///                         for Amazon Location Service.
        ///
        ///
        ///
        /// This member is required.
        public var style: Swift.String?

        public init (
            style: Swift.String? = nil
        )
        {
            self.style = style
        }
    }

}

extension LocationClientTypes.Place: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressNumber = "AddressNumber"
        case country = "Country"
        case geometry = "Geometry"
        case label = "Label"
        case municipality = "Municipality"
        case neighborhood = "Neighborhood"
        case postalCode = "PostalCode"
        case region = "Region"
        case street = "Street"
        case subRegion = "SubRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressNumber = addressNumber {
            try encodeContainer.encode(addressNumber, forKey: .addressNumber)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let geometry = geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let municipality = municipality {
            try encodeContainer.encode(municipality, forKey: .municipality)
        }
        if let neighborhood = neighborhood {
            try encodeContainer.encode(neighborhood, forKey: .neighborhood)
        }
        if let postalCode = postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let street = street {
            try encodeContainer.encode(street, forKey: .street)
        }
        if let subRegion = subRegion {
            try encodeContainer.encode(subRegion, forKey: .subRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PlaceGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
        let addressNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressNumber)
        addressNumber = addressNumberDecoded
        let streetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street)
        street = streetDecoded
        let neighborhoodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .neighborhood)
        neighborhood = neighborhoodDecoded
        let municipalityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .municipality)
        municipality = municipalityDecoded
        let subRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subRegion)
        subRegion = subRegionDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
    }
}

extension LocationClientTypes.Place: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Place(addressNumber: \(Swift.String(describing: addressNumber)), country: \(Swift.String(describing: country)), geometry: \(Swift.String(describing: geometry)), label: \(Swift.String(describing: label)), municipality: \(Swift.String(describing: municipality)), neighborhood: \(Swift.String(describing: neighborhood)), postalCode: \(Swift.String(describing: postalCode)), region: \(Swift.String(describing: region)), street: \(Swift.String(describing: street)), subRegion: \(Swift.String(describing: subRegion)))"}
}

extension LocationClientTypes {
    /// Contains details about addresses or points of interest that match the search
    ///          criteria.
    public struct Place: Swift.Equatable {
        /// The numerical portion of an address, such as a building number.
        public var addressNumber: Swift.String?
        /// A country/region specified using <a href="https://www.iso.org/iso-3166-country-codes.html">ISO 3166 3-digit
        ///          country/region code. For example, CAN.
        public var country: Swift.String?
        /// Places uses a point geometry to specify a location or a Place.
        /// This member is required.
        public var geometry: LocationClientTypes.PlaceGeometry?
        /// The full name and address of the point of interest such as a city,
        ///          region, or country. For example, 123 Any Street, Any Town, USA.
        public var label: Swift.String?
        /// A name for a local area, such as a city or town name. For example,
        ///          Toronto.
        public var municipality: Swift.String?
        /// The name of a community district. For example, Downtown.
        public var neighborhood: Swift.String?
        /// A group of numbers and letters in a country-specific format, which accompanies the
        ///          address for the purpose of identifying a location.
        public var postalCode: Swift.String?
        /// A name for an area or geographical division, such as a province or state name. For
        ///          example, British Columbia.
        public var region: Swift.String?
        /// The name for a street or a road to identify a location. For example, Main
        ///          Street.
        public var street: Swift.String?
        /// A country, or an area that's part of a larger region .  For example, Metro
        ///             Vancouver.
        public var subRegion: Swift.String?

        public init (
            addressNumber: Swift.String? = nil,
            country: Swift.String? = nil,
            geometry: LocationClientTypes.PlaceGeometry? = nil,
            label: Swift.String? = nil,
            municipality: Swift.String? = nil,
            neighborhood: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            region: Swift.String? = nil,
            street: Swift.String? = nil,
            subRegion: Swift.String? = nil
        )
        {
            self.addressNumber = addressNumber
            self.country = country
            self.geometry = geometry
            self.label = label
            self.municipality = municipality
            self.neighborhood = neighborhood
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.subRegion = subRegion
        }
    }

}

extension LocationClientTypes.PlaceGeometry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case point = "Point"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let point = point {
            var pointContainer = encodeContainer.nestedUnkeyedContainer(forKey: .point)
            for position0 in point {
                try pointContainer.encode(position0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pointContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .point)
        var pointDecoded0:[Swift.Double]? = nil
        if let pointContainer = pointContainer {
            pointDecoded0 = [Swift.Double]()
            for double0 in pointContainer {
                if let double0 = double0 {
                    pointDecoded0?.append(double0)
                }
            }
        }
        point = pointDecoded0
    }
}

extension LocationClientTypes.PlaceGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlaceGeometry(point: \(Swift.String(describing: point)))"}
}

extension LocationClientTypes {
    /// Places uses a point geometry to specify a location or a Place.
    public struct PlaceGeometry: Swift.Equatable {
        /// A single point geometry specifies a location for a Place using <a href="https://gisgeography.com/wgs84-world-geodetic-system/">WGS 84
        ///          coordinates:
        ///
        ///
        ///
        ///                   x — Specifies the x coordinate or longitude.
        ///
        ///
        ///
        ///                   y — Specifies the y coordinate or latitude.
        ///
        ///
        public var point: [Swift.Double]?

        public init (
            point: [Swift.Double]? = nil
        )
        {
            self.point = point
        }
    }

}

extension LocationClientTypes {
    public enum PricingPlan: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// This pricing plan must be picked for mobile asset management use cases
        case mobileassetmanagement
        /// This pricing plan must be picked for mobile asset tracking use cases.
        case mobileassettracking
        /// This pricing plan should be used for request based billing.
        case requestbasedusage
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingPlan] {
            return [
                .mobileassetmanagement,
                .mobileassettracking,
                .requestbasedusage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mobileassetmanagement: return "MobileAssetManagement"
            case .mobileassettracking: return "MobileAssetTracking"
            case .requestbasedusage: return "RequestBasedUsage"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PricingPlan(rawValue: rawValue) ?? PricingPlan.sdkUnknown(rawValue)
        }
    }
}

public struct PutGeofenceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutGeofenceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutGeofenceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutGeofenceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutGeofenceOutputError>
}

extension PutGeofenceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutGeofenceInput(collectionName: \(Swift.String(describing: collectionName)), geofenceId: \(Swift.String(describing: geofenceId)), geometry: \(Swift.String(describing: geometry)))"}
}

extension PutGeofenceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geometry = "Geometry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geometry = geometry {
            try encodeContainer.encode(geometry, forKey: .geometry)
        }
    }
}

public struct PutGeofenceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutGeofenceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutGeofenceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutGeofenceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutGeofenceOutputError>
}

public struct PutGeofenceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutGeofenceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutGeofenceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutGeofenceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutGeofenceOutputError>
}

public struct PutGeofenceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutGeofenceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutGeofenceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "geofencing.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutGeofenceInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutGeofenceOutputError>
}

public struct PutGeofenceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutGeofenceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutGeofenceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutGeofenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let collectionName = input.collectionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("collectionName is nil and needs a value for the path of this operation"))))
        }
        guard let geofenceId = input.geofenceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("geofenceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())/geofences/\(geofenceId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutGeofenceInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutGeofenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutGeofenceOutputError>
}

public struct PutGeofenceInput: Swift.Equatable {
    /// The geofence collection to store the geofence in.
    /// This member is required.
    public var collectionName: Swift.String?
    /// An identifier for the geofence. For example, ExampleGeofence-1.
    /// This member is required.
    public var geofenceId: Swift.String?
    /// Contains the polygon details to specify the position of the geofence.
    ///
    ///             Each <a href="https://docs.aws.amazon.com/location-geofences/latest/APIReference/API_GeofenceGeometry.html">geofence polygon can have a maximum of 1,000 vertices.
    ///
    /// This member is required.
    public var geometry: LocationClientTypes.GeofenceGeometry?

    public init (
        collectionName: Swift.String? = nil,
        geofenceId: Swift.String? = nil,
        geometry: LocationClientTypes.GeofenceGeometry? = nil
    )
    {
        self.collectionName = collectionName
        self.geofenceId = geofenceId
        self.geometry = geometry
    }
}

struct PutGeofenceInputBody: Swift.Equatable {
    public let geometry: LocationClientTypes.GeofenceGeometry?
}

extension PutGeofenceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geometry = "Geometry"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geometryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.GeofenceGeometry.self, forKey: .geometry)
        geometry = geometryDecoded
    }
}

extension PutGeofenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutGeofenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutGeofenceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutGeofenceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutGeofenceOutputResponse(createTime: \(Swift.String(describing: createTime)), geofenceId: \(Swift.String(describing: geofenceId)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension PutGeofenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutGeofenceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.geofenceId = output.geofenceId
            self.updateTime = output.updateTime
        } else {
            self.createTime = nil
            self.geofenceId = nil
            self.updateTime = nil
        }
    }
}

public struct PutGeofenceOutputResponse: Swift.Equatable {
    /// The timestamp for when the geofence was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ
    ///
    /// This member is required.
    public var createTime: ClientRuntime.Date?
    /// The geofence identifier entered in the request.
    /// This member is required.
    public var geofenceId: Swift.String?
    /// The timestamp for when the geofence was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ
    ///
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        createTime: ClientRuntime.Date? = nil,
        geofenceId: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.geofenceId = geofenceId
        self.updateTime = updateTime
    }
}

struct PutGeofenceOutputResponseBody: Swift.Equatable {
    public let geofenceId: Swift.String?
    public let createTime: ClientRuntime.Date?
    public let updateTime: ClientRuntime.Date?
}

extension PutGeofenceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case geofenceId = "GeofenceId"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geofenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geofenceId)
        geofenceId = geofenceIdDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource that you've entered was not found in your AWS account.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes.SearchForPositionResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case place = "Place"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let place = place {
            try encodeContainer.encode(place, forKey: .place)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.Place.self, forKey: .place)
        place = placeDecoded
    }
}

extension LocationClientTypes.SearchForPositionResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchForPositionResult(place: \(Swift.String(describing: place)))"}
}

extension LocationClientTypes {
    /// Specifies a single point of interest, or Place as a result of a search query obtained
    ///          from a dataset configured in the place index resource.
    public struct SearchForPositionResult: Swift.Equatable {
        /// Contains details about the relevant point of interest.
        /// This member is required.
        public var place: LocationClientTypes.Place?

        public init (
            place: LocationClientTypes.Place? = nil
        )
        {
            self.place = place
        }
    }

}

extension LocationClientTypes.SearchForTextResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case place = "Place"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let place = place {
            try encodeContainer.encode(place, forKey: .place)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placeDecoded = try containerValues.decodeIfPresent(LocationClientTypes.Place.self, forKey: .place)
        place = placeDecoded
    }
}

extension LocationClientTypes.SearchForTextResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchForTextResult(place: \(Swift.String(describing: place)))"}
}

extension LocationClientTypes {
    /// Contains relevant Places returned by calling
    ///          SearchPlaceIndexForText.
    public struct SearchForTextResult: Swift.Equatable {
        /// Contains details about the relevant point of interest.
        /// This member is required.
        public var place: LocationClientTypes.Place?

        public init (
            place: LocationClientTypes.Place? = nil
        )
        {
            self.place = place
        }
    }

}

public struct SearchPlaceIndexForPositionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchPlaceIndexForPositionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchPlaceIndexForPositionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchPlaceIndexForPositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchPlaceIndexForPositionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchPlaceIndexForPositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchPlaceIndexForPositionOutputError>
}

extension SearchPlaceIndexForPositionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForPositionInput(indexName: \(Swift.String(describing: indexName)), maxResults: \(Swift.String(describing: maxResults)), position: \(Swift.String(describing: position)))"}
}

extension SearchPlaceIndexForPositionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case position = "Position"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for position0 in position {
                try positionContainer.encode(position0)
            }
        }
    }
}

public struct SearchPlaceIndexForPositionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchPlaceIndexForPositionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchPlaceIndexForPositionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchPlaceIndexForPositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchPlaceIndexForPositionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchPlaceIndexForPositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchPlaceIndexForPositionOutputError>
}

public struct SearchPlaceIndexForPositionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchPlaceIndexForPositionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchPlaceIndexForPositionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchPlaceIndexForPositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchPlaceIndexForPositionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchPlaceIndexForPositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchPlaceIndexForPositionOutputError>
}

public struct SearchPlaceIndexForPositionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchPlaceIndexForPositionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: SearchPlaceIndexForPositionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchPlaceIndexForPositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "places.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SearchPlaceIndexForPositionInput
    public typealias MOutput = ClientRuntime.OperationOutput<SearchPlaceIndexForPositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchPlaceIndexForPositionOutputError>
}

public struct SearchPlaceIndexForPositionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchPlaceIndexForPositionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: SearchPlaceIndexForPositionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchPlaceIndexForPositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let indexName = input.indexName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("indexName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/places/v0/indexes/\(indexName.urlPercentEncoding())/search/position"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SearchPlaceIndexForPositionInput
    public typealias MOutput = ClientRuntime.OperationOutput<SearchPlaceIndexForPositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchPlaceIndexForPositionOutputError>
}

public struct SearchPlaceIndexForPositionInput: Swift.Equatable {
    /// The name of the place index resource you want to use for the search.
    /// This member is required.
    public var indexName: Swift.String?
    /// An optional paramer. The maximum number of results returned per request.
    ///          Default value: 50
    ///
    public var maxResults: Swift.Int
    /// Specifies a coordinate for the query defined by a longitude, and latitude.
    ///
    ///
    ///                The first position is the X coordinate, or longitude.
    ///
    ///
    ///                The second position is the Y coordinate, or latitude.
    ///
    ///
    ///          For example, position=xLongitude&amp;position=yLatitude .
    /// This member is required.
    public var position: [Swift.Double]?

    public init (
        indexName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        position: [Swift.Double]? = nil
    )
    {
        self.indexName = indexName
        self.maxResults = maxResults
        self.position = position
    }
}

struct SearchPlaceIndexForPositionInputBody: Swift.Equatable {
    public let position: [Swift.Double]?
    public let maxResults: Swift.Int
}

extension SearchPlaceIndexForPositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case position = "Position"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchPlaceIndexForPositionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchPlaceIndexForPositionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchPlaceIndexForPositionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchPlaceIndexForPositionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForPositionOutputResponse(results: \(Swift.String(describing: results)), summary: \(Swift.String(describing: summary)))"}
}

extension SearchPlaceIndexForPositionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchPlaceIndexForPositionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.results = output.results
            self.summary = output.summary
        } else {
            self.results = nil
            self.summary = nil
        }
    }
}

public struct SearchPlaceIndexForPositionOutputResponse: Swift.Equatable {
    /// Returns a list of Places closest to the specified position. Each result contains
    ///          additional information about the Places returned.
    /// This member is required.
    public var results: [LocationClientTypes.SearchForPositionResult]?
    /// Contains a summary of the request.
    /// This member is required.
    public var summary: LocationClientTypes.SearchPlaceIndexForPositionSummary?

    public init (
        results: [LocationClientTypes.SearchForPositionResult]? = nil,
        summary: LocationClientTypes.SearchPlaceIndexForPositionSummary? = nil
    )
    {
        self.results = results
        self.summary = summary
    }
}

struct SearchPlaceIndexForPositionOutputResponseBody: Swift.Equatable {
    public let summary: LocationClientTypes.SearchPlaceIndexForPositionSummary?
    public let results: [LocationClientTypes.SearchForPositionResult]?
}

extension SearchPlaceIndexForPositionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
        case summary = "Summary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.SearchPlaceIndexForPositionSummary.self, forKey: .summary)
        summary = summaryDecoded
        let resultsContainer = try containerValues.decodeIfPresent([LocationClientTypes.SearchForPositionResult?].self, forKey: .results)
        var resultsDecoded0:[LocationClientTypes.SearchForPositionResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [LocationClientTypes.SearchForPositionResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

extension LocationClientTypes.SearchPlaceIndexForPositionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case maxResults = "MaxResults"
        case position = "Position"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let position = position {
            var positionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .position)
            for position0 in position {
                try positionContainer.encode(position0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .position)
        var positionDecoded0:[Swift.Double]? = nil
        if let positionContainer = positionContainer {
            positionDecoded0 = [Swift.Double]()
            for double0 in positionContainer {
                if let double0 = double0 {
                    positionDecoded0?.append(double0)
                }
            }
        }
        position = positionDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

extension LocationClientTypes.SearchPlaceIndexForPositionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForPositionSummary(dataSource: \(Swift.String(describing: dataSource)), maxResults: \(Swift.String(describing: maxResults)), position: \(Swift.String(describing: position)))"}
}

extension LocationClientTypes {
    /// A summary of the reverse geocoding request sent using SearchPlaceIndexForPosition.
    public struct SearchPlaceIndexForPositionSummary: Swift.Equatable {
        /// The data provider of geospatial data. Indicates one of the available providers:
        ///
        ///
        ///                Esri
        ///
        ///
        ///                HERE
        ///
        ///
        ///          For additional details on data providers, see the <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers page.
        /// This member is required.
        public var dataSource: Swift.String?
        /// An optional parameter. The maximum number of results returned per request.
        ///          Default value: 50
        ///
        public var maxResults: Swift.Int
        /// The position given in the reverse geocoding request.
        /// This member is required.
        public var position: [Swift.Double]?

        public init (
            dataSource: Swift.String? = nil,
            maxResults: Swift.Int = 0,
            position: [Swift.Double]? = nil
        )
        {
            self.dataSource = dataSource
            self.maxResults = maxResults
            self.position = position
        }
    }

}

public struct SearchPlaceIndexForTextInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchPlaceIndexForTextInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchPlaceIndexForTextInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchPlaceIndexForTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchPlaceIndexForTextInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchPlaceIndexForTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchPlaceIndexForTextOutputError>
}

extension SearchPlaceIndexForTextInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForTextInput(biasPosition: \(Swift.String(describing: biasPosition)), filterBBox: \(Swift.String(describing: filterBBox)), filterCountries: \(Swift.String(describing: filterCountries)), indexName: \(Swift.String(describing: indexName)), maxResults: \(Swift.String(describing: maxResults)), text: \"CONTENT_REDACTED\")"}
}

extension SearchPlaceIndexForTextInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case biasPosition = "BiasPosition"
        case filterBBox = "FilterBBox"
        case filterCountries = "FilterCountries"
        case maxResults = "MaxResults"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let biasPosition = biasPosition {
            var biasPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .biasPosition)
            for position0 in biasPosition {
                try biasPositionContainer.encode(position0)
            }
        }
        if let filterBBox = filterBBox {
            var filterBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterBBox)
            for boundingbox0 in filterBBox {
                try filterBBoxContainer.encode(boundingbox0)
            }
        }
        if let filterCountries = filterCountries {
            var filterCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCountries)
            for countrycodelist0 in filterCountries {
                try filterCountriesContainer.encode(countrycodelist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct SearchPlaceIndexForTextInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchPlaceIndexForTextInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchPlaceIndexForTextInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchPlaceIndexForTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchPlaceIndexForTextInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchPlaceIndexForTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchPlaceIndexForTextOutputError>
}

public struct SearchPlaceIndexForTextInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchPlaceIndexForTextInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchPlaceIndexForTextInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchPlaceIndexForTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchPlaceIndexForTextInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchPlaceIndexForTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchPlaceIndexForTextOutputError>
}

public struct SearchPlaceIndexForTextInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchPlaceIndexForTextInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: SearchPlaceIndexForTextInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchPlaceIndexForTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "places.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SearchPlaceIndexForTextInput
    public typealias MOutput = ClientRuntime.OperationOutput<SearchPlaceIndexForTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchPlaceIndexForTextOutputError>
}

public struct SearchPlaceIndexForTextInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchPlaceIndexForTextInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: SearchPlaceIndexForTextInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchPlaceIndexForTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let indexName = input.indexName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("indexName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/places/v0/indexes/\(indexName.urlPercentEncoding())/search/text"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SearchPlaceIndexForTextInput
    public typealias MOutput = ClientRuntime.OperationOutput<SearchPlaceIndexForTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchPlaceIndexForTextOutputError>
}

public struct SearchPlaceIndexForTextInput: Swift.Equatable {
    /// Searches for results closest to the given position. An optional parameter defined by
    ///          longitude, and latitude.
    ///
    ///
    ///                The first bias position is the X coordinate, or longitude.
    ///
    ///
    ///                The second bias position is the Y coordinate, or latitude.
    ///
    ///
    ///          For example, bias=xLongitude&amp;bias=yLatitude.
    public var biasPosition: [Swift.Double]?
    /// Filters the results by returning only Places within the provided bounding box. An
    ///          optional parameter.
    ///          The first 2 bbox parameters describe the lower southwest corner:
    ///
    ///
    ///                The first bbox position is the X coordinate or longitude of the lower
    ///                southwest corner.
    ///
    ///
    ///                The second bbox position is the Y coordinate or latitude of the lower
    ///                southwest corner.
    ///
    ///
    ///          For example, bbox=xLongitudeSW&amp;bbox=yLatitudeSW.
    ///          The next bbox parameters describe the upper northeast corner:
    ///
    ///
    ///                The third bbox position is the X coordinate, or longitude of the
    ///                upper northeast corner.
    ///
    ///
    ///                The fourth bbox position is the Y coordinate, or longitude of the
    ///                upper northeast corner.
    ///
    ///
    ///          For example, bbox=xLongitudeNE&amp;bbox=yLatitudeNE
    ///
    public var filterBBox: [Swift.Double]?
    /// Limits the search to the given a list of countries/regions. An optional
    ///          parameter.
    ///
    ///
    ///                Use the <a href="https://www.iso.org/iso-3166-country-codes.html">ISO 3166 3-digit
    ///             country code. For example, Australia uses three upper-case characters:
    ///             AUS.
    ///
    ///
    public var filterCountries: [Swift.String]?
    /// The name of the place index resource you want to use for the search.
    /// This member is required.
    public var indexName: Swift.String?
    /// An optional parameter. The maximum number of results returned per request.
    ///          The default: 50
    ///
    public var maxResults: Swift.Int
    /// The address, name,
    ///          city, or region to be used in the search. In free-form text format. For example, 123 Any
    ///             Street.
    /// This member is required.
    public var text: Swift.String?

    public init (
        biasPosition: [Swift.Double]? = nil,
        filterBBox: [Swift.Double]? = nil,
        filterCountries: [Swift.String]? = nil,
        indexName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        text: Swift.String? = nil
    )
    {
        self.biasPosition = biasPosition
        self.filterBBox = filterBBox
        self.filterCountries = filterCountries
        self.indexName = indexName
        self.maxResults = maxResults
        self.text = text
    }
}

struct SearchPlaceIndexForTextInputBody: Swift.Equatable {
    public let text: Swift.String?
    public let biasPosition: [Swift.Double]?
    public let filterBBox: [Swift.Double]?
    public let filterCountries: [Swift.String]?
    public let maxResults: Swift.Int
}

extension SearchPlaceIndexForTextInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case biasPosition = "BiasPosition"
        case filterBBox = "FilterBBox"
        case filterCountries = "FilterCountries"
        case maxResults = "MaxResults"
        case text = "Text"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let biasPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .biasPosition)
        var biasPositionDecoded0:[Swift.Double]? = nil
        if let biasPositionContainer = biasPositionContainer {
            biasPositionDecoded0 = [Swift.Double]()
            for double0 in biasPositionContainer {
                if let double0 = double0 {
                    biasPositionDecoded0?.append(double0)
                }
            }
        }
        biasPosition = biasPositionDecoded0
        let filterBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .filterBBox)
        var filterBBoxDecoded0:[Swift.Double]? = nil
        if let filterBBoxContainer = filterBBoxContainer {
            filterBBoxDecoded0 = [Swift.Double]()
            for double0 in filterBBoxContainer {
                if let double0 = double0 {
                    filterBBoxDecoded0?.append(double0)
                }
            }
        }
        filterBBox = filterBBoxDecoded0
        let filterCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterCountries)
        var filterCountriesDecoded0:[Swift.String]? = nil
        if let filterCountriesContainer = filterCountriesContainer {
            filterCountriesDecoded0 = [Swift.String]()
            for string0 in filterCountriesContainer {
                if let string0 = string0 {
                    filterCountriesDecoded0?.append(string0)
                }
            }
        }
        filterCountries = filterCountriesDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchPlaceIndexForTextOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchPlaceIndexForTextOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchPlaceIndexForTextOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchPlaceIndexForTextOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForTextOutputResponse(results: \(Swift.String(describing: results)), summary: \(Swift.String(describing: summary)))"}
}

extension SearchPlaceIndexForTextOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchPlaceIndexForTextOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.results = output.results
            self.summary = output.summary
        } else {
            self.results = nil
            self.summary = nil
        }
    }
}

public struct SearchPlaceIndexForTextOutputResponse: Swift.Equatable {
    /// A list of Places closest to the specified position. Each result contains additional
    ///          information about the specific point of interest.
    /// This member is required.
    public var results: [LocationClientTypes.SearchForTextResult]?
    /// Contains a summary of the request. Contains the BiasPosition,
    ///          DataSource, FilterBBox, FilterCountries,
    ///          MaxResults, ResultBBox, and Text.
    /// This member is required.
    public var summary: LocationClientTypes.SearchPlaceIndexForTextSummary?

    public init (
        results: [LocationClientTypes.SearchForTextResult]? = nil,
        summary: LocationClientTypes.SearchPlaceIndexForTextSummary? = nil
    )
    {
        self.results = results
        self.summary = summary
    }
}

struct SearchPlaceIndexForTextOutputResponseBody: Swift.Equatable {
    public let summary: LocationClientTypes.SearchPlaceIndexForTextSummary?
    public let results: [LocationClientTypes.SearchForTextResult]?
}

extension SearchPlaceIndexForTextOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
        case summary = "Summary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(LocationClientTypes.SearchPlaceIndexForTextSummary.self, forKey: .summary)
        summary = summaryDecoded
        let resultsContainer = try containerValues.decodeIfPresent([LocationClientTypes.SearchForTextResult?].self, forKey: .results)
        var resultsDecoded0:[LocationClientTypes.SearchForTextResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [LocationClientTypes.SearchForTextResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

extension LocationClientTypes.SearchPlaceIndexForTextSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case biasPosition = "BiasPosition"
        case dataSource = "DataSource"
        case filterBBox = "FilterBBox"
        case filterCountries = "FilterCountries"
        case maxResults = "MaxResults"
        case resultBBox = "ResultBBox"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let biasPosition = biasPosition {
            var biasPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .biasPosition)
            for position0 in biasPosition {
                try biasPositionContainer.encode(position0)
            }
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let filterBBox = filterBBox {
            var filterBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterBBox)
            for boundingbox0 in filterBBox {
                try filterBBoxContainer.encode(boundingbox0)
            }
        }
        if let filterCountries = filterCountries {
            var filterCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCountries)
            for countrycodelist0 in filterCountries {
                try filterCountriesContainer.encode(countrycodelist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let resultBBox = resultBBox {
            var resultBBoxContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resultBBox)
            for boundingbox0 in resultBBox {
                try resultBBoxContainer.encode(boundingbox0)
            }
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let biasPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .biasPosition)
        var biasPositionDecoded0:[Swift.Double]? = nil
        if let biasPositionContainer = biasPositionContainer {
            biasPositionDecoded0 = [Swift.Double]()
            for double0 in biasPositionContainer {
                if let double0 = double0 {
                    biasPositionDecoded0?.append(double0)
                }
            }
        }
        biasPosition = biasPositionDecoded0
        let filterBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .filterBBox)
        var filterBBoxDecoded0:[Swift.Double]? = nil
        if let filterBBoxContainer = filterBBoxContainer {
            filterBBoxDecoded0 = [Swift.Double]()
            for double0 in filterBBoxContainer {
                if let double0 = double0 {
                    filterBBoxDecoded0?.append(double0)
                }
            }
        }
        filterBBox = filterBBoxDecoded0
        let filterCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterCountries)
        var filterCountriesDecoded0:[Swift.String]? = nil
        if let filterCountriesContainer = filterCountriesContainer {
            filterCountriesDecoded0 = [Swift.String]()
            for string0 in filterCountriesContainer {
                if let string0 = string0 {
                    filterCountriesDecoded0?.append(string0)
                }
            }
        }
        filterCountries = filterCountriesDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resultBBoxContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .resultBBox)
        var resultBBoxDecoded0:[Swift.Double]? = nil
        if let resultBBoxContainer = resultBBoxContainer {
            resultBBoxDecoded0 = [Swift.Double]()
            for double0 in resultBBoxContainer {
                if let double0 = double0 {
                    resultBBoxDecoded0?.append(double0)
                }
            }
        }
        resultBBox = resultBBoxDecoded0
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

extension LocationClientTypes.SearchPlaceIndexForTextSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchPlaceIndexForTextSummary(biasPosition: \(Swift.String(describing: biasPosition)), dataSource: \(Swift.String(describing: dataSource)), filterBBox: \(Swift.String(describing: filterBBox)), filterCountries: \(Swift.String(describing: filterCountries)), maxResults: \(Swift.String(describing: maxResults)), resultBBox: \(Swift.String(describing: resultBBox)), text: \"CONTENT_REDACTED\")"}
}

extension LocationClientTypes {
    /// A summary of the geocoding request sent using SearchPlaceIndexForText.
    public struct SearchPlaceIndexForTextSummary: Swift.Equatable {
        /// Contains the coordinates for the bias position entered in the geocoding request.
        public var biasPosition: [Swift.Double]?
        /// The data provider of geospatial data. Indicates one of the available providers:
        ///
        ///
        ///                Esri
        ///
        ///
        ///                HERE
        ///
        ///
        ///          For additional details on data providers, see the <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers page.
        /// This member is required.
        public var dataSource: Swift.String?
        /// Contains the coordinates for the optional bounding box coordinated entered in the
        ///          geocoding request.
        public var filterBBox: [Swift.Double]?
        /// Contains the country filter entered in the geocoding request.
        public var filterCountries: [Swift.String]?
        /// Contains the maximum number of results indicated for the request.
        public var maxResults: Swift.Int
        /// A bounding box that contains the search results within the specified area indicated by
        ///             FilterBBox. A subset of bounding box specified using
        ///             FilterBBox.
        public var resultBBox: [Swift.Double]?
        /// The address, name, city or region to be used in the geocoding request. In free-form text
        ///          format. For example, Vancouver.
        /// This member is required.
        public var text: Swift.String?

        public init (
            biasPosition: [Swift.Double]? = nil,
            dataSource: Swift.String? = nil,
            filterBBox: [Swift.Double]? = nil,
            filterCountries: [Swift.String]? = nil,
            maxResults: Swift.Int = 0,
            resultBBox: [Swift.Double]? = nil,
            text: Swift.String? = nil
        )
        {
            self.biasPosition = biasPosition
            self.dataSource = dataSource
            self.filterBBox = filterBBox
            self.filterCountries = filterCountries
            self.maxResults = maxResults
            self.resultBBox = resultBBox
            self.text = text
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation was denied because the request would exceed the maximum <a href="https://docs.aws.amazon.com/location/latest/developerguide/location-quotas.html">quota
///       set for Amazon Location Service.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message with the reason for the service quota exceeded exception error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes.Step: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distance = "Distance"
        case durationSeconds = "DurationSeconds"
        case endPosition = "EndPosition"
        case geometryOffset = "GeometryOffset"
        case startPosition = "StartPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distance = distance {
            try encodeContainer.encode(distance, forKey: .distance)
        }
        if let durationSeconds = durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let endPosition = endPosition {
            var endPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endPosition)
            for position0 in endPosition {
                try endPositionContainer.encode(position0)
            }
        }
        if let geometryOffset = geometryOffset {
            try encodeContainer.encode(geometryOffset, forKey: .geometryOffset)
        }
        if let startPosition = startPosition {
            var startPositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startPosition)
            for position0 in startPosition {
                try startPositionContainer.encode(position0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .startPosition)
        var startPositionDecoded0:[Swift.Double]? = nil
        if let startPositionContainer = startPositionContainer {
            startPositionDecoded0 = [Swift.Double]()
            for double0 in startPositionContainer {
                if let double0 = double0 {
                    startPositionDecoded0?.append(double0)
                }
            }
        }
        startPosition = startPositionDecoded0
        let endPositionContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .endPosition)
        var endPositionDecoded0:[Swift.Double]? = nil
        if let endPositionContainer = endPositionContainer {
            endPositionDecoded0 = [Swift.Double]()
            for double0 in endPositionContainer {
                if let double0 = double0 {
                    endPositionDecoded0?.append(double0)
                }
            }
        }
        endPosition = endPositionDecoded0
        let distanceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .distance)
        distance = distanceDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let geometryOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .geometryOffset)
        geometryOffset = geometryOffsetDecoded
    }
}

extension LocationClientTypes.Step: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Step(distance: \(Swift.String(describing: distance)), durationSeconds: \(Swift.String(describing: durationSeconds)), endPosition: \(Swift.String(describing: endPosition)), geometryOffset: \(Swift.String(describing: geometryOffset)), startPosition: \(Swift.String(describing: startPosition)))"}
}

extension LocationClientTypes {
    ///  Represents an element of a leg within a route. A step contains instructions for how
    ///             to move to the next step in the leg.
    public struct Step: Swift.Equatable {
        /// The travel distance between the step's StartPosition and
        ///                 EndPosition.
        /// This member is required.
        public var distance: Swift.Double?
        /// The estimated travel time, in seconds, from the step's StartPosition to
        ///             the EndPosition. . The travel mode and departure time that you specify in
        ///             the request determines the calculated time.
        /// This member is required.
        public var durationSeconds: Swift.Double?
        /// The end position of a step. If the position the last step in the leg, this position is
        ///             the same as the end position of the leg.
        /// This member is required.
        public var endPosition: [Swift.Double]?
        /// Represents the start position, or index, in a sequence of steps within the leg's line
        ///             string geometry. For example, the index of the first step in a leg geometry is
        ///                 0.
        ///         Included in the response for queries that set IncludeLegGeometry to
        ///                 True.
        public var geometryOffset: Swift.Int?
        /// The starting position of a step. If the position is the first step in the leg, this
        ///             position is the same as the start position of the leg.
        /// This member is required.
        public var startPosition: [Swift.Double]?

        public init (
            distance: Swift.Double? = nil,
            durationSeconds: Swift.Double? = nil,
            endPosition: [Swift.Double]? = nil,
            geometryOffset: Swift.Int? = nil,
            startPosition: [Swift.Double]? = nil
        )
        {
            self.distance = distance
            self.durationSeconds = durationSeconds
            self.endPosition = endPosition
            self.geometryOffset = geometryOffset
            self.startPosition = startPosition
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "metadata.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource whose tags you want to update.
    /// 	
    ///
    ///                Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
    ///
    ///
    ///
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags that have been applied to the specified resource. Tags are mapped from the tag key to the tag value: "TagKey" : "TagValue".
    /// 	
    ///
    ///                Format example: {"tag1" : "value1", "tag2" : "value2"}
    ///
    ///
    ///
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied because of request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes {
    public enum TravelMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case car
        case truck
        case walking
        case sdkUnknown(Swift.String)

        public static var allCases: [TravelMode] {
            return [
                .car,
                .truck,
                .walking,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .car: return "Car"
            case .truck: return "Truck"
            case .walking: return "Walking"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TravelMode(rawValue: rawValue) ?? TravelMode.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes.TruckDimensions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case height = "Height"
        case length = "Length"
        case unit = "Unit"
        case width = "Width"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let height = height {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let length = length {
            try encodeContainer.encode(length, forKey: .length)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let width = width {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lengthDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .length)
        length = lengthDecoded
        let heightDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .height)
        height = heightDecoded
        let widthDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .width)
        width = widthDecoded
        let unitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DimensionUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension LocationClientTypes.TruckDimensions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TruckDimensions(height: \(Swift.String(describing: height)), length: \(Swift.String(describing: length)), unit: \(Swift.String(describing: unit)), width: \(Swift.String(describing: width)))"}
}

extension LocationClientTypes {
    /// Contains details about the truck dimensions in the unit of measurement that you
    ///             specify. Used to filter out roads that can't support or allow the specified dimensions
    ///             for requests that specify TravelMode as Truck.
    public struct TruckDimensions: Swift.Equatable {
        /// The height of the truck.
        ///
        ///
        ///                 For example, 4.5.
        ///
        ///
        public var height: Swift.Double?
        /// The length of the truck.
        ///
        ///
        ///                 For example, 15.5.
        ///
        ///
        public var length: Swift.Double?
        ///  Specifies the unit of measurement for the truck dimensions.
        ///         Default Value: Meters
        ///
        public var unit: LocationClientTypes.DimensionUnit?
        /// The width of the truck.
        ///
        ///
        ///                 For example, 4.5.
        ///
        ///
        public var width: Swift.Double?

        public init (
            height: Swift.Double? = nil,
            length: Swift.Double? = nil,
            unit: LocationClientTypes.DimensionUnit? = nil,
            width: Swift.Double? = nil
        )
        {
            self.height = height
            self.length = length
            self.unit = unit
            self.width = width
        }
    }

}

extension LocationClientTypes.TruckWeight: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case total = "Total"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .total)
        total = totalDecoded
        let unitDecoded = try containerValues.decodeIfPresent(LocationClientTypes.VehicleWeightUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension LocationClientTypes.TruckWeight: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TruckWeight(total: \(Swift.String(describing: total)), unit: \(Swift.String(describing: unit)))"}
}

extension LocationClientTypes {
    /// Contains details about the truck's weight specifications. Used to avoid roads that
    ///             can't support or allow the total weight for requests that specify
    ///                 TravelMode as Truck.
    public struct TruckWeight: Swift.Equatable {
        /// The total weight of the truck.
        ///
        ///
        ///                 For example, 3500.
        ///
        ///
        public var total: Swift.Double?
        /// The unit of measurement to use for the truck weight.
        ///         Default Value: Kilograms
        ///
        public var unit: LocationClientTypes.VehicleWeightUnit?

        public init (
            total: Swift.Double? = nil,
            unit: LocationClientTypes.VehicleWeightUnit? = nil
        )
        {
            self.total = total
            self.unit = unit
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "metadata.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource from which you want to remove tags.
    /// 	
    ///
    ///                Format example: arn:aws:geo:region:account-id:resourcetype/ExampleResource
    ///
    ///
    ///
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateGeofenceCollectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGeofenceCollectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGeofenceCollectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGeofenceCollectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGeofenceCollectionOutputError>
}

extension UpdateGeofenceCollectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGeofenceCollectionInput(collectionName: \(Swift.String(describing: collectionName)), description: \(Swift.String(describing: description)), pricingPlan: \(Swift.String(describing: pricingPlan)), pricingPlanDataSource: \(Swift.String(describing: pricingPlanDataSource)))"}
}

extension UpdateGeofenceCollectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
    }
}

public struct UpdateGeofenceCollectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGeofenceCollectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGeofenceCollectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGeofenceCollectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGeofenceCollectionOutputError>
}

public struct UpdateGeofenceCollectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGeofenceCollectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGeofenceCollectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGeofenceCollectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGeofenceCollectionOutputError>
}

public struct UpdateGeofenceCollectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGeofenceCollectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateGeofenceCollectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "geofencing.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateGeofenceCollectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGeofenceCollectionOutputError>
}

public struct UpdateGeofenceCollectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGeofenceCollectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateGeofenceCollectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGeofenceCollectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let collectionName = input.collectionName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("collectionName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/geofencing/v0/collections/\(collectionName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateGeofenceCollectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGeofenceCollectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGeofenceCollectionOutputError>
}

public struct UpdateGeofenceCollectionInput: Swift.Equatable {
    /// The name of the geofence collection to update.
    /// This member is required.
    public var collectionName: Swift.String?
    /// Updates the description for the geofence collection.
    public var description: Swift.String?
    /// Updates the pricing plan for the geofence collection.
    ///         For more information about each pricing plan option restrictions, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service
    ///                 pricing.
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Updates the data provider for the geofence collection.
    ///         A required value for the following pricing plans: MobileAssetTracking|
    ///                 MobileAssetManagement
    ///
    ///         For more information about <a href="https://aws.amazon.com/location/data-providers/">data providers and
    ///                 <a href="https://aws.amazon.com/location/pricing/">pricing plans, see the
    ///             Amazon Location Service product page.
    ///
    ///             This can only be updated when updating the PricingPlan in the same
    ///                 request.
    ///             Amazon Location Service uses PricingPlanDataSource to calculate
    ///                 billing for your geofence collection. Your data won't be shared with the data
    ///                 provider, and will remain in your AWS account and Region unless you move it.
    ///
    public var pricingPlanDataSource: Swift.String?

    public init (
        collectionName: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil
    )
    {
        self.collectionName = collectionName
        self.description = description
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
    }
}

struct UpdateGeofenceCollectionInputBody: Swift.Equatable {
    public let pricingPlan: LocationClientTypes.PricingPlan?
    public let pricingPlanDataSource: Swift.String?
    public let description: Swift.String?
}

extension UpdateGeofenceCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGeofenceCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGeofenceCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGeofenceCollectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGeofenceCollectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGeofenceCollectionOutputResponse(collectionArn: \(Swift.String(describing: collectionArn)), collectionName: \(Swift.String(describing: collectionName)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension UpdateGeofenceCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateGeofenceCollectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.collectionArn = output.collectionArn
            self.collectionName = output.collectionName
            self.updateTime = output.updateTime
        } else {
            self.collectionArn = nil
            self.collectionName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateGeofenceCollectionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated geofence collection. Used to specify a
    ///             resource across AWS.
    ///
    ///
    ///                 Format example:
    ///                         arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollection
    ///
    ///
    ///
    /// This member is required.
    public var collectionArn: Swift.String?
    /// The name of the updated geofence collection.
    /// This member is required.
    public var collectionName: Swift.String?
    /// The time when the geofence collection was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ
    ///
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        collectionArn: Swift.String? = nil,
        collectionName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.collectionArn = collectionArn
        self.collectionName = collectionName
        self.updateTime = updateTime
    }
}

struct UpdateGeofenceCollectionOutputResponseBody: Swift.Equatable {
    public let collectionName: Swift.String?
    public let collectionArn: Swift.String?
    public let updateTime: ClientRuntime.Date?
}

extension UpdateGeofenceCollectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionArn = "CollectionArn"
        case collectionName = "CollectionName"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let collectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionArn)
        collectionArn = collectionArnDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

public struct UpdateMapInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMapInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMapOutputError>
}

extension UpdateMapInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMapInput(description: \(Swift.String(describing: description)), mapName: \(Swift.String(describing: mapName)), pricingPlan: \(Swift.String(describing: pricingPlan)))"}
}

extension UpdateMapInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
    }
}

public struct UpdateMapInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMapInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMapOutputError>
}

public struct UpdateMapInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMapInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMapInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMapInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMapOutputError>
}

public struct UpdateMapInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMapInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateMapInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "maps.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMapInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMapOutputError>
}

public struct UpdateMapInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMapInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateMapInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let mapName = input.mapName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("mapName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/maps/v0/maps/\(mapName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMapInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMapOutputError>
}

public struct UpdateMapInput: Swift.Equatable {
    /// Updates the description for the map resource.
    public var description: Swift.String?
    /// The name of the map resource to update.
    /// This member is required.
    public var mapName: Swift.String?
    /// Updates the pricing plan for the map resource.
    ///         For more information about each pricing plan option restrictions, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing.
    public var pricingPlan: LocationClientTypes.PricingPlan?

    public init (
        description: Swift.String? = nil,
        mapName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil
    )
    {
        self.description = description
        self.mapName = mapName
        self.pricingPlan = pricingPlan
    }
}

struct UpdateMapInputBody: Swift.Equatable {
    public let pricingPlan: LocationClientTypes.PricingPlan?
    public let description: Swift.String?
}

extension UpdateMapInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateMapOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMapOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMapOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMapOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMapOutputResponse(mapArn: \(Swift.String(describing: mapArn)), mapName: \(Swift.String(describing: mapName)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension UpdateMapOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMapOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mapArn = output.mapArn
            self.mapName = output.mapName
            self.updateTime = output.updateTime
        } else {
            self.mapArn = nil
            self.mapName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateMapOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated map resource. Used to specify a resource
    ///             across AWS.
    ///
    ///
    ///                Format example: arn:aws:geo:region:account-id:maps/ExampleMap
    ///
    ///
    ///
    /// This member is required.
    public var mapArn: Swift.String?
    /// The name of the updated map resource.
    /// This member is required.
    public var mapName: Swift.String?
    /// The timestamp for when the map resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        mapArn: Swift.String? = nil,
        mapName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.mapArn = mapArn
        self.mapName = mapName
        self.updateTime = updateTime
    }
}

struct UpdateMapOutputResponseBody: Swift.Equatable {
    public let mapName: Swift.String?
    public let mapArn: Swift.String?
    public let updateTime: ClientRuntime.Date?
}

extension UpdateMapOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mapArn = "MapArn"
        case mapName = "MapName"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapName)
        mapName = mapNameDecoded
        let mapArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapArn)
        mapArn = mapArnDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

public struct UpdatePlaceIndexInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePlaceIndexInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePlaceIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePlaceIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePlaceIndexOutputError>
}

extension UpdatePlaceIndexInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePlaceIndexInput(dataSourceConfiguration: \(Swift.String(describing: dataSourceConfiguration)), description: \(Swift.String(describing: description)), indexName: \(Swift.String(describing: indexName)), pricingPlan: \(Swift.String(describing: pricingPlan)))"}
}

extension UpdatePlaceIndexInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceConfiguration = "DataSourceConfiguration"
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceConfiguration = dataSourceConfiguration {
            try encodeContainer.encode(dataSourceConfiguration, forKey: .dataSourceConfiguration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
    }
}

public struct UpdatePlaceIndexInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePlaceIndexInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePlaceIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePlaceIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePlaceIndexOutputError>
}

public struct UpdatePlaceIndexInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePlaceIndexInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePlaceIndexInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePlaceIndexInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePlaceIndexOutputError>
}

public struct UpdatePlaceIndexInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePlaceIndexInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdatePlaceIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "places.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePlaceIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePlaceIndexOutputError>
}

public struct UpdatePlaceIndexInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePlaceIndexInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdatePlaceIndexInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePlaceIndexOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let indexName = input.indexName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("indexName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/places/v0/indexes/\(indexName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePlaceIndexInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePlaceIndexOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePlaceIndexOutputError>
}

public struct UpdatePlaceIndexInput: Swift.Equatable {
    /// Updates the data storage option for the place index resource.
    public var dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
    /// Updates the description for the place index resource.
    public var description: Swift.String?
    /// The name of the place index resource to update.
    /// This member is required.
    public var indexName: Swift.String?
    /// Updates the pricing plan for the place index resource.
    ///          For more information about each pricing plan option restrictions, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing.
    public var pricingPlan: LocationClientTypes.PricingPlan?

    public init (
        dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        indexName: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil
    )
    {
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.indexName = indexName
        self.pricingPlan = pricingPlan
    }
}

struct UpdatePlaceIndexInputBody: Swift.Equatable {
    public let pricingPlan: LocationClientTypes.PricingPlan?
    public let description: Swift.String?
    public let dataSourceConfiguration: LocationClientTypes.DataSourceConfiguration?
}

extension UpdatePlaceIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceConfiguration = "DataSourceConfiguration"
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(LocationClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
    }
}

extension UpdatePlaceIndexOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePlaceIndexOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePlaceIndexOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePlaceIndexOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePlaceIndexOutputResponse(indexArn: \(Swift.String(describing: indexArn)), indexName: \(Swift.String(describing: indexName)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension UpdatePlaceIndexOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePlaceIndexOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.indexArn = output.indexArn
            self.indexName = output.indexName
            self.updateTime = output.updateTime
        } else {
            self.indexArn = nil
            self.indexName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdatePlaceIndexOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the upated place index resource. Used to specify a
    ///          resource across AWS.
    ///
    ///
    ///                Format example: arn:aws:geo:region:account-id:place-
    ///             index/ExamplePlaceIndex
    ///
    ///
    ///
    /// This member is required.
    public var indexArn: Swift.String?
    /// The name of the updated place index resource.
    /// This member is required.
    public var indexName: Swift.String?
    /// The timestamp for when the place index resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601 format:
    ///             YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.indexArn = indexArn
        self.indexName = indexName
        self.updateTime = updateTime
    }
}

struct UpdatePlaceIndexOutputResponseBody: Swift.Equatable {
    public let indexName: Swift.String?
    public let indexArn: Swift.String?
    public let updateTime: ClientRuntime.Date?
}

extension UpdatePlaceIndexOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexArn = "IndexArn"
        case indexName = "IndexName"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let indexArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexArn)
        indexArn = indexArnDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

public struct UpdateRouteCalculatorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRouteCalculatorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRouteCalculatorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRouteCalculatorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRouteCalculatorOutputError>
}

extension UpdateRouteCalculatorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRouteCalculatorInput(calculatorName: \(Swift.String(describing: calculatorName)), description: \(Swift.String(describing: description)), pricingPlan: \(Swift.String(describing: pricingPlan)))"}
}

extension UpdateRouteCalculatorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
    }
}

public struct UpdateRouteCalculatorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRouteCalculatorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRouteCalculatorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRouteCalculatorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRouteCalculatorOutputError>
}

public struct UpdateRouteCalculatorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRouteCalculatorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRouteCalculatorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRouteCalculatorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRouteCalculatorOutputError>
}

public struct UpdateRouteCalculatorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRouteCalculatorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateRouteCalculatorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "routes.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRouteCalculatorInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRouteCalculatorOutputError>
}

public struct UpdateRouteCalculatorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRouteCalculatorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateRouteCalculatorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRouteCalculatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let calculatorName = input.calculatorName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("calculatorName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/routes/v0/calculators/\(calculatorName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRouteCalculatorInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRouteCalculatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRouteCalculatorOutputError>
}

public struct UpdateRouteCalculatorInput: Swift.Equatable {
    /// The name of the route calculator resource to update.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// Updates the description for the route calculator resource.
    public var description: Swift.String?
    /// Updates the pricing plan for the route calculator resource.
    ///         For more information about each pricing plan option restrictions, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location
    ///             Service pricing.
    public var pricingPlan: LocationClientTypes.PricingPlan?

    public init (
        calculatorName: Swift.String? = nil,
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil
    )
    {
        self.calculatorName = calculatorName
        self.description = description
        self.pricingPlan = pricingPlan
    }
}

struct UpdateRouteCalculatorInputBody: Swift.Equatable {
    public let pricingPlan: LocationClientTypes.PricingPlan?
    public let description: Swift.String?
}

extension UpdateRouteCalculatorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRouteCalculatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRouteCalculatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRouteCalculatorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRouteCalculatorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRouteCalculatorOutputResponse(calculatorArn: \(Swift.String(describing: calculatorArn)), calculatorName: \(Swift.String(describing: calculatorName)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension UpdateRouteCalculatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRouteCalculatorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.calculatorArn = output.calculatorArn
            self.calculatorName = output.calculatorName
            self.updateTime = output.updateTime
        } else {
            self.calculatorArn = nil
            self.calculatorName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateRouteCalculatorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated route calculator resource. Used to specify a resource
    ///             across AWS.
    ///
    ///
    ///                Format example: arn:aws:geo:region:account-id:route-
    ///                 calculator/ExampleCalculator
    ///
    ///
    ///
    /// This member is required.
    public var calculatorArn: Swift.String?
    /// The name of the updated route calculator resource.
    /// This member is required.
    public var calculatorName: Swift.String?
    /// The timestamp for when the route calculator was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        calculatorArn: Swift.String? = nil,
        calculatorName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.calculatorArn = calculatorArn
        self.calculatorName = calculatorName
        self.updateTime = updateTime
    }
}

struct UpdateRouteCalculatorOutputResponseBody: Swift.Equatable {
    public let calculatorName: Swift.String?
    public let calculatorArn: Swift.String?
    public let updateTime: ClientRuntime.Date?
}

extension UpdateRouteCalculatorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatorArn = "CalculatorArn"
        case calculatorName = "CalculatorName"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorName)
        calculatorName = calculatorNameDecoded
        let calculatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculatorArn)
        calculatorArn = calculatorArnDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

public struct UpdateTrackerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTrackerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTrackerOutputError>
}

extension UpdateTrackerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTrackerInput(description: \(Swift.String(describing: description)), pricingPlan: \(Swift.String(describing: pricingPlan)), pricingPlanDataSource: \(Swift.String(describing: pricingPlanDataSource)), trackerName: \(Swift.String(describing: trackerName)))"}
}

extension UpdateTrackerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pricingPlan = pricingPlan {
            try encodeContainer.encode(pricingPlan.rawValue, forKey: .pricingPlan)
        }
        if let pricingPlanDataSource = pricingPlanDataSource {
            try encodeContainer.encode(pricingPlanDataSource, forKey: .pricingPlanDataSource)
        }
    }
}

public struct UpdateTrackerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTrackerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTrackerOutputError>
}

public struct UpdateTrackerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTrackerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTrackerOutputError>
}

public struct UpdateTrackerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTrackerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateTrackerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "tracking.")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateTrackerInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTrackerOutputError>
}

public struct UpdateTrackerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTrackerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateTrackerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trackerName = input.trackerName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trackerName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tracking/v0/trackers/\(trackerName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateTrackerInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTrackerOutputError>
}

public struct UpdateTrackerInput: Swift.Equatable {
    /// Updates the description for the tracker resource.
    public var description: Swift.String?
    /// Updates the pricing plan for the tracker resource.
    ///         For more information about each pricing plan option restrictions, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service
    ///                 pricing.
    public var pricingPlan: LocationClientTypes.PricingPlan?
    /// Updates the data provider for the tracker resource.
    ///         A required value for the following pricing plans: MobileAssetTracking| MobileAssetManagement
    ///
    ///         For more information about <a href="https://aws.amazon.com/location/data-providers/">data providers and <a href="https://aws.amazon.com/location/pricing/">pricing plans, see the Amazon Location Service product
    ///             page
    ///
    ///             This can only be updated when updating the PricingPlan in the same
    ///                 request.
    ///             Amazon Location Service uses PricingPlanDataSource to calculate
    ///                 billing for your tracker resource. Your data won't be shared with the data provider,
    ///                 and will remain in your AWS account and Region unless you move it.
    ///
    public var pricingPlanDataSource: Swift.String?
    /// The name of the tracker resource to update.
    /// This member is required.
    public var trackerName: Swift.String?

    public init (
        description: Swift.String? = nil,
        pricingPlan: LocationClientTypes.PricingPlan? = nil,
        pricingPlanDataSource: Swift.String? = nil,
        trackerName: Swift.String? = nil
    )
    {
        self.description = description
        self.pricingPlan = pricingPlan
        self.pricingPlanDataSource = pricingPlanDataSource
        self.trackerName = trackerName
    }
}

struct UpdateTrackerInputBody: Swift.Equatable {
    public let pricingPlan: LocationClientTypes.PricingPlan?
    public let pricingPlanDataSource: Swift.String?
    public let description: Swift.String?
}

extension UpdateTrackerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case pricingPlan = "PricingPlan"
        case pricingPlanDataSource = "PricingPlanDataSource"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanDecoded = try containerValues.decodeIfPresent(LocationClientTypes.PricingPlan.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let pricingPlanDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanDataSource)
        pricingPlanDataSource = pricingPlanDataSourceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateTrackerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTrackerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTrackerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTrackerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTrackerOutputResponse(trackerArn: \(Swift.String(describing: trackerArn)), trackerName: \(Swift.String(describing: trackerName)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension UpdateTrackerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateTrackerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trackerArn = output.trackerArn
            self.trackerName = output.trackerName
            self.updateTime = output.updateTime
        } else {
            self.trackerArn = nil
            self.trackerName = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateTrackerOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated tracker resource. Used to specify a resource across
    ///             AWS.
    ///
    ///
    ///                Format example: arn:aws:geo:region:account-id:tracker/ExampleTracker
    ///
    ///
    ///
    /// This member is required.
    public var trackerArn: Swift.String?
    /// The name of the updated tracker resource.
    /// This member is required.
    public var trackerName: Swift.String?
    /// The timestamp for when the tracker resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601
    ///             format: YYYY-MM-DDThh:mm:ss.sssZ.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        trackerArn: Swift.String? = nil,
        trackerName: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.trackerArn = trackerArn
        self.trackerName = trackerName
        self.updateTime = updateTime
    }
}

struct UpdateTrackerOutputResponseBody: Swift.Equatable {
    public let trackerName: Swift.String?
    public let trackerArn: Swift.String?
    public let updateTime: ClientRuntime.Date?
}

extension UpdateTrackerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trackerArn = "TrackerArn"
        case trackerName = "TrackerName"
        case updateTime = "UpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let trackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerArn)
        trackerArn = trackerArnDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(fieldList: \(Swift.String(describing: fieldList)), message: \(Swift.String(describing: message)), reason: \(Swift.String(describing: reason)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input failed to meet the constraints specified by the AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The field where the invalid entry was detected.
    /// This member is required.
    public var fieldList: [LocationClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// A message with the reason for the validation exception error.
    /// This member is required.
    public var reason: LocationClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [LocationClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: LocationClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let reason: LocationClientTypes.ValidationExceptionReason?
    public let fieldList: [LocationClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList = "fieldList"
        case message = "message"
        case reason = "reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(LocationClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([LocationClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[LocationClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [LocationClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension LocationClientTypes.ValidationExceptionField: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LocationClientTypes.ValidationExceptionField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationExceptionField(message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)))"}
}

extension LocationClientTypes {
    /// The input failed to meet the constraints specified by the AWS service in a specified
    ///       field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message with the reason for the validation exception error.
        /// This member is required.
        public var message: Swift.String?
        /// The field name where the invalid entry was detected.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension LocationClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        ///     The input cannot be parsed. For example a required JSON document, ARN identifier,
        ///     date value, or numeric field cannot be parsed.
        ///
        case cannotparse
        ///     The input is present and parsable, but it is otherwise invalid. For example, a
        ///     required numeric argument is outside the allowed range.
        ///
        case fieldvalidationfailed
        /// The required input is missing.
        case missing
        /// The input is invalid but no more specific reason is applicable.
        case other
        /// No such operation is supported.
        case unknownoperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotparse,
                .fieldvalidationfailed,
                .missing,
                .other,
                .unknownoperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotparse: return "CannotParse"
            case .fieldvalidationfailed: return "FieldValidationFailed"
            case .missing: return "Missing"
            case .other: return "Other"
            case .unknownoperation: return "UnknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension LocationClientTypes {
    public enum VehicleWeightUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kilograms
        case pounds
        case sdkUnknown(Swift.String)

        public static var allCases: [VehicleWeightUnit] {
            return [
                .kilograms,
                .pounds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kilograms: return "Kilograms"
            case .pounds: return "Pounds"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VehicleWeightUnit(rawValue: rawValue) ?? VehicleWeightUnit.sdkUnknown(rawValue)
        }
    }
}
