// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension LocationClient {
    /// Creates an association between a geofence collection and a tracker resource. This
    ///             allows the tracker resource to communicate location data to the linked geofence
    ///             collection.
    ///         You can associate up to five geofence collections to each tracker resource.
    ///
    ///             Currently not supported — Cross-account configurations, such as creating associations between a tracker resource in one account and a geofence collection in another account.
    ///
    func associateTrackerConsumer(input: AssociateTrackerConsumerInput) async throws -> AssociateTrackerConsumerOutputResponse
    {
        typealias associateTrackerConsumerContinuation = CheckedContinuation<AssociateTrackerConsumerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateTrackerConsumerContinuation) in
            associateTrackerConsumer(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the position history of one or more devices from a tracker resource.
    func batchDeleteDevicePositionHistory(input: BatchDeleteDevicePositionHistoryInput) async throws -> BatchDeleteDevicePositionHistoryOutputResponse
    {
        typealias batchDeleteDevicePositionHistoryContinuation = CheckedContinuation<BatchDeleteDevicePositionHistoryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchDeleteDevicePositionHistoryContinuation) in
            batchDeleteDevicePositionHistory(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a batch of geofences from a geofence collection.
    ///
    ///             This operation deletes the resource permanently.
    ///
    func batchDeleteGeofence(input: BatchDeleteGeofenceInput) async throws -> BatchDeleteGeofenceOutputResponse
    {
        typealias batchDeleteGeofenceContinuation = CheckedContinuation<BatchDeleteGeofenceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchDeleteGeofenceContinuation) in
            batchDeleteGeofence(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Evaluates device positions against the geofence geometries from a given geofence
    ///             collection.
    ///         This operation always returns an empty response because geofences are asynchronously
    ///             evaluated. The evaluation determines if the device has entered or exited a geofenced
    ///             area, and then publishes one of the following events to Amazon EventBridge:
    ///
    ///
    ///
    ///                   ENTER if Amazon Location determines that the tracked device has entered
    ///                     a geofenced area.
    ///
    ///
    ///
    ///                   EXIT if Amazon Location determines that the tracked device has exited a
    ///                     geofenced area.
    ///
    ///
    ///
    ///             The last geofence that a device was observed within is tracked for 30 days after
    ///                 the most recent device position update.
    ///
    func batchEvaluateGeofences(input: BatchEvaluateGeofencesInput) async throws -> BatchEvaluateGeofencesOutputResponse
    {
        typealias batchEvaluateGeofencesContinuation = CheckedContinuation<BatchEvaluateGeofencesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchEvaluateGeofencesContinuation) in
            batchEvaluateGeofences(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the latest device positions for requested devices.
    func batchGetDevicePosition(input: BatchGetDevicePositionInput) async throws -> BatchGetDevicePositionOutputResponse
    {
        typealias batchGetDevicePositionContinuation = CheckedContinuation<BatchGetDevicePositionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchGetDevicePositionContinuation) in
            batchGetDevicePosition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// A batch request for storing geofence geometries into a given geofence collection, or
    ///             updates the geometry of an existing geofence if a geofence ID is included in the request.
    func batchPutGeofence(input: BatchPutGeofenceInput) async throws -> BatchPutGeofenceOutputResponse
    {
        typealias batchPutGeofenceContinuation = CheckedContinuation<BatchPutGeofenceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchPutGeofenceContinuation) in
            batchPutGeofence(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Uploads position update data for one or more devices to a tracker resource. Amazon Location
    ///             uses the data when reporting the last known device position and position history.
    ///
    ///            Only one position update is stored per sample time. Location data is sampled at a
    ///                 fixed rate of one position per 30-second interval and retained for 30 days before
    ///                 it's deleted.
    ///
    func batchUpdateDevicePosition(input: BatchUpdateDevicePositionInput) async throws -> BatchUpdateDevicePositionOutputResponse
    {
        typealias batchUpdateDevicePositionContinuation = CheckedContinuation<BatchUpdateDevicePositionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchUpdateDevicePositionContinuation) in
            batchUpdateDevicePosition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///
    ///             <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html">Calculates a route given the following required parameters:
    ///                 DeparturePostiton and DestinationPosition. Requires that
    ///             you first <a href="https://docs.aws.amazon.com/location-routes/latest/APIReference/API_CreateRouteCalculator.html">create a
    ///                 route calculator resource
    ///
    ///         By default, a request that doesn't specify a departure time uses the best time of day
    ///             to travel with the best traffic conditions when calculating the route.
    ///         Additional options include:
    ///
    ///
    ///
    ///                   <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#departure-time">Specifying a departure time using either DepartureTime or
    ///                         DepartureNow. This calculates a route based on predictive
    ///                     traffic data at the given time.
    ///
    ///                     You can't specify both DepartureTime and
    ///                             DepartureNow in a single request. Specifying both
    ///                         parameters returns an error message.
    ///
    ///
    ///
    ///
    ///                   <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#travel-mode">Specifying a travel mode using TravelMode. This lets you specify an
    ///                     additional route preference such as CarModeOptions if traveling by
    ///                         Car, or TruckModeOptions if traveling by
    ///                         Truck.
    ///
    ///
    ///
    ///
    func calculateRoute(input: CalculateRouteInput) async throws -> CalculateRouteOutputResponse
    {
        typealias calculateRouteContinuation = CheckedContinuation<CalculateRouteOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: calculateRouteContinuation) in
            calculateRoute(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a geofence collection, which manages and stores geofences.
    func createGeofenceCollection(input: CreateGeofenceCollectionInput) async throws -> CreateGeofenceCollectionOutputResponse
    {
        typealias createGeofenceCollectionContinuation = CheckedContinuation<CreateGeofenceCollectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createGeofenceCollectionContinuation) in
            createGeofenceCollection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a map resource in your AWS account, which provides map tiles of different
    ///             styles sourced from global location data providers.
    func createMap(input: CreateMapInput) async throws -> CreateMapOutputResponse
    {
        typealias createMapContinuation = CheckedContinuation<CreateMapOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createMapContinuation) in
            createMap(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a place index resource in your AWS account, which supports functions with
    ///          geospatial data sourced from your chosen data provider.
    func createPlaceIndex(input: CreatePlaceIndexInput) async throws -> CreatePlaceIndexOutputResponse
    {
        typealias createPlaceIndexContinuation = CheckedContinuation<CreatePlaceIndexOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createPlaceIndexContinuation) in
            createPlaceIndex(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a route calculator resource in your AWS account.
    ///         You can send requests to a route calculator resource to estimate travel time,
    ///             distance, and get directions. A route calculator sources traffic and road network data
    ///             from your chosen data provider.
    func createRouteCalculator(input: CreateRouteCalculatorInput) async throws -> CreateRouteCalculatorOutputResponse
    {
        typealias createRouteCalculatorContinuation = CheckedContinuation<CreateRouteCalculatorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createRouteCalculatorContinuation) in
            createRouteCalculator(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a tracker resource in your AWS account, which lets you retrieve current and
    ///             historical location of devices.
    func createTracker(input: CreateTrackerInput) async throws -> CreateTrackerOutputResponse
    {
        typealias createTrackerContinuation = CheckedContinuation<CreateTrackerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createTrackerContinuation) in
            createTracker(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a geofence collection from your AWS account.
    ///
    ///             This operation deletes the resource permanently. If the geofence collection is the
    ///                 target of a tracker resource, the devices will no longer be monitored.
    ///
    func deleteGeofenceCollection(input: DeleteGeofenceCollectionInput) async throws -> DeleteGeofenceCollectionOutputResponse
    {
        typealias deleteGeofenceCollectionContinuation = CheckedContinuation<DeleteGeofenceCollectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteGeofenceCollectionContinuation) in
            deleteGeofenceCollection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a map resource from your AWS account.
    ///
    ///             This operation deletes the resource permanently. If the map is being used in an application,
    ///                 the map may not render.
    ///
    func deleteMap(input: DeleteMapInput) async throws -> DeleteMapOutputResponse
    {
        typealias deleteMapContinuation = CheckedContinuation<DeleteMapOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteMapContinuation) in
            deleteMap(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a place index resource from your AWS account.
    ///
    ///             This operation deletes the resource permanently.
    ///
    func deletePlaceIndex(input: DeletePlaceIndexInput) async throws -> DeletePlaceIndexOutputResponse
    {
        typealias deletePlaceIndexContinuation = CheckedContinuation<DeletePlaceIndexOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deletePlaceIndexContinuation) in
            deletePlaceIndex(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a route calculator resource from your AWS account.
    ///
    ///             This operation deletes the resource permanently.
    ///
    func deleteRouteCalculator(input: DeleteRouteCalculatorInput) async throws -> DeleteRouteCalculatorOutputResponse
    {
        typealias deleteRouteCalculatorContinuation = CheckedContinuation<DeleteRouteCalculatorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRouteCalculatorContinuation) in
            deleteRouteCalculator(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a tracker resource from your AWS account.
    ///
    ///             This operation deletes the resource permanently. If the tracker resource is in use, you may
    ///                 encounter an error. Make sure that the target resource isn't a dependency for your
    ///                 applications.
    ///
    func deleteTracker(input: DeleteTrackerInput) async throws -> DeleteTrackerOutputResponse
    {
        typealias deleteTrackerContinuation = CheckedContinuation<DeleteTrackerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteTrackerContinuation) in
            deleteTracker(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the geofence collection details.
    func describeGeofenceCollection(input: DescribeGeofenceCollectionInput) async throws -> DescribeGeofenceCollectionOutputResponse
    {
        typealias describeGeofenceCollectionContinuation = CheckedContinuation<DescribeGeofenceCollectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeGeofenceCollectionContinuation) in
            describeGeofenceCollection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the map resource details.
    func describeMap(input: DescribeMapInput) async throws -> DescribeMapOutputResponse
    {
        typealias describeMapContinuation = CheckedContinuation<DescribeMapOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeMapContinuation) in
            describeMap(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the place index resource details.
    func describePlaceIndex(input: DescribePlaceIndexInput) async throws -> DescribePlaceIndexOutputResponse
    {
        typealias describePlaceIndexContinuation = CheckedContinuation<DescribePlaceIndexOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describePlaceIndexContinuation) in
            describePlaceIndex(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the route calculator resource details.
    func describeRouteCalculator(input: DescribeRouteCalculatorInput) async throws -> DescribeRouteCalculatorOutputResponse
    {
        typealias describeRouteCalculatorContinuation = CheckedContinuation<DescribeRouteCalculatorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRouteCalculatorContinuation) in
            describeRouteCalculator(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the tracker resource details.
    func describeTracker(input: DescribeTrackerInput) async throws -> DescribeTrackerOutputResponse
    {
        typealias describeTrackerContinuation = CheckedContinuation<DescribeTrackerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeTrackerContinuation) in
            describeTracker(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes the association between a tracker resource and a geofence collection.
    ///
    ///             Once you unlink a tracker resource from a geofence collection, the tracker
    ///                 positions will no longer be automatically evaluated against geofences.
    ///
    func disassociateTrackerConsumer(input: DisassociateTrackerConsumerInput) async throws -> DisassociateTrackerConsumerOutputResponse
    {
        typealias disassociateTrackerConsumerContinuation = CheckedContinuation<DisassociateTrackerConsumerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateTrackerConsumerContinuation) in
            disassociateTrackerConsumer(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a device's most recent position according to its sample time.
    ///
    ///             Device positions are deleted after 30 days.
    ///
    func getDevicePosition(input: GetDevicePositionInput) async throws -> GetDevicePositionOutputResponse
    {
        typealias getDevicePositionContinuation = CheckedContinuation<GetDevicePositionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDevicePositionContinuation) in
            getDevicePosition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the device position history from a tracker resource within a specified range
    ///             of time.
    ///
    ///            Device positions are deleted after 30 days.
    ///
    func getDevicePositionHistory(input: GetDevicePositionHistoryInput) async throws -> GetDevicePositionHistoryOutputResponse
    {
        typealias getDevicePositionHistoryContinuation = CheckedContinuation<GetDevicePositionHistoryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDevicePositionHistoryContinuation) in
            getDevicePositionHistory(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the geofence details from a geofence collection.
    func getGeofence(input: GetGeofenceInput) async throws -> GetGeofenceOutputResponse
    {
        typealias getGeofenceContinuation = CheckedContinuation<GetGeofenceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getGeofenceContinuation) in
            getGeofence(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves glyphs used to display labels on a map.
    func getMapGlyphs(input: GetMapGlyphsInput) async throws -> GetMapGlyphsOutputResponse
    {
        typealias getMapGlyphsContinuation = CheckedContinuation<GetMapGlyphsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getMapGlyphsContinuation) in
            getMapGlyphs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the sprite sheet corresponding to a map resource. The sprite sheet is a PNG
    ///             image paired with a JSON document describing the offsets of individual icons that will
    ///             be displayed on a rendered map.
    func getMapSprites(input: GetMapSpritesInput) async throws -> GetMapSpritesOutputResponse
    {
        typealias getMapSpritesContinuation = CheckedContinuation<GetMapSpritesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getMapSpritesContinuation) in
            getMapSprites(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the map style descriptor from a map resource.
    ///         The style descriptor contains speciﬁcations on how features render on a map. For
    ///             example, what data to display, what order to display the data in, and the style for the
    ///             data. Style descriptors follow the Mapbox Style Specification.
    func getMapStyleDescriptor(input: GetMapStyleDescriptorInput) async throws -> GetMapStyleDescriptorOutputResponse
    {
        typealias getMapStyleDescriptorContinuation = CheckedContinuation<GetMapStyleDescriptorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getMapStyleDescriptorContinuation) in
            getMapStyleDescriptor(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a vector data tile from the map resource. Map tiles are used by clients to
    ///             render a map. they're addressed using a grid arrangement with an X coordinate, Y
    ///             coordinate, and Z (zoom) level.
    ///         The origin (0, 0) is the top left of the map. Increasing the zoom level by 1 doubles
    ///             both the X and Y dimensions, so a tile containing data for the entire world at (0/0/0)
    ///             will be split into 4 tiles at zoom 1 (1/0/0, 1/0/1, 1/1/0, 1/1/1).
    func getMapTile(input: GetMapTileInput) async throws -> GetMapTileOutputResponse
    {
        typealias getMapTileContinuation = CheckedContinuation<GetMapTileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getMapTileContinuation) in
            getMapTile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// A batch request to retrieve all device positions.
    func listDevicePositions(input: ListDevicePositionsInput) async throws -> ListDevicePositionsOutputResponse
    {
        typealias listDevicePositionsContinuation = CheckedContinuation<ListDevicePositionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDevicePositionsContinuation) in
            listDevicePositions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists geofence collections in your AWS account.
    func listGeofenceCollections(input: ListGeofenceCollectionsInput) async throws -> ListGeofenceCollectionsOutputResponse
    {
        typealias listGeofenceCollectionsContinuation = CheckedContinuation<ListGeofenceCollectionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listGeofenceCollectionsContinuation) in
            listGeofenceCollections(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists geofences stored in a given geofence collection.
    func listGeofences(input: ListGeofencesInput) async throws -> ListGeofencesOutputResponse
    {
        typealias listGeofencesContinuation = CheckedContinuation<ListGeofencesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listGeofencesContinuation) in
            listGeofences(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists map resources in your AWS account.
    func listMaps(input: ListMapsInput) async throws -> ListMapsOutputResponse
    {
        typealias listMapsContinuation = CheckedContinuation<ListMapsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listMapsContinuation) in
            listMaps(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists place index resources in your AWS account.
    func listPlaceIndexes(input: ListPlaceIndexesInput) async throws -> ListPlaceIndexesOutputResponse
    {
        typealias listPlaceIndexesContinuation = CheckedContinuation<ListPlaceIndexesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listPlaceIndexesContinuation) in
            listPlaceIndexes(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists route calculator resources in your AWS account.
    func listRouteCalculators(input: ListRouteCalculatorsInput) async throws -> ListRouteCalculatorsOutputResponse
    {
        typealias listRouteCalculatorsContinuation = CheckedContinuation<ListRouteCalculatorsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listRouteCalculatorsContinuation) in
            listRouteCalculators(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of tags that are applied to the specified Amazon Location resource.
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists geofence collections currently associated to the given tracker resource.
    func listTrackerConsumers(input: ListTrackerConsumersInput) async throws -> ListTrackerConsumersOutputResponse
    {
        typealias listTrackerConsumersContinuation = CheckedContinuation<ListTrackerConsumersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTrackerConsumersContinuation) in
            listTrackerConsumers(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists tracker resources in your AWS account.
    func listTrackers(input: ListTrackersInput) async throws -> ListTrackersOutputResponse
    {
        typealias listTrackersContinuation = CheckedContinuation<ListTrackersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTrackersContinuation) in
            listTrackers(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Stores a geofence geometry in a given geofence collection, or updates the geometry of
    ///             an existing geofence if a geofence ID is included in the request.
    func putGeofence(input: PutGeofenceInput) async throws -> PutGeofenceOutputResponse
    {
        typealias putGeofenceContinuation = CheckedContinuation<PutGeofenceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putGeofenceContinuation) in
            putGeofence(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Reverse geocodes a given coordinate and returns a legible address. Allows you to search
    ///          for Places or points of interest near a given position.
    func searchPlaceIndexForPosition(input: SearchPlaceIndexForPositionInput) async throws -> SearchPlaceIndexForPositionOutputResponse
    {
        typealias searchPlaceIndexForPositionContinuation = CheckedContinuation<SearchPlaceIndexForPositionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: searchPlaceIndexForPositionContinuation) in
            searchPlaceIndexForPosition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Geocodes free-form text, such as an address, name, city, or region to allow you to
    ///          search for Places or points of interest.
    ///          Includes the option to apply additional parameters to narrow your list of
    ///          results.
    ///
    ///             You can search for places near a given position using BiasPosition, or
    ///             filter results within a bounding box using FilterBBox. Providing both
    ///             parameters simultaneously returns an error.
    ///
    func searchPlaceIndexForText(input: SearchPlaceIndexForTextInput) async throws -> SearchPlaceIndexForTextOutputResponse
    {
        typealias searchPlaceIndexForTextContinuation = CheckedContinuation<SearchPlaceIndexForTextOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: searchPlaceIndexForTextContinuation) in
            searchPlaceIndexForText(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Assigns one or more tags (key-value pairs) to the specified Amazon
    ///             Location Service resource.
    ///
    ///         Tags can help you organize and categorize your resources.
    ///             You can also use them to scope user permissions, by granting a user
    ///             permission to access or change only resources with certain tag values.
    ///
    ///         You can use the TagResource operation with an Amazon Location Service
    ///             resource that already has tags. If you specify a new tag key for the resource, this tag
    ///             is appended to the tags already associated with the resource. If you specify a tag key
    ///             that's already associated with the resource, the new tag value that you specify replaces
    ///             the previous value for that tag.
    ///
    ///         You can associate up to 50 tags with a resource.
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes one or more tags from the specified Amazon Location resource.
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the specified properties of a given geofence collection.
    func updateGeofenceCollection(input: UpdateGeofenceCollectionInput) async throws -> UpdateGeofenceCollectionOutputResponse
    {
        typealias updateGeofenceCollectionContinuation = CheckedContinuation<UpdateGeofenceCollectionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateGeofenceCollectionContinuation) in
            updateGeofenceCollection(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the specified properties of a given map resource.
    func updateMap(input: UpdateMapInput) async throws -> UpdateMapOutputResponse
    {
        typealias updateMapContinuation = CheckedContinuation<UpdateMapOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateMapContinuation) in
            updateMap(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the specified properties of a given place index resource.
    func updatePlaceIndex(input: UpdatePlaceIndexInput) async throws -> UpdatePlaceIndexOutputResponse
    {
        typealias updatePlaceIndexContinuation = CheckedContinuation<UpdatePlaceIndexOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updatePlaceIndexContinuation) in
            updatePlaceIndex(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the specified properties for a given route calculator resource.
    func updateRouteCalculator(input: UpdateRouteCalculatorInput) async throws -> UpdateRouteCalculatorOutputResponse
    {
        typealias updateRouteCalculatorContinuation = CheckedContinuation<UpdateRouteCalculatorOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateRouteCalculatorContinuation) in
            updateRouteCalculator(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the specified properties of a given tracker resource.
    func updateTracker(input: UpdateTrackerInput) async throws -> UpdateTrackerOutputResponse
    {
        typealias updateTrackerContinuation = CheckedContinuation<UpdateTrackerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateTrackerContinuation) in
            updateTracker(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
