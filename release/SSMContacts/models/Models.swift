// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SsmContactsClientTypes {
    public enum AcceptCodeValidation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enforce
        case ignore
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceptCodeValidation] {
            return [
                .enforce,
                .ignore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enforce: return "ENFORCE"
            case .ignore: return "IGNORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AcceptCodeValidation(rawValue: rawValue) ?? AcceptCodeValidation.sdkUnknown(rawValue)
        }
    }
}

public struct AcceptPageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptPageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptPageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptPageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptPageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptPageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptPageOutputError>
}

extension AcceptPageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptPageInput(acceptCode: \(Swift.String(describing: acceptCode)), acceptCodeValidation: \(Swift.String(describing: acceptCodeValidation)), acceptType: \(Swift.String(describing: acceptType)), contactChannelId: \(Swift.String(describing: contactChannelId)), note: \(Swift.String(describing: note)), pageId: \(Swift.String(describing: pageId)))"}
}

extension AcceptPageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptCode = "AcceptCode"
        case acceptCodeValidation = "AcceptCodeValidation"
        case acceptType = "AcceptType"
        case contactChannelId = "ContactChannelId"
        case note = "Note"
        case pageId = "PageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptCode = acceptCode {
            try encodeContainer.encode(acceptCode, forKey: .acceptCode)
        }
        if let acceptCodeValidation = acceptCodeValidation {
            try encodeContainer.encode(acceptCodeValidation.rawValue, forKey: .acceptCodeValidation)
        }
        if let acceptType = acceptType {
            try encodeContainer.encode(acceptType.rawValue, forKey: .acceptType)
        }
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let pageId = pageId {
            try encodeContainer.encode(pageId, forKey: .pageId)
        }
    }
}

public struct AcceptPageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptPageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptPageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptPageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptPageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptPageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptPageOutputError>
}

public struct AcceptPageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptPageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptPageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptPageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptPageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptPageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptPageOutputError>
}

public struct AcceptPageInput: Swift.Equatable {
    /// The accept code is a 6-digit code used to acknowledge the page.
    /// This member is required.
    public let acceptCode: Swift.String?
    /// An
    ///          optional field that Incident Manager uses to ENFORCE
    ///             AcceptCode validation when acknowledging an page.
    ///          Acknowledgement can occur by replying to a page, or when entering the AcceptCode in the
    ///          console. Enforcing AcceptCode validation causes Incident Manager to verify that the code
    ///          entered by the user matches the code sent by Incident Manager with the page.
    ///          Incident Manager can also IGNORE
    ///             AcceptCode validation. Ignoring AcceptCode validation causes
    ///          Incident Manager to accept any value entered for the AcceptCode.
    public let acceptCodeValidation: SsmContactsClientTypes.AcceptCodeValidation?
    /// The type indicates if the page was DELIVERED or READ.
    /// This member is required.
    public let acceptType: SsmContactsClientTypes.AcceptType?
    /// The ARN of the contact channel.
    public let contactChannelId: Swift.String?
    /// Information provided by the user when the user acknowledges the page.
    public let note: Swift.String?
    /// The Amazon Resource Name (ARN) of the engagement to a contact channel.
    /// This member is required.
    public let pageId: Swift.String?

    public init (
        acceptCode: Swift.String? = nil,
        acceptCodeValidation: SsmContactsClientTypes.AcceptCodeValidation? = nil,
        acceptType: SsmContactsClientTypes.AcceptType? = nil,
        contactChannelId: Swift.String? = nil,
        note: Swift.String? = nil,
        pageId: Swift.String? = nil
    )
    {
        self.acceptCode = acceptCode
        self.acceptCodeValidation = acceptCodeValidation
        self.acceptType = acceptType
        self.contactChannelId = contactChannelId
        self.note = note
        self.pageId = pageId
    }
}

struct AcceptPageInputBody: Swift.Equatable {
    public let pageId: Swift.String?
    public let contactChannelId: Swift.String?
    public let acceptType: SsmContactsClientTypes.AcceptType?
    public let note: Swift.String?
    public let acceptCode: Swift.String?
    public let acceptCodeValidation: SsmContactsClientTypes.AcceptCodeValidation?
}

extension AcceptPageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptCode = "AcceptCode"
        case acceptCodeValidation = "AcceptCodeValidation"
        case acceptType = "AcceptType"
        case contactChannelId = "ContactChannelId"
        case note = "Note"
        case pageId = "PageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageId)
        pageId = pageIdDecoded
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let acceptTypeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.AcceptType.self, forKey: .acceptType)
        acceptType = acceptTypeDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
        let acceptCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptCode)
        acceptCode = acceptCodeDecoded
        let acceptCodeValidationDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.AcceptCodeValidation.self, forKey: .acceptCodeValidation)
        acceptCodeValidation = acceptCodeValidationDecoded
    }
}

extension AcceptPageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptPageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptPageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptPageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptPageOutputResponse()"}
}

extension AcceptPageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AcceptPageOutputResponse: Swift.Equatable {

    public init() {}
}

struct AcceptPageOutputResponseBody: Swift.Equatable {
}

extension AcceptPageOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SsmContactsClientTypes {
    public enum AcceptType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delivered
        case read
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceptType] {
            return [
                .delivered,
                .read,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delivered: return "DELIVERED"
            case .read: return "READ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AcceptType(rawValue: rawValue) ?? AcceptType.sdkUnknown(rawValue)
        }
    }
}

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ActivateContactChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ActivateContactChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ActivateContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ActivateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ActivateContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ActivateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ActivateContactChannelOutputError>
}

extension ActivateContactChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivateContactChannelInput(activationCode: \(Swift.String(describing: activationCode)), contactChannelId: \(Swift.String(describing: contactChannelId)))"}
}

extension ActivateContactChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationCode = "ActivationCode"
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationCode = activationCode {
            try encodeContainer.encode(activationCode, forKey: .activationCode)
        }
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

public struct ActivateContactChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ActivateContactChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ActivateContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ActivateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ActivateContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ActivateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ActivateContactChannelOutputError>
}

public struct ActivateContactChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ActivateContactChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ActivateContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ActivateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ActivateContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ActivateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ActivateContactChannelOutputError>
}

public struct ActivateContactChannelInput: Swift.Equatable {
    /// The code sent to the contact channel when it was created in the contact.
    /// This member is required.
    public let activationCode: Swift.String?
    /// The Amazon Resource Name (ARN) of the contact channel.
    /// This member is required.
    public let contactChannelId: Swift.String?

    public init (
        activationCode: Swift.String? = nil,
        contactChannelId: Swift.String? = nil
    )
    {
        self.activationCode = activationCode
        self.contactChannelId = contactChannelId
    }
}

struct ActivateContactChannelInputBody: Swift.Equatable {
    public let contactChannelId: Swift.String?
    public let activationCode: Swift.String?
}

extension ActivateContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationCode = "ActivationCode"
        case contactChannelId = "ContactChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let activationCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationCode)
        activationCode = activationCodeDecoded
    }
}

extension ActivateContactChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateContactChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ActivateContactChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateContactChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivateContactChannelOutputResponse()"}
}

extension ActivateContactChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ActivateContactChannelOutputResponse: Swift.Equatable {

    public init() {}
}

struct ActivateContactChannelOutputResponseBody: Swift.Equatable {
}

extension ActivateContactChannelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SsmContactsClientTypes {
    public enum ActivationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activated
        case notActivated
        case sdkUnknown(Swift.String)

        public static var allCases: [ActivationStatus] {
            return [
                .activated,
                .notActivated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .notActivated: return "NOT_ACTIVATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActivationStatus(rawValue: rawValue) ?? ActivationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsmContactsClientTypes.ChannelTargetInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
        case retryIntervalInMinutes = "RetryIntervalInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
        if let retryIntervalInMinutes = retryIntervalInMinutes {
            try encodeContainer.encode(retryIntervalInMinutes, forKey: .retryIntervalInMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let retryIntervalInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryIntervalInMinutes)
        retryIntervalInMinutes = retryIntervalInMinutesDecoded
    }
}

extension SsmContactsClientTypes.ChannelTargetInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelTargetInfo(contactChannelId: \(Swift.String(describing: contactChannelId)), retryIntervalInMinutes: \(Swift.String(describing: retryIntervalInMinutes)))"}
}

extension SsmContactsClientTypes {
    /// Information about the contact channel that Incident Manager uses to engage the
    ///          contact.
    public struct ChannelTargetInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the contact channel.
        /// This member is required.
        public let contactChannelId: Swift.String?
        /// The number of minutes to wait to retry sending engagement in the case the engagement
        ///          initially fails.
        public let retryIntervalInMinutes: Swift.Int?

        public init (
            contactChannelId: Swift.String? = nil,
            retryIntervalInMinutes: Swift.Int? = nil
        )
        {
            self.contactChannelId = contactChannelId
            self.retryIntervalInMinutes = retryIntervalInMinutes
        }
    }

}

extension SsmContactsClientTypes {
    public enum ChannelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelType] {
            return [
                .email,
                .sms,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .sms: return "SMS"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelType(rawValue: rawValue) ?? ChannelType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Updating or deleting a resource causes an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Identifier of the resource in use
    /// This member is required.
    public var resourceId: Swift.String?
    /// ype of the resource in use
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SsmContactsClientTypes.Contact: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SsmContactsClientTypes.Contact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Contact(alias: \(Swift.String(describing: alias)), contactArn: \(Swift.String(describing: contactArn)), displayName: \(Swift.String(describing: displayName)), type: \(Swift.String(describing: type)))"}
}

extension SsmContactsClientTypes {
    /// A personal contact or escalation plan that Incident Manager engages during an
    ///          incident.
    public struct Contact: Swift.Equatable {
        /// The unique and identifiable alias of the contact or escalation plan.
        /// This member is required.
        public let alias: Swift.String?
        /// The Amazon Resource Name (ARN) of the contact or escalation plan.
        /// This member is required.
        public let contactArn: Swift.String?
        /// The full name of the contact or escalation plan.
        public let displayName: Swift.String?
        /// Refers to the type of contact. A single contact is type PERSONAL and an
        ///          escalation plan is type ESCALATION.
        /// This member is required.
        public let type: SsmContactsClientTypes.ContactType?

        public init (
            alias: Swift.String? = nil,
            contactArn: Swift.String? = nil,
            displayName: Swift.String? = nil,
            type: SsmContactsClientTypes.ContactType? = nil
        )
        {
            self.alias = alias
            self.contactArn = contactArn
            self.displayName = displayName
            self.type = type
        }
    }

}

extension SsmContactsClientTypes.ContactChannel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationStatus = "ActivationStatus"
        case contactArn = "ContactArn"
        case contactChannelArn = "ContactChannelArn"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationStatus = activationStatus {
            try encodeContainer.encode(activationStatus.rawValue, forKey: .activationStatus)
        }
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let contactChannelArn = contactChannelArn {
            try encodeContainer.encode(contactChannelArn, forKey: .contactChannelArn)
        }
        if let deliveryAddress = deliveryAddress {
            try encodeContainer.encode(deliveryAddress, forKey: .deliveryAddress)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
        let activationStatusDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ActivationStatus.self, forKey: .activationStatus)
        activationStatus = activationStatusDecoded
    }
}

extension SsmContactsClientTypes.ContactChannel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContactChannel(activationStatus: \(Swift.String(describing: activationStatus)), contactArn: \(Swift.String(describing: contactArn)), contactChannelArn: \(Swift.String(describing: contactChannelArn)), deliveryAddress: \(Swift.String(describing: deliveryAddress)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension SsmContactsClientTypes {
    /// The method that Incident Manager uses to engage a contact.
    public struct ContactChannel: Swift.Equatable {
        /// A Boolean value describing if the contact channel has been activated or not. If the
        ///          contact channel isn't activated, Incident Manager can't engage the contact through it.
        /// This member is required.
        public let activationStatus: SsmContactsClientTypes.ActivationStatus?
        /// The ARN of the contact that contains the contact channel.
        /// This member is required.
        public let contactArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the contact channel.
        /// This member is required.
        public let contactChannelArn: Swift.String?
        /// The details that Incident Manager uses when trying to engage the contact channel.
        /// This member is required.
        public let deliveryAddress: SsmContactsClientTypes.ContactChannelAddress?
        /// The name of the contact channel.
        /// This member is required.
        public let name: Swift.String?
        /// The type of the contact channel. Incident Manager supports three contact methods:
        ///
        ///
        ///                SMS
        ///
        ///
        ///                VOICE
        ///
        ///
        ///                EMAIL
        ///
        ///
        public let type: SsmContactsClientTypes.ChannelType?

        public init (
            activationStatus: SsmContactsClientTypes.ActivationStatus? = nil,
            contactArn: Swift.String? = nil,
            contactChannelArn: Swift.String? = nil,
            deliveryAddress: SsmContactsClientTypes.ContactChannelAddress? = nil,
            name: Swift.String? = nil,
            type: SsmContactsClientTypes.ChannelType? = nil
        )
        {
            self.activationStatus = activationStatus
            self.contactArn = contactArn
            self.contactChannelArn = contactChannelArn
            self.deliveryAddress = deliveryAddress
            self.name = name
            self.type = type
        }
    }

}

extension SsmContactsClientTypes.ContactChannelAddress: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simpleAddress = "SimpleAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleAddress = simpleAddress {
            try encodeContainer.encode(simpleAddress, forKey: .simpleAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simpleAddress)
        simpleAddress = simpleAddressDecoded
    }
}

extension SsmContactsClientTypes.ContactChannelAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContactChannelAddress(simpleAddress: \(Swift.String(describing: simpleAddress)))"}
}

extension SsmContactsClientTypes {
    /// The details that Incident Manager uses when trying to engage the contact channel.
    public struct ContactChannelAddress: Swift.Equatable {
        /// The format is dependent on the type of the contact channel. The following are the
        ///          expected formats:
        ///
        ///
        ///                SMS - '+' followed by the country code and phone number
        ///
        ///
        ///                VOICE - '+' followed by the country code and phone number
        ///
        ///
        ///                EMAIL - any standard email format
        ///
        ///
        public let simpleAddress: Swift.String?

        public init (
            simpleAddress: Swift.String? = nil
        )
        {
            self.simpleAddress = simpleAddress
        }
    }

}

extension SsmContactsClientTypes.ContactTargetInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case isEssential = "IsEssential"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let isEssential = isEssential {
            try encodeContainer.encode(isEssential, forKey: .isEssential)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let isEssentialDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEssential)
        isEssential = isEssentialDecoded
    }
}

extension SsmContactsClientTypes.ContactTargetInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContactTargetInfo(contactId: \(Swift.String(describing: contactId)), isEssential: \(Swift.String(describing: isEssential)))"}
}

extension SsmContactsClientTypes {
    /// The contact that Incident Manager is engaging during an incident.
    public struct ContactTargetInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the contact.
        public let contactId: Swift.String?
        /// A Boolean value determining if the contact's acknowledgement stops the progress of
        ///          stages in the plan.
        /// This member is required.
        public let isEssential: Swift.Bool?

        public init (
            contactId: Swift.String? = nil,
            isEssential: Swift.Bool? = nil
        )
        {
            self.contactId = contactId
            self.isEssential = isEssential
        }
    }

}

extension SsmContactsClientTypes {
    public enum ContactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case escalation
        case personal
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactType] {
            return [
                .escalation,
                .personal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .escalation: return "ESCALATION"
            case .personal: return "PERSONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactType(rawValue: rawValue) ?? ContactType.sdkUnknown(rawValue)
        }
    }
}

public struct CreateContactChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContactChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateContactChannelOutputError>
}

extension CreateContactChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateContactChannelInput(contactId: \(Swift.String(describing: contactId)), deferActivation: \(Swift.String(describing: deferActivation)), deliveryAddress: \(Swift.String(describing: deliveryAddress)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension CreateContactChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case deferActivation = "DeferActivation"
        case deliveryAddress = "DeliveryAddress"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let deferActivation = deferActivation {
            try encodeContainer.encode(deferActivation, forKey: .deferActivation)
        }
        if let deliveryAddress = deliveryAddress {
            try encodeContainer.encode(deliveryAddress, forKey: .deliveryAddress)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateContactChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContactChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateContactChannelOutputError>
}

public struct CreateContactChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContactChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateContactChannelOutputError>
}

public struct CreateContactChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact you are adding the contact channel to.
    /// This member is required.
    public let contactId: Swift.String?
    /// If you want to activate the channel at a later time, you can choose to defer activation.
    ///          Incident Manager can't engage your contact channel until it has been activated.
    public let deferActivation: Swift.Bool?
    /// The details that Incident Manager uses when trying to engage the contact channel. The format
    ///          is dependent on the type of the contact channel. The following are the expected
    ///          formats:
    ///
    ///
    ///                SMS - '+' followed by the country code and phone number
    ///
    ///
    ///                VOICE - '+' followed by the country code and phone number
    ///
    ///
    ///                EMAIL - any standard email format
    ///
    ///
    /// This member is required.
    public let deliveryAddress: SsmContactsClientTypes.ContactChannelAddress?
    /// A token ensuring that the action is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// The name of the contact channel.
    /// This member is required.
    public let name: Swift.String?
    /// Incident Manager supports three types of contact channels:
    ///
    ///
    ///
    ///                   SMS
    ///
    ///
    ///
    ///
    ///                   VOICE
    ///
    ///
    ///
    ///
    ///                   EMAIL
    ///
    ///
    ///
    /// This member is required.
    public let type: SsmContactsClientTypes.ChannelType?

    public init (
        contactId: Swift.String? = nil,
        deferActivation: Swift.Bool? = nil,
        deliveryAddress: SsmContactsClientTypes.ContactChannelAddress? = nil,
        idempotencyToken: Swift.String? = nil,
        name: Swift.String? = nil,
        type: SsmContactsClientTypes.ChannelType? = nil
    )
    {
        self.contactId = contactId
        self.deferActivation = deferActivation
        self.deliveryAddress = deliveryAddress
        self.idempotencyToken = idempotencyToken
        self.name = name
        self.type = type
    }
}

struct CreateContactChannelInputBody: Swift.Equatable {
    public let contactId: Swift.String?
    public let name: Swift.String?
    public let type: SsmContactsClientTypes.ChannelType?
    public let deliveryAddress: SsmContactsClientTypes.ContactChannelAddress?
    public let deferActivation: Swift.Bool?
    public let idempotencyToken: Swift.String?
}

extension CreateContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case deferActivation = "DeferActivation"
        case deliveryAddress = "DeliveryAddress"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
        let deferActivationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deferActivation)
        deferActivation = deferActivationDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateContactChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContactChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContactChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContactChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateContactChannelOutputResponse(contactChannelArn: \(Swift.String(describing: contactChannelArn)))"}
}

extension CreateContactChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateContactChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactChannelArn = output.contactChannelArn
        } else {
            self.contactChannelArn = nil
        }
    }
}

public struct CreateContactChannelOutputResponse: Swift.Equatable {
    /// The ARN of the contact channel.
    /// This member is required.
    public let contactChannelArn: Swift.String?

    public init (
        contactChannelArn: Swift.String? = nil
    )
    {
        self.contactChannelArn = contactChannelArn
    }
}

struct CreateContactChannelOutputResponseBody: Swift.Equatable {
    public let contactChannelArn: Swift.String?
}

extension CreateContactChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelArn = "ContactChannelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
    }
}

public struct CreateContactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateContactOutputError>
}

extension CreateContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateContactInput(alias: \(Swift.String(describing: alias)), displayName: \(Swift.String(describing: displayName)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), plan: \(Swift.String(describing: plan)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension CreateContactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case displayName = "DisplayName"
        case idempotencyToken = "IdempotencyToken"
        case plan = "Plan"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let plan = plan {
            try encodeContainer.encode(plan, forKey: .plan)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagslist0 in tags {
                try tagsContainer.encode(tagslist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateContactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateContactOutputError>
}

public struct CreateContactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateContactOutputError>
}

public struct CreateContactInput: Swift.Equatable {
    /// The short name to quickly identify a contact or escalation plan. The contact alias must
    ///          be unique and identifiable.
    /// This member is required.
    public let alias: Swift.String?
    /// The full name of the contact or escalation plan.
    public let displayName: Swift.String?
    /// A token ensuring that the action is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// A list of stages. A contact has an engagement plan with stages that contact specified
    ///          contact channels. An escalation plan uses stages that contact specified contacts.
    /// This member is required.
    public let plan: SsmContactsClientTypes.Plan?
    /// Adds a tag to the target. You can only tag resources created in the first Region of your
    ///          replication set.
    public let tags: [SsmContactsClientTypes.Tag]?
    /// To create an escalation plan use ESCALATION. To create a contact use
    ///             PERSONAL.
    /// This member is required.
    public let type: SsmContactsClientTypes.ContactType?

    public init (
        alias: Swift.String? = nil,
        displayName: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        plan: SsmContactsClientTypes.Plan? = nil,
        tags: [SsmContactsClientTypes.Tag]? = nil,
        type: SsmContactsClientTypes.ContactType? = nil
    )
    {
        self.alias = alias
        self.displayName = displayName
        self.idempotencyToken = idempotencyToken
        self.plan = plan
        self.tags = tags
        self.type = type
    }
}

struct CreateContactInputBody: Swift.Equatable {
    public let alias: Swift.String?
    public let displayName: Swift.String?
    public let type: SsmContactsClientTypes.ContactType?
    public let plan: SsmContactsClientTypes.Plan?
    public let tags: [SsmContactsClientTypes.Tag]?
    public let idempotencyToken: Swift.String?
}

extension CreateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case displayName = "DisplayName"
        case idempotencyToken = "IdempotencyToken"
        case plan = "Plan"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactType.self, forKey: .type)
        type = typeDecoded
        let planDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.Plan.self, forKey: .plan)
        plan = planDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmContactsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmContactsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateContactOutputResponse(contactArn: \(Swift.String(describing: contactArn)))"}
}

extension CreateContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
        } else {
            self.contactArn = nil
        }
    }
}

public struct CreateContactOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created contact or escalation plan.
    /// This member is required.
    public let contactArn: Swift.String?

    public init (
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct CreateContactOutputResponseBody: Swift.Equatable {
    public let contactArn: Swift.String?
}

extension CreateContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension DataEncryptionException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataEncryptionException(message: \(Swift.String(describing: message)))"}
}

extension DataEncryptionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DataEncryptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The action failed to due an encryption key error.
public struct DataEncryptionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DataEncryptionExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DataEncryptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeactivateContactChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeactivateContactChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeactivateContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeactivateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeactivateContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeactivateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeactivateContactChannelOutputError>
}

extension DeactivateContactChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeactivateContactChannelInput(contactChannelId: \(Swift.String(describing: contactChannelId)))"}
}

extension DeactivateContactChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

public struct DeactivateContactChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeactivateContactChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeactivateContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeactivateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeactivateContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeactivateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeactivateContactChannelOutputError>
}

public struct DeactivateContactChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeactivateContactChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeactivateContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeactivateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeactivateContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeactivateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeactivateContactChannelOutputError>
}

public struct DeactivateContactChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel you're deactivating.
    /// This member is required.
    public let contactChannelId: Swift.String?

    public init (
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct DeactivateContactChannelInputBody: Swift.Equatable {
    public let contactChannelId: Swift.String?
}

extension DeactivateContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension DeactivateContactChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeactivateContactChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeactivateContactChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeactivateContactChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeactivateContactChannelOutputResponse()"}
}

extension DeactivateContactChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeactivateContactChannelOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeactivateContactChannelOutputResponseBody: Swift.Equatable {
}

extension DeactivateContactChannelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteContactChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteContactChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteContactChannelOutputError>
}

extension DeleteContactChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteContactChannelInput(contactChannelId: \(Swift.String(describing: contactChannelId)))"}
}

extension DeleteContactChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

public struct DeleteContactChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteContactChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteContactChannelOutputError>
}

public struct DeleteContactChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteContactChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteContactChannelOutputError>
}

public struct DeleteContactChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel.
    /// This member is required.
    public let contactChannelId: Swift.String?

    public init (
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct DeleteContactChannelInputBody: Swift.Equatable {
    public let contactChannelId: Swift.String?
}

extension DeleteContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension DeleteContactChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContactChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContactChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContactChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteContactChannelOutputResponse()"}
}

extension DeleteContactChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContactChannelOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteContactChannelOutputResponseBody: Swift.Equatable {
}

extension DeleteContactChannelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteContactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteContactOutputError>
}

extension DeleteContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteContactInput(contactId: \(Swift.String(describing: contactId)))"}
}

extension DeleteContactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
    }
}

public struct DeleteContactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteContactOutputError>
}

public struct DeleteContactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteContactOutputError>
}

public struct DeleteContactInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact that you're deleting.
    /// This member is required.
    public let contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct DeleteContactInputBody: Swift.Equatable {
    public let contactId: Swift.String?
}

extension DeleteContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension DeleteContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteContactOutputResponse()"}
}

extension DeleteContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContactOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteContactOutputResponseBody: Swift.Equatable {
}

extension DeleteContactOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeEngagementInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngagementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEngagementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEngagementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngagementOutputError>
}

extension DescribeEngagementInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEngagementInput(engagementId: \(Swift.String(describing: engagementId)))"}
}

extension DescribeEngagementInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engagementId = engagementId {
            try encodeContainer.encode(engagementId, forKey: .engagementId)
        }
    }
}

public struct DescribeEngagementInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngagementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEngagementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEngagementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngagementOutputError>
}

public struct DescribeEngagementInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngagementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEngagementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEngagementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngagementOutputError>
}

public struct DescribeEngagementInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the engagement you want the details of.
    /// This member is required.
    public let engagementId: Swift.String?

    public init (
        engagementId: Swift.String? = nil
    )
    {
        self.engagementId = engagementId
    }
}

struct DescribeEngagementInputBody: Swift.Equatable {
    public let engagementId: Swift.String?
}

extension DescribeEngagementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementId)
        engagementId = engagementIdDecoded
    }
}

extension DescribeEngagementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEngagementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEngagementOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEngagementOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEngagementOutputResponse(contactArn: \(Swift.String(describing: contactArn)), content: \(Swift.String(describing: content)), engagementArn: \(Swift.String(describing: engagementArn)), incidentId: \(Swift.String(describing: incidentId)), publicContent: \(Swift.String(describing: publicContent)), publicSubject: \(Swift.String(describing: publicSubject)), sender: \(Swift.String(describing: sender)), startTime: \(Swift.String(describing: startTime)), stopTime: \(Swift.String(describing: stopTime)), subject: \(Swift.String(describing: subject)))"}
}

extension DescribeEngagementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEngagementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
            self.content = output.content
            self.engagementArn = output.engagementArn
            self.incidentId = output.incidentId
            self.publicContent = output.publicContent
            self.publicSubject = output.publicSubject
            self.sender = output.sender
            self.startTime = output.startTime
            self.stopTime = output.stopTime
            self.subject = output.subject
        } else {
            self.contactArn = nil
            self.content = nil
            self.engagementArn = nil
            self.incidentId = nil
            self.publicContent = nil
            self.publicSubject = nil
            self.sender = nil
            self.startTime = nil
            self.stopTime = nil
            self.subject = nil
        }
    }
}

public struct DescribeEngagementOutputResponse: Swift.Equatable {
    /// The ARN of the escalation plan or contacts involved in the engagement.
    /// This member is required.
    public let contactArn: Swift.String?
    /// The secure content of the message that was sent to the contact. Use this field for
    ///          engagements to VOICE and EMAIL.
    /// This member is required.
    public let content: Swift.String?
    /// The ARN of the engagement.
    /// This member is required.
    public let engagementArn: Swift.String?
    /// The ARN of the incident in which the engagement occurred.
    public let incidentId: Swift.String?
    /// The insecure content of the message that was sent to the contact. Use this field for
    ///          engagements to SMS.
    public let publicContent: Swift.String?
    /// The insecure subject of the message that was sent to the contact. Use this field for
    ///          engagements to SMS.
    public let publicSubject: Swift.String?
    /// The user that started the engagement.
    /// This member is required.
    public let sender: Swift.String?
    /// The time that the engagement started.
    public let startTime: ClientRuntime.Date?
    /// The time that the engagement ended.
    public let stopTime: ClientRuntime.Date?
    /// The secure subject of the message that was sent to the contact. Use this field for
    ///          engagements to VOICE and EMAIL.
    /// This member is required.
    public let subject: Swift.String?

    public init (
        contactArn: Swift.String? = nil,
        content: Swift.String? = nil,
        engagementArn: Swift.String? = nil,
        incidentId: Swift.String? = nil,
        publicContent: Swift.String? = nil,
        publicSubject: Swift.String? = nil,
        sender: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        stopTime: ClientRuntime.Date? = nil,
        subject: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.content = content
        self.engagementArn = engagementArn
        self.incidentId = incidentId
        self.publicContent = publicContent
        self.publicSubject = publicSubject
        self.sender = sender
        self.startTime = startTime
        self.stopTime = stopTime
        self.subject = subject
    }
}

struct DescribeEngagementOutputResponseBody: Swift.Equatable {
    public let contactArn: Swift.String?
    public let engagementArn: Swift.String?
    public let sender: Swift.String?
    public let subject: Swift.String?
    public let content: Swift.String?
    public let publicSubject: Swift.String?
    public let publicContent: Swift.String?
    public let incidentId: Swift.String?
    public let startTime: ClientRuntime.Date?
    public let stopTime: ClientRuntime.Date?
}

extension DescribeEngagementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case content = "Content"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case sender = "Sender"
        case startTime = "StartTime"
        case stopTime = "StopTime"
        case subject = "Subject"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let engagementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sender)
        sender = senderDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let publicSubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicSubject)
        publicSubject = publicSubjectDecoded
        let publicContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicContent)
        publicContent = publicContentDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

public struct DescribePageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePageOutputError>
}

extension DescribePageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePageInput(pageId: \(Swift.String(describing: pageId)))"}
}

extension DescribePageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageId = "PageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pageId = pageId {
            try encodeContainer.encode(pageId, forKey: .pageId)
        }
    }
}

public struct DescribePageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePageOutputError>
}

public struct DescribePageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePageOutputError>
}

public struct DescribePageInput: Swift.Equatable {
    /// The ID of the engagement to a contact channel.
    /// This member is required.
    public let pageId: Swift.String?

    public init (
        pageId: Swift.String? = nil
    )
    {
        self.pageId = pageId
    }
}

struct DescribePageInputBody: Swift.Equatable {
    public let pageId: Swift.String?
}

extension DescribePageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageId = "PageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageId)
        pageId = pageIdDecoded
    }
}

extension DescribePageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePageOutputResponse(contactArn: \(Swift.String(describing: contactArn)), content: \(Swift.String(describing: content)), deliveryTime: \(Swift.String(describing: deliveryTime)), engagementArn: \(Swift.String(describing: engagementArn)), incidentId: \(Swift.String(describing: incidentId)), pageArn: \(Swift.String(describing: pageArn)), publicContent: \(Swift.String(describing: publicContent)), publicSubject: \(Swift.String(describing: publicSubject)), readTime: \(Swift.String(describing: readTime)), sender: \(Swift.String(describing: sender)), sentTime: \(Swift.String(describing: sentTime)), subject: \(Swift.String(describing: subject)))"}
}

extension DescribePageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
            self.content = output.content
            self.deliveryTime = output.deliveryTime
            self.engagementArn = output.engagementArn
            self.incidentId = output.incidentId
            self.pageArn = output.pageArn
            self.publicContent = output.publicContent
            self.publicSubject = output.publicSubject
            self.readTime = output.readTime
            self.sender = output.sender
            self.sentTime = output.sentTime
            self.subject = output.subject
        } else {
            self.contactArn = nil
            self.content = nil
            self.deliveryTime = nil
            self.engagementArn = nil
            self.incidentId = nil
            self.pageArn = nil
            self.publicContent = nil
            self.publicSubject = nil
            self.readTime = nil
            self.sender = nil
            self.sentTime = nil
            self.subject = nil
        }
    }
}

public struct DescribePageOutputResponse: Swift.Equatable {
    /// The ARN of the contact that was engaged.
    /// This member is required.
    public let contactArn: Swift.String?
    /// The secure content of the message that was sent to the contact. Use this field for
    ///          engagements to VOICE and EMAIL.
    /// This member is required.
    public let content: Swift.String?
    /// The time that the contact channel received the engagement.
    public let deliveryTime: ClientRuntime.Date?
    /// The ARN of the engagement that engaged the contact channel.
    /// This member is required.
    public let engagementArn: Swift.String?
    /// The ARN of the incident that engaged the contact channel.
    public let incidentId: Swift.String?
    /// The Amazon Resource Name (ARN) of the engagement to a contact channel.
    /// This member is required.
    public let pageArn: Swift.String?
    /// The insecure content of the message that was sent to the contact. Use this field for
    ///          engagements to SMS.
    public let publicContent: Swift.String?
    /// The insecure subject of the message that was sent to the contact. Use this field for
    ///          engagements to SMS.
    public let publicSubject: Swift.String?
    /// The time that the contact channel acknowledged the engagement.
    public let readTime: ClientRuntime.Date?
    /// The user that started the engagement.
    /// This member is required.
    public let sender: Swift.String?
    /// The time the engagement was sent to the contact channel.
    public let sentTime: ClientRuntime.Date?
    /// The secure subject of the message that was sent to the contact. Use this field for
    ///          engagements to VOICE and EMAIL.
    /// This member is required.
    public let subject: Swift.String?

    public init (
        contactArn: Swift.String? = nil,
        content: Swift.String? = nil,
        deliveryTime: ClientRuntime.Date? = nil,
        engagementArn: Swift.String? = nil,
        incidentId: Swift.String? = nil,
        pageArn: Swift.String? = nil,
        publicContent: Swift.String? = nil,
        publicSubject: Swift.String? = nil,
        readTime: ClientRuntime.Date? = nil,
        sender: Swift.String? = nil,
        sentTime: ClientRuntime.Date? = nil,
        subject: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.content = content
        self.deliveryTime = deliveryTime
        self.engagementArn = engagementArn
        self.incidentId = incidentId
        self.pageArn = pageArn
        self.publicContent = publicContent
        self.publicSubject = publicSubject
        self.readTime = readTime
        self.sender = sender
        self.sentTime = sentTime
        self.subject = subject
    }
}

struct DescribePageOutputResponseBody: Swift.Equatable {
    public let pageArn: Swift.String?
    public let engagementArn: Swift.String?
    public let contactArn: Swift.String?
    public let sender: Swift.String?
    public let subject: Swift.String?
    public let content: Swift.String?
    public let publicSubject: Swift.String?
    public let publicContent: Swift.String?
    public let incidentId: Swift.String?
    public let sentTime: ClientRuntime.Date?
    public let readTime: ClientRuntime.Date?
    public let deliveryTime: ClientRuntime.Date?
}

extension DescribePageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case content = "Content"
        case deliveryTime = "DeliveryTime"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case pageArn = "PageArn"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case readTime = "ReadTime"
        case sender = "Sender"
        case sentTime = "SentTime"
        case subject = "Subject"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageArn)
        pageArn = pageArnDecoded
        let engagementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sender)
        sender = senderDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let publicSubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicSubject)
        publicSubject = publicSubjectDecoded
        let publicContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicContent)
        publicContent = publicContentDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let sentTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .sentTime)
        sentTime = sentTimeDecoded
        let readTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .readTime)
        readTime = readTimeDecoded
        let deliveryTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deliveryTime)
        deliveryTime = deliveryTimeDecoded
    }
}

extension SsmContactsClientTypes.Engagement: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case sender = "Sender"
        case startTime = "StartTime"
        case stopTime = "StopTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let engagementArn = engagementArn {
            try encodeContainer.encode(engagementArn, forKey: .engagementArn)
        }
        if let incidentId = incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let sender = sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let stopTime = stopTime {
            try encodeContainer.encode(stopTime.timeIntervalSince1970, forKey: .stopTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sender)
        sender = senderDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

extension SsmContactsClientTypes.Engagement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Engagement(contactArn: \(Swift.String(describing: contactArn)), engagementArn: \(Swift.String(describing: engagementArn)), incidentId: \(Swift.String(describing: incidentId)), sender: \(Swift.String(describing: sender)), startTime: \(Swift.String(describing: startTime)), stopTime: \(Swift.String(describing: stopTime)))"}
}

extension SsmContactsClientTypes {
    /// Incident Manager reaching out to a contact or escalation plan to engage contact during an
    ///          incident.
    public struct Engagement: Swift.Equatable {
        /// The ARN of the escalation plan or contact that Incident Manager is engaging.
        /// This member is required.
        public let contactArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the engagement.
        /// This member is required.
        public let engagementArn: Swift.String?
        /// The ARN of the incident that's engaging the contact.
        public let incidentId: Swift.String?
        /// The user that started the engagement.
        /// This member is required.
        public let sender: Swift.String?
        /// The time that the engagement began.
        public let startTime: ClientRuntime.Date?
        /// The time that the engagement ended.
        public let stopTime: ClientRuntime.Date?

        public init (
            contactArn: Swift.String? = nil,
            engagementArn: Swift.String? = nil,
            incidentId: Swift.String? = nil,
            sender: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            stopTime: ClientRuntime.Date? = nil
        )
        {
            self.contactArn = contactArn
            self.engagementArn = engagementArn
            self.incidentId = incidentId
            self.sender = sender
            self.startTime = startTime
            self.stopTime = stopTime
        }
    }

}

public struct GetContactChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContactChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContactChannelOutputError>
}

extension GetContactChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetContactChannelInput(contactChannelId: \(Swift.String(describing: contactChannelId)))"}
}

extension GetContactChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

public struct GetContactChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContactChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContactChannelOutputError>
}

public struct GetContactChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContactChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContactChannelOutputError>
}

public struct GetContactChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel you want information about.
    /// This member is required.
    public let contactChannelId: Swift.String?

    public init (
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct GetContactChannelInputBody: Swift.Equatable {
    public let contactChannelId: Swift.String?
}

extension GetContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension GetContactChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetContactChannelOutputResponse(activationStatus: \(Swift.String(describing: activationStatus)), contactArn: \(Swift.String(describing: contactArn)), contactChannelArn: \(Swift.String(describing: contactChannelArn)), deliveryAddress: \(Swift.String(describing: deliveryAddress)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension GetContactChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetContactChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activationStatus = output.activationStatus
            self.contactArn = output.contactArn
            self.contactChannelArn = output.contactChannelArn
            self.deliveryAddress = output.deliveryAddress
            self.name = output.name
            self.type = output.type
        } else {
            self.activationStatus = nil
            self.contactArn = nil
            self.contactChannelArn = nil
            self.deliveryAddress = nil
            self.name = nil
            self.type = nil
        }
    }
}

public struct GetContactChannelOutputResponse: Swift.Equatable {
    /// A Boolean value indicating if the contact channel has been activated or not.
    public let activationStatus: SsmContactsClientTypes.ActivationStatus?
    /// The ARN of the contact that the channel belongs to.
    /// This member is required.
    public let contactArn: Swift.String?
    /// The ARN of the contact channel.
    /// This member is required.
    public let contactChannelArn: Swift.String?
    /// The details that Incident Manager uses when trying to engage the contact channel.
    /// This member is required.
    public let deliveryAddress: SsmContactsClientTypes.ContactChannelAddress?
    /// The name of the contact channel
    /// This member is required.
    public let name: Swift.String?
    /// The type of contact channel. The type is SMS, VOICE, or
    ///             EMAIL.
    /// This member is required.
    public let type: SsmContactsClientTypes.ChannelType?

    public init (
        activationStatus: SsmContactsClientTypes.ActivationStatus? = nil,
        contactArn: Swift.String? = nil,
        contactChannelArn: Swift.String? = nil,
        deliveryAddress: SsmContactsClientTypes.ContactChannelAddress? = nil,
        name: Swift.String? = nil,
        type: SsmContactsClientTypes.ChannelType? = nil
    )
    {
        self.activationStatus = activationStatus
        self.contactArn = contactArn
        self.contactChannelArn = contactChannelArn
        self.deliveryAddress = deliveryAddress
        self.name = name
        self.type = type
    }
}

struct GetContactChannelOutputResponseBody: Swift.Equatable {
    public let contactArn: Swift.String?
    public let contactChannelArn: Swift.String?
    public let name: Swift.String?
    public let type: SsmContactsClientTypes.ChannelType?
    public let deliveryAddress: SsmContactsClientTypes.ContactChannelAddress?
    public let activationStatus: SsmContactsClientTypes.ActivationStatus?
}

extension GetContactChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationStatus = "ActivationStatus"
        case contactArn = "ContactArn"
        case contactChannelArn = "ContactChannelArn"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
        let activationStatusDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ActivationStatus.self, forKey: .activationStatus)
        activationStatus = activationStatusDecoded
    }
}

public struct GetContactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContactOutputError>
}

extension GetContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetContactInput(contactId: \(Swift.String(describing: contactId)))"}
}

extension GetContactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
    }
}

public struct GetContactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContactOutputError>
}

public struct GetContactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContactOutputError>
}

public struct GetContactInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public let contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct GetContactInputBody: Swift.Equatable {
    public let contactId: Swift.String?
}

extension GetContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension GetContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetContactOutputResponse(alias: \(Swift.String(describing: alias)), contactArn: \(Swift.String(describing: contactArn)), displayName: \(Swift.String(describing: displayName)), plan: \(Swift.String(describing: plan)), type: \(Swift.String(describing: type)))"}
}

extension GetContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.contactArn = output.contactArn
            self.displayName = output.displayName
            self.plan = output.plan
            self.type = output.type
        } else {
            self.alias = nil
            self.contactArn = nil
            self.displayName = nil
            self.plan = nil
            self.type = nil
        }
    }
}

public struct GetContactOutputResponse: Swift.Equatable {
    /// The alias of the contact or escalation plan. The alias is unique and
    ///          identifiable.
    /// This member is required.
    public let alias: Swift.String?
    /// The ARN of the contact or escalation plan.
    /// This member is required.
    public let contactArn: Swift.String?
    /// The full name of the contact or escalation plan.
    public let displayName: Swift.String?
    /// Details about the specific timing or stages and targets of the escalation plan or
    ///          engagement plan.
    /// This member is required.
    public let plan: SsmContactsClientTypes.Plan?
    /// The type of contact, either PERSONAL or ESCALATION.
    /// This member is required.
    public let type: SsmContactsClientTypes.ContactType?

    public init (
        alias: Swift.String? = nil,
        contactArn: Swift.String? = nil,
        displayName: Swift.String? = nil,
        plan: SsmContactsClientTypes.Plan? = nil,
        type: SsmContactsClientTypes.ContactType? = nil
    )
    {
        self.alias = alias
        self.contactArn = contactArn
        self.displayName = displayName
        self.plan = plan
        self.type = type
    }
}

struct GetContactOutputResponseBody: Swift.Equatable {
    public let contactArn: Swift.String?
    public let alias: Swift.String?
    public let displayName: Swift.String?
    public let type: SsmContactsClientTypes.ContactType?
    public let plan: SsmContactsClientTypes.Plan?
}

extension GetContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case plan = "Plan"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactType.self, forKey: .type)
        type = typeDecoded
        let planDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.Plan.self, forKey: .plan)
        plan = planDecoded
    }
}

public struct GetContactPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContactPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContactPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContactPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContactPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContactPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContactPolicyOutputError>
}

extension GetContactPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetContactPolicyInput(contactArn: \(Swift.String(describing: contactArn)))"}
}

extension GetContactPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

public struct GetContactPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContactPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContactPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContactPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContactPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContactPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContactPolicyOutputError>
}

public struct GetContactPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContactPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContactPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContactPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContactPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContactPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContactPolicyOutputError>
}

public struct GetContactPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public let contactArn: Swift.String?

    public init (
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct GetContactPolicyInputBody: Swift.Equatable {
    public let contactArn: Swift.String?
}

extension GetContactPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension GetContactPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetContactPolicyOutputResponse(contactArn: \(Swift.String(describing: contactArn)), policy: \(Swift.String(describing: policy)))"}
}

extension GetContactPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetContactPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
            self.policy = output.policy
        } else {
            self.contactArn = nil
            self.policy = nil
        }
    }
}

public struct GetContactPolicyOutputResponse: Swift.Equatable {
    /// The ARN of the contact or escalation plan.
    public let contactArn: Swift.String?
    /// Details about the resource policy attached to the contact or escalation plan.
    public let policy: Swift.String?

    public init (
        contactArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.policy = policy
    }
}

struct GetContactPolicyOutputResponseBody: Swift.Equatable {
    public let contactArn: Swift.String?
    public let policy: Swift.String?
}

extension GetContactPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Unexpected error occurred while
///          processing the request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// Advice to clients on when the call can be safely retried
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListContactChannelsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContactChannelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListContactChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContactChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListContactChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListContactChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContactChannelsOutputError>
}

extension ListContactChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListContactChannelsInput(contactId: \(Swift.String(describing: contactId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListContactChannelsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListContactChannelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContactChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListContactChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContactChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListContactChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListContactChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContactChannelsOutputError>
}

public struct ListContactChannelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContactChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListContactChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContactChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListContactChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListContactChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContactChannelsOutputError>
}

public struct ListContactChannelsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact.
    /// This member is required.
    public let contactId: Swift.String?
    /// The maximum number of contact channels per page.
    public let maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public let nextToken: Swift.String?

    public init (
        contactId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListContactChannelsInputBody: Swift.Equatable {
    public let contactId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListContactChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListContactChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContactChannelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactChannelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListContactChannelsOutputResponse(contactChannels: \(Swift.String(describing: contactChannels)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListContactChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListContactChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactChannels = output.contactChannels
            self.nextToken = output.nextToken
        } else {
            self.contactChannels = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactChannelsOutputResponse: Swift.Equatable {
    /// A list of contact channels related to the specified contact.
    /// This member is required.
    public let contactChannels: [SsmContactsClientTypes.ContactChannel]?
    /// The pagination token to continue to the next page of results.
    public let nextToken: Swift.String?

    public init (
        contactChannels: [SsmContactsClientTypes.ContactChannel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactChannels = contactChannels
        self.nextToken = nextToken
    }
}

struct ListContactChannelsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let contactChannels: [SsmContactsClientTypes.ContactChannel]?
}

extension ListContactChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannels = "ContactChannels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let contactChannelsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.ContactChannel?].self, forKey: .contactChannels)
        var contactChannelsDecoded0:[SsmContactsClientTypes.ContactChannel]? = nil
        if let contactChannelsContainer = contactChannelsContainer {
            contactChannelsDecoded0 = [SsmContactsClientTypes.ContactChannel]()
            for structure0 in contactChannelsContainer {
                if let structure0 = structure0 {
                    contactChannelsDecoded0?.append(structure0)
                }
            }
        }
        contactChannels = contactChannelsDecoded0
    }
}

public struct ListContactsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContactsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListContactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListContactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContactsOutputError>
}

extension ListContactsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListContactsInput(aliasPrefix: \(Swift.String(describing: aliasPrefix)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), type: \(Swift.String(describing: type)))"}
}

extension ListContactsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasPrefix = "AliasPrefix"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasPrefix = aliasPrefix {
            try encodeContainer.encode(aliasPrefix, forKey: .aliasPrefix)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct ListContactsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListContactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListContactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContactsOutputError>
}

public struct ListContactsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListContactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListContactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContactsOutputError>
}

public struct ListContactsInput: Swift.Equatable {
    /// Used to list only contacts who's aliases start with the specified prefix.
    public let aliasPrefix: Swift.String?
    /// The maximum number of contacts and escalation plans per page of results.
    public let maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public let nextToken: Swift.String?
    /// The type of contact. A contact is type PERSONAL and an escalation plan is
    ///          type ESCALATION.
    public let type: SsmContactsClientTypes.ContactType?

    public init (
        aliasPrefix: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: SsmContactsClientTypes.ContactType? = nil
    )
    {
        self.aliasPrefix = aliasPrefix
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListContactsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let aliasPrefix: Swift.String?
    public let type: SsmContactsClientTypes.ContactType?
}

extension ListContactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasPrefix = "AliasPrefix"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let aliasPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasPrefix)
        aliasPrefix = aliasPrefixDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ListContactsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContactsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListContactsOutputResponse(contacts: \(Swift.String(describing: contacts)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListContactsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListContactsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contacts = output.contacts
            self.nextToken = output.nextToken
        } else {
            self.contacts = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactsOutputResponse: Swift.Equatable {
    /// A list of the contacts and escalation plans in your Incident Manager account.
    public let contacts: [SsmContactsClientTypes.Contact]?
    /// The pagination token to continue to the next page of results.
    public let nextToken: Swift.String?

    public init (
        contacts: [SsmContactsClientTypes.Contact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contacts = contacts
        self.nextToken = nextToken
    }
}

struct ListContactsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let contacts: [SsmContactsClientTypes.Contact]?
}

extension ListContactsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contacts = "Contacts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let contactsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Contact?].self, forKey: .contacts)
        var contactsDecoded0:[SsmContactsClientTypes.Contact]? = nil
        if let contactsContainer = contactsContainer {
            contactsDecoded0 = [SsmContactsClientTypes.Contact]()
            for structure0 in contactsContainer {
                if let structure0 = structure0 {
                    contactsDecoded0?.append(structure0)
                }
            }
        }
        contacts = contactsDecoded0
    }
}

public struct ListEngagementsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEngagementsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEngagementsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEngagementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEngagementsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEngagementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEngagementsOutputError>
}

extension ListEngagementsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEngagementsInput(incidentId: \(Swift.String(describing: incidentId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), timeRangeValue: \(Swift.String(describing: timeRangeValue)))"}
}

extension ListEngagementsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case incidentId = "IncidentId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timeRangeValue = "TimeRangeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let incidentId = incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timeRangeValue = timeRangeValue {
            try encodeContainer.encode(timeRangeValue, forKey: .timeRangeValue)
        }
    }
}

public struct ListEngagementsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEngagementsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEngagementsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEngagementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEngagementsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEngagementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEngagementsOutputError>
}

public struct ListEngagementsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEngagementsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEngagementsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEngagementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEngagementsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEngagementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEngagementsOutputError>
}

public struct ListEngagementsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the incident you're listing engagements for.
    public let incidentId: Swift.String?
    /// The maximum number of engagements per page of results.
    public let maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public let nextToken: Swift.String?
    /// The time range to lists engagements for an incident.
    public let timeRangeValue: SsmContactsClientTypes.TimeRange?

    public init (
        incidentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timeRangeValue: SsmContactsClientTypes.TimeRange? = nil
    )
    {
        self.incidentId = incidentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timeRangeValue = timeRangeValue
    }
}

struct ListEngagementsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let incidentId: Swift.String?
    public let timeRangeValue: SsmContactsClientTypes.TimeRange?
}

extension ListEngagementsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case incidentId = "IncidentId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timeRangeValue = "TimeRangeValue"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let timeRangeValueDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.TimeRange.self, forKey: .timeRangeValue)
        timeRangeValue = timeRangeValueDecoded
    }
}

extension ListEngagementsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEngagementsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEngagementsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEngagementsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEngagementsOutputResponse(engagements: \(Swift.String(describing: engagements)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEngagementsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEngagementsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engagements = output.engagements
            self.nextToken = output.nextToken
        } else {
            self.engagements = nil
            self.nextToken = nil
        }
    }
}

public struct ListEngagementsOutputResponse: Swift.Equatable {
    /// A list of each engagement that occurred during the specified time range of an
    ///          incident.
    /// This member is required.
    public let engagements: [SsmContactsClientTypes.Engagement]?
    /// The pagination token to continue to the next page of results.
    public let nextToken: Swift.String?

    public init (
        engagements: [SsmContactsClientTypes.Engagement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engagements = engagements
        self.nextToken = nextToken
    }
}

struct ListEngagementsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let engagements: [SsmContactsClientTypes.Engagement]?
}

extension ListEngagementsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagements = "Engagements"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let engagementsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Engagement?].self, forKey: .engagements)
        var engagementsDecoded0:[SsmContactsClientTypes.Engagement]? = nil
        if let engagementsContainer = engagementsContainer {
            engagementsDecoded0 = [SsmContactsClientTypes.Engagement]()
            for structure0 in engagementsContainer {
                if let structure0 = structure0 {
                    engagementsDecoded0?.append(structure0)
                }
            }
        }
        engagements = engagementsDecoded0
    }
}

public struct ListPageReceiptsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPageReceiptsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPageReceiptsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPageReceiptsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPageReceiptsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPageReceiptsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPageReceiptsOutputError>
}

extension ListPageReceiptsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPageReceiptsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), pageId: \(Swift.String(describing: pageId)))"}
}

extension ListPageReceiptsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pageId = "PageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pageId = pageId {
            try encodeContainer.encode(pageId, forKey: .pageId)
        }
    }
}

public struct ListPageReceiptsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPageReceiptsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPageReceiptsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPageReceiptsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPageReceiptsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPageReceiptsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPageReceiptsOutputError>
}

public struct ListPageReceiptsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPageReceiptsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPageReceiptsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPageReceiptsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPageReceiptsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPageReceiptsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPageReceiptsOutputError>
}

public struct ListPageReceiptsInput: Swift.Equatable {
    /// The maximum number of acknowledgements per page of results.
    public let maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public let nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the engagement to a specific contact channel.
    /// This member is required.
    public let pageId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pageId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pageId = pageId
    }
}

struct ListPageReceiptsInputBody: Swift.Equatable {
    public let pageId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListPageReceiptsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pageId = "PageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageId)
        pageId = pageIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPageReceiptsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPageReceiptsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPageReceiptsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPageReceiptsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPageReceiptsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), receipts: \(Swift.String(describing: receipts)))"}
}

extension ListPageReceiptsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPageReceiptsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.receipts = output.receipts
        } else {
            self.nextToken = nil
            self.receipts = nil
        }
    }
}

public struct ListPageReceiptsOutputResponse: Swift.Equatable {
    /// The pagination token to continue to the next page of results.
    public let nextToken: Swift.String?
    /// A list of each acknowledgement.
    public let receipts: [SsmContactsClientTypes.Receipt]?

    public init (
        nextToken: Swift.String? = nil,
        receipts: [SsmContactsClientTypes.Receipt]? = nil
    )
    {
        self.nextToken = nextToken
        self.receipts = receipts
    }
}

struct ListPageReceiptsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let receipts: [SsmContactsClientTypes.Receipt]?
}

extension ListPageReceiptsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case receipts = "Receipts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let receiptsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Receipt?].self, forKey: .receipts)
        var receiptsDecoded0:[SsmContactsClientTypes.Receipt]? = nil
        if let receiptsContainer = receiptsContainer {
            receiptsDecoded0 = [SsmContactsClientTypes.Receipt]()
            for structure0 in receiptsContainer {
                if let structure0 = structure0 {
                    receiptsDecoded0?.append(structure0)
                }
            }
        }
        receipts = receiptsDecoded0
    }
}

public struct ListPagesByContactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPagesByContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPagesByContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPagesByContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPagesByContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPagesByContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPagesByContactOutputError>
}

extension ListPagesByContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPagesByContactInput(contactId: \(Swift.String(describing: contactId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPagesByContactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPagesByContactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPagesByContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPagesByContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPagesByContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPagesByContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPagesByContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPagesByContactOutputError>
}

public struct ListPagesByContactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPagesByContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPagesByContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPagesByContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPagesByContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPagesByContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPagesByContactOutputError>
}

public struct ListPagesByContactInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact you are retrieving engagements for.
    /// This member is required.
    public let contactId: Swift.String?
    /// The maximum number of engagements to contact channels to list per page of results.
    public let maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public let nextToken: Swift.String?

    public init (
        contactId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPagesByContactInputBody: Swift.Equatable {
    public let contactId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListPagesByContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPagesByContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPagesByContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPagesByContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPagesByContactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPagesByContactOutputResponse(nextToken: \(Swift.String(describing: nextToken)), pages: \(Swift.String(describing: pages)))"}
}

extension ListPagesByContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPagesByContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pages = output.pages
        } else {
            self.nextToken = nil
            self.pages = nil
        }
    }
}

public struct ListPagesByContactOutputResponse: Swift.Equatable {
    /// The pagination token to continue to the next page of results.
    public let nextToken: Swift.String?
    /// The list of engagements to a contact's contact channel.
    /// This member is required.
    public let pages: [SsmContactsClientTypes.Page]?

    public init (
        nextToken: Swift.String? = nil,
        pages: [SsmContactsClientTypes.Page]? = nil
    )
    {
        self.nextToken = nextToken
        self.pages = pages
    }
}

struct ListPagesByContactOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let pages: [SsmContactsClientTypes.Page]?
}

extension ListPagesByContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pages = "Pages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let pagesContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Page?].self, forKey: .pages)
        var pagesDecoded0:[SsmContactsClientTypes.Page]? = nil
        if let pagesContainer = pagesContainer {
            pagesDecoded0 = [SsmContactsClientTypes.Page]()
            for structure0 in pagesContainer {
                if let structure0 = structure0 {
                    pagesDecoded0?.append(structure0)
                }
            }
        }
        pages = pagesDecoded0
    }
}

public struct ListPagesByEngagementInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPagesByEngagementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPagesByEngagementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPagesByEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPagesByEngagementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPagesByEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPagesByEngagementOutputError>
}

extension ListPagesByEngagementInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPagesByEngagementInput(engagementId: \(Swift.String(describing: engagementId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPagesByEngagementInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engagementId = engagementId {
            try encodeContainer.encode(engagementId, forKey: .engagementId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPagesByEngagementInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPagesByEngagementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPagesByEngagementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPagesByEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPagesByEngagementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPagesByEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPagesByEngagementOutputError>
}

public struct ListPagesByEngagementInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPagesByEngagementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPagesByEngagementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPagesByEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPagesByEngagementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPagesByEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPagesByEngagementOutputError>
}

public struct ListPagesByEngagementInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the engagement.
    /// This member is required.
    public let engagementId: Swift.String?
    /// The maximum number of engagements to contact channels to list per page of
    ///          results.
    public let maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public let nextToken: Swift.String?

    public init (
        engagementId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engagementId = engagementId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPagesByEngagementInputBody: Swift.Equatable {
    public let engagementId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListPagesByEngagementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementId)
        engagementId = engagementIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPagesByEngagementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPagesByEngagementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPagesByEngagementOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPagesByEngagementOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPagesByEngagementOutputResponse(nextToken: \(Swift.String(describing: nextToken)), pages: \(Swift.String(describing: pages)))"}
}

extension ListPagesByEngagementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPagesByEngagementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pages = output.pages
        } else {
            self.nextToken = nil
            self.pages = nil
        }
    }
}

public struct ListPagesByEngagementOutputResponse: Swift.Equatable {
    /// The pagination token to continue to the next page of results.
    public let nextToken: Swift.String?
    /// The list of engagements to contact channels.
    /// This member is required.
    public let pages: [SsmContactsClientTypes.Page]?

    public init (
        nextToken: Swift.String? = nil,
        pages: [SsmContactsClientTypes.Page]? = nil
    )
    {
        self.nextToken = nextToken
        self.pages = pages
    }
}

struct ListPagesByEngagementOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let pages: [SsmContactsClientTypes.Page]?
}

extension ListPagesByEngagementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pages = "Pages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let pagesContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Page?].self, forKey: .pages)
        var pagesDecoded0:[SsmContactsClientTypes.Page]? = nil
        if let pagesContainer = pagesContainer {
            pagesDecoded0 = [SsmContactsClientTypes.Page]()
            for structure0 in pagesContainer {
                if let structure0 = structure0 {
                    pagesDecoded0?.append(structure0)
                }
            }
        }
        pages = pagesDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public let resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags related to the contact or escalation plan.
    public let tags: [SsmContactsClientTypes.Tag]?

    public init (
        tags: [SsmContactsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [SsmContactsClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmContactsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmContactsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SsmContactsClientTypes.Page: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case deliveryTime = "DeliveryTime"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case pageArn = "PageArn"
        case readTime = "ReadTime"
        case sender = "Sender"
        case sentTime = "SentTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let deliveryTime = deliveryTime {
            try encodeContainer.encode(deliveryTime.timeIntervalSince1970, forKey: .deliveryTime)
        }
        if let engagementArn = engagementArn {
            try encodeContainer.encode(engagementArn, forKey: .engagementArn)
        }
        if let incidentId = incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let pageArn = pageArn {
            try encodeContainer.encode(pageArn, forKey: .pageArn)
        }
        if let readTime = readTime {
            try encodeContainer.encode(readTime.timeIntervalSince1970, forKey: .readTime)
        }
        if let sender = sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let sentTime = sentTime {
            try encodeContainer.encode(sentTime.timeIntervalSince1970, forKey: .sentTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageArn)
        pageArn = pageArnDecoded
        let engagementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sender)
        sender = senderDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let sentTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .sentTime)
        sentTime = sentTimeDecoded
        let deliveryTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deliveryTime)
        deliveryTime = deliveryTimeDecoded
        let readTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .readTime)
        readTime = readTimeDecoded
    }
}

extension SsmContactsClientTypes.Page: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Page(contactArn: \(Swift.String(describing: contactArn)), deliveryTime: \(Swift.String(describing: deliveryTime)), engagementArn: \(Swift.String(describing: engagementArn)), incidentId: \(Swift.String(describing: incidentId)), pageArn: \(Swift.String(describing: pageArn)), readTime: \(Swift.String(describing: readTime)), sender: \(Swift.String(describing: sender)), sentTime: \(Swift.String(describing: sentTime)))"}
}

extension SsmContactsClientTypes {
    /// Incident Manager engaging a contact's contact channel.
    public struct Page: Swift.Equatable {
        /// The ARN of the contact that Incident Manager is engaging.
        /// This member is required.
        public let contactArn: Swift.String?
        /// The time the message was delivered to the contact channel.
        public let deliveryTime: ClientRuntime.Date?
        /// The ARN of the engagement that this page is part of.
        /// This member is required.
        public let engagementArn: Swift.String?
        /// The ARN of the incident that's engaging the contact channel.
        public let incidentId: Swift.String?
        /// The Amazon Resource Name (ARN) of the page to the contact channel.
        /// This member is required.
        public let pageArn: Swift.String?
        /// The time that the contact channel acknowledged engagement.
        public let readTime: ClientRuntime.Date?
        /// The user that started the engagement.
        /// This member is required.
        public let sender: Swift.String?
        /// The time that Incident Manager engaged the contact channel.
        public let sentTime: ClientRuntime.Date?

        public init (
            contactArn: Swift.String? = nil,
            deliveryTime: ClientRuntime.Date? = nil,
            engagementArn: Swift.String? = nil,
            incidentId: Swift.String? = nil,
            pageArn: Swift.String? = nil,
            readTime: ClientRuntime.Date? = nil,
            sender: Swift.String? = nil,
            sentTime: ClientRuntime.Date? = nil
        )
        {
            self.contactArn = contactArn
            self.deliveryTime = deliveryTime
            self.engagementArn = engagementArn
            self.incidentId = incidentId
            self.pageArn = pageArn
            self.readTime = readTime
            self.sender = sender
            self.sentTime = sentTime
        }
    }

}

extension SsmContactsClientTypes.Plan: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stages = "Stages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stages = stages {
            var stagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stages)
            for stageslist0 in stages {
                try stagesContainer.encode(stageslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagesContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Stage?].self, forKey: .stages)
        var stagesDecoded0:[SsmContactsClientTypes.Stage]? = nil
        if let stagesContainer = stagesContainer {
            stagesDecoded0 = [SsmContactsClientTypes.Stage]()
            for structure0 in stagesContainer {
                if let structure0 = structure0 {
                    stagesDecoded0?.append(structure0)
                }
            }
        }
        stages = stagesDecoded0
    }
}

extension SsmContactsClientTypes.Plan: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Plan(stages: \(Swift.String(describing: stages)))"}
}

extension SsmContactsClientTypes {
    /// The stages that an escalation plan or engagement plan engages contacts and contact
    ///          methods in.
    public struct Plan: Swift.Equatable {
        /// A list of stages that the escalation plan or engagement plan uses to engage contacts and
        ///          contact methods.
        /// This member is required.
        public let stages: [SsmContactsClientTypes.Stage]?

        public init (
            stages: [SsmContactsClientTypes.Stage]? = nil
        )
        {
            self.stages = stages
        }
    }

}

public struct PutContactPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutContactPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutContactPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutContactPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutContactPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutContactPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutContactPolicyOutputError>
}

extension PutContactPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutContactPolicyInput(contactArn: \(Swift.String(describing: contactArn)), policy: \(Swift.String(describing: policy)))"}
}

extension PutContactPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutContactPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutContactPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutContactPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutContactPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutContactPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutContactPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutContactPolicyOutputError>
}

public struct PutContactPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutContactPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutContactPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutContactPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutContactPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutContactPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutContactPolicyOutputError>
}

public struct PutContactPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public let contactArn: Swift.String?
    /// Details of the resource policy.
    /// This member is required.
    public let policy: Swift.String?

    public init (
        contactArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.policy = policy
    }
}

struct PutContactPolicyInputBody: Swift.Equatable {
    public let contactArn: Swift.String?
    public let policy: Swift.String?
}

extension PutContactPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutContactPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutContactPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutContactPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutContactPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutContactPolicyOutputResponse()"}
}

extension PutContactPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutContactPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutContactPolicyOutputResponseBody: Swift.Equatable {
}

extension PutContactPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SsmContactsClientTypes.Receipt: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelArn = "ContactChannelArn"
        case receiptInfo = "ReceiptInfo"
        case receiptTime = "ReceiptTime"
        case receiptType = "ReceiptType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelArn = contactChannelArn {
            try encodeContainer.encode(contactChannelArn, forKey: .contactChannelArn)
        }
        if let receiptInfo = receiptInfo {
            try encodeContainer.encode(receiptInfo, forKey: .receiptInfo)
        }
        if let receiptTime = receiptTime {
            try encodeContainer.encode(receiptTime.timeIntervalSince1970, forKey: .receiptTime)
        }
        if let receiptType = receiptType {
            try encodeContainer.encode(receiptType.rawValue, forKey: .receiptType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
        let receiptTypeDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ReceiptType.self, forKey: .receiptType)
        receiptType = receiptTypeDecoded
        let receiptInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .receiptInfo)
        receiptInfo = receiptInfoDecoded
        let receiptTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .receiptTime)
        receiptTime = receiptTimeDecoded
    }
}

extension SsmContactsClientTypes.Receipt: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Receipt(contactChannelArn: \(Swift.String(describing: contactChannelArn)), receiptInfo: \(Swift.String(describing: receiptInfo)), receiptTime: \(Swift.String(describing: receiptTime)), receiptType: \(Swift.String(describing: receiptType)))"}
}

extension SsmContactsClientTypes {
    /// Records events during an engagement.
    public struct Receipt: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the contact channel Incident Manager engaged.
        public let contactChannelArn: Swift.String?
        /// Information provided during the page acknowledgement.
        public let receiptInfo: Swift.String?
        /// The time receipt was SENT, DELIVERED, or
        ///          READ.
        /// This member is required.
        public let receiptTime: ClientRuntime.Date?
        /// The type follows the engagement cycle, SENT, DELIVERED, and
        ///             READ.
        /// This member is required.
        public let receiptType: SsmContactsClientTypes.ReceiptType?

        public init (
            contactChannelArn: Swift.String? = nil,
            receiptInfo: Swift.String? = nil,
            receiptTime: ClientRuntime.Date? = nil,
            receiptType: SsmContactsClientTypes.ReceiptType? = nil
        )
        {
            self.contactChannelArn = contactChannelArn
            self.receiptInfo = receiptInfo
            self.receiptTime = receiptTime
            self.receiptType = receiptType
        }
    }

}

extension SsmContactsClientTypes {
    public enum ReceiptType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delivered
        case error
        case read
        case sent
        case stop
        case sdkUnknown(Swift.String)

        public static var allCases: [ReceiptType] {
            return [
                .delivered,
                .error,
                .read,
                .sent,
                .stop,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delivered: return "DELIVERED"
            case .error: return "ERROR"
            case .read: return "READ"
            case .sent: return "SENT"
            case .stop: return "STOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReceiptType(rawValue: rawValue) ?? ReceiptType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request references a resource that
///          doesn't
///          exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Hypothetical resource identifier that was not found
    /// This member is required.
    public var resourceId: Swift.String?
    /// Hypothetical resource type that was not found
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct SendActivationCodeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendActivationCodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendActivationCodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendActivationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendActivationCodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendActivationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendActivationCodeOutputError>
}

extension SendActivationCodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendActivationCodeInput(contactChannelId: \(Swift.String(describing: contactChannelId)))"}
}

extension SendActivationCodeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

public struct SendActivationCodeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendActivationCodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendActivationCodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendActivationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendActivationCodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendActivationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendActivationCodeOutputError>
}

public struct SendActivationCodeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendActivationCodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendActivationCodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendActivationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendActivationCodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendActivationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendActivationCodeOutputError>
}

public struct SendActivationCodeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel.
    /// This member is required.
    public let contactChannelId: Swift.String?

    public init (
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct SendActivationCodeInputBody: Swift.Equatable {
    public let contactChannelId: Swift.String?
}

extension SendActivationCodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension SendActivationCodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendActivationCodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendActivationCodeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendActivationCodeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendActivationCodeOutputResponse()"}
}

extension SendActivationCodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SendActivationCodeOutputResponse: Swift.Equatable {

    public init() {}
}

struct SendActivationCodeOutputResponseBody: Swift.Equatable {
}

extension SendActivationCodeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)), quotaCode: \(Swift.String(describing: quotaCode)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Service Quotas requirement to identify originating service
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Identifier of the resource affected
    public var resourceId: Swift.String?
    /// Type of the resource affected
    public var resourceType: Swift.String?
    /// Service Quotas requirement to identify originating quota
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
    public let quotaCode: Swift.String?
    public let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension SsmContactsClientTypes.Stage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInMinutes = "DurationInMinutes"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInMinutes = durationInMinutes {
            try encodeContainer.encode(durationInMinutes, forKey: .durationInMinutes)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targetslist0 in targets {
                try targetsContainer.encode(targetslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmContactsClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmContactsClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension SsmContactsClientTypes.Stage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Stage(durationInMinutes: \(Swift.String(describing: durationInMinutes)), targets: \(Swift.String(describing: targets)))"}
}

extension SsmContactsClientTypes {
    /// A set amount of time that an escalation plan or engagement plan engages the specified
    ///          contacts or contact methods.
    public struct Stage: Swift.Equatable {
        /// The time to wait until beginning the next stage. The duration can only be set to 0 if a
        ///          target is specified.
        /// This member is required.
        public let durationInMinutes: Swift.Int?
        /// The contacts or contact methods that the escalation plan or engagement plan is
        ///          engaging.
        /// This member is required.
        public let targets: [SsmContactsClientTypes.Target]?

        public init (
            durationInMinutes: Swift.Int? = nil,
            targets: [SsmContactsClientTypes.Target]? = nil
        )
        {
            self.durationInMinutes = durationInMinutes
            self.targets = targets
        }
    }

}

public struct StartEngagementInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartEngagementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartEngagementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartEngagementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartEngagementOutputError>
}

extension StartEngagementInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartEngagementInput(contactId: \(Swift.String(describing: contactId)), content: \(Swift.String(describing: content)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), incidentId: \(Swift.String(describing: incidentId)), publicContent: \(Swift.String(describing: publicContent)), publicSubject: \(Swift.String(describing: publicSubject)), sender: \(Swift.String(describing: sender)), subject: \(Swift.String(describing: subject)))"}
}

extension StartEngagementInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case content = "Content"
        case idempotencyToken = "IdempotencyToken"
        case incidentId = "IncidentId"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case sender = "Sender"
        case subject = "Subject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let incidentId = incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let publicContent = publicContent {
            try encodeContainer.encode(publicContent, forKey: .publicContent)
        }
        if let publicSubject = publicSubject {
            try encodeContainer.encode(publicSubject, forKey: .publicSubject)
        }
        if let sender = sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }
}

public struct StartEngagementInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartEngagementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartEngagementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartEngagementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartEngagementOutputError>
}

public struct StartEngagementInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartEngagementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartEngagementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartEngagementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartEngagementOutputError>
}

public struct StartEngagementInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact being engaged.
    /// This member is required.
    public let contactId: Swift.String?
    /// The secure content of the message that was sent to the contact. Use this field for
    ///          engagements to VOICE or EMAIL.
    /// This member is required.
    public let content: Swift.String?
    /// A token ensuring that the action is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// The ARN of the incident that the engagement is part of.
    public let incidentId: Swift.String?
    /// The insecure content of the message that was sent to the contact. Use this field for
    ///          engagements to SMS.
    public let publicContent: Swift.String?
    /// The insecure subject of the message that was sent to the contact. Use this field for
    ///          engagements to SMS.
    public let publicSubject: Swift.String?
    /// The user that started the engagement.
    /// This member is required.
    public let sender: Swift.String?
    /// The secure subject of the message that was sent to the contact. Use this field for
    ///          engagements to VOICE or EMAIL.
    /// This member is required.
    public let subject: Swift.String?

    public init (
        contactId: Swift.String? = nil,
        content: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        incidentId: Swift.String? = nil,
        publicContent: Swift.String? = nil,
        publicSubject: Swift.String? = nil,
        sender: Swift.String? = nil,
        subject: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.content = content
        self.idempotencyToken = idempotencyToken
        self.incidentId = incidentId
        self.publicContent = publicContent
        self.publicSubject = publicSubject
        self.sender = sender
        self.subject = subject
    }
}

struct StartEngagementInputBody: Swift.Equatable {
    public let contactId: Swift.String?
    public let sender: Swift.String?
    public let subject: Swift.String?
    public let content: Swift.String?
    public let publicSubject: Swift.String?
    public let publicContent: Swift.String?
    public let incidentId: Swift.String?
    public let idempotencyToken: Swift.String?
}

extension StartEngagementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case content = "Content"
        case idempotencyToken = "IdempotencyToken"
        case incidentId = "IncidentId"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case sender = "Sender"
        case subject = "Subject"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let senderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sender)
        sender = senderDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let publicSubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicSubject)
        publicSubject = publicSubjectDecoded
        let publicContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicContent)
        publicContent = publicContentDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension StartEngagementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartEngagementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartEngagementOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartEngagementOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartEngagementOutputResponse(engagementArn: \(Swift.String(describing: engagementArn)))"}
}

extension StartEngagementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartEngagementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engagementArn = output.engagementArn
        } else {
            self.engagementArn = nil
        }
    }
}

public struct StartEngagementOutputResponse: Swift.Equatable {
    /// The ARN of the engagement.
    /// This member is required.
    public let engagementArn: Swift.String?

    public init (
        engagementArn: Swift.String? = nil
    )
    {
        self.engagementArn = engagementArn
    }
}

struct StartEngagementOutputResponseBody: Swift.Equatable {
    public let engagementArn: Swift.String?
}

extension StartEngagementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementArn = "EngagementArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
    }
}

public struct StopEngagementInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopEngagementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopEngagementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopEngagementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopEngagementOutputError>
}

extension StopEngagementInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopEngagementInput(engagementId: \(Swift.String(describing: engagementId)), reason: \(Swift.String(describing: reason)))"}
}

extension StopEngagementInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
        case reason = "Reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engagementId = engagementId {
            try encodeContainer.encode(engagementId, forKey: .engagementId)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

public struct StopEngagementInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopEngagementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopEngagementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopEngagementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopEngagementOutputError>
}

public struct StopEngagementInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopEngagementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopEngagementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopEngagementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopEngagementOutputError>
}

public struct StopEngagementInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the engagement.
    /// This member is required.
    public let engagementId: Swift.String?
    /// The reason that you're stopping the engagement.
    public let reason: Swift.String?

    public init (
        engagementId: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.engagementId = engagementId
        self.reason = reason
    }
}

struct StopEngagementInputBody: Swift.Equatable {
    public let engagementId: Swift.String?
    public let reason: Swift.String?
}

extension StopEngagementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementId)
        engagementId = engagementIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension StopEngagementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopEngagementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopEngagementOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopEngagementOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopEngagementOutputResponse()"}
}

extension StopEngagementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopEngagementOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopEngagementOutputResponseBody: Swift.Equatable {
}

extension StopEngagementOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SsmContactsClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsmContactsClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension SsmContactsClientTypes {
    /// A container of a key-value name pair.
    public struct Tag: Swift.Equatable {
        /// Name of the
        ///          object
        ///          key.
        public let key: Swift.String?
        /// Value of the tag.
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagslist0 in tags {
                try tagsContainer.encode(tagslist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public let resourceARN: Swift.String?
    /// A list of tags that you are adding to the contact or escalation plan.
    /// This member is required.
    public let tags: [SsmContactsClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [SsmContactsClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tags: [SsmContactsClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsmContactsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsmContactsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SsmContactsClientTypes.Target: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelTargetInfo = "ChannelTargetInfo"
        case contactTargetInfo = "ContactTargetInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelTargetInfo = channelTargetInfo {
            try encodeContainer.encode(channelTargetInfo, forKey: .channelTargetInfo)
        }
        if let contactTargetInfo = contactTargetInfo {
            try encodeContainer.encode(contactTargetInfo, forKey: .contactTargetInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelTargetInfoDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ChannelTargetInfo.self, forKey: .channelTargetInfo)
        channelTargetInfo = channelTargetInfoDecoded
        let contactTargetInfoDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactTargetInfo.self, forKey: .contactTargetInfo)
        contactTargetInfo = contactTargetInfoDecoded
    }
}

extension SsmContactsClientTypes.Target: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Target(channelTargetInfo: \(Swift.String(describing: channelTargetInfo)), contactTargetInfo: \(Swift.String(describing: contactTargetInfo)))"}
}

extension SsmContactsClientTypes {
    /// The contact or contact channel that is being engaged.
    public struct Target: Swift.Equatable {
        /// Information about the contact channel Incident Manager is engaging.
        public let channelTargetInfo: SsmContactsClientTypes.ChannelTargetInfo?
        /// Information about the contact that Incident Manager is engaging.
        public let contactTargetInfo: SsmContactsClientTypes.ContactTargetInfo?

        public init (
            channelTargetInfo: SsmContactsClientTypes.ChannelTargetInfo? = nil,
            contactTargetInfo: SsmContactsClientTypes.ContactTargetInfo? = nil
        )
        {
            self.channelTargetInfo = channelTargetInfo
            self.contactTargetInfo = contactTargetInfo
        }
    }

}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)), quotaCode: \(Swift.String(describing: quotaCode)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Service Quotas requirement to identify originating service
    public var quotaCode: Swift.String?
    /// Advice to clients on when the call can be safely retried
    public var retryAfterSeconds: Swift.Int
    /// Service Quotas requirement to identify originating quota
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let quotaCode: Swift.String?
    public let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension SsmContactsClientTypes.TimeRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension SsmContactsClientTypes.TimeRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TimeRange(endTime: \(Swift.String(describing: endTime)), startTime: \(Swift.String(describing: startTime)))"}
}

extension SsmContactsClientTypes {
    /// A range of between two set times
    public struct TimeRange: Swift.Equatable {
        /// The end of the time range.
        public let endTime: ClientRuntime.Date?
        /// The start of the time range.
        public let startTime: ClientRuntime.Date?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public let resourceARN: Swift.String?
    /// The key of the tag that you want to remove.
    /// This member is required.
    public let tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateContactChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateContactChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateContactChannelOutputError>
}

extension UpdateContactChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateContactChannelInput(contactChannelId: \(Swift.String(describing: contactChannelId)), deliveryAddress: \(Swift.String(describing: deliveryAddress)), name: \(Swift.String(describing: name)))"}
}

extension UpdateContactChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
        if let deliveryAddress = deliveryAddress {
            try encodeContainer.encode(deliveryAddress, forKey: .deliveryAddress)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateContactChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateContactChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateContactChannelOutputError>
}

public struct UpdateContactChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateContactChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateContactChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateContactChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateContactChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateContactChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateContactChannelOutputError>
}

public struct UpdateContactChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel you want to update.
    /// This member is required.
    public let contactChannelId: Swift.String?
    /// The details that Incident Manager uses when trying to engage the contact channel.
    public let deliveryAddress: SsmContactsClientTypes.ContactChannelAddress?
    /// The name of the contact channel
    public let name: Swift.String?

    public init (
        contactChannelId: Swift.String? = nil,
        deliveryAddress: SsmContactsClientTypes.ContactChannelAddress? = nil,
        name: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
        self.deliveryAddress = deliveryAddress
        self.name = name
    }
}

struct UpdateContactChannelInputBody: Swift.Equatable {
    public let contactChannelId: Swift.String?
    public let name: Swift.String?
    public let deliveryAddress: SsmContactsClientTypes.ContactChannelAddress?
}

extension UpdateContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
    }
}

extension UpdateContactChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateContactChannelOutputResponse()"}
}

extension UpdateContactChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactChannelOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateContactChannelOutputResponseBody: Swift.Equatable {
}

extension UpdateContactChannelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateContactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateContactOutputError>
}

extension UpdateContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateContactInput(contactId: \(Swift.String(describing: contactId)), displayName: \(Swift.String(describing: displayName)), plan: \(Swift.String(describing: plan)))"}
}

extension UpdateContactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case displayName = "DisplayName"
        case plan = "Plan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let plan = plan {
            try encodeContainer.encode(plan, forKey: .plan)
        }
    }
}

public struct UpdateContactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateContactOutputError>
}

public struct UpdateContactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateContactOutputError>
}

public struct UpdateContactInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan you're updating.
    /// This member is required.
    public let contactId: Swift.String?
    /// The full name of the contact or escalation plan.
    public let displayName: Swift.String?
    /// A list of stages. A contact has an engagement plan with stages for specified contact
    ///          channels. An escalation plan uses these stages to contact specified contacts.
    public let plan: SsmContactsClientTypes.Plan?

    public init (
        contactId: Swift.String? = nil,
        displayName: Swift.String? = nil,
        plan: SsmContactsClientTypes.Plan? = nil
    )
    {
        self.contactId = contactId
        self.displayName = displayName
        self.plan = plan
    }
}

struct UpdateContactInputBody: Swift.Equatable {
    public let contactId: Swift.String?
    public let displayName: Swift.String?
    public let plan: SsmContactsClientTypes.Plan?
}

extension UpdateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case displayName = "DisplayName"
        case plan = "Plan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let planDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.Plan.self, forKey: .plan)
        plan = planDecoded
    }
}

extension UpdateContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataEncryptionException" : self = .dataEncryptionException(try DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dataEncryptionException(DataEncryptionException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateContactOutputResponse()"}
}

extension UpdateContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateContactOutputResponseBody: Swift.Equatable {
}

extension UpdateContactOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(fields: \(Swift.String(describing: fields)), message: \(Swift.String(describing: message)), reason: \(Swift.String(describing: reason)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an
///          AWS
///          service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The fields that caused the error
    public var fields: [SsmContactsClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// Reason the request failed validation
    public var reason: SsmContactsClientTypes.ValidationExceptionReason?

    public init (
        fields: [SsmContactsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: SsmContactsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let reason: SsmContactsClientTypes.ValidationExceptionReason?
    public let fields: [SsmContactsClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(SsmContactsClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([SsmContactsClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[SsmContactsClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [SsmContactsClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension SsmContactsClientTypes.ValidationExceptionField: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsmContactsClientTypes.ValidationExceptionField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationExceptionField(message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)))"}
}

extension SsmContactsClientTypes {
    /// Provides information about which field caused the exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Information about what caused the field to cause an exception.
        /// This member is required.
        public let message: Swift.String?
        /// The name of the field that caused the exception.
        /// This member is required.
        public let name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension SsmContactsClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
